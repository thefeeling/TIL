## 1장 출생
---
### 1.1 -er로 끝나는 이름을 사용하지 마세요
### 1.2 생성자 하나를 주 생성자로 만드세요
### 1.3 생성자에 코드를 넣지 마세요

## 2장 학습
---
### 2.1 가능하면 적게 캡슐화하세요
### 2.2 최소한 뭔가는 캡슐화하세요
### 2.3 항상 인터페이스를 사용하세요
### 2.4 메서드 이름을 신중하게 선택하세요
### 2.5 퍼블릭 상수(public constant)를 사용하지 마세요

### 2.6 불변 객체로 만드세요
### 2.7 문서를 작성하는 대신 테스트를 만드세요
### 2.8모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요
### 2.9인터페이스를 짧게 유지하고 스마트(smart)를 사용하세요

## 3장 취업
---
### 3.1 5개 이하의 public 메서드만 노출하세요
- 20개의 메소드를 가진 클래스를 50줄로 구현했다고 이 클래스가 작다고 말할 수 있을까?
- public 메소드가 많을수록 클래스도 거기에 비례하여 커질수 있고, 이는 곧 유지보수성을 저하시키는 요인이 될 수 있음
- public 메소드의 수를 최소로 사용. public 메소드는 객체의 진입점이며 진입점의 수가 적을수록 문제가 발생하더라도 쉽게 수정이 가능
- 클래스가 작으면 메소드와 필드가 더 가까이 있을 확률이 높기 때문에 응집도가 높아지는 효과가 있을 수 있음.
### 3.2 정적 메서드를 사용하지 마세요
- 정적 메소드를 사용하게 되면, 평가의 방법이 eager한 방식으로 처리가 될 여지가 큼
- 정적 메소드를 사용하지 않고, 이를 객체로 만들 경우, 필요한 순간에 평가를 진행할 수 있기 때문에 lazy한 평가를 수행할 수 있어 어느정도 성능적인 최적화가 가능.
- 명령형 vs 선언형, 잘짜놓은 객체지향스러운 코드는 선언형 성격이 강함. 결국 [알고리즘 - 실행]의 맥락으로 접근하는 것이 아닌 [객체 - 행동]의 관점으로 사고하는 것을 이야기함.
- 유틸리티 성격의 클래스(XXXXUtil, XXXXHeler)를 굳이 사용하는 경우엔, 해당 객체의 인스턴스화가 필요없기 때문에 private constructor를 선언하여 객체 생성을 막도록 하는 것이 좋다.
- 싱글톤의 목적은 객체의 상태를 가지는 것이 아니라, `분리 가능한 의존성`을 가지는 것이 핵심이다. 하지만, 싱글톤 역시 또 다른 의미의 전역 변수를 만드는 것과 크게 다르지 않을 수 있다.
- 이상적인 FP에서는 최소의 출구만을 만드는 것이 최선
- 더 작은 객체로 개념을 고립시키고 이를 조합하는 것이 객체지향에서는 최선이다.

### 3.3인자의 값으로 NULL을 절대 허용하지 마세요
- `null`은 죄악이다. 프로그래머들이 접근할 수 없는 메모리 값을 `0`으로 표현하고 이를 가리켜 null로 부르는 동의에서 시작된 것이다.
- `null`을 전달해야 하는 상황이라면, 차라리 빈 객체를 만들어 전달하자.
- `null`에 대한 처리를 해야 하는 상황이라면, 반드시 쉴드패턴(`shield pattern`)과 같은 구현 방식으로 예외를 호출자에게 전달하도록 유도하는 것이 좋다. JVM에서 권고하는 예외 클래스를 사용하는 것이 그 예시
```java
public Iterable<File> find(Mask mask) {
	if (mask == null) {
		throw new IllegalArgumentException("Mask can't be NULL");
	}
}
```


### 3.4충성스러우면서 불변이거나, 아니면 상수이거나
### 3.5 절대 getter와 setter를 사용하지 마세요
### 3.6 부 ctor 밖에서는 new를 사용하지 마세요
### 3.7 인트로스펙션과 캐스팅을 피하세요

## 4장 은퇴
---
### 4.1 절대 NULL을 반환하지 마세요
### 4.2체크 예외(checked exception)만 던지세요
### 4.3 final이거나 abstract이거나
### 4.4 RAII를 사용하세요

## 후기
