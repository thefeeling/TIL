{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/copycode.css","path":"css/copycode.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/copyright.css","path":"css/copyright.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/dark.css","path":"css/dark.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/search.css","path":"css/search.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/copycode.js","path":"js/copycode.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/copyright.js","path":"js/copyright.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/love.js","path":"js/love.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1627800860497},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"d2772ece6d4422ccdaa0359c3e07588834044052","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"9a94875cbf4c27fbe2e63da0496242addc6d2876","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"414914ebb159fac1922b056b905e570ac7521925","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"dfd555c00e85ffc4207c88968d12b219c1f086ec","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f215d92a882247a7cc5ea80b241bedfcec0ea6ca","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"c1acd247e14588cdf101a69460cb8319c18cd078","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"581b0cbefdaa5f894922133989dd2d3bf71ded79","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"9c451e5efd72c5bb8b56e8c2b94be731e99db05b","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"80759482d07063c091e940f964a1cf6693d3d406","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1627800872058},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1627800872058},{"_id":"source/_posts/ETC.md","hash":"95f30e9e69de0f3518280251211a79c758e23751","modified":1627649274427},{"_id":"source/_posts/README.md","hash":"e6ed4b49756e808ea07e8acb797cc6fdf1f5da9b","modified":1627649274453},{"_id":"source/.DS_Store","hash":"9be7c141dd56abb0905b9c0f718deabce0d34095","modified":1627800992305},{"_id":"source/_posts/.DS_Store","hash":"aa1222ae0a4ceabe040bb25bfd69840112fe8bd7","modified":1627801006519},{"_id":"source/_posts/ARCHITECTURE/Idempotent.md","hash":"f6e14241a33d4e38aa6cc789453f2a51af1290e5","modified":1627803603878},{"_id":"source/_posts/AWS/cloudfront_s3_route53_staticweb.md","hash":"077eb9e756928d57fef5db96fa4c783075a61f61","modified":1627906769208},{"_id":"source/_posts/AWS/serverless_framework.md","hash":"9fb22bdc57150c94470207deeb2d99018bc46fd0","modified":1627906772104},{"_id":"source/_posts/ARCHITECTURE/.DS_Store","hash":"f5eef61585ffec8844e8f1c69b568379e67419e6","modified":1562846951371},{"_id":"source/_posts/ARCHITECTURE/ELEGANT_OBJECT.md","hash":"a703dcd3252fe3f4047e04f69a9aa1744e3e2557","modified":1627906807943},{"_id":"source/_posts/AWS/vpc.md","hash":"6842a4dba1a1689bb697c3fc9f0d649f71fac31c","modified":1627649274416},{"_id":"source/_posts/CS/한권으로읽는컴퓨터구조와프로그래밍.md","hash":"2d3c1ee88c9da3c9ad7166ffb62bc22412eb2586","modified":1627906843968},{"_id":"source/_posts/DDD/DDD_START_1.md","hash":"65cf251d2b36eeaacbd57bc6a3a827feae42528f","modified":1627906382402},{"_id":"source/_posts/DDD/DDD_START_3.md","hash":"a9f49f2deda19b39cd0bf5361a0cdd02723cafbf","modified":1627905758789},{"_id":"source/_posts/DDD/DDD_START_2.md","hash":"fb3a013b3fec8dac9841f3578f8578d601c3edd2","modified":1627905775150},{"_id":"source/_posts/DIARY/20190304.md","hash":"3f0dc2055900a0d9f574435027ff36c9998087d7","modified":1627905724038},{"_id":"source/_posts/DIARY/20190305.md","hash":"91c0db8ba8f1353b117dfbc68828fce11a157c45","modified":1627905809952},{"_id":"source/_posts/DIARY/20190307.md","hash":"011e8a5c844ffa8b1a0a5de736d6395ba5500b4c","modified":1627905712935},{"_id":"source/_posts/DIARY/20190311.md","hash":"c1ca63bf7a86b12a0384bc1b4a35a501a1f029f7","modified":1627905706840},{"_id":"source/_posts/DIARY/.DS_Store","hash":"9089055989ab1d7660eb3fb483a8889924fe9143","modified":1602136715756},{"_id":"source/_posts/DIARY/20190501.md","hash":"81945ff51d836966aacd71b19e53cfa661e113c5","modified":1627905700448},{"_id":"source/_posts/DIARY/20190507.md","hash":"30e40c5c7ed955e12763c42c959be61c1d81398a","modified":1627905689073},{"_id":"source/_posts/DIARY/20190526.md","hash":"b4a354a14f5aba5fa4a1014279719524ddba3ee1","modified":1627905682274},{"_id":"source/_posts/DIARY/20190504.md","hash":"a3e258caf8f05f2e9e669eab6aaa4f0f9c5c9807","modified":1627905695136},{"_id":"source/_posts/DIARY/20190528.md","hash":"4626cd58d55af1bde7eeb5c477e612a5a34ded01","modified":1627905675724},{"_id":"source/_posts/DIARY/20190603.md","hash":"bc1fde4a32b7e4b7b2868fe3e2bb8ed22d86fbab","modified":1627905668548},{"_id":"source/_posts/DIARY/20190609.md","hash":"0cb3adcade8d112d32d1da36fac1638d73e29515","modified":1627905660986},{"_id":"source/_posts/DIARY/20190622.md","hash":"73a9082ce0ae27887d54eccb1414699bbb6c9cec","modified":1627905654046},{"_id":"source/_posts/DIARY/20190714.md","hash":"30ea6f585bd8a1504b92c639e8d10692776e7a4f","modified":1627905647809},{"_id":"source/_posts/DIARY/20190810.md","hash":"e8289c46e650a826e06e8c1dc5d45e0a9dcc4584","modified":1627905611596},{"_id":"source/_posts/DIARY/20200305.md","hash":"2a329a0cac059f8a7c5f4d953afd3728bc5d4941","modified":1627905819281},{"_id":"source/_posts/DIARY/20200922.md","hash":"6e8021ba7f8d0a0262c3700b57c0ffaa1605c258","modified":1627905631674},{"_id":"source/_posts/DIARY/20210727.md","hash":"218ab938f5a35afd0013972b6cf127cf437b9459","modified":1627905527260},{"_id":"source/_posts/DIARY/20210730.md","hash":"810c2421411c3cad1dbb00662988ec20ca24053f","modified":1627804135261},{"_id":"source/_posts/DIARY/20210728.md","hash":"46641ca6cb2f1dfec89e1769c8c9cbb1b22170fd","modified":1627905494270},{"_id":"source/_posts/HTTP/그림으로배우는_HTTP_CH6.md","hash":"1e2de93da015982c1b1fcdaa16e14b8bbc59a66d","modified":1627906243747},{"_id":"source/_posts/HTTP/그림으로배우는_HTTP_CH5.md","hash":"647c1711abc532fe5be39be96460ddfa15de8710","modified":1627906240822},{"_id":"source/_posts/Java/APACHE_HTTP_CLIENT.md","hash":"03539ae621efc97f1f319a44e6a9eaae6e7fe670","modified":1627907050246},{"_id":"source/_posts/Java/EffectiveJava3e_ch2.md","hash":"58cc3cbb07a79acde686dff7955a43c31157ba59","modified":1627906035918},{"_id":"source/_posts/Java/EffectiveJava3e_ch3.md","hash":"ae0ecccc6ff3b074524c3a6dcda712be9bbe9a4a","modified":1627906042606},{"_id":"source/_posts/Java/NETTY_IN_ACTION.md","hash":"ad7403cd416d8cc3efcf9023ca015b6ae6d2ddeb","modified":1627905579897},{"_id":"source/_posts/Java/THREAD.md","hash":"c108be2a00532484f1c07d7e65b0e15a630518cd","modified":1627907080958},{"_id":"source/_posts/Java/.DS_Store","hash":"bc3c1d7e5ce90b11bc6141c320c33d5561e0934e","modified":1627491566573},{"_id":"source/_posts/Java/mapStruct.md","hash":"6b817af8949082203eb9288b1a427c65427d4b3d","modified":1627905921916},{"_id":"source/_posts/JavaScript/BestPracticesforSpiesStubsAndMocksinSinon.js.md","hash":"93bb10dbf50ab5346ac33a463b59021eec668f79","modified":1627907287137},{"_id":"source/_posts/JavaScript/ES6_defaultparameter_spreadoperator.md","hash":"262b0e596d9baa05b8710af152bf179a5faccdaf","modified":1627907290375},{"_id":"source/_posts/JavaScript/Function.md","hash":"df457fc03af1716f0fae780278833e29353af699","modified":1627907297973},{"_id":"source/_posts/JavaScript/ES6_let_const.md","hash":"d804c3616af56008ab761d21cea12bf663b56bd3","modified":1627907293249},{"_id":"source/_posts/JavaScript/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1627490506223},{"_id":"source/_posts/JavaScript/MemoryManagement.md","hash":"1f8551ec42bcae9266967dcb0c342b61701ffe7d","modified":1627907300977},{"_id":"source/_posts/JavaScript/NVM-NodeJs.md","hash":"d2e24793481f251cb71ef1e7568f4cedd365aa00","modified":1627907303955},{"_id":"source/_posts/JavaScript/Prototype.md","hash":"6345fb50fe42c8032ccedd90a17bb0a7b78c4fe4","modified":1627906112907},{"_id":"source/_posts/JavaScript/React-Redux-Test.md","hash":"6e523799be77c6331074943c52ae5cc66227c51e","modified":1627907310743},{"_id":"source/_posts/JavaScript/pm2.md","hash":"88e4ce29d29258c2c7a67840f6a8b27563359823","modified":1627906129522},{"_id":"source/_posts/JavaScript/express.js.md","hash":"60d84dd8cfc7e7a42e079ce1c47ce5a88a5a1074","modified":1627906138821},{"_id":"source/_posts/JavaScript/react-route.md","hash":"2987bf5a243c28fda06cbf4c179f23140a1caf37","modified":1627907313363},{"_id":"source/_posts/Kotlin/How_to_make_sense_of_Kotlin_coroutines.md","hash":"e83423e81c4767689238a169c1ccdb67ce499120","modified":1627906008518},{"_id":"source/_posts/Kotlin/Kotlin_In_Action.md","hash":"a42bd57251e7b6f9af4a12999f6b474049b1bf0c","modified":1627905562033},{"_id":"source/_posts/Kotlin/Kotlin_With_Spring.md","hash":"e929fb4adedf8ce6ecd0ff12e9a6a476aa900a59","modified":1627906024117},{"_id":"source/_posts/Kotlin/Kotlin_CookBook.md","hash":"2dd1c88fdb917bd167b6fd0f58378b62adf7ae9e","modified":1627907136175},{"_id":"source/_posts/Kotlin/Reference.md","hash":"f475d24fbb035a998e7e82384057c52de84b50bb","modified":1627907162435},{"_id":"source/_posts/Kotlin/Rx_Kotlin_1.md","hash":"d4393b079dbc3464006c94ce902250bd483fd911","modified":1627905946957},{"_id":"source/_posts/Kotlin/Rx_Kotlin_2.md","hash":"480179c8c0c9366f238aaf4b148b11c3fab7fb94","modified":1627905951834},{"_id":"source/_posts/Kotlin/StandardFunction.md","hash":"be2d48b322191c4461e4c8434baac5f13fb9b45c","modified":1627907189300},{"_id":"source/_posts/Kotlin/WithJava.md","hash":"5e8b8b4de143420b1047a9622c9e2c9677c6c375","modified":1627907207252},{"_id":"source/_posts/MESSAGING/REDISSON.md","hash":"00d6369db493e65b0d263139b414d16c43b94776","modified":1627906869943},{"_id":"source/_posts/MESSAGING/RabbitMQ.md","hash":"474c1e4b0da7d80ec54de2b13085df40fd1b7d84","modified":1627906899070},{"_id":"source/_posts/MYSQL/replication.md","hash":"3a3c01181f058ac02ef4539868b855601a5b68ca","modified":1627906683665},{"_id":"source/_posts/Persistence/Alternative_JPA.md","hash":"6cf1082cd0dbde3958755814811bf00e4b9ae533","modified":1627905993667},{"_id":"source/_posts/Persistence/JPA_ENHANCE_INSERT.md","hash":"e0f1cc97a1c8e4fabbde8726321f5f13a8740d6f","modified":1627907392327},{"_id":"source/_posts/Persistence/JPA_ACCESS.md","hash":"2ae90ec7bc4cf2bdce3089a566d6b4d45a694d42","modified":1627907373850},{"_id":"source/_posts/Persistence/JPA_EntityManager.md","hash":"5afcd90cd7e37ec336c4201eac9a9af10c492f9e","modified":1627907408001},{"_id":"source/_posts/Persistence/JPA_Reference.md","hash":"fe8b02b4e2e63a3ec66ad0e5740d176e1491f436","modified":1627907451107},{"_id":"source/_posts/Persistence/JPA_영속성관리.md","hash":"97395b2b902fb6d1504798d39cbafea2006849f9","modified":1627907355036},{"_id":"source/_posts/Persistence/JPA_컬렉션_리스너.md","hash":"6b4545ddfd2c35898b488351f064e29e675004f7","modified":1627907357962},{"_id":"source/_posts/Persistence/jooq.md","hash":"bb50b894bd417f65125074a749f61509b60e365f","modified":1627907454410},{"_id":"source/_posts/REDIS/redlock.md","hash":"2252b01093a10854b3c01c7ffd8f12202ff4c1f8","modified":1627906929945},{"_id":"source/_posts/Spring/BATCH_1.md","hash":"e2eabf29289cf2b4e6cb1dfc54672ed0dfd50a3c","modified":1627906080885},{"_id":"source/_posts/Spring/BATCH_3.md","hash":"627eb9358f0115a746b77962259eaec137a1227c","modified":1627906093207},{"_id":"source/_posts/Spring/BATCH_2.md","hash":"9fd6e2ee4e050cbbffd4f5557844c3be89af944d","modified":1627906087731},{"_id":"source/_posts/Spring/LOG.md","hash":"1619e76223069888ba84b7fda4cd80536e596546","modified":1627905983433},{"_id":"source/_posts/Spring/MVC_PartialReseponse.md","hash":"318076b75d03a4c400ba22222212d2eef8e6b7ab","modified":1627905906006},{"_id":"source/_posts/Spring/MVC_RequestParam.md","hash":"5fbf7b8c70ce3cc33b6e349eda1f8352d672efb9","modified":1627905543459},{"_id":"source/_posts/Spring/RestTemplate.md","hash":"eda226d9e38b445bae36e008ce3aabb9d05093a0","modified":1627804946469},{"_id":"source/_posts/Spring/TEST.md","hash":"6477c5e3ad72581297def0cc17420e7bf7d4445c","modified":1627804958280},{"_id":"source/_posts/Spring/WEBFLUX.md","hash":"6b2f488810123970f5793690a3caeaa36fcfce74","modified":1627804968856},{"_id":"source/_posts/TOOL-IDE/WebStorm_Optimize.md","hash":"b09a8393b2ec1887098cb30ed74cd192d66a9fc8","modified":1627906977247},{"_id":"themes/maupassant/.gitignore","hash":"16945417d10c15c950306794dbb0d970b5a199fe","modified":1627801888550},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1627801888550},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1627801888550},{"_id":"themes/maupassant/README.md","hash":"08a3499122e10a8fd8e0a75dcd4cce0125e8c98d","modified":1627813717274},{"_id":"themes/maupassant/_config.yml","hash":"281ee25ba07898c8b69e5311fb3b70be625fe573","modified":1627904524858},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1627801888558},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1627801888552},{"_id":"themes/maupassant/languages/en.yml","hash":"9c979a2f107536399bbe2be572c2d0bebcdd9d95","modified":1627801888552},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1627801888552},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1627801888552},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1627801888553},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1627801888553},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"78cc1794a3ce3e186c462c1a70f097d0c05cd210","modified":1627801888553},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"e9747f9b3ec1314a3cae44a9a90e7649af739633","modified":1627801888553},{"_id":"themes/maupassant/layout/archive.pug","hash":"749028e57a2eaad8c92ce2a2426c98605ab746a7","modified":1627801888557},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"80995eadfd89ee9aa36f4672f8d405e03f13af15","modified":1627801888557},{"_id":"themes/maupassant/layout/base.pug","hash":"a226db456b92c9e8611a8bfda07818e6c3d13dd5","modified":1627801888557},{"_id":"themes/maupassant/layout/index.pug","hash":"8f7e660f3682bd7258c5dfe54fa7c38a8cacd6d9","modified":1627815547779},{"_id":"themes/maupassant/layout/page.pug","hash":"a285a76950bb1b91f482ef9c473472bd0ede601d","modified":1627801888557},{"_id":"themes/maupassant/layout/post.pug","hash":"c0113056cbcfbba79867835ba364a37d9ccd3cfb","modified":1627801888557},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1627801888558},{"_id":"themes/maupassant/layout/tagcloud.pug","hash":"4aa57b41e919a12b6d7691cd4a36d3a531b55fcb","modified":1627801888558},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1627801888558},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"53415a1ca3337edcda99cd87abf3f087f3979624","modified":1627815635520},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"ee41abc4fe1610293ef4958275c41c9423d68105","modified":1627801888554},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1627811177858},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"51881cde4653f00e9d0de68fb9c201b52b100b9e","modified":1627801888554},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1627801888554},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1627801888554},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1627801888554},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1627801888555},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1627801888555},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"53d721ea4c93564cb0bdde065572ff6128574d36","modified":1627801888555},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1627801888555},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"b3c846a2e0ac79933e32c343029b769f2865a27f","modified":1627801888555},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1627801888555},{"_id":"themes/maupassant/layout/_widget/copyright.pug","hash":"32701dcba9c52d4bc73badaf8afe91af3f87b6a0","modified":1627801888556},{"_id":"themes/maupassant/layout/_widget/donate.pug","hash":"50855ce17af4298ce0f15236e2308c4a1760e7e3","modified":1627801888556},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"1ef7a333ab9bfa169276d0ad48aecf5166ab63cb","modified":1627801888556},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1627801888556},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1627801888556},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1627801888556},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1627801888556},{"_id":"themes/maupassant/source/css/copycode.css","hash":"e2463b8dacf629e180a1b6cd80667ca8044292eb","modified":1627801888558},{"_id":"themes/maupassant/source/css/copyright.css","hash":"a418da11a88d1feb14500df42ed97a64da6a7611","modified":1627801888559},{"_id":"themes/maupassant/source/css/dark.css","hash":"0faf42a84e243032b736c5f06ddbb95ac69e779c","modified":1627801888559},{"_id":"themes/maupassant/source/css/donate.css","hash":"95b2fd65042afecc0b5530847c369bcc11d74bd0","modified":1627801888559},{"_id":"themes/maupassant/source/css/search.css","hash":"9406e138d7bb6a9ef4a067eba1dafa627519c8a7","modified":1627801888559},{"_id":"themes/maupassant/source/css/style.scss","hash":"051f7e54915b88f5b6bc828001b063b10408f049","modified":1627904895274},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"3d94d2f9b09e352802628c9225578e1086f5fef3","modified":1627801888560},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"590b6b6462896168d08b30dfe2de5f08950d5553","modified":1627801888561},{"_id":"themes/maupassant/source/img/like.svg","hash":"e6e4bd1af076be9358316cac89efdc22ef4a5064","modified":1627801888561},{"_id":"themes/maupassant/source/img/github.svg","hash":"277798d16cb6106e45ef74f6b9972011fa43401b","modified":1627801888561},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"09786c983a10bc570dcd05b87cec601e9d01eb00","modified":1627801888561},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"19c1f68ec8c0b8e9f7855e7a6e78077f70a1aedc","modified":1627801888562},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1627801888562},{"_id":"themes/maupassant/source/js/copycode.js","hash":"fde1f153bab1f00ae8930668094c00aa9ff3c7a3","modified":1627801888562},{"_id":"themes/maupassant/source/js/donate.js","hash":"bdddd8d9847462d020f7a511e7e12c046223195d","modified":1627801888562},{"_id":"themes/maupassant/source/js/copyright.js","hash":"7b1bd775ea22abf33d57f78628f436bf656e439a","modified":1627801888562},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1627801888563},{"_id":"themes/maupassant/source/js/love.js","hash":"5cf89f622bf891cf1986845eb92eadef6f358eb7","modified":1627801888563},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1627801888563},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1627801888563},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1627801888563},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1627801888564},{"_id":"source/_posts/AWS/ETC.md","hash":"7c5f9e6985234eb22e970589e8bcd4b916ca22ee","modified":1627906785880},{"_id":"themes/apollo/.gitignore","hash":"a006beea0877a0aa3610ee00e73f62cb1d45125b","modified":1627806204806},{"_id":"themes/apollo/README.md","hash":"b2cdcb158721c13eee6a2ae237d0488a738ed8c5","modified":1627806204807},{"_id":"themes/apollo/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1627806204807},{"_id":"themes/apollo/_config.yml","hash":"261de70c54a5b6bac83afc8e1a77bbd715fae547","modified":1627806204808},{"_id":"themes/apollo/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1627806204809},{"_id":"themes/apollo/package.json","hash":"eb1e76ec0b7ed6c6c7b2bd32b4f1e1bbe15800ca","modified":1627806204814},{"_id":"themes/apollo/doc/doc-en.md","hash":"409e931a444c02a57b64a0a44dde6e66c1881ca0","modified":1627806204808},{"_id":"themes/apollo/doc/doc-zh.md","hash":"2a6a81840cdaf497969268a12d8f62c98cc38103","modified":1627806204809},{"_id":"themes/apollo/languages/en.yml","hash":"ca168b190932229884db1de755ec2f793c758a16","modified":1627806204809},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"22a2d16fe8c0dddb016b5325b9b9c182a1b49ae1","modified":1627806204810},{"_id":"themes/apollo/layout/archive.jade","hash":"62797414355bf4474092bc3a32726c8340820ffb","modified":1627806204810},{"_id":"themes/apollo/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1627806204810},{"_id":"themes/apollo/layout/post.jade","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1627806204814},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1627806204811},{"_id":"themes/apollo/source/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1627806204815},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"f23c6c40e14cdf16783b3c2baf736c9dce18408c","modified":1627806204811},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1627806204812},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"529c2ec06cfbc3d5b6d66dd320db50dfab5577a6","modified":1627806204813},{"_id":"themes/apollo/layout/partial/head.jade","hash":"43d2db73f0247a9a3ed00ecb95b537a872b7201a","modified":1627806204812},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"217f8b17054e5079f2d30bb7e2e4e36c0f2161b7","modified":1627806204812},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"f4842d9d3d763fbb823d112a6f49f24cc42a0ad4","modified":1627806204813},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"6bff591ae3d1ff6750f239c4c933ad61f009f36a","modified":1627806204813},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1627806204816},{"_id":"themes/apollo/source/css/apollo.css","hash":"e07a11a5da5fc097f023e06a85575356066afd09","modified":1627806204815},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"e0092f469264b55b25e0d441274f1c812147e7d1","modified":1627806204820},{"_id":"themes/apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1627806204816},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"ae967b2049ecb9b8c4e139ecce32fd9fb5358ac5","modified":1627806204817},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"d2f740a7d48349b7536777c795f82ab740836d0f","modified":1627806204816},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1627806204817},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1627806204817},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1627806204818},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1627806204818},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"fc5dda52cfbb10e27e2471e03f4606fb3d588225","modified":1627806204818},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1627806204820},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"1998f207541a2590a5624549f96c5e65d136690a","modified":1627806204820},{"_id":"themes/aloha/.bowerrc","hash":"5d8502d31f0ed07e935bc6faf5e7f8ce8308ab75","modified":1627807976503},{"_id":"themes/aloha/.editorconfig","hash":"3b7ce764f2d4f18f5fbe1096561e2bb65032e034","modified":1627807976503},{"_id":"themes/aloha/.gitignore","hash":"6c706fc646a2e59060b1bee6a089dfb3c778764c","modified":1627807976503},{"_id":"themes/aloha/.travis.yml","hash":"78870628e0c372dd310c22a09fd05edba798f4c7","modified":1627807976503},{"_id":"themes/aloha/LICENSE","hash":"7332cb9b022f3bc6f3806062ea3e24dab6ab7872","modified":1627807976503},{"_id":"themes/aloha/README.md","hash":"a19f1b0a53773223b5d3dc4272d7896c3775425a","modified":1627807976504},{"_id":"themes/aloha/_config.yml","hash":"3824d02cca3f2223611e73fdfdff50b0ff4c741d","modified":1627807976504},{"_id":"themes/aloha/bower.json","hash":"8233b2c8f90e453b2745ae7f3284ddf1f9b75a3d","modified":1627807976504},{"_id":"themes/aloha/gulpfile.js","hash":"bfaee2f68dfe2b9eb879a737cbc221e28f85c27f","modified":1627807976504},{"_id":"themes/aloha/package.json","hash":"8233b2c8f90e453b2745ae7f3284ddf1f9b75a3d","modified":1627807976510},{"_id":"themes/aloha/languages/en.yml","hash":"765e1052c4322c31088b2c7015718b1dcca2a5d7","modified":1627807976504},{"_id":"themes/aloha/languages/zh-CN.yml","hash":"9c6261721ca39721f0423aa487cfd5245e90bfdf","modified":1627807976504},{"_id":"themes/aloha/layout/archive.ejs","hash":"6913e223894986573c78c2a4a378d71d858784fe","modified":1627807976509},{"_id":"themes/aloha/layout/category.ejs","hash":"10739afe65298c0bb4b0946b02b5e1d38c4787ae","modified":1627807976509},{"_id":"themes/aloha/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1627807976509},{"_id":"themes/aloha/layout/layout.ejs","hash":"0b58c63e91f608fe8e2827ccc91eb000e8fd20b3","modified":1627807976510},{"_id":"themes/aloha/layout/page.ejs","hash":"f2070022e642c96b962c4e9e4425614e77809dc0","modified":1627807976510},{"_id":"themes/aloha/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1627807976510},{"_id":"themes/aloha/layout/tag.ejs","hash":"5caae7fe165eeb5e78880355e02e41f4b520db51","modified":1627807976510},{"_id":"themes/aloha/scripts/aloha-util.js","hash":"bc14e5337314eabaa88662897a134655adca004c","modified":1627807976510},{"_id":"themes/aloha/scripts/filter.js","hash":"efc79ce47f2bd3e49b61abbc71a3d6c9cd5413a5","modified":1627807976511},{"_id":"themes/aloha/scripts/helper.js","hash":"0803912708018c969630fe92f040deeb091b561a","modified":1627807976511},{"_id":"themes/aloha/layout/_partial/archive-post.ejs","hash":"31afcbe64063ba274e02f0df5ff2f1eaf6a410d2","modified":1627807976505},{"_id":"themes/aloha/layout/_partial/archive.ejs","hash":"a9792ed70d2bde56216682420d7e4f1a2a6b0a36","modified":1627807976505},{"_id":"themes/aloha/layout/_partial/article.ejs","hash":"caf26cd0f21b827f54406244375b9ed83691d66c","modified":1627807976505},{"_id":"themes/aloha/layout/_partial/footer.ejs","hash":"71ed42d099988a69ceae2f75404eb79031ff7be0","modified":1627807976505},{"_id":"themes/aloha/layout/_partial/header.ejs","hash":"2c24409923cc04734730560d658e6b56d36204bf","modified":1627807976505},{"_id":"themes/aloha/layout/_partial/js-params.ejs","hash":"77984c4bbf6c14a95a156ffd0d7302ac0b968af1","modified":1627807976506},{"_id":"themes/aloha/layout/_partial/menu.ejs","hash":"6309fe92f6f72e0796934e5373e7c0e293af032a","modified":1627807976506},{"_id":"themes/aloha/layout/_partial/pagination.ejs","hash":"71ace53e3e404212775d05f0ed991e02a79b6f1e","modified":1627807976506},{"_id":"themes/aloha/layout/_partial/recent-posts.ejs","hash":"c4d6ad99fabe8a9821511e2c39861b268779d40e","modified":1627807976507},{"_id":"themes/aloha/layout/_partial/search-modal.ejs","hash":"5f6bd05120b3df19024dd59da0be45031a00f6ca","modified":1627807976507},{"_id":"themes/aloha/layout/_partial/sidebar-card.ejs","hash":"f9ba3f0f22a2717fec3e0bb7fa66a9237b4ad368","modified":1627807976508},{"_id":"themes/aloha/layout/_partial/structured-data-markup.ejs","hash":"1d9579c8f3620faf08cdba9c134ea11c67180180","modified":1627807976508},{"_id":"themes/aloha/layout/_widget/disqus.ejs","hash":"543502ec45ac273e4681d8dc5c9140ee34d871ee","modified":1627807976509},{"_id":"themes/aloha/layout/_widget/duoshuo.ejs","hash":"91b3780f25cc94b8e4379c7ffbad3fded3b8c939","modified":1627807976509},{"_id":"themes/aloha/scripts/filter/after_post_render.js","hash":"17dfe245d8804f6ed109b78d43883e53fbead4ca","modified":1627807976511},{"_id":"themes/aloha/scripts/helper/toc.js","hash":"a898c9de0a099b4f720c6586ca89a0b7c826af0c","modified":1627807976511},{"_id":"themes/aloha/source/css/aloha.less","hash":"39910135947134d51fd490af7fab5f85636d189d","modified":1627807976512},{"_id":"themes/aloha/source/css/aloha.css","hash":"bec88f07f869e55381425b493d458ef8d3b11e82","modified":1627807976512},{"_id":"themes/aloha/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1627807976519},{"_id":"themes/aloha/source/images/scrolltop.png","hash":"97ae9aeea6178c2d73ced32aa7161743b1962998","modified":1627807976520},{"_id":"themes/aloha/source/js/aloha-events.js","hash":"2cd034c5bce6e1260bf7918ebfa1efa287694f6b","modified":1627807976520},{"_id":"themes/aloha/source/js/aloha.js","hash":"679001bf3666d0d32702308cfa77e3d714d2d2f6","modified":1627807976520},{"_id":"themes/aloha/source/js/semantic-ui-algolia.js","hash":"108379745038ae336bbcb11e53fc2733248632b0","modified":1627807976520},{"_id":"themes/aloha/layout/_partial/post/category.ejs","hash":"e04160c8de3cb3470aa659b22812fd466d78c234","modified":1627807976506},{"_id":"themes/aloha/layout/_partial/post/date.ejs","hash":"c334b04c440fad46619fff14422b6e7b57cae7c7","modified":1627807976507},{"_id":"themes/aloha/layout/_partial/post/gallery.ejs","hash":"0dbacc346e0250edcd814309056fb80ad5ae967f","modified":1627807976507},{"_id":"themes/aloha/layout/_partial/post/tag.ejs","hash":"0b16be115bb0bd548cdcbfb5ef0d0a9378b6d8be","modified":1627807976507},{"_id":"themes/aloha/layout/_partial/post/nav.ejs","hash":"cf2aae1bf16c813c6a3a2d2f4271ef037a57d159","modified":1627807976507},{"_id":"themes/aloha/layout/_partial/post/title.ejs","hash":"48ac6bb0e6d8c0c14c2390952b35867539f08f69","modified":1627807976507},{"_id":"themes/aloha/source/css/_partial/highlight.less","hash":"b51526be9463a6a427267592c6a54066136cfe4d","modified":1627807976511},{"_id":"themes/aloha/source/css/_partial/variables.less","hash":"09e4bcb52124928352b351769976e5fd157ed785","modified":1627807976512},{"_id":"themes/aloha/source/css/_partial/main.less","hash":"14f5f0dbac5fbbc6f7cfdd7e423edb908ea1cc57","modified":1627807976512},{"_id":"themes/aloha/layout/_partial/theme/simple/post-description.ejs","hash":"a95c1cdc5f262736853174a13e4a5061d7e4a48e","modified":1627807976508},{"_id":"themes/aloha/layout/_partial/theme/simple/post_item.ejs","hash":"e023d17ae73276067bb6f96dabdef509a97fcdec","modified":1627807976508},{"_id":"themes/aloha/source/css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.eot","hash":"3e63fc9b3de4580f1f3bec0631436f755b80f167","modified":1627807976515},{"_id":"themes/aloha/source/css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.woff2","hash":"1075231650f579955905bb2f6527148a8e2b4b16","modified":1627807976518},{"_id":"themes/aloha/source/favicon.ico","hash":"732a554507e50045577bb007d0e11eeb1b775b66","modified":1627807976518},{"_id":"themes/aloha/source/css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.ttf","hash":"9088143b19979779b2116cef38b661f72d982e19","modified":1627807976517},{"_id":"themes/aloha/source/css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.woff","hash":"56ce13e71c2150d81bc972940584915181bd6081","modified":1627807976517},{"_id":"themes/aloha/source/images/avatar.jpg","hash":"8f35072a67cc7de306601cf5a56e988207430620","modified":1627807976520},{"_id":"themes/aloha/source/css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.svg","hash":"26bb1c5ef100a1cd71923f1d5dc29fc797ef4639","modified":1627807976516},{"_id":"themes/aloha/source/css/semantic-ui/2.2.4/semantic.min.css","hash":"00d3a19960b111ae8e805afce3788ee0213aa363","modified":1627807976514},{"_id":"public/atom.xml","hash":"85c175b3c534061e53d6cb2df31a71d28a3250de","modified":1627809831062},{"_id":"public/sitemap.xml","hash":"518065bf5f2c8017938a9b23a4be7912beb03b3d","modified":1627905077496},{"_id":"public/robots.txt","hash":"dad564521d41026801e6a916b5892b84921aa551","modified":1627905077496},{"_id":"public/2021/07/30/DIARY/20210730/index.html","hash":"6bbc619d5ad7e53197ff09c53c2e5189b8c8e6b2","modified":1627905077496},{"_id":"public/2021/07/30/HTTP/그림으로배우는_HTTP_CH5/index.html","hash":"eb4cff58f6c2699566055772ee0c4a55f71979ea","modified":1627905077496},{"_id":"public/2021/07/29/ARCHITECTURE/Idempotent/index.html","hash":"0a6a81bf5c5512a5efdad04cdc2d281f5e13ab25","modified":1627905077496},{"_id":"public/2021/07/29/CS/한권으로읽는컴퓨터구조와프로그래밍/index.html","hash":"237c8f6ab57417c90ff61a857d272afa867c34c6","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20190304/index.html","hash":"379cacab23e1f9bfb59d350ec625931a342c30e6","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20190305/index.html","hash":"d262273255dd00962bd47ba840a9307489ca9dab","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20190307/index.html","hash":"8e1df38bb1a83672259f29e4eef6c15f95f0e2cf","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20190311/index.html","hash":"e48c91025d1328d0b4ddd8483310f6d2157ba30c","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20190501/index.html","hash":"b1336445b468bdfba591a5ac90e658804d9bd32b","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20190507/index.html","hash":"dfe97eafda17d4ac375846ce2fe02722515f3be2","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20190526/index.html","hash":"5e7467c13986ca75aecc40b82cd878aa8d3cffa2","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20190504/index.html","hash":"de06fbce2d157238f54eb6c7ac9ebe0a5820669b","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20190528/index.html","hash":"529830aa765621564c8003887d8a81f77ed09172","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20190603/index.html","hash":"816b574e025c76417b11068cd11dfd1742f32a23","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20190609/index.html","hash":"0afc156f6f01cf797a8a65fe8e047aec9359b922","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20190622/index.html","hash":"c4169f1c26983c820c5d677d8f62788b567474aa","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20190714/index.html","hash":"b8f60c2da4573062dea0073a9d62de9a892594c7","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20190810/index.html","hash":"acf080d90da1a8da7abeeaed2fe73d7d1bd5d1bc","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20200305/index.html","hash":"b728f662173931d768e2b8ec3efeed7de0a9eb33","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20200922/index.html","hash":"780661f0d2c38facd7a92306114eaf8a6aeab75f","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20210727/index.html","hash":"7100c137edec499052dcbc4f40500e7e57416425","modified":1627905077496},{"_id":"public/2021/07/29/DIARY/20210728/index.html","hash":"dd69f71758b6944718fdf4577c54580a4fbf859a","modified":1627905077496},{"_id":"public/2021/07/29/AWS/ETC/index.html","hash":"06533e3a68040297cd5e9043bccfd424f60d1b94","modified":1627905077496},{"_id":"public/2021/07/28/Java/APACHE_HTTP_CLIENT/index.html","hash":"686affc3fffb200740b6c4c52cc3fb1cf5607a0a","modified":1627905077496},{"_id":"public/2021/07/28/Java/THREAD/index.html","hash":"1e14602ddc9f2c503edcc30f14684f2a38fe903e","modified":1627905077496},{"_id":"public/2021/07/28/JavaScript/Function/index.html","hash":"1088046227679e8f2f6221cc632cd0b25da516ac","modified":1627905077496},{"_id":"public/2021/07/28/JavaScript/react-route/index.html","hash":"95ff2eb8f2f27362e29cc785e3ede8a709b1c06f","modified":1627905077496},{"_id":"public/2021/07/28/Kotlin/Reference/index.html","hash":"54323643731a2e3517ff07d438caf503fdf8182d","modified":1627905077496},{"_id":"public/2021/07/28/Kotlin/Rx_Kotlin_2/index.html","hash":"54dda47385810e53a5ffc18153c45b748cb6d3f4","modified":1627905077496},{"_id":"public/2021/07/28/MESSAGING/REDISSON/index.html","hash":"4107b759061cb3338d32b3f697a5789f8b3a8254","modified":1627905077496},{"_id":"public/2021/07/28/MESSAGING/RabbitMQ/index.html","hash":"e5aa25c384e00a3d16a63ce1acff45541a605d27","modified":1627905077496},{"_id":"public/2021/07/28/Persistence/JPA_ACCESS/index.html","hash":"2dfba27679dec2b17737f1bdeaa50ec70015d4a4","modified":1627905077496},{"_id":"public/2021/07/28/Persistence/JPA_EntityManager/index.html","hash":"263787470a8003b837ae4a50a4076af057b72963","modified":1627905077496},{"_id":"public/2021/07/28/Persistence/JPA_Reference/index.html","hash":"89a094de889ae0074856e09fb6ed973bbd9b7a11","modified":1627905077496},{"_id":"public/2021/07/28/Persistence/jooq/index.html","hash":"2ee3d7399f307233affe0e305b88705dfc5e6fee","modified":1627905077496},{"_id":"public/2021/07/28/REDIS/redlock/index.html","hash":"6d92cb1c21ce118840e1eb157f7d290e93151e78","modified":1627905077496},{"_id":"public/2021/07/28/Spring/MVC_RequestParam/index.html","hash":"aa72bb01f3903ac92176bd4eaa114a68dc97f393","modified":1627905077496},{"_id":"public/2021/07/28/Spring/RestTemplate/index.html","hash":"7b026a60d542e058f614c16de3fd7808af5ae481","modified":1627905077496},{"_id":"public/2021/07/28/TOOL-IDE/WebStorm_Optimize/index.html","hash":"1b8a31dd358b5412711d5edeab176e2f4ff86265","modified":1627905077496},{"_id":"public/archives/index.html","hash":"4a31133b453b5ffa651e756ef881dbc74cd7f101","modified":1627905077496},{"_id":"public/archives/page/2/index.html","hash":"1c14ac52f1eda6d8be150f1d3cd0f0fb840f1955","modified":1627905077496},{"_id":"public/archives/page/3/index.html","hash":"7a099607fb7acbb4e78c4cbb56c55e5af541ebec","modified":1627905077496},{"_id":"public/archives/page/4/index.html","hash":"91dd84a02d2806e001ad567191a39878283bda20","modified":1627905077496},{"_id":"public/archives/page/5/index.html","hash":"666cf5bdd43be244d94813efc085a8eb12b29b48","modified":1627905077496},{"_id":"public/archives/page/6/index.html","hash":"c396154e55aa6f8ad5c7391011d09cbef53d7ca0","modified":1627905077496},{"_id":"public/archives/page/7/index.html","hash":"919f0c41ae0f18a1bc2e4c6a2fab0041be5eb619","modified":1627905077496},{"_id":"public/archives/page/8/index.html","hash":"fcd3c7a45044c6c03efb7f85bd4b5f8e8273b212","modified":1627905077496},{"_id":"public/archives/2021/index.html","hash":"88b9dfe4a3d8aa2fcb8681aeba7a34261828b85a","modified":1627905077496},{"_id":"public/archives/2021/page/2/index.html","hash":"0cdd5ad5c2b8b34c19b5339cd9a4aace9fb47e24","modified":1627905077496},{"_id":"public/archives/2021/page/3/index.html","hash":"a1360c3e42e129a0b5594beb6e0339dc57bea623","modified":1627905077496},{"_id":"public/archives/2021/page/4/index.html","hash":"fc312e9b12e037a393ab60eb3881a059e5c4c358","modified":1627905077496},{"_id":"public/archives/2021/page/5/index.html","hash":"4a732cd8349cbba52254c8c35ff40fc1b7c8ebdf","modified":1627905077496},{"_id":"public/archives/2021/page/6/index.html","hash":"840db064714033f5ed16ffd8e1abcb1f62f7a289","modified":1627905077496},{"_id":"public/archives/2021/page/7/index.html","hash":"2b1c42b5a58ec48b82c5f0d075ce0a13e51207e4","modified":1627905077496},{"_id":"public/archives/2021/page/8/index.html","hash":"cfa9f28306369c44d1befa873534cda3ed08ffc4","modified":1627905077496},{"_id":"public/archives/2021/07/index.html","hash":"1c8ddfeec342ae60f4165b9479fb2376291027c8","modified":1627905077496},{"_id":"public/archives/2021/07/page/2/index.html","hash":"def1f21eec1cd9c5530f0a5f1816d6c0318ec2d0","modified":1627905077496},{"_id":"public/archives/2021/07/page/3/index.html","hash":"d87339a48e805bcd4e3911492c659d62965563e3","modified":1627905077496},{"_id":"public/archives/2021/07/page/4/index.html","hash":"3a93e8859cce0993b9d101e307b366bbaa8cb6c3","modified":1627905077496},{"_id":"public/archives/2021/07/page/5/index.html","hash":"22cb36b8a6e18da62372100628c7472861ca0113","modified":1627905077496},{"_id":"public/archives/2021/07/page/6/index.html","hash":"6aa47fb5e127ae3481a6531c7cda531a956c4a82","modified":1627905077496},{"_id":"public/archives/2021/07/page/7/index.html","hash":"74a90cd4ce73d2a9c4113d953a9cefe5e9c2a4a2","modified":1627905077496},{"_id":"public/archives/2021/07/page/8/index.html","hash":"46f7b50345bba210b43d02704e78ab580192ec02","modified":1627905077496},{"_id":"public/categories/ARCHITECTURE/index.html","hash":"d2fbf6c53b7f16fd107b5edfff6eaecf22e5f34c","modified":1627905077496},{"_id":"public/categories/AWS/index.html","hash":"7a61a096b37f23ca951c99f1b99bcda7afce17b0","modified":1627905077496},{"_id":"public/categories/CS/index.html","hash":"f072921582efa0ff234e536ad92dc1cafb4af99c","modified":1627905077496},{"_id":"public/categories/DDD/index.html","hash":"bc1e15a79fcedfa2ac5c9d4ee977098e61d7e51b","modified":1627905077496},{"_id":"public/categories/DIARY/index.html","hash":"9862200ac365849b61b015cc23e3ced18e5a8d7a","modified":1627905077496},{"_id":"public/categories/DIARY/page/2/index.html","hash":"336014ad008f373b77e126411644579a37bf2993","modified":1627905077496},{"_id":"public/categories/HTTP/index.html","hash":"7c127a7b672d0bce85dcd347213f53388cc16bf6","modified":1627905077496},{"_id":"public/categories/Java/index.html","hash":"c6aec1f7816abf5ebe7b0d7e963426b5a3e3177f","modified":1627905077496},{"_id":"public/categories/JavaScript/index.html","hash":"25fea2a98ac805f3ed324ade445874c4422d7bb6","modified":1627905077496},{"_id":"public/categories/JavaScript/page/2/index.html","hash":"e3096b084151b5353c3542911250e3f1b248fd52","modified":1627905077496},{"_id":"public/categories/Kotlin/index.html","hash":"9eb3f4b120fd4629a349294906446de615dccba7","modified":1627905077496},{"_id":"public/categories/MESSAGING/index.html","hash":"bb5316d7630885c85ec00b3bbc0c957a578d8838","modified":1627905077496},{"_id":"public/categories/Persistence/index.html","hash":"6989e00315e06c7ee7da6a6258725a46555b5686","modified":1627905077496},{"_id":"public/categories/Redis/index.html","hash":"bf17a1b0e547b7d6e0d1a77feef452e778e7d9ab","modified":1627905077496},{"_id":"public/categories/Spring/index.html","hash":"524e8287e70036de8fb62478459e661204c95305","modified":1627905077496},{"_id":"public/index.html","hash":"9e6b87a0394a5a28ebb8d28e17b0225f1db3e9d9","modified":1627905077496},{"_id":"public/page/2/index.html","hash":"6d4bc42e00f44c16743600208c516b5d42545ca8","modified":1627905077496},{"_id":"public/page/3/index.html","hash":"f1314ff03988da4c468090651961644d80994eaa","modified":1627905077496},{"_id":"public/page/4/index.html","hash":"92a5da78bf7d3965a9d1670b885b3d3f75ddc960","modified":1627905077496},{"_id":"public/page/5/index.html","hash":"09a88aa886d1e1d97edde9655c0839355a20cc0c","modified":1627905077496},{"_id":"public/page/6/index.html","hash":"b79cb14548447a8f48704f957a4bd7477ecafaa6","modified":1627905077496},{"_id":"public/page/7/index.html","hash":"4143df3468f24fc102d214131ad2051fe41ce1ed","modified":1627905077496},{"_id":"public/page/8/index.html","hash":"1b6ccae85ce1a959b05dcf8283bd13e813a5b2e9","modified":1627905077496},{"_id":"public/2021/07/30/HTTP/그림으로배우는_HTTP_CH6/index.html","hash":"64472caea9d57c49d00ee4e9502703f822e8f834","modified":1627905077496},{"_id":"public/2021/07/29/AWS/cloudfront_s3_route53_staticweb/index.html","hash":"3c7c3fec97bfcb463b1d9691af99173c123ccaf7","modified":1627905077496},{"_id":"public/2021/07/29/AWS/serverless_framework/index.html","hash":"b31264f33711d65dbbe8598b6636f4646cf7825a","modified":1627905077496},{"_id":"public/2021/07/29/ARCHITECTURE/ELEGANT_OBJECT/index.html","hash":"7a59fc745ead8e88708096283da36ec02201c429","modified":1627905077496},{"_id":"public/2021/07/29/DDD/DDD_START_1/index.html","hash":"35acbcff54b133e6b5abafc80441247e4f16082a","modified":1627905077496},{"_id":"public/2021/07/29/DDD/DDD_START_2/index.html","hash":"b6a934f68a1a67a5b37ac8b2fc2b2eb44eb1c697","modified":1627905077496},{"_id":"public/2021/07/29/DDD/DDD_START_3/index.html","hash":"64f3a418117347e3b3a98e6da997c69db4dc2a20","modified":1627905077496},{"_id":"public/2021/07/28/Java/EffectiveJava3e_ch2/index.html","hash":"201f6d1f9929058d8fe3f4d1a9273ffb90a1b126","modified":1627905077496},{"_id":"public/2021/07/28/Java/EffectiveJava3e_ch3/index.html","hash":"18d909d71f61c450bd5f19d9bf422e192d88cab8","modified":1627905077496},{"_id":"public/2021/07/28/Java/mapStruct/index.html","hash":"49b42016436e5090869d00cd00efba81e3495ea3","modified":1627905077496},{"_id":"public/2021/07/28/JavaScript/BestPracticesforSpiesStubsAndMocksinSinon.js/index.html","hash":"72270d3ef65c1a3163d146072e190bb1041da1bf","modified":1627905077496},{"_id":"public/2021/07/28/JavaScript/ES6_defaultparameter_spreadoperator/index.html","hash":"c784f571e065e9c94cf7fc08ed51ef7385964c13","modified":1627905077496},{"_id":"public/2021/07/28/JavaScript/MemoryManagement/index.html","hash":"df5389ea42244358d5ccb60ef06d51501af06e02","modified":1627905077496},{"_id":"public/2021/07/28/JavaScript/ES6_let_const/index.html","hash":"2d54d7884a6b63656a71f91f94757457c9bfe98a","modified":1627905077496},{"_id":"public/2021/07/28/JavaScript/NVM-NodeJs/index.html","hash":"a005721e12fadd04686965aa87f1b1246e9aeacb","modified":1627905077496},{"_id":"public/2021/07/28/JavaScript/Prototype/index.html","hash":"0965491cff6bc6505815fd7885db6fb1f344dd41","modified":1627905077496},{"_id":"public/2021/07/28/JavaScript/React-Redux-Test/index.html","hash":"d46c5999938bfbb8e7f6927c693429704cfc2e5c","modified":1627905077496},{"_id":"public/2021/07/28/JavaScript/pm2/index.html","hash":"8d3c7273c4fcafc858326127958f48f5de93e9b3","modified":1627905077496},{"_id":"public/2021/07/28/JavaScript/express.js/index.html","hash":"17403001b5205c197470164ff137c45534b4fc46","modified":1627905077496},{"_id":"public/2021/07/28/Kotlin/Kotlin_With_Spring/index.html","hash":"d8218cc2e58069c5f796f5573d6c9aaceac97ee5","modified":1627905077496},{"_id":"public/2021/07/28/Kotlin/Rx_Kotlin_1/index.html","hash":"1ba9631fd669977edd2722567b8e2562bd71139c","modified":1627905077496},{"_id":"public/2021/07/28/Kotlin/StandardFunction/index.html","hash":"df3d055e013e40f7d92288c6dae5ad5078ab8529","modified":1627905077496},{"_id":"public/2021/07/28/Kotlin/WithJava/index.html","hash":"c47d53202d09ebd833f53d0f947334205441e106","modified":1627905077496},{"_id":"public/2021/07/28/Persistence/Alternative_JPA/index.html","hash":"8b94deeaa8526ab19d76450df6857c51750ba69d","modified":1627905077496},{"_id":"public/2021/07/28/Persistence/JPA_ENHANCE_INSERT/index.html","hash":"d1b5bd2152cb3b1277cdb14bf5cc2aa3ce38cd8f","modified":1627905077496},{"_id":"public/2021/07/28/Persistence/JPA_컬렉션_리스너/index.html","hash":"fd9a74569d21f76a4e6a35d036acbd1e554ca919","modified":1627905077496},{"_id":"public/2021/07/28/Spring/BATCH_1/index.html","hash":"aea9b850d377a1a7ed9af0105502f03f7b5d7e15","modified":1627905077496},{"_id":"public/2021/07/28/Spring/BATCH_3/index.html","hash":"de8512a953792d7790a2556c84fbfa2b9122e406","modified":1627905077496},{"_id":"public/2021/07/28/Spring/BATCH_2/index.html","hash":"f52e5a5776b73b23247f8805a8cf668ef4ec079f","modified":1627905077496},{"_id":"public/2021/07/28/Spring/LOG/index.html","hash":"ffe17d337811d5c8de129b4213ebcf6b968898b0","modified":1627905077496},{"_id":"public/2021/07/28/Spring/MVC_PartialReseponse/index.html","hash":"a58232077ae0335079eb86a913e2a7d3c10e5427","modified":1627905077496},{"_id":"public/2021/07/28/Spring/TEST/index.html","hash":"37c521b7a60b3ff08d6beedd0e13a4c12c4885fd","modified":1627905077496},{"_id":"public/2021/07/28/Spring/WEBFLUX/index.html","hash":"1193d573cd6f8c484a34654e3d74d03f0c3b686b","modified":1627905077496},{"_id":"public/2021/07/28/Java/NETTY_IN_ACTION/index.html","hash":"a3e006052d1b2aa0fc0a2cf900daabf6b391f2a5","modified":1627905077496},{"_id":"public/2021/07/28/Kotlin/How_to_make_sense_of_Kotlin_coroutines/index.html","hash":"2dc36b04e013488197eb66735af59d071df9cf2d","modified":1627905077496},{"_id":"public/2021/07/28/Kotlin/Kotlin_In_Action/index.html","hash":"8cc30bbac57f8442c0114d551a93233ce648dd08","modified":1627905077496},{"_id":"public/2021/07/28/MYSQL/replication/index.html","hash":"7504790885a6e20f034557cd480ff77b1cf5558d","modified":1627905077496},{"_id":"public/2021/07/28/Persistence/JPA_영속성관리/index.html","hash":"f41d7099f97629022d87877616b32d64d8873d3a","modified":1627905077496},{"_id":"public/2021/07/28/Kotlin/Kotlin_CookBook/index.html","hash":"a142844eea0ced368b81b141dbfe6542221ff5e6","modified":1627905077496},{"_id":"public/img/bitcoin.svg","hash":"590b6b6462896168d08b30dfe2de5f08950d5553","modified":1627905077496},{"_id":"public/img/like.svg","hash":"e6e4bd1af076be9358316cac89efdc22ef4a5064","modified":1627905077496},{"_id":"public/img/alipay.svg","hash":"3d94d2f9b09e352802628c9225578e1086f5fef3","modified":1627905077496},{"_id":"public/img/paypal.svg","hash":"09786c983a10bc570dcd05b87cec601e9d01eb00","modified":1627905077496},{"_id":"public/img/github.svg","hash":"277798d16cb6106e45ef74f6b9972011fa43401b","modified":1627905077496},{"_id":"public/img/wechat.svg","hash":"19c1f68ec8c0b8e9f7855e7a6e78077f70a1aedc","modified":1627905077496},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1627905077496},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1627905077496},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1627905077496},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1627905077496},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1627905077496},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1627905077496},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1627905077496},{"_id":"public/css/copycode.css","hash":"e2463b8dacf629e180a1b6cd80667ca8044292eb","modified":1627905077496},{"_id":"public/css/search.css","hash":"9406e138d7bb6a9ef4a067eba1dafa627519c8a7","modified":1627905077496},{"_id":"public/css/copyright.css","hash":"a418da11a88d1feb14500df42ed97a64da6a7611","modified":1627905077496},{"_id":"public/css/donate.css","hash":"95b2fd65042afecc0b5530847c369bcc11d74bd0","modified":1627905077496},{"_id":"public/css/dark.css","hash":"0faf42a84e243032b736c5f06ddbb95ac69e779c","modified":1627905077496},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1627905077496},{"_id":"public/js/copycode.js","hash":"fde1f153bab1f00ae8930668094c00aa9ff3c7a3","modified":1627905077496},{"_id":"public/js/donate.js","hash":"bdddd8d9847462d020f7a511e7e12c046223195d","modified":1627905077496},{"_id":"public/js/copyright.js","hash":"7b1bd775ea22abf33d57f78628f436bf656e439a","modified":1627905077496},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1627905077496},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1627905077496},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1627905077496},{"_id":"public/js/love.js","hash":"5cf89f622bf891cf1986845eb92eadef6f358eb7","modified":1627905077496},{"_id":"public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1627905077496},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1627905077496},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1627905077496},{"_id":"public/css/style.css","hash":"9bdb19857838e230e5cec7258aca8b1a697f3f90","modified":1627905077496},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1627905077496},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1627905077496},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1627905077496},{"_id":"themes/maupassant/.DS_Store","hash":"1e9a1076aa1768a2a13613b38a19b234750f1db0","modified":1627814025720},{"_id":"source/menu.yml","hash":"5b9702197e9890374031345063601d975bb48162","modified":1627815856977},{"_id":"source/_data/menu.yml","hash":"5b9702197e9890374031345063601d975bb48162","modified":1627815944429},{"_id":"source/test.html","hash":"a3c1869afb3831a254a789061f3d7c67a66dc788","modified":1627817657206},{"_id":"public/test.html","hash":"bdfebfa9293b89488cf2d515e7c8c8f501eb1f66","modified":1627817671243},{"_id":"source/_posts/HTTP/Idempotent.md","hash":"9dffd5f5a79b2b88fe734c7a0144f5d29ebaafd0","modified":1627906269273}],"Category":[{"name":"ARCHITECTURE","_id":"ckrsw4lpt0000rthv74dl5eo5"},{"name":"AWS","_id":"ckrswaiic000226hv9qm1cbmh"},{"name":"CS","_id":"ckrswbmol000826hvgn4n6rnt"},{"name":"DDD","_id":"ckrswbya6000a26hveb658hbx"},{"name":"DIARY","_id":"ckrswe8up000e26hv4axdbya3"},{"name":"HTTP","_id":"ckrswk92a000y26hv0xc00wmw"},{"name":"Java","_id":"ckrswkts9001126hv79u47plu"},{"name":"JavaScript","_id":"ckrswp98d001826hv5xoe8bwv"},{"name":"Kotlin","_id":"ckrswte7s0006kxhv2qav3dqi"},{"name":"MESSAGING","_id":"ckrsww5po000jkxhv2l4688kd"},{"name":"Persistence","_id":"ckrswx93k000nkxhv0rpoeojh"},{"name":"Redis","_id":"ckrswzigd000wkxhvcmcz0gn8"},{"name":"Spring","_id":"ckrswzu1j000ykxhv30njd8xe"}],"Data":[],"Page":[],"Post":[{"title":"S3 + CloudFront + Route53 + Vuepress + Gulp을 활용한 SPA 어플리케이션 배포","date":"2019-07-11T15:00:00.000Z","_content":"\n## S3 + CloudFront + Route53 + Vuepress + Gulp을 활용한 SPA 어플리케이션 배포\n\n회사에서 별도로 업무 문서 관리 용도로 Static 사이트를 배포해야 할 일이 생겨서, 어차피 AWS 환경을 사용하고 있으니 S3 + Cloudfront + Route53을 활용하여 사이트를 배포하면 좋을꺼 같아 해당 업무를 수행하면서 사용했던 내용을 간단하게 정리해봤다.\n\n문서는 어차피 마크다운으로 작성하기 때문에, 마크다운을 Static Resource로 변환해주는 프레임워크나 환경을 찾다가 우연하게 미려한 UI에 끌려 [Vuepress](https://vuepress.vuejs.org/)를 선택하게 됬다.\n\n- 템플릿 참고: [vuepress-template](https://github.com/stasson/vuepress-template)\n\n배포 방법은 여러가지가 있겠지만, 우선 급한대로 gulp를 활용하여 배포 스크립트를 작성했고 스크립트 내용은 별게 없기 때문에 아래와 같이 작성하여 사용했다.\n\n#### gulpfile.js\n```javascript\n\n'use strict';\n\nconst gulp = require('gulp');\nconst awspublish = require('gulp-awspublish');\nconst cloudfront = require(\"gulp-cloudfront\");\nrequire('dotenv').config();\n\ngulp.task('publish', () => {\n  const aws = {\n    region: process.env.AWS_REGION,\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n    distributionId: process.env.PROD_DISTRIBUTION_ID,\n    params: {\n      Bucket: process.env.PROD_BUCKET\n    },\n  };\n\n  const headers = {\n    \"Cache-Control\": \"max-age=0\"\n  };\n\n\n  const publisher = awspublish.create(aws);\n  return gulp.src('./public/**/*')\n    .pipe(awspublish.gzip())\n    .pipe(publisher.publish(headers))\n    .pipe(publisher.cache())\n    .pipe(awspublish.reporter())\n    .pipe(cloudfront(aws));\n});\n```\n배포에 필요한 환경변수는 `.env`을 통하여 참조하도록 구성했다. 파일의 내용은 하단과 같다. 환경과 관련된 중요한 정보를 담고 있기 떄문에 VersionControl을 하지 않고 로컬에서만 관리하도록 했다.\n\n#### .env\n```bash\n# AWS 리전명\nAWS_REGION={AWS REGION} \n\n# 액세스 키\nAWS_ACCESS_KEY_ID={ACCESS_KEY}\n\n# 시크릿 키\nAWS_SECRET_ACCESS_KEY={SECRET_ACCESS_KEY}\n\n# 버킷명\nPROD_BUCKET={BUCKET_NAME}\n\n# CloudFront 배포ID\nPROD_DISTRIBUTION_ID={CLOUDFRONT_DISTRIBUTION-ID}\n```\n\n\n### S3 버킷 생성\n![](https://i.imgur.com/sM202Cw.png)\n  - 버킷 생성 후 Static Web Site 옵션 활성화\n\n### CloudFront 설정\n#### Distribution\n- Price-Class\n  - 필요에 맞는 지역을 선택, Global을 사용하게 되면 과금이 크게 될 수 있으므로 적절한 선택이 필요함.\n- WAF Web ACL\n  - 별도로 병화벽 사용 시 지정, WAF를 사용하면 IP Whitelist 관리 및 SQL Injection 공격까지 막아 줄 수 있음\n- Alternate Domain Names\n  - Route53에서 지정한 CNAME 사용\n- SSL Certificate\n  - Custom SSL Certificate 지정, AWS Certificate Manager에서 생성한 인증서 사용하면 편함\n- Security Policy\n  - TLSv1.1_2016 (recommended)\n- Supported HTTP Versions\n  - HTTP/2, HTTP/1.1, HTTP/1.0\n- Default Root Object\n  - index.html 지정\n#### Origins and Origin Groups\n- Origin Domain Name: S3 static site 경로를 지정\n- Restrict Bucket Access: No\n\n#### Behaviors\n- HTTP METHOD, 캐싱 정책 및 HTTP 리다이렉션을 지정할 수 있음\n- 요청/응답 주기에 따른 AWS Lambda Function 지정 가능\n\n#### Error Pages\n![](https://i.imgur.com/KHZH6e4.png)\n- HTTP Error Code가 발생했을 때, 이후 액션을 어떻게 할건지 정할 수 있음.\n- SPA의 경우, Client-Side Routing을 하기 떄문에, 실제 S3 오리진에 없는 리소스가 존재하더라도 접근에 대한 제어는 Client Application에서 제어 해야 함.\n\n#### Invalidations\n- 캐싱된 CloudFront의 자원을 Invalidation 할때 사용 \n\n### Route53 설정\n* Hosted-Zone -> Create-Record-Set\n![](https://i.imgur.com/P5clcf6.png)\n- `Name`에는 서브도메인명 지정\n- `Alias`의 값은 `Yes`로 지정\n- `Alias Target`의 값은 위에서 배포한 CloudFront의 Domain Name을 지정\n- `Create`를 누르고 마무리\n\n### 참고 URL\n- [Amazon S3 버킷과 함께 CloudFront 배포 사용](https://support.ptc.com/help/thingworx_hc/thingworx_utilities_8_hc/ko/index.html#page/ThingWorx_Utilities/Converge_CDNCloudFrontWS3.html)\n- [S3 웹 사이트 엔드포인트를 CloudFront 배포의 오리진으로 사용하고 있습니다. HTTP 응답 코드 403(액세스 거부)이 수신되는 이유는 무엇입니까?](https://aws.amazon.com/ko/premiumsupport/knowledge-center/s3-website-cloudfront-error-403/)\n- [How To Host Static Website On Amazon AWS S3](https://www.hackingnote.com/en/web-deployment/how-to-host-static-website-on-amazon-aws-s3)\n- [Host a Static Site on AWS, using S3 and CloudFront](https://www.davidbaumgold.com/tutorials/host-static-site-aws-s3-cloudfront/)\n","source":"_posts/AWS/cloudfront_s3_route53_staticweb.md","raw":"---\ntitle: S3 + CloudFront + Route53 + Vuepress + Gulp을 활용한 SPA 어플리케이션 배포\ndate: 2019/7/12 00:00:00\ncategories:\n- AWS\n---\n\n## S3 + CloudFront + Route53 + Vuepress + Gulp을 활용한 SPA 어플리케이션 배포\n\n회사에서 별도로 업무 문서 관리 용도로 Static 사이트를 배포해야 할 일이 생겨서, 어차피 AWS 환경을 사용하고 있으니 S3 + Cloudfront + Route53을 활용하여 사이트를 배포하면 좋을꺼 같아 해당 업무를 수행하면서 사용했던 내용을 간단하게 정리해봤다.\n\n문서는 어차피 마크다운으로 작성하기 때문에, 마크다운을 Static Resource로 변환해주는 프레임워크나 환경을 찾다가 우연하게 미려한 UI에 끌려 [Vuepress](https://vuepress.vuejs.org/)를 선택하게 됬다.\n\n- 템플릿 참고: [vuepress-template](https://github.com/stasson/vuepress-template)\n\n배포 방법은 여러가지가 있겠지만, 우선 급한대로 gulp를 활용하여 배포 스크립트를 작성했고 스크립트 내용은 별게 없기 때문에 아래와 같이 작성하여 사용했다.\n\n#### gulpfile.js\n```javascript\n\n'use strict';\n\nconst gulp = require('gulp');\nconst awspublish = require('gulp-awspublish');\nconst cloudfront = require(\"gulp-cloudfront\");\nrequire('dotenv').config();\n\ngulp.task('publish', () => {\n  const aws = {\n    region: process.env.AWS_REGION,\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n    distributionId: process.env.PROD_DISTRIBUTION_ID,\n    params: {\n      Bucket: process.env.PROD_BUCKET\n    },\n  };\n\n  const headers = {\n    \"Cache-Control\": \"max-age=0\"\n  };\n\n\n  const publisher = awspublish.create(aws);\n  return gulp.src('./public/**/*')\n    .pipe(awspublish.gzip())\n    .pipe(publisher.publish(headers))\n    .pipe(publisher.cache())\n    .pipe(awspublish.reporter())\n    .pipe(cloudfront(aws));\n});\n```\n배포에 필요한 환경변수는 `.env`을 통하여 참조하도록 구성했다. 파일의 내용은 하단과 같다. 환경과 관련된 중요한 정보를 담고 있기 떄문에 VersionControl을 하지 않고 로컬에서만 관리하도록 했다.\n\n#### .env\n```bash\n# AWS 리전명\nAWS_REGION={AWS REGION} \n\n# 액세스 키\nAWS_ACCESS_KEY_ID={ACCESS_KEY}\n\n# 시크릿 키\nAWS_SECRET_ACCESS_KEY={SECRET_ACCESS_KEY}\n\n# 버킷명\nPROD_BUCKET={BUCKET_NAME}\n\n# CloudFront 배포ID\nPROD_DISTRIBUTION_ID={CLOUDFRONT_DISTRIBUTION-ID}\n```\n\n\n### S3 버킷 생성\n![](https://i.imgur.com/sM202Cw.png)\n  - 버킷 생성 후 Static Web Site 옵션 활성화\n\n### CloudFront 설정\n#### Distribution\n- Price-Class\n  - 필요에 맞는 지역을 선택, Global을 사용하게 되면 과금이 크게 될 수 있으므로 적절한 선택이 필요함.\n- WAF Web ACL\n  - 별도로 병화벽 사용 시 지정, WAF를 사용하면 IP Whitelist 관리 및 SQL Injection 공격까지 막아 줄 수 있음\n- Alternate Domain Names\n  - Route53에서 지정한 CNAME 사용\n- SSL Certificate\n  - Custom SSL Certificate 지정, AWS Certificate Manager에서 생성한 인증서 사용하면 편함\n- Security Policy\n  - TLSv1.1_2016 (recommended)\n- Supported HTTP Versions\n  - HTTP/2, HTTP/1.1, HTTP/1.0\n- Default Root Object\n  - index.html 지정\n#### Origins and Origin Groups\n- Origin Domain Name: S3 static site 경로를 지정\n- Restrict Bucket Access: No\n\n#### Behaviors\n- HTTP METHOD, 캐싱 정책 및 HTTP 리다이렉션을 지정할 수 있음\n- 요청/응답 주기에 따른 AWS Lambda Function 지정 가능\n\n#### Error Pages\n![](https://i.imgur.com/KHZH6e4.png)\n- HTTP Error Code가 발생했을 때, 이후 액션을 어떻게 할건지 정할 수 있음.\n- SPA의 경우, Client-Side Routing을 하기 떄문에, 실제 S3 오리진에 없는 리소스가 존재하더라도 접근에 대한 제어는 Client Application에서 제어 해야 함.\n\n#### Invalidations\n- 캐싱된 CloudFront의 자원을 Invalidation 할때 사용 \n\n### Route53 설정\n* Hosted-Zone -> Create-Record-Set\n![](https://i.imgur.com/P5clcf6.png)\n- `Name`에는 서브도메인명 지정\n- `Alias`의 값은 `Yes`로 지정\n- `Alias Target`의 값은 위에서 배포한 CloudFront의 Domain Name을 지정\n- `Create`를 누르고 마무리\n\n### 참고 URL\n- [Amazon S3 버킷과 함께 CloudFront 배포 사용](https://support.ptc.com/help/thingworx_hc/thingworx_utilities_8_hc/ko/index.html#page/ThingWorx_Utilities/Converge_CDNCloudFrontWS3.html)\n- [S3 웹 사이트 엔드포인트를 CloudFront 배포의 오리진으로 사용하고 있습니다. HTTP 응답 코드 403(액세스 거부)이 수신되는 이유는 무엇입니까?](https://aws.amazon.com/ko/premiumsupport/knowledge-center/s3-website-cloudfront-error-403/)\n- [How To Host Static Website On Amazon AWS S3](https://www.hackingnote.com/en/web-deployment/how-to-host-static-website-on-amazon-aws-s3)\n- [Host a Static Site on AWS, using S3 and CloudFront](https://www.davidbaumgold.com/tutorials/host-static-site-aws-s3-cloudfront/)\n","slug":"AWS/cloudfront_s3_route53_staticweb","published":1,"updated":"2021-08-02T12:19:29.208Z","_id":"ckrsup4zp0003tjhv0elm9q94","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"S3-CloudFront-Route53-Vuepress-Gulp을-활용한-SPA-어플리케이션-배포\"><a href=\"#S3-CloudFront-Route53-Vuepress-Gulp을-활용한-SPA-어플리케이션-배포\" class=\"headerlink\" title=\"S3 + CloudFront + Route53 + Vuepress + Gulp을 활용한 SPA 어플리케이션 배포\"></a>S3 + CloudFront + Route53 + Vuepress + Gulp을 활용한 SPA 어플리케이션 배포</h2><p>회사에서 별도로 업무 문서 관리 용도로 Static 사이트를 배포해야 할 일이 생겨서, 어차피 AWS 환경을 사용하고 있으니 S3 + Cloudfront + Route53을 활용하여 사이트를 배포하면 좋을꺼 같아 해당 업무를 수행하면서 사용했던 내용을 간단하게 정리해봤다.</p>\n<p>문서는 어차피 마크다운으로 작성하기 때문에, 마크다운을 Static Resource로 변환해주는 프레임워크나 환경을 찾다가 우연하게 미려한 UI에 끌려 <a href=\"https://vuepress.vuejs.org/\">Vuepress</a>를 선택하게 됬다.</p>\n<ul>\n<li>템플릿 참고: <a href=\"https://github.com/stasson/vuepress-template\">vuepress-template</a></li>\n</ul>\n<p>배포 방법은 여러가지가 있겠지만, 우선 급한대로 gulp를 활용하여 배포 스크립트를 작성했고 스크립트 내용은 별게 없기 때문에 아래와 같이 작성하여 사용했다.</p>\n<h4 id=\"gulpfile-js\"><a href=\"#gulpfile-js\" class=\"headerlink\" title=\"gulpfile.js\"></a>gulpfile.js</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> awspublish = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-awspublish&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> cloudfront = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;gulp-cloudfront&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;dotenv&#x27;</span>).config();</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;publish&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> aws = &#123;</span><br><span class=\"line\">    <span class=\"attr\">region</span>: process.env.AWS_REGION,</span><br><span class=\"line\">    <span class=\"attr\">accessKeyId</span>: process.env.AWS_ACCESS_KEY_ID,</span><br><span class=\"line\">    <span class=\"attr\">secretAccessKey</span>: process.env.AWS_SECRET_ACCESS_KEY,</span><br><span class=\"line\">    <span class=\"attr\">distributionId</span>: process.env.PROD_DISTRIBUTION_ID,</span><br><span class=\"line\">    <span class=\"attr\">params</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">Bucket</span>: process.env.PROD_BUCKET</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> headers = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Cache-Control&quot;</span>: <span class=\"string\">&quot;max-age=0&quot;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> publisher = awspublish.create(aws);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;./public/**/*&#x27;</span>)</span><br><span class=\"line\">    .pipe(awspublish.gzip())</span><br><span class=\"line\">    .pipe(publisher.publish(headers))</span><br><span class=\"line\">    .pipe(publisher.cache())</span><br><span class=\"line\">    .pipe(awspublish.reporter())</span><br><span class=\"line\">    .pipe(cloudfront(aws));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>배포에 필요한 환경변수는 <code>.env</code>을 통하여 참조하도록 구성했다. 파일의 내용은 하단과 같다. 환경과 관련된 중요한 정보를 담고 있기 떄문에 VersionControl을 하지 않고 로컬에서만 관리하도록 했다.</p>\n<h4 id=\"env\"><a href=\"#env\" class=\"headerlink\" title=\".env\"></a>.env</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># AWS 리전명</span></span><br><span class=\"line\">AWS_REGION=&#123;AWS REGION&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 액세스 키</span></span><br><span class=\"line\">AWS_ACCESS_KEY_ID=&#123;ACCESS_KEY&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 시크릿 키</span></span><br><span class=\"line\">AWS_SECRET_ACCESS_KEY=&#123;SECRET_ACCESS_KEY&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 버킷명</span></span><br><span class=\"line\">PROD_BUCKET=&#123;BUCKET_NAME&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CloudFront 배포ID</span></span><br><span class=\"line\">PROD_DISTRIBUTION_ID=&#123;CLOUDFRONT_DISTRIBUTION-ID&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"S3-버킷-생성\"><a href=\"#S3-버킷-생성\" class=\"headerlink\" title=\"S3 버킷 생성\"></a>S3 버킷 생성</h3><p><img src=\"https://i.imgur.com/sM202Cw.png\"></p>\n<ul>\n<li>버킷 생성 후 Static Web Site 옵션 활성화</li>\n</ul>\n<h3 id=\"CloudFront-설정\"><a href=\"#CloudFront-설정\" class=\"headerlink\" title=\"CloudFront 설정\"></a>CloudFront 설정</h3><h4 id=\"Distribution\"><a href=\"#Distribution\" class=\"headerlink\" title=\"Distribution\"></a>Distribution</h4><ul>\n<li>Price-Class<ul>\n<li>필요에 맞는 지역을 선택, Global을 사용하게 되면 과금이 크게 될 수 있으므로 적절한 선택이 필요함.</li>\n</ul>\n</li>\n<li>WAF Web ACL<ul>\n<li>별도로 병화벽 사용 시 지정, WAF를 사용하면 IP Whitelist 관리 및 SQL Injection 공격까지 막아 줄 수 있음</li>\n</ul>\n</li>\n<li>Alternate Domain Names<ul>\n<li>Route53에서 지정한 CNAME 사용</li>\n</ul>\n</li>\n<li>SSL Certificate<ul>\n<li>Custom SSL Certificate 지정, AWS Certificate Manager에서 생성한 인증서 사용하면 편함</li>\n</ul>\n</li>\n<li>Security Policy<ul>\n<li>TLSv1.1_2016 (recommended)</li>\n</ul>\n</li>\n<li>Supported HTTP Versions<ul>\n<li>HTTP/2, HTTP/1.1, HTTP/1.0</li>\n</ul>\n</li>\n<li>Default Root Object<ul>\n<li>index.html 지정<h4 id=\"Origins-and-Origin-Groups\"><a href=\"#Origins-and-Origin-Groups\" class=\"headerlink\" title=\"Origins and Origin Groups\"></a>Origins and Origin Groups</h4></li>\n</ul>\n</li>\n<li>Origin Domain Name: S3 static site 경로를 지정</li>\n<li>Restrict Bucket Access: No</li>\n</ul>\n<h4 id=\"Behaviors\"><a href=\"#Behaviors\" class=\"headerlink\" title=\"Behaviors\"></a>Behaviors</h4><ul>\n<li>HTTP METHOD, 캐싱 정책 및 HTTP 리다이렉션을 지정할 수 있음</li>\n<li>요청/응답 주기에 따른 AWS Lambda Function 지정 가능</li>\n</ul>\n<h4 id=\"Error-Pages\"><a href=\"#Error-Pages\" class=\"headerlink\" title=\"Error Pages\"></a>Error Pages</h4><p><img src=\"https://i.imgur.com/KHZH6e4.png\"></p>\n<ul>\n<li>HTTP Error Code가 발생했을 때, 이후 액션을 어떻게 할건지 정할 수 있음.</li>\n<li>SPA의 경우, Client-Side Routing을 하기 떄문에, 실제 S3 오리진에 없는 리소스가 존재하더라도 접근에 대한 제어는 Client Application에서 제어 해야 함.</li>\n</ul>\n<h4 id=\"Invalidations\"><a href=\"#Invalidations\" class=\"headerlink\" title=\"Invalidations\"></a>Invalidations</h4><ul>\n<li>캐싱된 CloudFront의 자원을 Invalidation 할때 사용 </li>\n</ul>\n<h3 id=\"Route53-설정\"><a href=\"#Route53-설정\" class=\"headerlink\" title=\"Route53 설정\"></a>Route53 설정</h3><ul>\n<li>Hosted-Zone -&gt; Create-Record-Set<br><img src=\"https://i.imgur.com/P5clcf6.png\"></li>\n</ul>\n<ul>\n<li><code>Name</code>에는 서브도메인명 지정</li>\n<li><code>Alias</code>의 값은 <code>Yes</code>로 지정</li>\n<li><code>Alias Target</code>의 값은 위에서 배포한 CloudFront의 Domain Name을 지정</li>\n<li><code>Create</code>를 누르고 마무리</li>\n</ul>\n<h3 id=\"참고-URL\"><a href=\"#참고-URL\" class=\"headerlink\" title=\"참고 URL\"></a>참고 URL</h3><ul>\n<li><a href=\"https://support.ptc.com/help/thingworx_hc/thingworx_utilities_8_hc/ko/index.html#page/ThingWorx_Utilities/Converge_CDNCloudFrontWS3.html\">Amazon S3 버킷과 함께 CloudFront 배포 사용</a></li>\n<li><a href=\"https://aws.amazon.com/ko/premiumsupport/knowledge-center/s3-website-cloudfront-error-403/\">S3 웹 사이트 엔드포인트를 CloudFront 배포의 오리진으로 사용하고 있습니다. HTTP 응답 코드 403(액세스 거부)이 수신되는 이유는 무엇입니까?</a></li>\n<li><a href=\"https://www.hackingnote.com/en/web-deployment/how-to-host-static-website-on-amazon-aws-s3\">How To Host Static Website On Amazon AWS S3</a></li>\n<li><a href=\"https://www.davidbaumgold.com/tutorials/host-static-site-aws-s3-cloudfront/\">Host a Static Site on AWS, using S3 and CloudFront</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"S3-CloudFront-Route53-Vuepress-Gulp을-활용한-SPA-어플리케이션-배포\"><a href=\"#S3-CloudFront-Route53-Vuepress-Gulp을-활용한-SPA-어플리케이션-배포\" class=\"headerlink\" title=\"S3 + CloudFront + Route53 + Vuepress + Gulp을 활용한 SPA 어플리케이션 배포\"></a>S3 + CloudFront + Route53 + Vuepress + Gulp을 활용한 SPA 어플리케이션 배포</h2><p>회사에서 별도로 업무 문서 관리 용도로 Static 사이트를 배포해야 할 일이 생겨서, 어차피 AWS 환경을 사용하고 있으니 S3 + Cloudfront + Route53을 활용하여 사이트를 배포하면 좋을꺼 같아 해당 업무를 수행하면서 사용했던 내용을 간단하게 정리해봤다.</p>\n<p>문서는 어차피 마크다운으로 작성하기 때문에, 마크다운을 Static Resource로 변환해주는 프레임워크나 환경을 찾다가 우연하게 미려한 UI에 끌려 <a href=\"https://vuepress.vuejs.org/\">Vuepress</a>를 선택하게 됬다.</p>\n<ul>\n<li>템플릿 참고: <a href=\"https://github.com/stasson/vuepress-template\">vuepress-template</a></li>\n</ul>\n<p>배포 방법은 여러가지가 있겠지만, 우선 급한대로 gulp를 활용하여 배포 스크립트를 작성했고 스크립트 내용은 별게 없기 때문에 아래와 같이 작성하여 사용했다.</p>\n<h4 id=\"gulpfile-js\"><a href=\"#gulpfile-js\" class=\"headerlink\" title=\"gulpfile.js\"></a>gulpfile.js</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> awspublish = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-awspublish&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> cloudfront = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;gulp-cloudfront&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;dotenv&#x27;</span>).config();</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;publish&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> aws = &#123;</span><br><span class=\"line\">    <span class=\"attr\">region</span>: process.env.AWS_REGION,</span><br><span class=\"line\">    <span class=\"attr\">accessKeyId</span>: process.env.AWS_ACCESS_KEY_ID,</span><br><span class=\"line\">    <span class=\"attr\">secretAccessKey</span>: process.env.AWS_SECRET_ACCESS_KEY,</span><br><span class=\"line\">    <span class=\"attr\">distributionId</span>: process.env.PROD_DISTRIBUTION_ID,</span><br><span class=\"line\">    <span class=\"attr\">params</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">Bucket</span>: process.env.PROD_BUCKET</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> headers = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Cache-Control&quot;</span>: <span class=\"string\">&quot;max-age=0&quot;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> publisher = awspublish.create(aws);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;./public/**/*&#x27;</span>)</span><br><span class=\"line\">    .pipe(awspublish.gzip())</span><br><span class=\"line\">    .pipe(publisher.publish(headers))</span><br><span class=\"line\">    .pipe(publisher.cache())</span><br><span class=\"line\">    .pipe(awspublish.reporter())</span><br><span class=\"line\">    .pipe(cloudfront(aws));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>배포에 필요한 환경변수는 <code>.env</code>을 통하여 참조하도록 구성했다. 파일의 내용은 하단과 같다. 환경과 관련된 중요한 정보를 담고 있기 떄문에 VersionControl을 하지 않고 로컬에서만 관리하도록 했다.</p>\n<h4 id=\"env\"><a href=\"#env\" class=\"headerlink\" title=\".env\"></a>.env</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># AWS 리전명</span></span><br><span class=\"line\">AWS_REGION=&#123;AWS REGION&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 액세스 키</span></span><br><span class=\"line\">AWS_ACCESS_KEY_ID=&#123;ACCESS_KEY&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 시크릿 키</span></span><br><span class=\"line\">AWS_SECRET_ACCESS_KEY=&#123;SECRET_ACCESS_KEY&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 버킷명</span></span><br><span class=\"line\">PROD_BUCKET=&#123;BUCKET_NAME&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CloudFront 배포ID</span></span><br><span class=\"line\">PROD_DISTRIBUTION_ID=&#123;CLOUDFRONT_DISTRIBUTION-ID&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"S3-버킷-생성\"><a href=\"#S3-버킷-생성\" class=\"headerlink\" title=\"S3 버킷 생성\"></a>S3 버킷 생성</h3><p><img src=\"https://i.imgur.com/sM202Cw.png\"></p>\n<ul>\n<li>버킷 생성 후 Static Web Site 옵션 활성화</li>\n</ul>\n<h3 id=\"CloudFront-설정\"><a href=\"#CloudFront-설정\" class=\"headerlink\" title=\"CloudFront 설정\"></a>CloudFront 설정</h3><h4 id=\"Distribution\"><a href=\"#Distribution\" class=\"headerlink\" title=\"Distribution\"></a>Distribution</h4><ul>\n<li>Price-Class<ul>\n<li>필요에 맞는 지역을 선택, Global을 사용하게 되면 과금이 크게 될 수 있으므로 적절한 선택이 필요함.</li>\n</ul>\n</li>\n<li>WAF Web ACL<ul>\n<li>별도로 병화벽 사용 시 지정, WAF를 사용하면 IP Whitelist 관리 및 SQL Injection 공격까지 막아 줄 수 있음</li>\n</ul>\n</li>\n<li>Alternate Domain Names<ul>\n<li>Route53에서 지정한 CNAME 사용</li>\n</ul>\n</li>\n<li>SSL Certificate<ul>\n<li>Custom SSL Certificate 지정, AWS Certificate Manager에서 생성한 인증서 사용하면 편함</li>\n</ul>\n</li>\n<li>Security Policy<ul>\n<li>TLSv1.1_2016 (recommended)</li>\n</ul>\n</li>\n<li>Supported HTTP Versions<ul>\n<li>HTTP/2, HTTP/1.1, HTTP/1.0</li>\n</ul>\n</li>\n<li>Default Root Object<ul>\n<li>index.html 지정<h4 id=\"Origins-and-Origin-Groups\"><a href=\"#Origins-and-Origin-Groups\" class=\"headerlink\" title=\"Origins and Origin Groups\"></a>Origins and Origin Groups</h4></li>\n</ul>\n</li>\n<li>Origin Domain Name: S3 static site 경로를 지정</li>\n<li>Restrict Bucket Access: No</li>\n</ul>\n<h4 id=\"Behaviors\"><a href=\"#Behaviors\" class=\"headerlink\" title=\"Behaviors\"></a>Behaviors</h4><ul>\n<li>HTTP METHOD, 캐싱 정책 및 HTTP 리다이렉션을 지정할 수 있음</li>\n<li>요청/응답 주기에 따른 AWS Lambda Function 지정 가능</li>\n</ul>\n<h4 id=\"Error-Pages\"><a href=\"#Error-Pages\" class=\"headerlink\" title=\"Error Pages\"></a>Error Pages</h4><p><img src=\"https://i.imgur.com/KHZH6e4.png\"></p>\n<ul>\n<li>HTTP Error Code가 발생했을 때, 이후 액션을 어떻게 할건지 정할 수 있음.</li>\n<li>SPA의 경우, Client-Side Routing을 하기 떄문에, 실제 S3 오리진에 없는 리소스가 존재하더라도 접근에 대한 제어는 Client Application에서 제어 해야 함.</li>\n</ul>\n<h4 id=\"Invalidations\"><a href=\"#Invalidations\" class=\"headerlink\" title=\"Invalidations\"></a>Invalidations</h4><ul>\n<li>캐싱된 CloudFront의 자원을 Invalidation 할때 사용 </li>\n</ul>\n<h3 id=\"Route53-설정\"><a href=\"#Route53-설정\" class=\"headerlink\" title=\"Route53 설정\"></a>Route53 설정</h3><ul>\n<li>Hosted-Zone -&gt; Create-Record-Set<br><img src=\"https://i.imgur.com/P5clcf6.png\"></li>\n</ul>\n<ul>\n<li><code>Name</code>에는 서브도메인명 지정</li>\n<li><code>Alias</code>의 값은 <code>Yes</code>로 지정</li>\n<li><code>Alias Target</code>의 값은 위에서 배포한 CloudFront의 Domain Name을 지정</li>\n<li><code>Create</code>를 누르고 마무리</li>\n</ul>\n<h3 id=\"참고-URL\"><a href=\"#참고-URL\" class=\"headerlink\" title=\"참고 URL\"></a>참고 URL</h3><ul>\n<li><a href=\"https://support.ptc.com/help/thingworx_hc/thingworx_utilities_8_hc/ko/index.html#page/ThingWorx_Utilities/Converge_CDNCloudFrontWS3.html\">Amazon S3 버킷과 함께 CloudFront 배포 사용</a></li>\n<li><a href=\"https://aws.amazon.com/ko/premiumsupport/knowledge-center/s3-website-cloudfront-error-403/\">S3 웹 사이트 엔드포인트를 CloudFront 배포의 오리진으로 사용하고 있습니다. HTTP 응답 코드 403(액세스 거부)이 수신되는 이유는 무엇입니까?</a></li>\n<li><a href=\"https://www.hackingnote.com/en/web-deployment/how-to-host-static-website-on-amazon-aws-s3\">How To Host Static Website On Amazon AWS S3</a></li>\n<li><a href=\"https://www.davidbaumgold.com/tutorials/host-static-site-aws-s3-cloudfront/\">Host a Static Site on AWS, using S3 and CloudFront</a></li>\n</ul>\n"},{"title":"Serverless Framework","date":"2019-07-11T15:00:00.000Z","_content":"\n# Serverless Framework\n\n# Install\n```bash\n# 1. Node 버젼의 경우 6.10.X를 지원하고 있음\n#    작년까지는 6.10....... 최근에 8.10도 지원하네요\n> nvm use v8.10\n\n# 2. Local로 설치하셔도 무관합니다.\n> npm install -g serverless\n\n# 3. AWS Credential 셋팅(accessKey / SecretKey / Default region)\n> aws configure\n\n# 4. 설치 확인\n> sls --help\n\n# 5. 템플릿 생성\n> sls create --template aws-nodejs --path my-service\n```\n\n# Template\n- **aws-nodejs**\n- aws-nodejs-typescript\n- aws-nodejs-ecma-script\n- aws-python\n- aws-python3\n- **aws-kotlin-jvm-maven**\n- **aws-kotlin-nodejs-gradle**\n- aws-groovy-gradle\n- **aws-java-gradle**\n- **aws-java-maven**\n- aws-scala-sbt\n- aws-csharp\n- aws-fsharp\n- aws-go\n\n# 기본 폴더 트리(aws-nodejs)\n```\ndrwxr-xr-x   5 Daniel  staff   170  4 11 10:56 .\ndrwxr-xr-x  15 Daniel  staff   510  4 11 10:56 ..\n-rw-r--r--   1 Daniel  staff    86  4 11 10:56 .gitignore\n-rw-r--r--   1 Daniel  staff   466  4 11 10:56 handler.js\n-rw-r--r--   1 Daniel  staff  2829  4 11 10:56 serverless.yml\n```\n\n# Command\n\n```\n> sls --help\n\nconfig ........................ Configure Serverless\nconfig credentials ............ Configures a new provider profile for the Serverless Framework\ncreate ........................ Create new Serverless service\ndeploy ........................ Deploy a Serverless service\ndeploy function ............... Deploy a single function from the service\ndeploy list ................... List deployed version of your Serverless Service\ndeploy list functions ......... List all the deployed functions and their versions\ninfo .......................... Display information about the service\ninstall ....................... Install a Serverless service from GitHub or a plugin from the Serverless registry\ninvoke ........................ Invoke a deployed function\ninvoke local .................. Invoke function locally\nlogs .......................... Output the logs of a deployed function\nmetrics ....................... Show metrics for a specific function\noffline ....................... Simulates API Gateway to call your lambda functions offline.\noffline start ................. Simulates API Gateway to call your lambda functions offline using backward compatible initialization.\nremove ........................ Remove Serverless service and all resources\n\nPlugins\n... many\n```\n\n\n\n# Deploy\n\n- [AWS Deploy Guide](https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/deploying-lambda-apps.html)\n\n- 배포는 전체 혹은 함수 단위로 가능\n\n  ```bash\n  sls deploy --stage test # 전체\n  sls deploy function --stage test --function alarm\n  sls deploy function --stage test --function alarm -v\n  ```\n\n- 배포 플로우\n\n  - `serverless.yml`을 참조하여 CloudFormation을 작성.\n  - 함수 코드 압축 후 S3 업로드\n  - 이전 배포 버젼의 해시를 참고하여 현재 버젼과 비교\n  - 만약 운영중인 소스와 현재 배포 버젼의 해시가 동일하다면 종료됨.\n\n# 구현 사례\n\n- [AWS KMS를 이용한 암호화 API 구축하기](http://woowabros.github.io/experience/2017/02/06/aws-kms.html)\n- [AWS Lambda를 이용한 이미지 썸네일 생성 개발 후기](https://medium.com/n42-corp/aws-lambda%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%8D%B8%EB%84%A4%EC%9D%BC-%EC%83%9D%EC%84%B1-%EA%B0%9C%EB%B0%9C-%ED%9B%84%EA%B8%B0-acc278d49980)\n\n\n\n# 삽질 내용\n\n- 인텔리제이/웹스톰에서 디버깅 할때는 `serverless-offline` 사용 및 `SLS_DEBUG` 환경 변수 사용\n- 코드 실행의 Maximum Time은 5분!, 5분 이내에 수행이 종료되는게 불확실한 경우 Lambda를 이벤트 발생기로만 사용하는 방법을 고려!\n- Private VPC를 설정하여 lambda를 사용하는 경우, NAT Gateway 설정을 추가로 해야 외부 서버와 통신 가능\n- 중복 호출 및 불필요한 리소스 설정이 안되도록 주의해야 함\n  - 폭탄 과금의 위험이….\n- CPU 파워는 설정 메모리에 따라 올라가고 내려감.\n- Serverless framework, `serverless.yml` 설정 파일의 공백에 주의. \n  - 2space를 기본으로 하며 제대로 공백 처리가 안된경우 배포 시 제대로 설정이 안될 수 있음.\n- AWS의 외부 리소스 사용 시, 람다 실행에 대한 롤 설정이 제대로 되어 있어야 함!\n\n# 참고자료\n- https://www.slideshare.net/KyuhyunByun1/albec2-to-api-gateway-lambda\n- https://www.youtube.com/playlist?list=PLzvRQMJ9HDiT5b4OsmIBiMbsPjfp4kfg3","source":"_posts/AWS/serverless_framework.md","raw":"---\ntitle: Serverless Framework\ndate: 2019/7/12 00:00:00\ncategories:\n- AWS\n---\n\n# Serverless Framework\n\n# Install\n```bash\n# 1. Node 버젼의 경우 6.10.X를 지원하고 있음\n#    작년까지는 6.10....... 최근에 8.10도 지원하네요\n> nvm use v8.10\n\n# 2. Local로 설치하셔도 무관합니다.\n> npm install -g serverless\n\n# 3. AWS Credential 셋팅(accessKey / SecretKey / Default region)\n> aws configure\n\n# 4. 설치 확인\n> sls --help\n\n# 5. 템플릿 생성\n> sls create --template aws-nodejs --path my-service\n```\n\n# Template\n- **aws-nodejs**\n- aws-nodejs-typescript\n- aws-nodejs-ecma-script\n- aws-python\n- aws-python3\n- **aws-kotlin-jvm-maven**\n- **aws-kotlin-nodejs-gradle**\n- aws-groovy-gradle\n- **aws-java-gradle**\n- **aws-java-maven**\n- aws-scala-sbt\n- aws-csharp\n- aws-fsharp\n- aws-go\n\n# 기본 폴더 트리(aws-nodejs)\n```\ndrwxr-xr-x   5 Daniel  staff   170  4 11 10:56 .\ndrwxr-xr-x  15 Daniel  staff   510  4 11 10:56 ..\n-rw-r--r--   1 Daniel  staff    86  4 11 10:56 .gitignore\n-rw-r--r--   1 Daniel  staff   466  4 11 10:56 handler.js\n-rw-r--r--   1 Daniel  staff  2829  4 11 10:56 serverless.yml\n```\n\n# Command\n\n```\n> sls --help\n\nconfig ........................ Configure Serverless\nconfig credentials ............ Configures a new provider profile for the Serverless Framework\ncreate ........................ Create new Serverless service\ndeploy ........................ Deploy a Serverless service\ndeploy function ............... Deploy a single function from the service\ndeploy list ................... List deployed version of your Serverless Service\ndeploy list functions ......... List all the deployed functions and their versions\ninfo .......................... Display information about the service\ninstall ....................... Install a Serverless service from GitHub or a plugin from the Serverless registry\ninvoke ........................ Invoke a deployed function\ninvoke local .................. Invoke function locally\nlogs .......................... Output the logs of a deployed function\nmetrics ....................... Show metrics for a specific function\noffline ....................... Simulates API Gateway to call your lambda functions offline.\noffline start ................. Simulates API Gateway to call your lambda functions offline using backward compatible initialization.\nremove ........................ Remove Serverless service and all resources\n\nPlugins\n... many\n```\n\n\n\n# Deploy\n\n- [AWS Deploy Guide](https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/deploying-lambda-apps.html)\n\n- 배포는 전체 혹은 함수 단위로 가능\n\n  ```bash\n  sls deploy --stage test # 전체\n  sls deploy function --stage test --function alarm\n  sls deploy function --stage test --function alarm -v\n  ```\n\n- 배포 플로우\n\n  - `serverless.yml`을 참조하여 CloudFormation을 작성.\n  - 함수 코드 압축 후 S3 업로드\n  - 이전 배포 버젼의 해시를 참고하여 현재 버젼과 비교\n  - 만약 운영중인 소스와 현재 배포 버젼의 해시가 동일하다면 종료됨.\n\n# 구현 사례\n\n- [AWS KMS를 이용한 암호화 API 구축하기](http://woowabros.github.io/experience/2017/02/06/aws-kms.html)\n- [AWS Lambda를 이용한 이미지 썸네일 생성 개발 후기](https://medium.com/n42-corp/aws-lambda%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%8D%B8%EB%84%A4%EC%9D%BC-%EC%83%9D%EC%84%B1-%EA%B0%9C%EB%B0%9C-%ED%9B%84%EA%B8%B0-acc278d49980)\n\n\n\n# 삽질 내용\n\n- 인텔리제이/웹스톰에서 디버깅 할때는 `serverless-offline` 사용 및 `SLS_DEBUG` 환경 변수 사용\n- 코드 실행의 Maximum Time은 5분!, 5분 이내에 수행이 종료되는게 불확실한 경우 Lambda를 이벤트 발생기로만 사용하는 방법을 고려!\n- Private VPC를 설정하여 lambda를 사용하는 경우, NAT Gateway 설정을 추가로 해야 외부 서버와 통신 가능\n- 중복 호출 및 불필요한 리소스 설정이 안되도록 주의해야 함\n  - 폭탄 과금의 위험이….\n- CPU 파워는 설정 메모리에 따라 올라가고 내려감.\n- Serverless framework, `serverless.yml` 설정 파일의 공백에 주의. \n  - 2space를 기본으로 하며 제대로 공백 처리가 안된경우 배포 시 제대로 설정이 안될 수 있음.\n- AWS의 외부 리소스 사용 시, 람다 실행에 대한 롤 설정이 제대로 되어 있어야 함!\n\n# 참고자료\n- https://www.slideshare.net/KyuhyunByun1/albec2-to-api-gateway-lambda\n- https://www.youtube.com/playlist?list=PLzvRQMJ9HDiT5b4OsmIBiMbsPjfp4kfg3","slug":"AWS/serverless_framework","published":1,"updated":"2021-08-02T12:19:32.104Z","_id":"ckrsup4zq0004tjhvf9rch1ju","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Serverless-Framework\"><a href=\"#Serverless-Framework\" class=\"headerlink\" title=\"Serverless Framework\"></a>Serverless Framework</h1><h1 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. Node 버젼의 경우 6.10.X를 지원하고 있음</span></span><br><span class=\"line\"><span class=\"comment\">#    작년까지는 6.10....... 최근에 8.10도 지원하네요</span></span><br><span class=\"line\">&gt; nvm use v8.10</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. Local로 설치하셔도 무관합니다.</span></span><br><span class=\"line\">&gt; npm install -g serverless</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. AWS Credential 셋팅(accessKey / SecretKey / Default region)</span></span><br><span class=\"line\">&gt; aws configure</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 설치 확인</span></span><br><span class=\"line\">&gt; sls --<span class=\"built_in\">help</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 템플릿 생성</span></span><br><span class=\"line\">&gt; sls create --template aws-nodejs --path my-service</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Template\"><a href=\"#Template\" class=\"headerlink\" title=\"Template\"></a>Template</h1><ul>\n<li><strong>aws-nodejs</strong></li>\n<li>aws-nodejs-typescript</li>\n<li>aws-nodejs-ecma-script</li>\n<li>aws-python</li>\n<li>aws-python3</li>\n<li><strong>aws-kotlin-jvm-maven</strong></li>\n<li><strong>aws-kotlin-nodejs-gradle</strong></li>\n<li>aws-groovy-gradle</li>\n<li><strong>aws-java-gradle</strong></li>\n<li><strong>aws-java-maven</strong></li>\n<li>aws-scala-sbt</li>\n<li>aws-csharp</li>\n<li>aws-fsharp</li>\n<li>aws-go</li>\n</ul>\n<h1 id=\"기본-폴더-트리-aws-nodejs\"><a href=\"#기본-폴더-트리-aws-nodejs\" class=\"headerlink\" title=\"기본 폴더 트리(aws-nodejs)\"></a>기본 폴더 트리(aws-nodejs)</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drwxr-xr-x   5 Daniel  staff   170  4 11 10:56 .</span><br><span class=\"line\">drwxr-xr-x  15 Daniel  staff   510  4 11 10:56 ..</span><br><span class=\"line\">-rw-r--r--   1 Daniel  staff    86  4 11 10:56 .gitignore</span><br><span class=\"line\">-rw-r--r--   1 Daniel  staff   466  4 11 10:56 handler.js</span><br><span class=\"line\">-rw-r--r--   1 Daniel  staff  2829  4 11 10:56 serverless.yml</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Command\"><a href=\"#Command\" class=\"headerlink\" title=\"Command\"></a>Command</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; sls --help</span><br><span class=\"line\"></span><br><span class=\"line\">config ........................ Configure Serverless</span><br><span class=\"line\">config credentials ............ Configures a new provider profile for the Serverless Framework</span><br><span class=\"line\">create ........................ Create new Serverless service</span><br><span class=\"line\">deploy ........................ Deploy a Serverless service</span><br><span class=\"line\">deploy function ............... Deploy a single function from the service</span><br><span class=\"line\">deploy list ................... List deployed version of your Serverless Service</span><br><span class=\"line\">deploy list functions ......... List all the deployed functions and their versions</span><br><span class=\"line\">info .......................... Display information about the service</span><br><span class=\"line\">install ....................... Install a Serverless service from GitHub or a plugin from the Serverless registry</span><br><span class=\"line\">invoke ........................ Invoke a deployed function</span><br><span class=\"line\">invoke local .................. Invoke function locally</span><br><span class=\"line\">logs .......................... Output the logs of a deployed function</span><br><span class=\"line\">metrics ....................... Show metrics for a specific function</span><br><span class=\"line\">offline ....................... Simulates API Gateway to call your lambda functions offline.</span><br><span class=\"line\">offline start ................. Simulates API Gateway to call your lambda functions offline using backward compatible initialization.</span><br><span class=\"line\">remove ........................ Remove Serverless service and all resources</span><br><span class=\"line\"></span><br><span class=\"line\">Plugins</span><br><span class=\"line\">... many</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Deploy\"><a href=\"#Deploy\" class=\"headerlink\" title=\"Deploy\"></a>Deploy</h1><ul>\n<li><p><a href=\"https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/deploying-lambda-apps.html\">AWS Deploy Guide</a></p>\n</li>\n<li><p>배포는 전체 혹은 함수 단위로 가능</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sls deploy --stage <span class=\"built_in\">test</span> <span class=\"comment\"># 전체</span></span><br><span class=\"line\">sls deploy <span class=\"keyword\">function</span> --stage <span class=\"built_in\">test</span> --<span class=\"keyword\">function</span> alarm</span><br><span class=\"line\">sls deploy <span class=\"keyword\">function</span> --stage <span class=\"built_in\">test</span> --<span class=\"keyword\">function</span> alarm -v</span><br></pre></td></tr></table></figure></li>\n<li><p>배포 플로우</p>\n<ul>\n<li><code>serverless.yml</code>을 참조하여 CloudFormation을 작성.</li>\n<li>함수 코드 압축 후 S3 업로드</li>\n<li>이전 배포 버젼의 해시를 참고하여 현재 버젼과 비교</li>\n<li>만약 운영중인 소스와 현재 배포 버젼의 해시가 동일하다면 종료됨.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"구현-사례\"><a href=\"#구현-사례\" class=\"headerlink\" title=\"구현 사례\"></a>구현 사례</h1><ul>\n<li><a href=\"http://woowabros.github.io/experience/2017/02/06/aws-kms.html\">AWS KMS를 이용한 암호화 API 구축하기</a></li>\n<li><a href=\"https://medium.com/n42-corp/aws-lambda%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%8D%B8%EB%84%A4%EC%9D%BC-%EC%83%9D%EC%84%B1-%EA%B0%9C%EB%B0%9C-%ED%9B%84%EA%B8%B0-acc278d49980\">AWS Lambda를 이용한 이미지 썸네일 생성 개발 후기</a></li>\n</ul>\n<h1 id=\"삽질-내용\"><a href=\"#삽질-내용\" class=\"headerlink\" title=\"삽질 내용\"></a>삽질 내용</h1><ul>\n<li>인텔리제이/웹스톰에서 디버깅 할때는 <code>serverless-offline</code> 사용 및 <code>SLS_DEBUG</code> 환경 변수 사용</li>\n<li>코드 실행의 Maximum Time은 5분!, 5분 이내에 수행이 종료되는게 불확실한 경우 Lambda를 이벤트 발생기로만 사용하는 방법을 고려!</li>\n<li>Private VPC를 설정하여 lambda를 사용하는 경우, NAT Gateway 설정을 추가로 해야 외부 서버와 통신 가능</li>\n<li>중복 호출 및 불필요한 리소스 설정이 안되도록 주의해야 함<ul>\n<li>폭탄 과금의 위험이….</li>\n</ul>\n</li>\n<li>CPU 파워는 설정 메모리에 따라 올라가고 내려감.</li>\n<li>Serverless framework, <code>serverless.yml</code> 설정 파일의 공백에 주의. <ul>\n<li>2space를 기본으로 하며 제대로 공백 처리가 안된경우 배포 시 제대로 설정이 안될 수 있음.</li>\n</ul>\n</li>\n<li>AWS의 외부 리소스 사용 시, 람다 실행에 대한 롤 설정이 제대로 되어 있어야 함!</li>\n</ul>\n<h1 id=\"참고자료\"><a href=\"#참고자료\" class=\"headerlink\" title=\"참고자료\"></a>참고자료</h1><ul>\n<li><a href=\"https://www.slideshare.net/KyuhyunByun1/albec2-to-api-gateway-lambda\">https://www.slideshare.net/KyuhyunByun1/albec2-to-api-gateway-lambda</a></li>\n<li><a href=\"https://www.youtube.com/playlist?list=PLzvRQMJ9HDiT5b4OsmIBiMbsPjfp4kfg3\">https://www.youtube.com/playlist?list=PLzvRQMJ9HDiT5b4OsmIBiMbsPjfp4kfg3</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Serverless-Framework\"><a href=\"#Serverless-Framework\" class=\"headerlink\" title=\"Serverless Framework\"></a>Serverless Framework</h1><h1 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. Node 버젼의 경우 6.10.X를 지원하고 있음</span></span><br><span class=\"line\"><span class=\"comment\">#    작년까지는 6.10....... 최근에 8.10도 지원하네요</span></span><br><span class=\"line\">&gt; nvm use v8.10</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. Local로 설치하셔도 무관합니다.</span></span><br><span class=\"line\">&gt; npm install -g serverless</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. AWS Credential 셋팅(accessKey / SecretKey / Default region)</span></span><br><span class=\"line\">&gt; aws configure</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 설치 확인</span></span><br><span class=\"line\">&gt; sls --<span class=\"built_in\">help</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 템플릿 생성</span></span><br><span class=\"line\">&gt; sls create --template aws-nodejs --path my-service</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Template\"><a href=\"#Template\" class=\"headerlink\" title=\"Template\"></a>Template</h1><ul>\n<li><strong>aws-nodejs</strong></li>\n<li>aws-nodejs-typescript</li>\n<li>aws-nodejs-ecma-script</li>\n<li>aws-python</li>\n<li>aws-python3</li>\n<li><strong>aws-kotlin-jvm-maven</strong></li>\n<li><strong>aws-kotlin-nodejs-gradle</strong></li>\n<li>aws-groovy-gradle</li>\n<li><strong>aws-java-gradle</strong></li>\n<li><strong>aws-java-maven</strong></li>\n<li>aws-scala-sbt</li>\n<li>aws-csharp</li>\n<li>aws-fsharp</li>\n<li>aws-go</li>\n</ul>\n<h1 id=\"기본-폴더-트리-aws-nodejs\"><a href=\"#기본-폴더-트리-aws-nodejs\" class=\"headerlink\" title=\"기본 폴더 트리(aws-nodejs)\"></a>기본 폴더 트리(aws-nodejs)</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drwxr-xr-x   5 Daniel  staff   170  4 11 10:56 .</span><br><span class=\"line\">drwxr-xr-x  15 Daniel  staff   510  4 11 10:56 ..</span><br><span class=\"line\">-rw-r--r--   1 Daniel  staff    86  4 11 10:56 .gitignore</span><br><span class=\"line\">-rw-r--r--   1 Daniel  staff   466  4 11 10:56 handler.js</span><br><span class=\"line\">-rw-r--r--   1 Daniel  staff  2829  4 11 10:56 serverless.yml</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Command\"><a href=\"#Command\" class=\"headerlink\" title=\"Command\"></a>Command</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; sls --help</span><br><span class=\"line\"></span><br><span class=\"line\">config ........................ Configure Serverless</span><br><span class=\"line\">config credentials ............ Configures a new provider profile for the Serverless Framework</span><br><span class=\"line\">create ........................ Create new Serverless service</span><br><span class=\"line\">deploy ........................ Deploy a Serverless service</span><br><span class=\"line\">deploy function ............... Deploy a single function from the service</span><br><span class=\"line\">deploy list ................... List deployed version of your Serverless Service</span><br><span class=\"line\">deploy list functions ......... List all the deployed functions and their versions</span><br><span class=\"line\">info .......................... Display information about the service</span><br><span class=\"line\">install ....................... Install a Serverless service from GitHub or a plugin from the Serverless registry</span><br><span class=\"line\">invoke ........................ Invoke a deployed function</span><br><span class=\"line\">invoke local .................. Invoke function locally</span><br><span class=\"line\">logs .......................... Output the logs of a deployed function</span><br><span class=\"line\">metrics ....................... Show metrics for a specific function</span><br><span class=\"line\">offline ....................... Simulates API Gateway to call your lambda functions offline.</span><br><span class=\"line\">offline start ................. Simulates API Gateway to call your lambda functions offline using backward compatible initialization.</span><br><span class=\"line\">remove ........................ Remove Serverless service and all resources</span><br><span class=\"line\"></span><br><span class=\"line\">Plugins</span><br><span class=\"line\">... many</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Deploy\"><a href=\"#Deploy\" class=\"headerlink\" title=\"Deploy\"></a>Deploy</h1><ul>\n<li><p><a href=\"https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/deploying-lambda-apps.html\">AWS Deploy Guide</a></p>\n</li>\n<li><p>배포는 전체 혹은 함수 단위로 가능</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sls deploy --stage <span class=\"built_in\">test</span> <span class=\"comment\"># 전체</span></span><br><span class=\"line\">sls deploy <span class=\"keyword\">function</span> --stage <span class=\"built_in\">test</span> --<span class=\"keyword\">function</span> alarm</span><br><span class=\"line\">sls deploy <span class=\"keyword\">function</span> --stage <span class=\"built_in\">test</span> --<span class=\"keyword\">function</span> alarm -v</span><br></pre></td></tr></table></figure></li>\n<li><p>배포 플로우</p>\n<ul>\n<li><code>serverless.yml</code>을 참조하여 CloudFormation을 작성.</li>\n<li>함수 코드 압축 후 S3 업로드</li>\n<li>이전 배포 버젼의 해시를 참고하여 현재 버젼과 비교</li>\n<li>만약 운영중인 소스와 현재 배포 버젼의 해시가 동일하다면 종료됨.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"구현-사례\"><a href=\"#구현-사례\" class=\"headerlink\" title=\"구현 사례\"></a>구현 사례</h1><ul>\n<li><a href=\"http://woowabros.github.io/experience/2017/02/06/aws-kms.html\">AWS KMS를 이용한 암호화 API 구축하기</a></li>\n<li><a href=\"https://medium.com/n42-corp/aws-lambda%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%8D%B8%EB%84%A4%EC%9D%BC-%EC%83%9D%EC%84%B1-%EA%B0%9C%EB%B0%9C-%ED%9B%84%EA%B8%B0-acc278d49980\">AWS Lambda를 이용한 이미지 썸네일 생성 개발 후기</a></li>\n</ul>\n<h1 id=\"삽질-내용\"><a href=\"#삽질-내용\" class=\"headerlink\" title=\"삽질 내용\"></a>삽질 내용</h1><ul>\n<li>인텔리제이/웹스톰에서 디버깅 할때는 <code>serverless-offline</code> 사용 및 <code>SLS_DEBUG</code> 환경 변수 사용</li>\n<li>코드 실행의 Maximum Time은 5분!, 5분 이내에 수행이 종료되는게 불확실한 경우 Lambda를 이벤트 발생기로만 사용하는 방법을 고려!</li>\n<li>Private VPC를 설정하여 lambda를 사용하는 경우, NAT Gateway 설정을 추가로 해야 외부 서버와 통신 가능</li>\n<li>중복 호출 및 불필요한 리소스 설정이 안되도록 주의해야 함<ul>\n<li>폭탄 과금의 위험이….</li>\n</ul>\n</li>\n<li>CPU 파워는 설정 메모리에 따라 올라가고 내려감.</li>\n<li>Serverless framework, <code>serverless.yml</code> 설정 파일의 공백에 주의. <ul>\n<li>2space를 기본으로 하며 제대로 공백 처리가 안된경우 배포 시 제대로 설정이 안될 수 있음.</li>\n</ul>\n</li>\n<li>AWS의 외부 리소스 사용 시, 람다 실행에 대한 롤 설정이 제대로 되어 있어야 함!</li>\n</ul>\n<h1 id=\"참고자료\"><a href=\"#참고자료\" class=\"headerlink\" title=\"참고자료\"></a>참고자료</h1><ul>\n<li><a href=\"https://www.slideshare.net/KyuhyunByun1/albec2-to-api-gateway-lambda\">https://www.slideshare.net/KyuhyunByun1/albec2-to-api-gateway-lambda</a></li>\n<li><a href=\"https://www.youtube.com/playlist?list=PLzvRQMJ9HDiT5b4OsmIBiMbsPjfp4kfg3\">https://www.youtube.com/playlist?list=PLzvRQMJ9HDiT5b4OsmIBiMbsPjfp4kfg3</a></li>\n</ul>\n"},{"title":"엘레강트 오브젝트","date":"2021-04-23T15:00:00.000Z","_content":"\n# 엘레강트 오브젝트\n## 1장 출생\n---\n### 1.1 -er로 끝나는 이름을 사용하지 마세요\n### 1.2 생성자 하나를 주 생성자로 만드세요\n### 1.3 생성자에 코드를 넣지 마세요\n\n## 2장 학습\n---\n### 2.1 가능하면 적게 캡슐화하세요\n### 2.2 최소한 뭔가는 캡슐화하세요\n### 2.3 항상 인터페이스를 사용하세요\n### 2.4 메서드 이름을 신중하게 선택하세요\n### 2.5 퍼블릭 상수(public constant)를 사용하지 마세요\n\n### 2.6 불변 객체로 만드세요\n### 2.7 문서를 작성하는 대신 테스트를 만드세요\n### 2.8모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요\n### 2.9인터페이스를 짧게 유지하고 스마트(smart)를 사용하세요\n\n## 3장 취업\n---\n### 3.1 5개 이하의 public 메서드만 노출하세요\n- 20개의 메소드를 가진 클래스를 50줄로 구현했다고 이 클래스가 작다고 말할 수 있을까?\n- public 메소드가 많을수록 클래스도 거기에 비례하여 커질수 있고, 이는 곧 유지보수성을 저하시키는 요인이 될 수 있음\n- public 메소드의 수를 최소로 사용. public 메소드는 객체의 진입점이며 진입점의 수가 적을수록 문제가 발생하더라도 쉽게 수정이 가능\n- 클래스가 작으면 메소드와 필드가 더 가까이 있을 확률이 높기 때문에 응집도가 높아지는 효과가 있을 수 있음.\n### 3.2 정적 메서드를 사용하지 마세요\n- 정적 메소드를 사용하게 되면, 평가의 방법이 eager한 방식으로 처리가 될 여지가 큼\n- 정적 메소드를 사용하지 않고, 이를 객체로 만들 경우, 필요한 순간에 평가를 진행할 수 있기 때문에 lazy한 평가를 수행할 수 있어 어느정도 성능적인 최적화가 가능.\n- 명령형 vs 선언형, 잘짜놓은 객체지향스러운 코드는 선언형 성격이 강함. 결국 [알고리즘 - 실행]의 맥락으로 접근하는 것이 아닌 [객체 - 행동]의 관점으로 사고하는 것을 이야기함.\n- 유틸리티 성격의 클래스(XXXXUtil, XXXXHeler)를 굳이 사용하는 경우엔, 해당 객체의 인스턴스화가 필요없기 때문에 private constructor를 선언하여 객체 생성을 막도록 하는 것이 좋다.\n- 싱글톤의 목적은 객체의 상태를 가지는 것이 아니라, `분리 가능한 의존성`을 가지는 것이 핵심이다. 하지만, 싱글톤 역시 또 다른 의미의 전역 변수를 만드는 것과 크게 다르지 않을 수 있다.\n- 이상적인 FP에서는 최소의 출구만을 만드는 것이 최선\n- 더 작은 객체로 개념을 고립시키고 이를 조합하는 것이 객체지향에서는 최선이다.\n\n### 3.3인자의 값으로 NULL을 절대 허용하지 마세요\n- `null`은 죄악이다. 프로그래머들이 접근할 수 없는 메모리 값을 `0`으로 표현하고 이를 가리켜 null로 부르는 동의에서 시작된 것이다.\n- `null`을 전달해야 하는 상황이라면, 차라리 빈 객체를 만들어 전달하자.\n- `null`에 대한 처리를 해야 하는 상황이라면, 반드시 쉴드패턴(`shield pattern`)과 같은 구현 방식으로 예외를 호출자에게 전달하도록 유도하는 것이 좋다. JVM에서 권고하는 예외 클래스를 사용하는 것이 그 예시\n```java\npublic Iterable<File> find(Mask mask) {\n\tif (mask == null) {\n\t\tthrow new IllegalArgumentException(\"Mask can't be NULL\");\n\t}\n}\n```\n\n\n### 3.4 충성스러우면서 불변이거나, 아니면 상수이거나\n- 많은 사람들이 상태(`state`)와 데이터(`data`)를 오해하고 있음\n- 객체란 디스크에 있는 파일, 웹 페이지 혹은 메모리에 존재하는 바이트 배열, 해시맵 등과 같은 실제 엔티티의 대표자이다.\n```java\n// 아래 코드에서 File 객체는 실제 파일의 대표자 역할을 수행\npublic void echo() {\n\tFile f = new File(\"/tmp/test.txt\");\n\tSystem.out.println(\"File size : %d\", f.length());\n}\n```\n- 일반적인 객체는 식별자(identity), 상태(state), 행동(behavior)를 포함. \n\n### 3.5 절대 getter와 setter를 사용하지 마세요\n- 클래스는 다르다. 어떤 식으로든 맴버에게 접근하는 것을 허용하지 않으며, 노출을 하지도 않는다. 할 수 있는 일은 오직 객체에게 `요청`하는 것 뿐이다.\n- 자료구조는 `glass box`, 객체는 `black box`\n- ***프로그래밍에서 가시성의 범위를 줄이는 것은 사물을 단순화시키는 것이며 이해의 범위가 작을수록 유지보수성과 코드의 대한 이해/수정이 쉬워진다.***\n- `Getter/Setter`는 클래스를 자료구조로 사용하는 목적에서 도입이 되었다. 이는 곧, 발가벗겨진 데이터가 그대로 노출이 되며 절차적인 프로그래밍 스타일을 사용하도록 부추기게 된다.\n- `Getter/Setter`는 데이터가 무방비로 `public`하게 노출되어 있는 것과 마찬가지이다. 결국 이러한 형태의 객체는 하나의 데이터로서 역할만을 수행할 수 밖에 없다.\n\n### 3.6 부 ctor 밖에서는 new를 사용하지 마세요\n- 클래스가 작고 단순하며 네트워크나 디스크, 데이터베이스 등의 값비싼 자원을 사용하지 않는다면 전혀 문제가 되지 않을 것이다.\n```java\npublic class Cash {\n\tprivate final int dollars;\n\n\tpublic int euro() {\n\t\treturn new Exchange().rate(\"USD\", \"EUR\") * this.dollars;\n\t}\n}\n```\n- `euro()` 메소드를 사용할때마다 원격지와 통신을 하게 될 경우에 이 객체를 사용하는 사용자 입장에서는 매번 원격지와의 통신을 강요받을 수 밖에 없다. 이러한 결합을 피하기 위해서는 코드 자체를 수정할 수 밖에 없는데 이런식의 수정은 테스트와 유지보수성을 급격하게 낮출 수 밖에 없다. 다시 말해, 의존성에 대한 제어를 `Cash` 클래스 자신이 하고 있는 상황이다.\n\n```java\npublic class Cash {\n\tprivate final int dollars;\n\tprivate final Exchange exchange;\n\n\tCash(int value, Exchange exchange) {\n\t\tthis.dollars = value;\n\t\tthis.exchange = exchange;\n\t}\n\n\tpublic int euro() {\n\t\treturn this.rate(\"USD\", \"EUR\") * this.dollars;\n\t}\n}\n```\n- 위와 같이 코드를 수정하게 될 경우, 생성자를 통하여 제공받은 `Exchange`와 협력을 할 수 있게 된다.\n- 의존성에 대한 제어 주체가 `Cash` 클래스가 아닌 외부 혹은 사용하는 쪽에서 제어할 수 있도록 수정이 되었다.\n- 객체가 필요한 의존성을 직접 생성하는 대신, 생성자를 통해 **의존성을 주입** 받으며 `Exchange` 타입의 의존성 즉 직접 작성한 코드 혹은 다른 객체를 주입하여 해당 객체가 호출이 되도록 **제어의 역전**을 수행하게 된다.\n\n\n### 3.7 인트로스펙션과 캐스팅을 피하세요\n```java\npublic <T> int size(Iterable<T> items) {\n\tif (items instanceof Collection) {\n\t\treturn Collection.class.cast(items).size()\n\t}\n\tint size = 0;\n\tfor (T item: items) {\n\t\t++size;\n\t}\n\treturn size;\n}\n```\n- 런타임에 객체 타입을 조사하는 것은 클래스 사이의 결합도가 높아지기 때문에 기술적인 관점에서 좋지 않음\n- 위 예제에서는 `Iterable`과 `Collection` 인터페이스에 의존을 하고 있으며, 대상이 많아질수록 별도의 분기와 코드가 생겨나기 때문에 유지보수성이 좋아질 수가 없을 것이다.\n- 취급하는 타입에 따라 객체를 차별하기 때문에 자율성이라는 객체지향의 기본적인 베이스 정신을 훼손하는 코드라고 한다.\n- 타입 체킹 혹은 캐스팅을 하려거든 차라리 `메소드 오버로딩(method overloading)`을 활용하자.\n```java\npublic <T> int size(Iterable<T> items) {\n\tint size = 0;\n\tfor (T item: items) {\n\t\t++size;\n\t}\n\treturn size;\n}\n\npublic <T> int size(Collection<T> items) {\n\treturn items.size();\n}\n\n```\n## 4장 은퇴\n---\n### 4.1 절대 NULL을 반환하지 마세요\n- 객체를 장애를 가진 존재로 취급해서는 안된다\n- 항상 `NullPointerException` 예외가 던져질지 모른다는 사실은 기술적인 불편함을 넘어서서 해당 객체에 대한 `신뢰`가 무너졌다는 사실이다. 결국, ***객체에게 작업을 요청한 후 안심하고 결과에 의지할 수 없다.*** 또한,  이는 곧 유지보수성의 심각한 손실로 이어진다.\n- **객체라는 사상에는 우리가 신뢰하는 엔티티라는 개념이 담겨져 있다.**\n- 객체는 자신이 맡은 일을 수행하는 방법을 스스로 결정한다. \n```java\nvoid list(File dir) {\n\tFile[] files = dir.listFiles();\n\t// 매번 아래와 같은 체크를 해야 한다면, 장황한 코드의 추가와 더불어 매번 반환값을 확인해야 한다.\n\tif (files == null) {\n\t\tthrow new IOException(\"Directory is absent\");\n\t}\n\tfor (File file : files) {\n\t\tSystem.out.println(file.getName());\n\t}\n}\n```\n- `빠르게 실패하기 원칙(fail fast principle)`, `null`을 리턴하는 대신 예외를 던져 빠르게 실패하는 것.\n- `빠르게 실패하기 원칙` vs `안전하게 실패하기`\n  - 안전하게 실패하기는 버그, 입출력 문제, 메모리 오버플로우 등이 발생한 상황에서도 소프트웨어가 계속 실행될 수 있도록 최대한 많은 노력을 기울이는 것\n  - 빠르게 실패하기는 일반 문제가 발생하면 곧바로 실행을 중단하고 빠르게 예외를 던짐. 실패를 감추는 대신 강조.\n- 어떤 버그는 명확하지만, 또 그렇지 않고 조용히 숨어 있는 경우가 있다.\n  > 버그가 존재하는 사실을 숨기는 것은 스스로에게 죄를 짓고 있는 것이며 상처를 드러내어 치료하는 대신, 상처를 숨기고 모든 일이 순조롭게 진행되고 있다고 환자에게 거짓말을 하는 행위이다. \n- NULL의 대안은?\n  - 메소드를 분리\n  ```java\n  // 아래의 경우, DB IO가 두번 발생하여 비효율적이다.\n  public boolean exists(String name) {\n\t  if (/*DB에 없다면*/) {\n\t\t  return false;\n\t  }\n\t  return true;\n  }\n  \n  public User user(String name) {\n\t  return /* From DB */\n  }\n  ```\n  - NULL을 반환하는 대신 기본값을 반환\n  ```java\n  public Collection<User> users(String name) {\n\tif (/*DB에 없다면*/) {\n\t\treturn emptyList();\n\t}\n\treturn Collections.singleton(/* From DB */)\n  }\n  ```\n  - `Optional`과 같은 클래스를 활용\n  - `Null` Object를 만드는 방법\n  ```java\n  public class NullUser implements User {\n\tprivate final String label;\n\tNullUser(String name) {\n\t\tthis.label = name;\n\t}\n\n\t@Override\n\tpublic String name() {\n\t\treturn this.label;\n\t}\n\n\t@Override\n\tpublic void raise() {\n\t\tthrow new IllegalStateException(\"인상 못해유~\")\n\t}\n  }\n  ```\n### 4.2 체크 예외(checked exception)만 던지세요\n- Checked Exception은 메소드를 호출하는 쪽에 예외를 처리하도록 강제할 수 있다. \nMethod에 명시적으로 예외의 타입이 노출이 되기 때문에 어떤 종류의 예외가 발생할지 예측할 수 있다. 다시 말해, 책임을 클라이언트에 전달하면서 제 자신이 안전하지 않다라고 선언하는 샘이다.\n- UnChecked Exception의 경우, 별도로 예외를 처리하지 않으면 최상위로 전달~ 전달~\n- 꼭 필요한 경우가 아니라면 예외는 안잡는 것이 최선이다. 예외를 처리할때는 반드시 그 이유가 존재해야 한다. 만약 제어 흐름을 위해 예외를 사용하는 것이라면 이는 예외라는 것의 처리 목적과 전혀 부합하지 않게된다.\n- 예외는 반드시(항상) 체이닝하세요. \n절대 원래 예외를 무시하지 말고 체이닝하여 낮은 수준의 근본 원인을 소프트웨어의 상위 레이어로 이동시킬 수 있게 된다. 또한, 문제에 대한 가치 있는 정보를 포함하기 때문에 빠르게 실수에 대응할 수 있게 된다.\n- 예외는 복구가 될 수 있다. 하지만, 무분별한 예외 복구보다는 분명한 이유가 있는 예외 복구와 진입로/출구로 가는 접점에 이를 배치하는 것이 좀 더 효율적이라고 할 수 있다.\n```java\npublic static void main(String[] args) {\n\ttry {\n\t\tSystem.out.println(new App().run())\n\t} catch(Exception ex) {\n\t\tSystem.err.println(\"죄송하지만 문제가 발생했어요:\" + ex.getLocalizedMessage() )\n\t}\n}\n```\n- main에서 예외를 잡지 않게 되면 런타임 환경으로 예외가 전달되고 결국 JVM이 이를 처리하게 될 것이다. 이는 곧 사용자에게 노출을 시키지 말아야 할 메세지를 노출하게 될수도 있다. 위와 같은 장소가 예외를 복구하기 좋은 장소라고 할 수 있다.\n\n### 4.3 final이거나 abstract이거나\n### 4.4 RAII를 사용하세요\n\n## 후기\n","source":"_posts/ARCHITECTURE/ELEGANT_OBJECT.md","raw":"---\ntitle: 엘레강트 오브젝트\ndate: 2021/4/24 00:00:00\ncategories:\n- ARCHITECTURE\n---\n\n# 엘레강트 오브젝트\n## 1장 출생\n---\n### 1.1 -er로 끝나는 이름을 사용하지 마세요\n### 1.2 생성자 하나를 주 생성자로 만드세요\n### 1.3 생성자에 코드를 넣지 마세요\n\n## 2장 학습\n---\n### 2.1 가능하면 적게 캡슐화하세요\n### 2.2 최소한 뭔가는 캡슐화하세요\n### 2.3 항상 인터페이스를 사용하세요\n### 2.4 메서드 이름을 신중하게 선택하세요\n### 2.5 퍼블릭 상수(public constant)를 사용하지 마세요\n\n### 2.6 불변 객체로 만드세요\n### 2.7 문서를 작성하는 대신 테스트를 만드세요\n### 2.8모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요\n### 2.9인터페이스를 짧게 유지하고 스마트(smart)를 사용하세요\n\n## 3장 취업\n---\n### 3.1 5개 이하의 public 메서드만 노출하세요\n- 20개의 메소드를 가진 클래스를 50줄로 구현했다고 이 클래스가 작다고 말할 수 있을까?\n- public 메소드가 많을수록 클래스도 거기에 비례하여 커질수 있고, 이는 곧 유지보수성을 저하시키는 요인이 될 수 있음\n- public 메소드의 수를 최소로 사용. public 메소드는 객체의 진입점이며 진입점의 수가 적을수록 문제가 발생하더라도 쉽게 수정이 가능\n- 클래스가 작으면 메소드와 필드가 더 가까이 있을 확률이 높기 때문에 응집도가 높아지는 효과가 있을 수 있음.\n### 3.2 정적 메서드를 사용하지 마세요\n- 정적 메소드를 사용하게 되면, 평가의 방법이 eager한 방식으로 처리가 될 여지가 큼\n- 정적 메소드를 사용하지 않고, 이를 객체로 만들 경우, 필요한 순간에 평가를 진행할 수 있기 때문에 lazy한 평가를 수행할 수 있어 어느정도 성능적인 최적화가 가능.\n- 명령형 vs 선언형, 잘짜놓은 객체지향스러운 코드는 선언형 성격이 강함. 결국 [알고리즘 - 실행]의 맥락으로 접근하는 것이 아닌 [객체 - 행동]의 관점으로 사고하는 것을 이야기함.\n- 유틸리티 성격의 클래스(XXXXUtil, XXXXHeler)를 굳이 사용하는 경우엔, 해당 객체의 인스턴스화가 필요없기 때문에 private constructor를 선언하여 객체 생성을 막도록 하는 것이 좋다.\n- 싱글톤의 목적은 객체의 상태를 가지는 것이 아니라, `분리 가능한 의존성`을 가지는 것이 핵심이다. 하지만, 싱글톤 역시 또 다른 의미의 전역 변수를 만드는 것과 크게 다르지 않을 수 있다.\n- 이상적인 FP에서는 최소의 출구만을 만드는 것이 최선\n- 더 작은 객체로 개념을 고립시키고 이를 조합하는 것이 객체지향에서는 최선이다.\n\n### 3.3인자의 값으로 NULL을 절대 허용하지 마세요\n- `null`은 죄악이다. 프로그래머들이 접근할 수 없는 메모리 값을 `0`으로 표현하고 이를 가리켜 null로 부르는 동의에서 시작된 것이다.\n- `null`을 전달해야 하는 상황이라면, 차라리 빈 객체를 만들어 전달하자.\n- `null`에 대한 처리를 해야 하는 상황이라면, 반드시 쉴드패턴(`shield pattern`)과 같은 구현 방식으로 예외를 호출자에게 전달하도록 유도하는 것이 좋다. JVM에서 권고하는 예외 클래스를 사용하는 것이 그 예시\n```java\npublic Iterable<File> find(Mask mask) {\n\tif (mask == null) {\n\t\tthrow new IllegalArgumentException(\"Mask can't be NULL\");\n\t}\n}\n```\n\n\n### 3.4 충성스러우면서 불변이거나, 아니면 상수이거나\n- 많은 사람들이 상태(`state`)와 데이터(`data`)를 오해하고 있음\n- 객체란 디스크에 있는 파일, 웹 페이지 혹은 메모리에 존재하는 바이트 배열, 해시맵 등과 같은 실제 엔티티의 대표자이다.\n```java\n// 아래 코드에서 File 객체는 실제 파일의 대표자 역할을 수행\npublic void echo() {\n\tFile f = new File(\"/tmp/test.txt\");\n\tSystem.out.println(\"File size : %d\", f.length());\n}\n```\n- 일반적인 객체는 식별자(identity), 상태(state), 행동(behavior)를 포함. \n\n### 3.5 절대 getter와 setter를 사용하지 마세요\n- 클래스는 다르다. 어떤 식으로든 맴버에게 접근하는 것을 허용하지 않으며, 노출을 하지도 않는다. 할 수 있는 일은 오직 객체에게 `요청`하는 것 뿐이다.\n- 자료구조는 `glass box`, 객체는 `black box`\n- ***프로그래밍에서 가시성의 범위를 줄이는 것은 사물을 단순화시키는 것이며 이해의 범위가 작을수록 유지보수성과 코드의 대한 이해/수정이 쉬워진다.***\n- `Getter/Setter`는 클래스를 자료구조로 사용하는 목적에서 도입이 되었다. 이는 곧, 발가벗겨진 데이터가 그대로 노출이 되며 절차적인 프로그래밍 스타일을 사용하도록 부추기게 된다.\n- `Getter/Setter`는 데이터가 무방비로 `public`하게 노출되어 있는 것과 마찬가지이다. 결국 이러한 형태의 객체는 하나의 데이터로서 역할만을 수행할 수 밖에 없다.\n\n### 3.6 부 ctor 밖에서는 new를 사용하지 마세요\n- 클래스가 작고 단순하며 네트워크나 디스크, 데이터베이스 등의 값비싼 자원을 사용하지 않는다면 전혀 문제가 되지 않을 것이다.\n```java\npublic class Cash {\n\tprivate final int dollars;\n\n\tpublic int euro() {\n\t\treturn new Exchange().rate(\"USD\", \"EUR\") * this.dollars;\n\t}\n}\n```\n- `euro()` 메소드를 사용할때마다 원격지와 통신을 하게 될 경우에 이 객체를 사용하는 사용자 입장에서는 매번 원격지와의 통신을 강요받을 수 밖에 없다. 이러한 결합을 피하기 위해서는 코드 자체를 수정할 수 밖에 없는데 이런식의 수정은 테스트와 유지보수성을 급격하게 낮출 수 밖에 없다. 다시 말해, 의존성에 대한 제어를 `Cash` 클래스 자신이 하고 있는 상황이다.\n\n```java\npublic class Cash {\n\tprivate final int dollars;\n\tprivate final Exchange exchange;\n\n\tCash(int value, Exchange exchange) {\n\t\tthis.dollars = value;\n\t\tthis.exchange = exchange;\n\t}\n\n\tpublic int euro() {\n\t\treturn this.rate(\"USD\", \"EUR\") * this.dollars;\n\t}\n}\n```\n- 위와 같이 코드를 수정하게 될 경우, 생성자를 통하여 제공받은 `Exchange`와 협력을 할 수 있게 된다.\n- 의존성에 대한 제어 주체가 `Cash` 클래스가 아닌 외부 혹은 사용하는 쪽에서 제어할 수 있도록 수정이 되었다.\n- 객체가 필요한 의존성을 직접 생성하는 대신, 생성자를 통해 **의존성을 주입** 받으며 `Exchange` 타입의 의존성 즉 직접 작성한 코드 혹은 다른 객체를 주입하여 해당 객체가 호출이 되도록 **제어의 역전**을 수행하게 된다.\n\n\n### 3.7 인트로스펙션과 캐스팅을 피하세요\n```java\npublic <T> int size(Iterable<T> items) {\n\tif (items instanceof Collection) {\n\t\treturn Collection.class.cast(items).size()\n\t}\n\tint size = 0;\n\tfor (T item: items) {\n\t\t++size;\n\t}\n\treturn size;\n}\n```\n- 런타임에 객체 타입을 조사하는 것은 클래스 사이의 결합도가 높아지기 때문에 기술적인 관점에서 좋지 않음\n- 위 예제에서는 `Iterable`과 `Collection` 인터페이스에 의존을 하고 있으며, 대상이 많아질수록 별도의 분기와 코드가 생겨나기 때문에 유지보수성이 좋아질 수가 없을 것이다.\n- 취급하는 타입에 따라 객체를 차별하기 때문에 자율성이라는 객체지향의 기본적인 베이스 정신을 훼손하는 코드라고 한다.\n- 타입 체킹 혹은 캐스팅을 하려거든 차라리 `메소드 오버로딩(method overloading)`을 활용하자.\n```java\npublic <T> int size(Iterable<T> items) {\n\tint size = 0;\n\tfor (T item: items) {\n\t\t++size;\n\t}\n\treturn size;\n}\n\npublic <T> int size(Collection<T> items) {\n\treturn items.size();\n}\n\n```\n## 4장 은퇴\n---\n### 4.1 절대 NULL을 반환하지 마세요\n- 객체를 장애를 가진 존재로 취급해서는 안된다\n- 항상 `NullPointerException` 예외가 던져질지 모른다는 사실은 기술적인 불편함을 넘어서서 해당 객체에 대한 `신뢰`가 무너졌다는 사실이다. 결국, ***객체에게 작업을 요청한 후 안심하고 결과에 의지할 수 없다.*** 또한,  이는 곧 유지보수성의 심각한 손실로 이어진다.\n- **객체라는 사상에는 우리가 신뢰하는 엔티티라는 개념이 담겨져 있다.**\n- 객체는 자신이 맡은 일을 수행하는 방법을 스스로 결정한다. \n```java\nvoid list(File dir) {\n\tFile[] files = dir.listFiles();\n\t// 매번 아래와 같은 체크를 해야 한다면, 장황한 코드의 추가와 더불어 매번 반환값을 확인해야 한다.\n\tif (files == null) {\n\t\tthrow new IOException(\"Directory is absent\");\n\t}\n\tfor (File file : files) {\n\t\tSystem.out.println(file.getName());\n\t}\n}\n```\n- `빠르게 실패하기 원칙(fail fast principle)`, `null`을 리턴하는 대신 예외를 던져 빠르게 실패하는 것.\n- `빠르게 실패하기 원칙` vs `안전하게 실패하기`\n  - 안전하게 실패하기는 버그, 입출력 문제, 메모리 오버플로우 등이 발생한 상황에서도 소프트웨어가 계속 실행될 수 있도록 최대한 많은 노력을 기울이는 것\n  - 빠르게 실패하기는 일반 문제가 발생하면 곧바로 실행을 중단하고 빠르게 예외를 던짐. 실패를 감추는 대신 강조.\n- 어떤 버그는 명확하지만, 또 그렇지 않고 조용히 숨어 있는 경우가 있다.\n  > 버그가 존재하는 사실을 숨기는 것은 스스로에게 죄를 짓고 있는 것이며 상처를 드러내어 치료하는 대신, 상처를 숨기고 모든 일이 순조롭게 진행되고 있다고 환자에게 거짓말을 하는 행위이다. \n- NULL의 대안은?\n  - 메소드를 분리\n  ```java\n  // 아래의 경우, DB IO가 두번 발생하여 비효율적이다.\n  public boolean exists(String name) {\n\t  if (/*DB에 없다면*/) {\n\t\t  return false;\n\t  }\n\t  return true;\n  }\n  \n  public User user(String name) {\n\t  return /* From DB */\n  }\n  ```\n  - NULL을 반환하는 대신 기본값을 반환\n  ```java\n  public Collection<User> users(String name) {\n\tif (/*DB에 없다면*/) {\n\t\treturn emptyList();\n\t}\n\treturn Collections.singleton(/* From DB */)\n  }\n  ```\n  - `Optional`과 같은 클래스를 활용\n  - `Null` Object를 만드는 방법\n  ```java\n  public class NullUser implements User {\n\tprivate final String label;\n\tNullUser(String name) {\n\t\tthis.label = name;\n\t}\n\n\t@Override\n\tpublic String name() {\n\t\treturn this.label;\n\t}\n\n\t@Override\n\tpublic void raise() {\n\t\tthrow new IllegalStateException(\"인상 못해유~\")\n\t}\n  }\n  ```\n### 4.2 체크 예외(checked exception)만 던지세요\n- Checked Exception은 메소드를 호출하는 쪽에 예외를 처리하도록 강제할 수 있다. \nMethod에 명시적으로 예외의 타입이 노출이 되기 때문에 어떤 종류의 예외가 발생할지 예측할 수 있다. 다시 말해, 책임을 클라이언트에 전달하면서 제 자신이 안전하지 않다라고 선언하는 샘이다.\n- UnChecked Exception의 경우, 별도로 예외를 처리하지 않으면 최상위로 전달~ 전달~\n- 꼭 필요한 경우가 아니라면 예외는 안잡는 것이 최선이다. 예외를 처리할때는 반드시 그 이유가 존재해야 한다. 만약 제어 흐름을 위해 예외를 사용하는 것이라면 이는 예외라는 것의 처리 목적과 전혀 부합하지 않게된다.\n- 예외는 반드시(항상) 체이닝하세요. \n절대 원래 예외를 무시하지 말고 체이닝하여 낮은 수준의 근본 원인을 소프트웨어의 상위 레이어로 이동시킬 수 있게 된다. 또한, 문제에 대한 가치 있는 정보를 포함하기 때문에 빠르게 실수에 대응할 수 있게 된다.\n- 예외는 복구가 될 수 있다. 하지만, 무분별한 예외 복구보다는 분명한 이유가 있는 예외 복구와 진입로/출구로 가는 접점에 이를 배치하는 것이 좀 더 효율적이라고 할 수 있다.\n```java\npublic static void main(String[] args) {\n\ttry {\n\t\tSystem.out.println(new App().run())\n\t} catch(Exception ex) {\n\t\tSystem.err.println(\"죄송하지만 문제가 발생했어요:\" + ex.getLocalizedMessage() )\n\t}\n}\n```\n- main에서 예외를 잡지 않게 되면 런타임 환경으로 예외가 전달되고 결국 JVM이 이를 처리하게 될 것이다. 이는 곧 사용자에게 노출을 시키지 말아야 할 메세지를 노출하게 될수도 있다. 위와 같은 장소가 예외를 복구하기 좋은 장소라고 할 수 있다.\n\n### 4.3 final이거나 abstract이거나\n### 4.4 RAII를 사용하세요\n\n## 후기\n","slug":"ARCHITECTURE/ELEGANT_OBJECT","published":1,"updated":"2021-08-02T12:20:07.943Z","_id":"ckrsup4zr0005tjhvhkiod5h4","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"엘레강트-오브젝트\"><a href=\"#엘레강트-오브젝트\" class=\"headerlink\" title=\"엘레강트 오브젝트\"></a>엘레강트 오브젝트</h1><h2 id=\"1장-출생\"><a href=\"#1장-출생\" class=\"headerlink\" title=\"1장 출생\"></a>1장 출생</h2><hr>\n<h3 id=\"1-1-er로-끝나는-이름을-사용하지-마세요\"><a href=\"#1-1-er로-끝나는-이름을-사용하지-마세요\" class=\"headerlink\" title=\"1.1 -er로 끝나는 이름을 사용하지 마세요\"></a>1.1 -er로 끝나는 이름을 사용하지 마세요</h3><h3 id=\"1-2-생성자-하나를-주-생성자로-만드세요\"><a href=\"#1-2-생성자-하나를-주-생성자로-만드세요\" class=\"headerlink\" title=\"1.2 생성자 하나를 주 생성자로 만드세요\"></a>1.2 생성자 하나를 주 생성자로 만드세요</h3><h3 id=\"1-3-생성자에-코드를-넣지-마세요\"><a href=\"#1-3-생성자에-코드를-넣지-마세요\" class=\"headerlink\" title=\"1.3 생성자에 코드를 넣지 마세요\"></a>1.3 생성자에 코드를 넣지 마세요</h3><h2 id=\"2장-학습\"><a href=\"#2장-학습\" class=\"headerlink\" title=\"2장 학습\"></a>2장 학습</h2><hr>\n<h3 id=\"2-1-가능하면-적게-캡슐화하세요\"><a href=\"#2-1-가능하면-적게-캡슐화하세요\" class=\"headerlink\" title=\"2.1 가능하면 적게 캡슐화하세요\"></a>2.1 가능하면 적게 캡슐화하세요</h3><h3 id=\"2-2-최소한-뭔가는-캡슐화하세요\"><a href=\"#2-2-최소한-뭔가는-캡슐화하세요\" class=\"headerlink\" title=\"2.2 최소한 뭔가는 캡슐화하세요\"></a>2.2 최소한 뭔가는 캡슐화하세요</h3><h3 id=\"2-3-항상-인터페이스를-사용하세요\"><a href=\"#2-3-항상-인터페이스를-사용하세요\" class=\"headerlink\" title=\"2.3 항상 인터페이스를 사용하세요\"></a>2.3 항상 인터페이스를 사용하세요</h3><h3 id=\"2-4-메서드-이름을-신중하게-선택하세요\"><a href=\"#2-4-메서드-이름을-신중하게-선택하세요\" class=\"headerlink\" title=\"2.4 메서드 이름을 신중하게 선택하세요\"></a>2.4 메서드 이름을 신중하게 선택하세요</h3><h3 id=\"2-5-퍼블릭-상수-public-constant-를-사용하지-마세요\"><a href=\"#2-5-퍼블릭-상수-public-constant-를-사용하지-마세요\" class=\"headerlink\" title=\"2.5 퍼블릭 상수(public constant)를 사용하지 마세요\"></a>2.5 퍼블릭 상수(public constant)를 사용하지 마세요</h3><h3 id=\"2-6-불변-객체로-만드세요\"><a href=\"#2-6-불변-객체로-만드세요\" class=\"headerlink\" title=\"2.6 불변 객체로 만드세요\"></a>2.6 불변 객체로 만드세요</h3><h3 id=\"2-7-문서를-작성하는-대신-테스트를-만드세요\"><a href=\"#2-7-문서를-작성하는-대신-테스트를-만드세요\" class=\"headerlink\" title=\"2.7 문서를 작성하는 대신 테스트를 만드세요\"></a>2.7 문서를 작성하는 대신 테스트를 만드세요</h3><h3 id=\"2-8모의-객체-Mock-대신-페이크-객체-Fake-를-사용하세요\"><a href=\"#2-8모의-객체-Mock-대신-페이크-객체-Fake-를-사용하세요\" class=\"headerlink\" title=\"2.8모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요\"></a>2.8모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요</h3><h3 id=\"2-9인터페이스를-짧게-유지하고-스마트-smart-를-사용하세요\"><a href=\"#2-9인터페이스를-짧게-유지하고-스마트-smart-를-사용하세요\" class=\"headerlink\" title=\"2.9인터페이스를 짧게 유지하고 스마트(smart)를 사용하세요\"></a>2.9인터페이스를 짧게 유지하고 스마트(smart)를 사용하세요</h3><h2 id=\"3장-취업\"><a href=\"#3장-취업\" class=\"headerlink\" title=\"3장 취업\"></a>3장 취업</h2><hr>\n<h3 id=\"3-1-5개-이하의-public-메서드만-노출하세요\"><a href=\"#3-1-5개-이하의-public-메서드만-노출하세요\" class=\"headerlink\" title=\"3.1 5개 이하의 public 메서드만 노출하세요\"></a>3.1 5개 이하의 public 메서드만 노출하세요</h3><ul>\n<li>20개의 메소드를 가진 클래스를 50줄로 구현했다고 이 클래스가 작다고 말할 수 있을까?</li>\n<li>public 메소드가 많을수록 클래스도 거기에 비례하여 커질수 있고, 이는 곧 유지보수성을 저하시키는 요인이 될 수 있음</li>\n<li>public 메소드의 수를 최소로 사용. public 메소드는 객체의 진입점이며 진입점의 수가 적을수록 문제가 발생하더라도 쉽게 수정이 가능</li>\n<li>클래스가 작으면 메소드와 필드가 더 가까이 있을 확률이 높기 때문에 응집도가 높아지는 효과가 있을 수 있음.<h3 id=\"3-2-정적-메서드를-사용하지-마세요\"><a href=\"#3-2-정적-메서드를-사용하지-마세요\" class=\"headerlink\" title=\"3.2 정적 메서드를 사용하지 마세요\"></a>3.2 정적 메서드를 사용하지 마세요</h3></li>\n<li>정적 메소드를 사용하게 되면, 평가의 방법이 eager한 방식으로 처리가 될 여지가 큼</li>\n<li>정적 메소드를 사용하지 않고, 이를 객체로 만들 경우, 필요한 순간에 평가를 진행할 수 있기 때문에 lazy한 평가를 수행할 수 있어 어느정도 성능적인 최적화가 가능.</li>\n<li>명령형 vs 선언형, 잘짜놓은 객체지향스러운 코드는 선언형 성격이 강함. 결국 [알고리즘 - 실행]의 맥락으로 접근하는 것이 아닌 [객체 - 행동]의 관점으로 사고하는 것을 이야기함.</li>\n<li>유틸리티 성격의 클래스(XXXXUtil, XXXXHeler)를 굳이 사용하는 경우엔, 해당 객체의 인스턴스화가 필요없기 때문에 private constructor를 선언하여 객체 생성을 막도록 하는 것이 좋다.</li>\n<li>싱글톤의 목적은 객체의 상태를 가지는 것이 아니라, <code>분리 가능한 의존성</code>을 가지는 것이 핵심이다. 하지만, 싱글톤 역시 또 다른 의미의 전역 변수를 만드는 것과 크게 다르지 않을 수 있다.</li>\n<li>이상적인 FP에서는 최소의 출구만을 만드는 것이 최선</li>\n<li>더 작은 객체로 개념을 고립시키고 이를 조합하는 것이 객체지향에서는 최선이다.</li>\n</ul>\n<h3 id=\"3-3인자의-값으로-NULL을-절대-허용하지-마세요\"><a href=\"#3-3인자의-값으로-NULL을-절대-허용하지-마세요\" class=\"headerlink\" title=\"3.3인자의 값으로 NULL을 절대 허용하지 마세요\"></a>3.3인자의 값으로 NULL을 절대 허용하지 마세요</h3><ul>\n<li><code>null</code>은 죄악이다. 프로그래머들이 접근할 수 없는 메모리 값을 <code>0</code>으로 표현하고 이를 가리켜 null로 부르는 동의에서 시작된 것이다.</li>\n<li><code>null</code>을 전달해야 하는 상황이라면, 차라리 빈 객체를 만들어 전달하자.</li>\n<li><code>null</code>에 대한 처리를 해야 하는 상황이라면, 반드시 쉴드패턴(<code>shield pattern</code>)과 같은 구현 방식으로 예외를 호출자에게 전달하도록 유도하는 것이 좋다. JVM에서 권고하는 예외 클래스를 사용하는 것이 그 예시<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Iterable&lt;File&gt; <span class=\"title\">find</span><span class=\"params\">(Mask mask)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mask == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Mask can&#x27;t be NULL&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"3-4-충성스러우면서-불변이거나-아니면-상수이거나\"><a href=\"#3-4-충성스러우면서-불변이거나-아니면-상수이거나\" class=\"headerlink\" title=\"3.4 충성스러우면서 불변이거나, 아니면 상수이거나\"></a>3.4 충성스러우면서 불변이거나, 아니면 상수이거나</h3><ul>\n<li>많은 사람들이 상태(<code>state</code>)와 데이터(<code>data</code>)를 오해하고 있음</li>\n<li>객체란 디스크에 있는 파일, 웹 페이지 혹은 메모리에 존재하는 바이트 배열, 해시맵 등과 같은 실제 엔티티의 대표자이다.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 아래 코드에서 File 객체는 실제 파일의 대표자 역할을 수행</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">echo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tFile f = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/tmp/test.txt&quot;</span>);</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;File size : %d&quot;</span>, f.length());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>일반적인 객체는 식별자(identity), 상태(state), 행동(behavior)를 포함. </li>\n</ul>\n<h3 id=\"3-5-절대-getter와-setter를-사용하지-마세요\"><a href=\"#3-5-절대-getter와-setter를-사용하지-마세요\" class=\"headerlink\" title=\"3.5 절대 getter와 setter를 사용하지 마세요\"></a>3.5 절대 getter와 setter를 사용하지 마세요</h3><ul>\n<li>클래스는 다르다. 어떤 식으로든 맴버에게 접근하는 것을 허용하지 않으며, 노출을 하지도 않는다. 할 수 있는 일은 오직 객체에게 <code>요청</code>하는 것 뿐이다.</li>\n<li>자료구조는 <code>glass box</code>, 객체는 <code>black box</code></li>\n<li><em><strong>프로그래밍에서 가시성의 범위를 줄이는 것은 사물을 단순화시키는 것이며 이해의 범위가 작을수록 유지보수성과 코드의 대한 이해/수정이 쉬워진다.</strong></em></li>\n<li><code>Getter/Setter</code>는 클래스를 자료구조로 사용하는 목적에서 도입이 되었다. 이는 곧, 발가벗겨진 데이터가 그대로 노출이 되며 절차적인 프로그래밍 스타일을 사용하도록 부추기게 된다.</li>\n<li><code>Getter/Setter</code>는 데이터가 무방비로 <code>public</code>하게 노출되어 있는 것과 마찬가지이다. 결국 이러한 형태의 객체는 하나의 데이터로서 역할만을 수행할 수 밖에 없다.</li>\n</ul>\n<h3 id=\"3-6-부-ctor-밖에서는-new를-사용하지-마세요\"><a href=\"#3-6-부-ctor-밖에서는-new를-사용하지-마세요\" class=\"headerlink\" title=\"3.6 부 ctor 밖에서는 new를 사용하지 마세요\"></a>3.6 부 ctor 밖에서는 new를 사용하지 마세요</h3><ul>\n<li>클래스가 작고 단순하며 네트워크나 디스크, 데이터베이스 등의 값비싼 자원을 사용하지 않는다면 전혀 문제가 되지 않을 것이다.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cash</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> dollars;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">euro</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Exchange().rate(<span class=\"string\">&quot;USD&quot;</span>, <span class=\"string\">&quot;EUR&quot;</span>) * <span class=\"keyword\">this</span>.dollars;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>euro()</code> 메소드를 사용할때마다 원격지와 통신을 하게 될 경우에 이 객체를 사용하는 사용자 입장에서는 매번 원격지와의 통신을 강요받을 수 밖에 없다. 이러한 결합을 피하기 위해서는 코드 자체를 수정할 수 밖에 없는데 이런식의 수정은 테스트와 유지보수성을 급격하게 낮출 수 밖에 없다. 다시 말해, 의존성에 대한 제어를 <code>Cash</code> 클래스 자신이 하고 있는 상황이다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cash</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> dollars;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Exchange exchange;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCash(<span class=\"keyword\">int</span> value, Exchange exchange) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.dollars = value;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.exchange = exchange;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">euro</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.rate(<span class=\"string\">&quot;USD&quot;</span>, <span class=\"string\">&quot;EUR&quot;</span>) * <span class=\"keyword\">this</span>.dollars;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>위와 같이 코드를 수정하게 될 경우, 생성자를 통하여 제공받은 <code>Exchange</code>와 협력을 할 수 있게 된다.</li>\n<li>의존성에 대한 제어 주체가 <code>Cash</code> 클래스가 아닌 외부 혹은 사용하는 쪽에서 제어할 수 있도록 수정이 되었다.</li>\n<li>객체가 필요한 의존성을 직접 생성하는 대신, 생성자를 통해 <strong>의존성을 주입</strong> 받으며 <code>Exchange</code> 타입의 의존성 즉 직접 작성한 코드 혹은 다른 객체를 주입하여 해당 객체가 호출이 되도록 <strong>제어의 역전</strong>을 수행하게 된다.</li>\n</ul>\n<h3 id=\"3-7-인트로스펙션과-캐스팅을-피하세요\"><a href=\"#3-7-인트로스펙션과-캐스팅을-피하세요\" class=\"headerlink\" title=\"3.7 인트로스펙션과 캐스팅을 피하세요\"></a>3.7 인트로스펙션과 캐스팅을 피하세요</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">(Iterable&lt;T&gt; items)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (items <span class=\"keyword\">instanceof</span> Collection) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Collection.class.cast(items).size()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (T item: items) &#123;</span><br><span class=\"line\">\t\t++size;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>런타임에 객체 타입을 조사하는 것은 클래스 사이의 결합도가 높아지기 때문에 기술적인 관점에서 좋지 않음</li>\n<li>위 예제에서는 <code>Iterable</code>과 <code>Collection</code> 인터페이스에 의존을 하고 있으며, 대상이 많아질수록 별도의 분기와 코드가 생겨나기 때문에 유지보수성이 좋아질 수가 없을 것이다.</li>\n<li>취급하는 타입에 따라 객체를 차별하기 때문에 자율성이라는 객체지향의 기본적인 베이스 정신을 훼손하는 코드라고 한다.</li>\n<li>타입 체킹 혹은 캐스팅을 하려거든 차라리 <code>메소드 오버로딩(method overloading)</code>을 활용하자.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">(Iterable&lt;T&gt; items)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (T item: items) &#123;</span><br><span class=\"line\">\t\t++size;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">(Collection&lt;T&gt; items)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> items.size();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"4장-은퇴\"><a href=\"#4장-은퇴\" class=\"headerlink\" title=\"4장 은퇴\"></a>4장 은퇴</h2></li>\n</ul>\n<hr>\n<h3 id=\"4-1-절대-NULL을-반환하지-마세요\"><a href=\"#4-1-절대-NULL을-반환하지-마세요\" class=\"headerlink\" title=\"4.1 절대 NULL을 반환하지 마세요\"></a>4.1 절대 NULL을 반환하지 마세요</h3><ul>\n<li>객체를 장애를 가진 존재로 취급해서는 안된다</li>\n<li>항상 <code>NullPointerException</code> 예외가 던져질지 모른다는 사실은 기술적인 불편함을 넘어서서 해당 객체에 대한 <code>신뢰</code>가 무너졌다는 사실이다. 결국, <em><strong>객체에게 작업을 요청한 후 안심하고 결과에 의지할 수 없다.</strong></em> 또한,  이는 곧 유지보수성의 심각한 손실로 이어진다.</li>\n<li><strong>객체라는 사상에는 우리가 신뢰하는 엔티티라는 개념이 담겨져 있다.</strong></li>\n<li>객체는 자신이 맡은 일을 수행하는 방법을 스스로 결정한다. <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">list</span><span class=\"params\">(File dir)</span> </span>&#123;</span><br><span class=\"line\">\tFile[] files = dir.listFiles();</span><br><span class=\"line\">\t<span class=\"comment\">// 매번 아래와 같은 체크를 해야 한다면, 장황한 코드의 추가와 더불어 매번 반환값을 확인해야 한다.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (files == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">&quot;Directory is absent&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (File file : files) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(file.getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>빠르게 실패하기 원칙(fail fast principle)</code>, <code>null</code>을 리턴하는 대신 예외를 던져 빠르게 실패하는 것.</li>\n<li><code>빠르게 실패하기 원칙</code> vs <code>안전하게 실패하기</code><ul>\n<li>안전하게 실패하기는 버그, 입출력 문제, 메모리 오버플로우 등이 발생한 상황에서도 소프트웨어가 계속 실행될 수 있도록 최대한 많은 노력을 기울이는 것</li>\n<li>빠르게 실패하기는 일반 문제가 발생하면 곧바로 실행을 중단하고 빠르게 예외를 던짐. 실패를 감추는 대신 강조.</li>\n</ul>\n</li>\n<li>어떤 버그는 명확하지만, 또 그렇지 않고 조용히 숨어 있는 경우가 있다.<blockquote>\n<p>버그가 존재하는 사실을 숨기는 것은 스스로에게 죄를 짓고 있는 것이며 상처를 드러내어 치료하는 대신, 상처를 숨기고 모든 일이 순조롭게 진행되고 있다고 환자에게 거짓말을 하는 행위이다. </p>\n</blockquote>\n</li>\n<li>NULL의 대안은?<ul>\n<li>메소드를 분리<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 아래의 경우, DB IO가 두번 발생하여 비효율적이다.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">exists</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"comment\">/*DB에 없다면*/</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">user</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"comment\">/* From DB */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>NULL을 반환하는 대신 기본값을 반환<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> Collection&lt;User&gt; <span class=\"title\">users</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"comment\">/*DB에 없다면*/</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> emptyList();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> Collections.singleton(<span class=\"comment\">/* From DB */</span>)</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>Optional</code>과 같은 클래스를 활용</li>\n<li><code>Null</code> Object를 만드는 방법<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NullUser</span> <span class=\"keyword\">implements</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String label;</span><br><span class=\"line\">NullUser(String name) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.label = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.label;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">raise</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;인상 못해유~&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-체크-예외-checked-exception-만-던지세요\"><a href=\"#4-2-체크-예외-checked-exception-만-던지세요\" class=\"headerlink\" title=\"4.2 체크 예외(checked exception)만 던지세요\"></a>4.2 체크 예외(checked exception)만 던지세요</h3></li>\n</ul>\n</li>\n<li>Checked Exception은 메소드를 호출하는 쪽에 예외를 처리하도록 강제할 수 있다.<br>Method에 명시적으로 예외의 타입이 노출이 되기 때문에 어떤 종류의 예외가 발생할지 예측할 수 있다. 다시 말해, 책임을 클라이언트에 전달하면서 제 자신이 안전하지 않다라고 선언하는 샘이다.</li>\n<li>UnChecked Exception의 경우, 별도로 예외를 처리하지 않으면 최상위로 전달~ 전달~</li>\n<li>꼭 필요한 경우가 아니라면 예외는 안잡는 것이 최선이다. 예외를 처리할때는 반드시 그 이유가 존재해야 한다. 만약 제어 흐름을 위해 예외를 사용하는 것이라면 이는 예외라는 것의 처리 목적과 전혀 부합하지 않게된다.</li>\n<li>예외는 반드시(항상) 체이닝하세요.<br>절대 원래 예외를 무시하지 말고 체이닝하여 낮은 수준의 근본 원인을 소프트웨어의 상위 레이어로 이동시킬 수 있게 된다. 또한, 문제에 대한 가치 있는 정보를 포함하기 때문에 빠르게 실수에 대응할 수 있게 된다.</li>\n<li>예외는 복구가 될 수 있다. 하지만, 무분별한 예외 복구보다는 분명한 이유가 있는 예외 복구와 진입로/출구로 가는 접점에 이를 배치하는 것이 좀 더 효율적이라고 할 수 있다.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"keyword\">new</span> App().run())</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span>(Exception ex) &#123;</span><br><span class=\"line\">\t\tSystem.err.println(<span class=\"string\">&quot;죄송하지만 문제가 발생했어요:&quot;</span> + ex.getLocalizedMessage() )</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>main에서 예외를 잡지 않게 되면 런타임 환경으로 예외가 전달되고 결국 JVM이 이를 처리하게 될 것이다. 이는 곧 사용자에게 노출을 시키지 말아야 할 메세지를 노출하게 될수도 있다. 위와 같은 장소가 예외를 복구하기 좋은 장소라고 할 수 있다.</li>\n</ul>\n<h3 id=\"4-3-final이거나-abstract이거나\"><a href=\"#4-3-final이거나-abstract이거나\" class=\"headerlink\" title=\"4.3 final이거나 abstract이거나\"></a>4.3 final이거나 abstract이거나</h3><h3 id=\"4-4-RAII를-사용하세요\"><a href=\"#4-4-RAII를-사용하세요\" class=\"headerlink\" title=\"4.4 RAII를 사용하세요\"></a>4.4 RAII를 사용하세요</h3><h2 id=\"후기\"><a href=\"#후기\" class=\"headerlink\" title=\"후기\"></a>후기</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"엘레강트-오브젝트\"><a href=\"#엘레강트-오브젝트\" class=\"headerlink\" title=\"엘레강트 오브젝트\"></a>엘레강트 오브젝트</h1><h2 id=\"1장-출생\"><a href=\"#1장-출생\" class=\"headerlink\" title=\"1장 출생\"></a>1장 출생</h2><hr>\n<h3 id=\"1-1-er로-끝나는-이름을-사용하지-마세요\"><a href=\"#1-1-er로-끝나는-이름을-사용하지-마세요\" class=\"headerlink\" title=\"1.1 -er로 끝나는 이름을 사용하지 마세요\"></a>1.1 -er로 끝나는 이름을 사용하지 마세요</h3><h3 id=\"1-2-생성자-하나를-주-생성자로-만드세요\"><a href=\"#1-2-생성자-하나를-주-생성자로-만드세요\" class=\"headerlink\" title=\"1.2 생성자 하나를 주 생성자로 만드세요\"></a>1.2 생성자 하나를 주 생성자로 만드세요</h3><h3 id=\"1-3-생성자에-코드를-넣지-마세요\"><a href=\"#1-3-생성자에-코드를-넣지-마세요\" class=\"headerlink\" title=\"1.3 생성자에 코드를 넣지 마세요\"></a>1.3 생성자에 코드를 넣지 마세요</h3><h2 id=\"2장-학습\"><a href=\"#2장-학습\" class=\"headerlink\" title=\"2장 학습\"></a>2장 학습</h2><hr>\n<h3 id=\"2-1-가능하면-적게-캡슐화하세요\"><a href=\"#2-1-가능하면-적게-캡슐화하세요\" class=\"headerlink\" title=\"2.1 가능하면 적게 캡슐화하세요\"></a>2.1 가능하면 적게 캡슐화하세요</h3><h3 id=\"2-2-최소한-뭔가는-캡슐화하세요\"><a href=\"#2-2-최소한-뭔가는-캡슐화하세요\" class=\"headerlink\" title=\"2.2 최소한 뭔가는 캡슐화하세요\"></a>2.2 최소한 뭔가는 캡슐화하세요</h3><h3 id=\"2-3-항상-인터페이스를-사용하세요\"><a href=\"#2-3-항상-인터페이스를-사용하세요\" class=\"headerlink\" title=\"2.3 항상 인터페이스를 사용하세요\"></a>2.3 항상 인터페이스를 사용하세요</h3><h3 id=\"2-4-메서드-이름을-신중하게-선택하세요\"><a href=\"#2-4-메서드-이름을-신중하게-선택하세요\" class=\"headerlink\" title=\"2.4 메서드 이름을 신중하게 선택하세요\"></a>2.4 메서드 이름을 신중하게 선택하세요</h3><h3 id=\"2-5-퍼블릭-상수-public-constant-를-사용하지-마세요\"><a href=\"#2-5-퍼블릭-상수-public-constant-를-사용하지-마세요\" class=\"headerlink\" title=\"2.5 퍼블릭 상수(public constant)를 사용하지 마세요\"></a>2.5 퍼블릭 상수(public constant)를 사용하지 마세요</h3><h3 id=\"2-6-불변-객체로-만드세요\"><a href=\"#2-6-불변-객체로-만드세요\" class=\"headerlink\" title=\"2.6 불변 객체로 만드세요\"></a>2.6 불변 객체로 만드세요</h3><h3 id=\"2-7-문서를-작성하는-대신-테스트를-만드세요\"><a href=\"#2-7-문서를-작성하는-대신-테스트를-만드세요\" class=\"headerlink\" title=\"2.7 문서를 작성하는 대신 테스트를 만드세요\"></a>2.7 문서를 작성하는 대신 테스트를 만드세요</h3><h3 id=\"2-8모의-객체-Mock-대신-페이크-객체-Fake-를-사용하세요\"><a href=\"#2-8모의-객체-Mock-대신-페이크-객체-Fake-를-사용하세요\" class=\"headerlink\" title=\"2.8모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요\"></a>2.8모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요</h3><h3 id=\"2-9인터페이스를-짧게-유지하고-스마트-smart-를-사용하세요\"><a href=\"#2-9인터페이스를-짧게-유지하고-스마트-smart-를-사용하세요\" class=\"headerlink\" title=\"2.9인터페이스를 짧게 유지하고 스마트(smart)를 사용하세요\"></a>2.9인터페이스를 짧게 유지하고 스마트(smart)를 사용하세요</h3><h2 id=\"3장-취업\"><a href=\"#3장-취업\" class=\"headerlink\" title=\"3장 취업\"></a>3장 취업</h2><hr>\n<h3 id=\"3-1-5개-이하의-public-메서드만-노출하세요\"><a href=\"#3-1-5개-이하의-public-메서드만-노출하세요\" class=\"headerlink\" title=\"3.1 5개 이하의 public 메서드만 노출하세요\"></a>3.1 5개 이하의 public 메서드만 노출하세요</h3><ul>\n<li>20개의 메소드를 가진 클래스를 50줄로 구현했다고 이 클래스가 작다고 말할 수 있을까?</li>\n<li>public 메소드가 많을수록 클래스도 거기에 비례하여 커질수 있고, 이는 곧 유지보수성을 저하시키는 요인이 될 수 있음</li>\n<li>public 메소드의 수를 최소로 사용. public 메소드는 객체의 진입점이며 진입점의 수가 적을수록 문제가 발생하더라도 쉽게 수정이 가능</li>\n<li>클래스가 작으면 메소드와 필드가 더 가까이 있을 확률이 높기 때문에 응집도가 높아지는 효과가 있을 수 있음.<h3 id=\"3-2-정적-메서드를-사용하지-마세요\"><a href=\"#3-2-정적-메서드를-사용하지-마세요\" class=\"headerlink\" title=\"3.2 정적 메서드를 사용하지 마세요\"></a>3.2 정적 메서드를 사용하지 마세요</h3></li>\n<li>정적 메소드를 사용하게 되면, 평가의 방법이 eager한 방식으로 처리가 될 여지가 큼</li>\n<li>정적 메소드를 사용하지 않고, 이를 객체로 만들 경우, 필요한 순간에 평가를 진행할 수 있기 때문에 lazy한 평가를 수행할 수 있어 어느정도 성능적인 최적화가 가능.</li>\n<li>명령형 vs 선언형, 잘짜놓은 객체지향스러운 코드는 선언형 성격이 강함. 결국 [알고리즘 - 실행]의 맥락으로 접근하는 것이 아닌 [객체 - 행동]의 관점으로 사고하는 것을 이야기함.</li>\n<li>유틸리티 성격의 클래스(XXXXUtil, XXXXHeler)를 굳이 사용하는 경우엔, 해당 객체의 인스턴스화가 필요없기 때문에 private constructor를 선언하여 객체 생성을 막도록 하는 것이 좋다.</li>\n<li>싱글톤의 목적은 객체의 상태를 가지는 것이 아니라, <code>분리 가능한 의존성</code>을 가지는 것이 핵심이다. 하지만, 싱글톤 역시 또 다른 의미의 전역 변수를 만드는 것과 크게 다르지 않을 수 있다.</li>\n<li>이상적인 FP에서는 최소의 출구만을 만드는 것이 최선</li>\n<li>더 작은 객체로 개념을 고립시키고 이를 조합하는 것이 객체지향에서는 최선이다.</li>\n</ul>\n<h3 id=\"3-3인자의-값으로-NULL을-절대-허용하지-마세요\"><a href=\"#3-3인자의-값으로-NULL을-절대-허용하지-마세요\" class=\"headerlink\" title=\"3.3인자의 값으로 NULL을 절대 허용하지 마세요\"></a>3.3인자의 값으로 NULL을 절대 허용하지 마세요</h3><ul>\n<li><code>null</code>은 죄악이다. 프로그래머들이 접근할 수 없는 메모리 값을 <code>0</code>으로 표현하고 이를 가리켜 null로 부르는 동의에서 시작된 것이다.</li>\n<li><code>null</code>을 전달해야 하는 상황이라면, 차라리 빈 객체를 만들어 전달하자.</li>\n<li><code>null</code>에 대한 처리를 해야 하는 상황이라면, 반드시 쉴드패턴(<code>shield pattern</code>)과 같은 구현 방식으로 예외를 호출자에게 전달하도록 유도하는 것이 좋다. JVM에서 권고하는 예외 클래스를 사용하는 것이 그 예시<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Iterable&lt;File&gt; <span class=\"title\">find</span><span class=\"params\">(Mask mask)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mask == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Mask can&#x27;t be NULL&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"3-4-충성스러우면서-불변이거나-아니면-상수이거나\"><a href=\"#3-4-충성스러우면서-불변이거나-아니면-상수이거나\" class=\"headerlink\" title=\"3.4 충성스러우면서 불변이거나, 아니면 상수이거나\"></a>3.4 충성스러우면서 불변이거나, 아니면 상수이거나</h3><ul>\n<li>많은 사람들이 상태(<code>state</code>)와 데이터(<code>data</code>)를 오해하고 있음</li>\n<li>객체란 디스크에 있는 파일, 웹 페이지 혹은 메모리에 존재하는 바이트 배열, 해시맵 등과 같은 실제 엔티티의 대표자이다.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 아래 코드에서 File 객체는 실제 파일의 대표자 역할을 수행</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">echo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tFile f = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/tmp/test.txt&quot;</span>);</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;File size : %d&quot;</span>, f.length());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>일반적인 객체는 식별자(identity), 상태(state), 행동(behavior)를 포함. </li>\n</ul>\n<h3 id=\"3-5-절대-getter와-setter를-사용하지-마세요\"><a href=\"#3-5-절대-getter와-setter를-사용하지-마세요\" class=\"headerlink\" title=\"3.5 절대 getter와 setter를 사용하지 마세요\"></a>3.5 절대 getter와 setter를 사용하지 마세요</h3><ul>\n<li>클래스는 다르다. 어떤 식으로든 맴버에게 접근하는 것을 허용하지 않으며, 노출을 하지도 않는다. 할 수 있는 일은 오직 객체에게 <code>요청</code>하는 것 뿐이다.</li>\n<li>자료구조는 <code>glass box</code>, 객체는 <code>black box</code></li>\n<li><em><strong>프로그래밍에서 가시성의 범위를 줄이는 것은 사물을 단순화시키는 것이며 이해의 범위가 작을수록 유지보수성과 코드의 대한 이해/수정이 쉬워진다.</strong></em></li>\n<li><code>Getter/Setter</code>는 클래스를 자료구조로 사용하는 목적에서 도입이 되었다. 이는 곧, 발가벗겨진 데이터가 그대로 노출이 되며 절차적인 프로그래밍 스타일을 사용하도록 부추기게 된다.</li>\n<li><code>Getter/Setter</code>는 데이터가 무방비로 <code>public</code>하게 노출되어 있는 것과 마찬가지이다. 결국 이러한 형태의 객체는 하나의 데이터로서 역할만을 수행할 수 밖에 없다.</li>\n</ul>\n<h3 id=\"3-6-부-ctor-밖에서는-new를-사용하지-마세요\"><a href=\"#3-6-부-ctor-밖에서는-new를-사용하지-마세요\" class=\"headerlink\" title=\"3.6 부 ctor 밖에서는 new를 사용하지 마세요\"></a>3.6 부 ctor 밖에서는 new를 사용하지 마세요</h3><ul>\n<li>클래스가 작고 단순하며 네트워크나 디스크, 데이터베이스 등의 값비싼 자원을 사용하지 않는다면 전혀 문제가 되지 않을 것이다.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cash</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> dollars;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">euro</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Exchange().rate(<span class=\"string\">&quot;USD&quot;</span>, <span class=\"string\">&quot;EUR&quot;</span>) * <span class=\"keyword\">this</span>.dollars;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>euro()</code> 메소드를 사용할때마다 원격지와 통신을 하게 될 경우에 이 객체를 사용하는 사용자 입장에서는 매번 원격지와의 통신을 강요받을 수 밖에 없다. 이러한 결합을 피하기 위해서는 코드 자체를 수정할 수 밖에 없는데 이런식의 수정은 테스트와 유지보수성을 급격하게 낮출 수 밖에 없다. 다시 말해, 의존성에 대한 제어를 <code>Cash</code> 클래스 자신이 하고 있는 상황이다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cash</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> dollars;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Exchange exchange;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCash(<span class=\"keyword\">int</span> value, Exchange exchange) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.dollars = value;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.exchange = exchange;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">euro</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.rate(<span class=\"string\">&quot;USD&quot;</span>, <span class=\"string\">&quot;EUR&quot;</span>) * <span class=\"keyword\">this</span>.dollars;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>위와 같이 코드를 수정하게 될 경우, 생성자를 통하여 제공받은 <code>Exchange</code>와 협력을 할 수 있게 된다.</li>\n<li>의존성에 대한 제어 주체가 <code>Cash</code> 클래스가 아닌 외부 혹은 사용하는 쪽에서 제어할 수 있도록 수정이 되었다.</li>\n<li>객체가 필요한 의존성을 직접 생성하는 대신, 생성자를 통해 <strong>의존성을 주입</strong> 받으며 <code>Exchange</code> 타입의 의존성 즉 직접 작성한 코드 혹은 다른 객체를 주입하여 해당 객체가 호출이 되도록 <strong>제어의 역전</strong>을 수행하게 된다.</li>\n</ul>\n<h3 id=\"3-7-인트로스펙션과-캐스팅을-피하세요\"><a href=\"#3-7-인트로스펙션과-캐스팅을-피하세요\" class=\"headerlink\" title=\"3.7 인트로스펙션과 캐스팅을 피하세요\"></a>3.7 인트로스펙션과 캐스팅을 피하세요</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">(Iterable&lt;T&gt; items)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (items <span class=\"keyword\">instanceof</span> Collection) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Collection.class.cast(items).size()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (T item: items) &#123;</span><br><span class=\"line\">\t\t++size;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>런타임에 객체 타입을 조사하는 것은 클래스 사이의 결합도가 높아지기 때문에 기술적인 관점에서 좋지 않음</li>\n<li>위 예제에서는 <code>Iterable</code>과 <code>Collection</code> 인터페이스에 의존을 하고 있으며, 대상이 많아질수록 별도의 분기와 코드가 생겨나기 때문에 유지보수성이 좋아질 수가 없을 것이다.</li>\n<li>취급하는 타입에 따라 객체를 차별하기 때문에 자율성이라는 객체지향의 기본적인 베이스 정신을 훼손하는 코드라고 한다.</li>\n<li>타입 체킹 혹은 캐스팅을 하려거든 차라리 <code>메소드 오버로딩(method overloading)</code>을 활용하자.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">(Iterable&lt;T&gt; items)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (T item: items) &#123;</span><br><span class=\"line\">\t\t++size;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">(Collection&lt;T&gt; items)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> items.size();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"4장-은퇴\"><a href=\"#4장-은퇴\" class=\"headerlink\" title=\"4장 은퇴\"></a>4장 은퇴</h2></li>\n</ul>\n<hr>\n<h3 id=\"4-1-절대-NULL을-반환하지-마세요\"><a href=\"#4-1-절대-NULL을-반환하지-마세요\" class=\"headerlink\" title=\"4.1 절대 NULL을 반환하지 마세요\"></a>4.1 절대 NULL을 반환하지 마세요</h3><ul>\n<li>객체를 장애를 가진 존재로 취급해서는 안된다</li>\n<li>항상 <code>NullPointerException</code> 예외가 던져질지 모른다는 사실은 기술적인 불편함을 넘어서서 해당 객체에 대한 <code>신뢰</code>가 무너졌다는 사실이다. 결국, <em><strong>객체에게 작업을 요청한 후 안심하고 결과에 의지할 수 없다.</strong></em> 또한,  이는 곧 유지보수성의 심각한 손실로 이어진다.</li>\n<li><strong>객체라는 사상에는 우리가 신뢰하는 엔티티라는 개념이 담겨져 있다.</strong></li>\n<li>객체는 자신이 맡은 일을 수행하는 방법을 스스로 결정한다. <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">list</span><span class=\"params\">(File dir)</span> </span>&#123;</span><br><span class=\"line\">\tFile[] files = dir.listFiles();</span><br><span class=\"line\">\t<span class=\"comment\">// 매번 아래와 같은 체크를 해야 한다면, 장황한 코드의 추가와 더불어 매번 반환값을 확인해야 한다.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (files == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">&quot;Directory is absent&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (File file : files) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(file.getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>빠르게 실패하기 원칙(fail fast principle)</code>, <code>null</code>을 리턴하는 대신 예외를 던져 빠르게 실패하는 것.</li>\n<li><code>빠르게 실패하기 원칙</code> vs <code>안전하게 실패하기</code><ul>\n<li>안전하게 실패하기는 버그, 입출력 문제, 메모리 오버플로우 등이 발생한 상황에서도 소프트웨어가 계속 실행될 수 있도록 최대한 많은 노력을 기울이는 것</li>\n<li>빠르게 실패하기는 일반 문제가 발생하면 곧바로 실행을 중단하고 빠르게 예외를 던짐. 실패를 감추는 대신 강조.</li>\n</ul>\n</li>\n<li>어떤 버그는 명확하지만, 또 그렇지 않고 조용히 숨어 있는 경우가 있다.<blockquote>\n<p>버그가 존재하는 사실을 숨기는 것은 스스로에게 죄를 짓고 있는 것이며 상처를 드러내어 치료하는 대신, 상처를 숨기고 모든 일이 순조롭게 진행되고 있다고 환자에게 거짓말을 하는 행위이다. </p>\n</blockquote>\n</li>\n<li>NULL의 대안은?<ul>\n<li>메소드를 분리<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 아래의 경우, DB IO가 두번 발생하여 비효율적이다.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">exists</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"comment\">/*DB에 없다면*/</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">user</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"comment\">/* From DB */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>NULL을 반환하는 대신 기본값을 반환<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> Collection&lt;User&gt; <span class=\"title\">users</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"comment\">/*DB에 없다면*/</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> emptyList();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> Collections.singleton(<span class=\"comment\">/* From DB */</span>)</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>Optional</code>과 같은 클래스를 활용</li>\n<li><code>Null</code> Object를 만드는 방법<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NullUser</span> <span class=\"keyword\">implements</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String label;</span><br><span class=\"line\">NullUser(String name) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.label = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.label;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">raise</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;인상 못해유~&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-체크-예외-checked-exception-만-던지세요\"><a href=\"#4-2-체크-예외-checked-exception-만-던지세요\" class=\"headerlink\" title=\"4.2 체크 예외(checked exception)만 던지세요\"></a>4.2 체크 예외(checked exception)만 던지세요</h3></li>\n</ul>\n</li>\n<li>Checked Exception은 메소드를 호출하는 쪽에 예외를 처리하도록 강제할 수 있다.<br>Method에 명시적으로 예외의 타입이 노출이 되기 때문에 어떤 종류의 예외가 발생할지 예측할 수 있다. 다시 말해, 책임을 클라이언트에 전달하면서 제 자신이 안전하지 않다라고 선언하는 샘이다.</li>\n<li>UnChecked Exception의 경우, 별도로 예외를 처리하지 않으면 최상위로 전달~ 전달~</li>\n<li>꼭 필요한 경우가 아니라면 예외는 안잡는 것이 최선이다. 예외를 처리할때는 반드시 그 이유가 존재해야 한다. 만약 제어 흐름을 위해 예외를 사용하는 것이라면 이는 예외라는 것의 처리 목적과 전혀 부합하지 않게된다.</li>\n<li>예외는 반드시(항상) 체이닝하세요.<br>절대 원래 예외를 무시하지 말고 체이닝하여 낮은 수준의 근본 원인을 소프트웨어의 상위 레이어로 이동시킬 수 있게 된다. 또한, 문제에 대한 가치 있는 정보를 포함하기 때문에 빠르게 실수에 대응할 수 있게 된다.</li>\n<li>예외는 복구가 될 수 있다. 하지만, 무분별한 예외 복구보다는 분명한 이유가 있는 예외 복구와 진입로/출구로 가는 접점에 이를 배치하는 것이 좀 더 효율적이라고 할 수 있다.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"keyword\">new</span> App().run())</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span>(Exception ex) &#123;</span><br><span class=\"line\">\t\tSystem.err.println(<span class=\"string\">&quot;죄송하지만 문제가 발생했어요:&quot;</span> + ex.getLocalizedMessage() )</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>main에서 예외를 잡지 않게 되면 런타임 환경으로 예외가 전달되고 결국 JVM이 이를 처리하게 될 것이다. 이는 곧 사용자에게 노출을 시키지 말아야 할 메세지를 노출하게 될수도 있다. 위와 같은 장소가 예외를 복구하기 좋은 장소라고 할 수 있다.</li>\n</ul>\n<h3 id=\"4-3-final이거나-abstract이거나\"><a href=\"#4-3-final이거나-abstract이거나\" class=\"headerlink\" title=\"4.3 final이거나 abstract이거나\"></a>4.3 final이거나 abstract이거나</h3><h3 id=\"4-4-RAII를-사용하세요\"><a href=\"#4-4-RAII를-사용하세요\" class=\"headerlink\" title=\"4.4 RAII를 사용하세요\"></a>4.4 RAII를 사용하세요</h3><h2 id=\"후기\"><a href=\"#후기\" class=\"headerlink\" title=\"후기\"></a>후기</h2>"},{"title":"DDD Start - 1장","date":"2019-06-08T11:54:00.000Z","_content":"\n# DDD Start - 1장\n\n> DDD Start의 1장 내용을 정리\n\n## 도메인\n*소프트웨어로 해결하려고 하는 문제의 영역.*\n\n- 하나의 도메인은 다시 하위 도메인으로 나눌 수 있는데, 이렇게 나눠놓은 하위 도메인끼리 연동하여 완전한 기능을 제공하게 된다. \n- 이렇게 문제의 영역을 해결하는 과정에서 꼭 모든 기능을 소프트웨어로 구현해야 할 필요는 없다. 즉, 해당 도메인에서 필요한 기능을 외부 업체 또는 기능을 활용하여 연동 할 수도 있다.\n\n## 도메인 모델\n*문제 영역을 개념적으로 표현*\n\n- 도메인에 대한 모델을 여러 이해 당사자가 이해할 수 있는 개념적 모델링을 할 수 있다.\n  - 단순히 구현 수준에서의 모델이 아닌, 여러 이해 당사자가 이해할 수 있는 모델로서 작성하는 것이 의미가 있다.\n- 표현하는 방법은 해당 도메인에 따라, 달라질 수 있다\n  - UML, 그래프 등 가장 상황에 알맞는 표현을 사용하는 것이 좋다.\n- 구현 모델은 개념 모델과 달라질 수 있는데, 개념 모델을 최대한 따르도록 작성하는 것이 좋다.\n\n> *도메인은 여러 하위 도메인으로 구성 될 수 있는데, 하위 도메인이 다루는 영역별로 같은 혹시 비슷한 용어도 다르게 해석될 수 있다. 다시 말해, 여러 하위 도메인을 하나의 표현 모델로 모델링하면 혼선이 발생할 수 있기 때문에 좋지 않은 방법이라고 할 수 있다.*\n## 도메인 모델 패턴\n\n- 표현(Presentation)\n사용자의 요청을 처리, 여기서 사용자는 실 사용자 혹은 외부 시스템이 될 수도 있다.\n- 응용(Application)\n요청 받은 기능을 실행, 업무 로직을 직접 구현하지 않으며, 도메인 계층을 조합하여 기능을 실행\n- 도메인(Domain)\n도메인을 규칙을 실행\n- 인프라스트럭쳐(Infrastructure)\n저수준에서의 즉, 데이터베이스 혹은 메시징과 같은 시스템 종속적인 부분을 처리\n\n## 엔티티/벨류\n엔티티와 벨류를 제대로 구분해야 도메인을 올바르게 설계하고 구현할 수 있기 때문에 구분하여 사용하는 것은 매우 중요하다. \n\n### 엔티티\n```kotlin\nclass Order(\n\tval orderNumber: String, // 식별자\n\t...\n)\n```\n- 고유의 식별자를 가진다.\n  - 식별자를 위한 고유의 벨류 값을 만들어서 사용 할수도 있다.\n- 엔티티의 식별자를 생성하는 시점은 도메인의 특징 혹은 사용하는 기술에 따라 달라질 수 있다.\n  - 도메인의 유의미한 규칙을 사용\n    - 비슷한 도메인 상황이더라도, 사용하는 식별자 생성 규칙이 달라질 수 있다.\n  - UUID\n  - 값을 직접 입력\n    - 회원가입에서 사용하는 이메일 혹은 아이디일 경우\n  - 일련번호 사용\n    - 데이터베이스의 시퀀스(오라클 등) 혹은 자동증가 값을 사용하는 경우\n\n### 벨류\n```kotlin\nclass OrderLine(\n\tvar product: Product,\n\tvar price: Int,\n\tvar quantity: Int,\n\tvar amounts: Int\n)\n```\n- 값을 표현하는 클래스/객체로서 개념적으로 완전한 하나를 표현할 떄 사용\n- *일반적으로 하나 이상의 필드/멤버 값을 포함하는 경우가 많으나, 반드시 하나 이상을 포함해야 하는 것은 아니다. 의미를 좀 더 명확하게 사용하기 위해 사용하는 경우도 있다. 또한, 벨류 타입을 위한 기능을 추가할 수 도 있다.*\n- 벨류 객체의 데이터를 변경 할때는 기존 데이터를 변경하는 방식(세터를 이용하는 방식 등)보다는 새로운 벨류 객체를 생성하는 방식을 선호한다.(Immutable한 접근)\n  > 세터를 이용하는 방식을 사용할 경우, 참조 투명성과 관련된 문제가 생길 수 있다. 즉, 참조 값이 바뀌지 않은 상태에서 상태 값에 대한 변경이 의도하지 않은 상황에서 생길 수 있다.\n\n\n### 도메인 모델에 세터를 사용하지 않기\n- 세터를 사용하는 방식은 `도메인의 핵심 개념이나 의도를 명확하게 표현하기 힘들게 한다`\n- 도메인 객체를 생성하는 시점에 완벽한 상태가 아닐 수 있게 되므로, 잠정적인 에러 가능성을 가질 수 밖에 없다.\n- 이를 막기 위해서는, **객체를 생성하는 시점에 완벽한 상태 값을 주입해주는 것이다.** 즉, `생성자` 혹은 `팩토리 매소드` 등을 활용하여 필요한 객체 혹은 데이터를 모두 받아야 한다. \n```kotlin\nclass Order private constructor (\n\tval orderNumber: OrderNo,\n\tval totalAmount: Money,\n\tval shippingInfo: ShippingInfo\n\tval orderLine: List<OrderLine>,\n\tval orderState: OrderState = OrderState.PAYMENT_WAITING,\n\tval createdAt: LocalDateTime = LocalDateTime.now(),\n\tval updatedAt: LocalDateTime = LocalDateTime.now()\n) {\n\tcompanion object {\n\t\tfun create(\n\t\t\torderNumber: OrderNo,\n\t\t\ttotalAmount: Money,\n\t\t\tshippingInfo: ShippingInfo\n\t\t\torderLine: List<OrderLine>\n\t\t) = Order(\n\t\t\torderNumber = orderNumber,\n\t\t\ttotalAmount = totalAmount,\n\t\t\tshippingInfo = shippingInfo,\n\t\t\torderLine = orderLine,\n\t\t\torderState = OrderState.PAYMENT_WAITING,\n\t\t\tcreatedAt = LocalDateTime.now(),\n\t\t\tupdatedAt = LocalDateTime.now()\t\t\t\n\t\t)\n\t}\n}\n```\n> Kotlin의 기본값 할당(Default Value Assignment)을 활용하면 필수 값과 옵션 값을 나눠서 할당 받을 수 있어서 편리하다.\n\n## 도메인 용어\n- 도메인의 용어를 코드에서 충분하게 반영하지 않으면, 개발자들은 코드에 대한 의미 해석에 부담을 주게 된다.\n```kotlin\n// 이게 뭔말이야...\nemum class OrderState {\n\tSTEP1, STPE2, STEP3 ...\n}\n```\n- 실제 도메인에 맞는 유의미한 단어 선택을 통하여, 코드를 해석하는 과정을 줄이는 것이 중요하다. 이를 위해서는 적절한 단어 선택을 위한 이해 관계자들의 노력이 필요하다.\n```kotlin\nemum class OrderState(val statement: String) {\n\tPAYMENT_WAITING(\"입금대기\"),\n\tPREPARING(\"배송준비\"), \n\tSHIPPED(\"출고\"), \n\tDELIVERING(\"배송중\"), \n\tDELIVERY_COMPLETED(\"배송완료\")\n}\n``` \n","source":"_posts/DDD/DDD_START_1.md","raw":"---\ntitle: DDD Start - 1장\ndate: 2019.6.8. 20:54\ncategories:\n- DDD\n---\n\n# DDD Start - 1장\n\n> DDD Start의 1장 내용을 정리\n\n## 도메인\n*소프트웨어로 해결하려고 하는 문제의 영역.*\n\n- 하나의 도메인은 다시 하위 도메인으로 나눌 수 있는데, 이렇게 나눠놓은 하위 도메인끼리 연동하여 완전한 기능을 제공하게 된다. \n- 이렇게 문제의 영역을 해결하는 과정에서 꼭 모든 기능을 소프트웨어로 구현해야 할 필요는 없다. 즉, 해당 도메인에서 필요한 기능을 외부 업체 또는 기능을 활용하여 연동 할 수도 있다.\n\n## 도메인 모델\n*문제 영역을 개념적으로 표현*\n\n- 도메인에 대한 모델을 여러 이해 당사자가 이해할 수 있는 개념적 모델링을 할 수 있다.\n  - 단순히 구현 수준에서의 모델이 아닌, 여러 이해 당사자가 이해할 수 있는 모델로서 작성하는 것이 의미가 있다.\n- 표현하는 방법은 해당 도메인에 따라, 달라질 수 있다\n  - UML, 그래프 등 가장 상황에 알맞는 표현을 사용하는 것이 좋다.\n- 구현 모델은 개념 모델과 달라질 수 있는데, 개념 모델을 최대한 따르도록 작성하는 것이 좋다.\n\n> *도메인은 여러 하위 도메인으로 구성 될 수 있는데, 하위 도메인이 다루는 영역별로 같은 혹시 비슷한 용어도 다르게 해석될 수 있다. 다시 말해, 여러 하위 도메인을 하나의 표현 모델로 모델링하면 혼선이 발생할 수 있기 때문에 좋지 않은 방법이라고 할 수 있다.*\n## 도메인 모델 패턴\n\n- 표현(Presentation)\n사용자의 요청을 처리, 여기서 사용자는 실 사용자 혹은 외부 시스템이 될 수도 있다.\n- 응용(Application)\n요청 받은 기능을 실행, 업무 로직을 직접 구현하지 않으며, 도메인 계층을 조합하여 기능을 실행\n- 도메인(Domain)\n도메인을 규칙을 실행\n- 인프라스트럭쳐(Infrastructure)\n저수준에서의 즉, 데이터베이스 혹은 메시징과 같은 시스템 종속적인 부분을 처리\n\n## 엔티티/벨류\n엔티티와 벨류를 제대로 구분해야 도메인을 올바르게 설계하고 구현할 수 있기 때문에 구분하여 사용하는 것은 매우 중요하다. \n\n### 엔티티\n```kotlin\nclass Order(\n\tval orderNumber: String, // 식별자\n\t...\n)\n```\n- 고유의 식별자를 가진다.\n  - 식별자를 위한 고유의 벨류 값을 만들어서 사용 할수도 있다.\n- 엔티티의 식별자를 생성하는 시점은 도메인의 특징 혹은 사용하는 기술에 따라 달라질 수 있다.\n  - 도메인의 유의미한 규칙을 사용\n    - 비슷한 도메인 상황이더라도, 사용하는 식별자 생성 규칙이 달라질 수 있다.\n  - UUID\n  - 값을 직접 입력\n    - 회원가입에서 사용하는 이메일 혹은 아이디일 경우\n  - 일련번호 사용\n    - 데이터베이스의 시퀀스(오라클 등) 혹은 자동증가 값을 사용하는 경우\n\n### 벨류\n```kotlin\nclass OrderLine(\n\tvar product: Product,\n\tvar price: Int,\n\tvar quantity: Int,\n\tvar amounts: Int\n)\n```\n- 값을 표현하는 클래스/객체로서 개념적으로 완전한 하나를 표현할 떄 사용\n- *일반적으로 하나 이상의 필드/멤버 값을 포함하는 경우가 많으나, 반드시 하나 이상을 포함해야 하는 것은 아니다. 의미를 좀 더 명확하게 사용하기 위해 사용하는 경우도 있다. 또한, 벨류 타입을 위한 기능을 추가할 수 도 있다.*\n- 벨류 객체의 데이터를 변경 할때는 기존 데이터를 변경하는 방식(세터를 이용하는 방식 등)보다는 새로운 벨류 객체를 생성하는 방식을 선호한다.(Immutable한 접근)\n  > 세터를 이용하는 방식을 사용할 경우, 참조 투명성과 관련된 문제가 생길 수 있다. 즉, 참조 값이 바뀌지 않은 상태에서 상태 값에 대한 변경이 의도하지 않은 상황에서 생길 수 있다.\n\n\n### 도메인 모델에 세터를 사용하지 않기\n- 세터를 사용하는 방식은 `도메인의 핵심 개념이나 의도를 명확하게 표현하기 힘들게 한다`\n- 도메인 객체를 생성하는 시점에 완벽한 상태가 아닐 수 있게 되므로, 잠정적인 에러 가능성을 가질 수 밖에 없다.\n- 이를 막기 위해서는, **객체를 생성하는 시점에 완벽한 상태 값을 주입해주는 것이다.** 즉, `생성자` 혹은 `팩토리 매소드` 등을 활용하여 필요한 객체 혹은 데이터를 모두 받아야 한다. \n```kotlin\nclass Order private constructor (\n\tval orderNumber: OrderNo,\n\tval totalAmount: Money,\n\tval shippingInfo: ShippingInfo\n\tval orderLine: List<OrderLine>,\n\tval orderState: OrderState = OrderState.PAYMENT_WAITING,\n\tval createdAt: LocalDateTime = LocalDateTime.now(),\n\tval updatedAt: LocalDateTime = LocalDateTime.now()\n) {\n\tcompanion object {\n\t\tfun create(\n\t\t\torderNumber: OrderNo,\n\t\t\ttotalAmount: Money,\n\t\t\tshippingInfo: ShippingInfo\n\t\t\torderLine: List<OrderLine>\n\t\t) = Order(\n\t\t\torderNumber = orderNumber,\n\t\t\ttotalAmount = totalAmount,\n\t\t\tshippingInfo = shippingInfo,\n\t\t\torderLine = orderLine,\n\t\t\torderState = OrderState.PAYMENT_WAITING,\n\t\t\tcreatedAt = LocalDateTime.now(),\n\t\t\tupdatedAt = LocalDateTime.now()\t\t\t\n\t\t)\n\t}\n}\n```\n> Kotlin의 기본값 할당(Default Value Assignment)을 활용하면 필수 값과 옵션 값을 나눠서 할당 받을 수 있어서 편리하다.\n\n## 도메인 용어\n- 도메인의 용어를 코드에서 충분하게 반영하지 않으면, 개발자들은 코드에 대한 의미 해석에 부담을 주게 된다.\n```kotlin\n// 이게 뭔말이야...\nemum class OrderState {\n\tSTEP1, STPE2, STEP3 ...\n}\n```\n- 실제 도메인에 맞는 유의미한 단어 선택을 통하여, 코드를 해석하는 과정을 줄이는 것이 중요하다. 이를 위해서는 적절한 단어 선택을 위한 이해 관계자들의 노력이 필요하다.\n```kotlin\nemum class OrderState(val statement: String) {\n\tPAYMENT_WAITING(\"입금대기\"),\n\tPREPARING(\"배송준비\"), \n\tSHIPPED(\"출고\"), \n\tDELIVERING(\"배송중\"), \n\tDELIVERY_COMPLETED(\"배송완료\")\n}\n``` \n","slug":"DDD/DDD_START_1","published":1,"updated":"2021-08-02T12:13:02.402Z","_id":"ckrsup4zs0007tjhv84dp8912","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"DDD-Start-1장\"><a href=\"#DDD-Start-1장\" class=\"headerlink\" title=\"DDD Start - 1장\"></a>DDD Start - 1장</h1><blockquote>\n<p>DDD Start의 1장 내용을 정리</p>\n</blockquote>\n<h2 id=\"도메인\"><a href=\"#도메인\" class=\"headerlink\" title=\"도메인\"></a>도메인</h2><p><em>소프트웨어로 해결하려고 하는 문제의 영역.</em></p>\n<ul>\n<li>하나의 도메인은 다시 하위 도메인으로 나눌 수 있는데, 이렇게 나눠놓은 하위 도메인끼리 연동하여 완전한 기능을 제공하게 된다. </li>\n<li>이렇게 문제의 영역을 해결하는 과정에서 꼭 모든 기능을 소프트웨어로 구현해야 할 필요는 없다. 즉, 해당 도메인에서 필요한 기능을 외부 업체 또는 기능을 활용하여 연동 할 수도 있다.</li>\n</ul>\n<h2 id=\"도메인-모델\"><a href=\"#도메인-모델\" class=\"headerlink\" title=\"도메인 모델\"></a>도메인 모델</h2><p><em>문제 영역을 개념적으로 표현</em></p>\n<ul>\n<li>도메인에 대한 모델을 여러 이해 당사자가 이해할 수 있는 개념적 모델링을 할 수 있다.<ul>\n<li>단순히 구현 수준에서의 모델이 아닌, 여러 이해 당사자가 이해할 수 있는 모델로서 작성하는 것이 의미가 있다.</li>\n</ul>\n</li>\n<li>표현하는 방법은 해당 도메인에 따라, 달라질 수 있다<ul>\n<li>UML, 그래프 등 가장 상황에 알맞는 표현을 사용하는 것이 좋다.</li>\n</ul>\n</li>\n<li>구현 모델은 개념 모델과 달라질 수 있는데, 개념 모델을 최대한 따르도록 작성하는 것이 좋다.</li>\n</ul>\n<blockquote>\n<p><em>도메인은 여러 하위 도메인으로 구성 될 수 있는데, 하위 도메인이 다루는 영역별로 같은 혹시 비슷한 용어도 다르게 해석될 수 있다. 다시 말해, 여러 하위 도메인을 하나의 표현 모델로 모델링하면 혼선이 발생할 수 있기 때문에 좋지 않은 방법이라고 할 수 있다.</em></p>\n</blockquote>\n<h2 id=\"도메인-모델-패턴\"><a href=\"#도메인-모델-패턴\" class=\"headerlink\" title=\"도메인 모델 패턴\"></a>도메인 모델 패턴</h2><ul>\n<li>표현(Presentation)<br>사용자의 요청을 처리, 여기서 사용자는 실 사용자 혹은 외부 시스템이 될 수도 있다.</li>\n<li>응용(Application)<br>요청 받은 기능을 실행, 업무 로직을 직접 구현하지 않으며, 도메인 계층을 조합하여 기능을 실행</li>\n<li>도메인(Domain)<br>도메인을 규칙을 실행</li>\n<li>인프라스트럭쳐(Infrastructure)<br>저수준에서의 즉, 데이터베이스 혹은 메시징과 같은 시스템 종속적인 부분을 처리</li>\n</ul>\n<h2 id=\"엔티티-벨류\"><a href=\"#엔티티-벨류\" class=\"headerlink\" title=\"엔티티/벨류\"></a>엔티티/벨류</h2><p>엔티티와 벨류를 제대로 구분해야 도메인을 올바르게 설계하고 구현할 수 있기 때문에 구분하여 사용하는 것은 매우 중요하다. </p>\n<h3 id=\"엔티티\"><a href=\"#엔티티\" class=\"headerlink\" title=\"엔티티\"></a>엔티티</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span></span>(</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> orderNumber: String, <span class=\"comment\">// 식별자</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>고유의 식별자를 가진다.<ul>\n<li>식별자를 위한 고유의 벨류 값을 만들어서 사용 할수도 있다.</li>\n</ul>\n</li>\n<li>엔티티의 식별자를 생성하는 시점은 도메인의 특징 혹은 사용하는 기술에 따라 달라질 수 있다.<ul>\n<li>도메인의 유의미한 규칙을 사용<ul>\n<li>비슷한 도메인 상황이더라도, 사용하는 식별자 생성 규칙이 달라질 수 있다.</li>\n</ul>\n</li>\n<li>UUID</li>\n<li>값을 직접 입력<ul>\n<li>회원가입에서 사용하는 이메일 혹은 아이디일 경우</li>\n</ul>\n</li>\n<li>일련번호 사용<ul>\n<li>데이터베이스의 시퀀스(오라클 등) 혹은 자동증가 값을 사용하는 경우</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"벨류\"><a href=\"#벨류\" class=\"headerlink\" title=\"벨류\"></a>벨류</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderLine</span></span>(</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> product: Product,</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> price: <span class=\"built_in\">Int</span>,</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> quantity: <span class=\"built_in\">Int</span>,</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> amounts: <span class=\"built_in\">Int</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>값을 표현하는 클래스/객체로서 개념적으로 완전한 하나를 표현할 떄 사용</li>\n<li><em>일반적으로 하나 이상의 필드/멤버 값을 포함하는 경우가 많으나, 반드시 하나 이상을 포함해야 하는 것은 아니다. 의미를 좀 더 명확하게 사용하기 위해 사용하는 경우도 있다. 또한, 벨류 타입을 위한 기능을 추가할 수 도 있다.</em></li>\n<li>벨류 객체의 데이터를 변경 할때는 기존 데이터를 변경하는 방식(세터를 이용하는 방식 등)보다는 새로운 벨류 객체를 생성하는 방식을 선호한다.(Immutable한 접근)<blockquote>\n<p>세터를 이용하는 방식을 사용할 경우, 참조 투명성과 관련된 문제가 생길 수 있다. 즉, 참조 값이 바뀌지 않은 상태에서 상태 값에 대한 변경이 의도하지 않은 상황에서 생길 수 있다.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"도메인-모델에-세터를-사용하지-않기\"><a href=\"#도메인-모델에-세터를-사용하지-않기\" class=\"headerlink\" title=\"도메인 모델에 세터를 사용하지 않기\"></a>도메인 모델에 세터를 사용하지 않기</h3><ul>\n<li>세터를 사용하는 방식은 <code>도메인의 핵심 개념이나 의도를 명확하게 표현하기 힘들게 한다</code></li>\n<li>도메인 객체를 생성하는 시점에 완벽한 상태가 아닐 수 있게 되므로, 잠정적인 에러 가능성을 가질 수 밖에 없다.</li>\n<li>이를 막기 위해서는, <strong>객체를 생성하는 시점에 완벽한 상태 값을 주입해주는 것이다.</strong> 즉, <code>생성자</code> 혹은 <code>팩토리 매소드</code> 등을 활용하여 필요한 객체 혹은 데이터를 모두 받아야 한다. <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> <span class=\"keyword\">private</span> <span class=\"keyword\">constructor</span> </span>(</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> orderNumber: OrderNo,</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> totalAmount: Money,</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> shippingInfo: ShippingInfo</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> orderLine: List&lt;OrderLine&gt;,</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> orderState: OrderState = OrderState.PAYMENT_WAITING,</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> createdAt: LocalDateTime = LocalDateTime.now(),</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> updatedAt: LocalDateTime = LocalDateTime.now()</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">create</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\torderNumber: <span class=\"type\">OrderNo</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\ttotalAmount: <span class=\"type\">Money</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\tshippingInfo: <span class=\"type\">ShippingInfo</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t<span class=\"type\">orderLine</span>: <span class=\"type\">List</span>&lt;<span class=\"type\">OrderLine</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t)</span></span> = Order(</span><br><span class=\"line\">\t\t\torderNumber = orderNumber,</span><br><span class=\"line\">\t\t\ttotalAmount = totalAmount,</span><br><span class=\"line\">\t\t\tshippingInfo = shippingInfo,</span><br><span class=\"line\">\t\t\torderLine = orderLine,</span><br><span class=\"line\">\t\t\torderState = OrderState.PAYMENT_WAITING,</span><br><span class=\"line\">\t\t\tcreatedAt = LocalDateTime.now(),</span><br><span class=\"line\">\t\t\tupdatedAt = LocalDateTime.now()\t\t\t</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Kotlin의 기본값 할당(Default Value Assignment)을 활용하면 필수 값과 옵션 값을 나눠서 할당 받을 수 있어서 편리하다.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"도메인-용어\"><a href=\"#도메인-용어\" class=\"headerlink\" title=\"도메인 용어\"></a>도메인 용어</h2><ul>\n<li>도메인의 용어를 코드에서 충분하게 반영하지 않으면, 개발자들은 코드에 대한 의미 해석에 부담을 주게 된다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 이게 뭔말이야...</span></span><br><span class=\"line\">emum <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderState</span> </span>&#123;</span><br><span class=\"line\">\tSTEP1, STPE2, STEP3 ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>실제 도메인에 맞는 유의미한 단어 선택을 통하여, 코드를 해석하는 과정을 줄이는 것이 중요하다. 이를 위해서는 적절한 단어 선택을 위한 이해 관계자들의 노력이 필요하다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">emum <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderState</span></span>(<span class=\"keyword\">val</span> statement: String) &#123;</span><br><span class=\"line\">\tPAYMENT_WAITING(<span class=\"string\">&quot;입금대기&quot;</span>),</span><br><span class=\"line\">\tPREPARING(<span class=\"string\">&quot;배송준비&quot;</span>), </span><br><span class=\"line\">\tSHIPPED(<span class=\"string\">&quot;출고&quot;</span>), </span><br><span class=\"line\">\tDELIVERING(<span class=\"string\">&quot;배송중&quot;</span>), </span><br><span class=\"line\">\tDELIVERY_COMPLETED(<span class=\"string\">&quot;배송완료&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"DDD-Start-1장\"><a href=\"#DDD-Start-1장\" class=\"headerlink\" title=\"DDD Start - 1장\"></a>DDD Start - 1장</h1><blockquote>\n<p>DDD Start의 1장 내용을 정리</p>\n</blockquote>\n<h2 id=\"도메인\"><a href=\"#도메인\" class=\"headerlink\" title=\"도메인\"></a>도메인</h2><p><em>소프트웨어로 해결하려고 하는 문제의 영역.</em></p>\n<ul>\n<li>하나의 도메인은 다시 하위 도메인으로 나눌 수 있는데, 이렇게 나눠놓은 하위 도메인끼리 연동하여 완전한 기능을 제공하게 된다. </li>\n<li>이렇게 문제의 영역을 해결하는 과정에서 꼭 모든 기능을 소프트웨어로 구현해야 할 필요는 없다. 즉, 해당 도메인에서 필요한 기능을 외부 업체 또는 기능을 활용하여 연동 할 수도 있다.</li>\n</ul>\n<h2 id=\"도메인-모델\"><a href=\"#도메인-모델\" class=\"headerlink\" title=\"도메인 모델\"></a>도메인 모델</h2><p><em>문제 영역을 개념적으로 표현</em></p>\n<ul>\n<li>도메인에 대한 모델을 여러 이해 당사자가 이해할 수 있는 개념적 모델링을 할 수 있다.<ul>\n<li>단순히 구현 수준에서의 모델이 아닌, 여러 이해 당사자가 이해할 수 있는 모델로서 작성하는 것이 의미가 있다.</li>\n</ul>\n</li>\n<li>표현하는 방법은 해당 도메인에 따라, 달라질 수 있다<ul>\n<li>UML, 그래프 등 가장 상황에 알맞는 표현을 사용하는 것이 좋다.</li>\n</ul>\n</li>\n<li>구현 모델은 개념 모델과 달라질 수 있는데, 개념 모델을 최대한 따르도록 작성하는 것이 좋다.</li>\n</ul>\n<blockquote>\n<p><em>도메인은 여러 하위 도메인으로 구성 될 수 있는데, 하위 도메인이 다루는 영역별로 같은 혹시 비슷한 용어도 다르게 해석될 수 있다. 다시 말해, 여러 하위 도메인을 하나의 표현 모델로 모델링하면 혼선이 발생할 수 있기 때문에 좋지 않은 방법이라고 할 수 있다.</em></p>\n</blockquote>\n<h2 id=\"도메인-모델-패턴\"><a href=\"#도메인-모델-패턴\" class=\"headerlink\" title=\"도메인 모델 패턴\"></a>도메인 모델 패턴</h2><ul>\n<li>표현(Presentation)<br>사용자의 요청을 처리, 여기서 사용자는 실 사용자 혹은 외부 시스템이 될 수도 있다.</li>\n<li>응용(Application)<br>요청 받은 기능을 실행, 업무 로직을 직접 구현하지 않으며, 도메인 계층을 조합하여 기능을 실행</li>\n<li>도메인(Domain)<br>도메인을 규칙을 실행</li>\n<li>인프라스트럭쳐(Infrastructure)<br>저수준에서의 즉, 데이터베이스 혹은 메시징과 같은 시스템 종속적인 부분을 처리</li>\n</ul>\n<h2 id=\"엔티티-벨류\"><a href=\"#엔티티-벨류\" class=\"headerlink\" title=\"엔티티/벨류\"></a>엔티티/벨류</h2><p>엔티티와 벨류를 제대로 구분해야 도메인을 올바르게 설계하고 구현할 수 있기 때문에 구분하여 사용하는 것은 매우 중요하다. </p>\n<h3 id=\"엔티티\"><a href=\"#엔티티\" class=\"headerlink\" title=\"엔티티\"></a>엔티티</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span></span>(</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> orderNumber: String, <span class=\"comment\">// 식별자</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>고유의 식별자를 가진다.<ul>\n<li>식별자를 위한 고유의 벨류 값을 만들어서 사용 할수도 있다.</li>\n</ul>\n</li>\n<li>엔티티의 식별자를 생성하는 시점은 도메인의 특징 혹은 사용하는 기술에 따라 달라질 수 있다.<ul>\n<li>도메인의 유의미한 규칙을 사용<ul>\n<li>비슷한 도메인 상황이더라도, 사용하는 식별자 생성 규칙이 달라질 수 있다.</li>\n</ul>\n</li>\n<li>UUID</li>\n<li>값을 직접 입력<ul>\n<li>회원가입에서 사용하는 이메일 혹은 아이디일 경우</li>\n</ul>\n</li>\n<li>일련번호 사용<ul>\n<li>데이터베이스의 시퀀스(오라클 등) 혹은 자동증가 값을 사용하는 경우</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"벨류\"><a href=\"#벨류\" class=\"headerlink\" title=\"벨류\"></a>벨류</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderLine</span></span>(</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> product: Product,</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> price: <span class=\"built_in\">Int</span>,</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> quantity: <span class=\"built_in\">Int</span>,</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> amounts: <span class=\"built_in\">Int</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>값을 표현하는 클래스/객체로서 개념적으로 완전한 하나를 표현할 떄 사용</li>\n<li><em>일반적으로 하나 이상의 필드/멤버 값을 포함하는 경우가 많으나, 반드시 하나 이상을 포함해야 하는 것은 아니다. 의미를 좀 더 명확하게 사용하기 위해 사용하는 경우도 있다. 또한, 벨류 타입을 위한 기능을 추가할 수 도 있다.</em></li>\n<li>벨류 객체의 데이터를 변경 할때는 기존 데이터를 변경하는 방식(세터를 이용하는 방식 등)보다는 새로운 벨류 객체를 생성하는 방식을 선호한다.(Immutable한 접근)<blockquote>\n<p>세터를 이용하는 방식을 사용할 경우, 참조 투명성과 관련된 문제가 생길 수 있다. 즉, 참조 값이 바뀌지 않은 상태에서 상태 값에 대한 변경이 의도하지 않은 상황에서 생길 수 있다.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"도메인-모델에-세터를-사용하지-않기\"><a href=\"#도메인-모델에-세터를-사용하지-않기\" class=\"headerlink\" title=\"도메인 모델에 세터를 사용하지 않기\"></a>도메인 모델에 세터를 사용하지 않기</h3><ul>\n<li>세터를 사용하는 방식은 <code>도메인의 핵심 개념이나 의도를 명확하게 표현하기 힘들게 한다</code></li>\n<li>도메인 객체를 생성하는 시점에 완벽한 상태가 아닐 수 있게 되므로, 잠정적인 에러 가능성을 가질 수 밖에 없다.</li>\n<li>이를 막기 위해서는, <strong>객체를 생성하는 시점에 완벽한 상태 값을 주입해주는 것이다.</strong> 즉, <code>생성자</code> 혹은 <code>팩토리 매소드</code> 등을 활용하여 필요한 객체 혹은 데이터를 모두 받아야 한다. <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> <span class=\"keyword\">private</span> <span class=\"keyword\">constructor</span> </span>(</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> orderNumber: OrderNo,</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> totalAmount: Money,</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> shippingInfo: ShippingInfo</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> orderLine: List&lt;OrderLine&gt;,</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> orderState: OrderState = OrderState.PAYMENT_WAITING,</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> createdAt: LocalDateTime = LocalDateTime.now(),</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> updatedAt: LocalDateTime = LocalDateTime.now()</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">create</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\torderNumber: <span class=\"type\">OrderNo</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\ttotalAmount: <span class=\"type\">Money</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\tshippingInfo: <span class=\"type\">ShippingInfo</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t<span class=\"type\">orderLine</span>: <span class=\"type\">List</span>&lt;<span class=\"type\">OrderLine</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t)</span></span> = Order(</span><br><span class=\"line\">\t\t\torderNumber = orderNumber,</span><br><span class=\"line\">\t\t\ttotalAmount = totalAmount,</span><br><span class=\"line\">\t\t\tshippingInfo = shippingInfo,</span><br><span class=\"line\">\t\t\torderLine = orderLine,</span><br><span class=\"line\">\t\t\torderState = OrderState.PAYMENT_WAITING,</span><br><span class=\"line\">\t\t\tcreatedAt = LocalDateTime.now(),</span><br><span class=\"line\">\t\t\tupdatedAt = LocalDateTime.now()\t\t\t</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Kotlin의 기본값 할당(Default Value Assignment)을 활용하면 필수 값과 옵션 값을 나눠서 할당 받을 수 있어서 편리하다.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"도메인-용어\"><a href=\"#도메인-용어\" class=\"headerlink\" title=\"도메인 용어\"></a>도메인 용어</h2><ul>\n<li>도메인의 용어를 코드에서 충분하게 반영하지 않으면, 개발자들은 코드에 대한 의미 해석에 부담을 주게 된다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 이게 뭔말이야...</span></span><br><span class=\"line\">emum <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderState</span> </span>&#123;</span><br><span class=\"line\">\tSTEP1, STPE2, STEP3 ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>실제 도메인에 맞는 유의미한 단어 선택을 통하여, 코드를 해석하는 과정을 줄이는 것이 중요하다. 이를 위해서는 적절한 단어 선택을 위한 이해 관계자들의 노력이 필요하다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">emum <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderState</span></span>(<span class=\"keyword\">val</span> statement: String) &#123;</span><br><span class=\"line\">\tPAYMENT_WAITING(<span class=\"string\">&quot;입금대기&quot;</span>),</span><br><span class=\"line\">\tPREPARING(<span class=\"string\">&quot;배송준비&quot;</span>), </span><br><span class=\"line\">\tSHIPPED(<span class=\"string\">&quot;출고&quot;</span>), </span><br><span class=\"line\">\tDELIVERING(<span class=\"string\">&quot;배송중&quot;</span>), </span><br><span class=\"line\">\tDELIVERY_COMPLETED(<span class=\"string\">&quot;배송완료&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"한권으로읽는컴퓨터구조와프로그래밍","date":"2021-06-19T15:00:00.000Z","_content":"\n# 한권으로읽는컴퓨터구조와프로그래밍\n## UTF-8, P.81 ~ 83\n- [유니코드](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C_0000~0FFF)를 2진수로 인코딩하는 방식. **쉽게 말해, 글자를 2진수로 매핑해둔 코드들 전체를 가리켜 유니코드라고 부르는 것이다.**\n- UTF-8은 가변바이트 사용한다. 예를 들어, 1바이트로 표현이 충분한 A같은 경우는 0x41로 표현하며 한글의 경우 3바이트로 표현한다. 아스키코드 호환의 1바이트(8비트)부터 4바이트(32비트) 영역까지 [유니코드](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C_0000~0FFF)가 존재하며, 코드는 U+로 시작하며 이는 유니코드를 뜻하는 프리픽스이며 이후에 16진수로 표현된다.\n- 유니코드의 U+C546과 같은 코드 Index를 가리켜 `CodePoint` 혹은 `CodeUnit`라 부르기도 한다.\n- 한글로 예를 들면, 유니코드에서 U+C000 코드부터 시작하며 아래는 변환하는 예제이다.\n  |한글|유니코드|2진수|\n  |------|------|---|\n  |안|U+C548|(1110)1100 (10)010101 (10)001000|\n  |오|U+C624|(1110)1100 (10)011000 (10)100100|\n  |네|U+B124|(1110)1011 (10)000100 (10)100100|\n- 바이트별로 비트 배열이 조금씩 달라지는데, 이건 다른 복잡한 이유가 있는 것이 아니라 `규칙`이다.\n  - 1바이트의 경우 MSB(Most Significant Bit)를 0으로 고정 => 7bit에 해당하는 부분이 `유효비트`\n  - 2바이트의 경우 첫 번째 MSB를 110, 2번째 MSB를 10으로 고정 => 11bit에 해당하는 부분이 코`유효비트`\n  - 3바이트의 경우 첫 번째 MSB를 1110, 나머지 MSB는 10으로 고정 => bit에 해당하는 부분이 `유효비트`\n  - 4바이트의 경우 첫 번째 MSB를 11110, 나머지 MSB는 10으로 고정 => bit에 해당하는 부분이 `유효비트`\n\n## 객체지향의 함정, P.311\n> 객체에는 함수에 해당하는 메서드와 데이터에 해당하는 프로퍼티가 들어 있다. 정수값 등 크기가 작은 데이터를 저장하는 프로퍼티는 객체 구조체 안에 들어가고 메모리 할당이 더 필요한 프로퍼티는 객체 구조체 안에 포인터를 통하여 참조된다. 메서드가 아주 많거나 하면 이 구조체가 아주 커질수 있는데, 이를 별도의 데이터 구조에 나눠 담으면 이런 문제는 해결할 수 있다. 시간/공간/트레이드 오프의 예라고 할 수 있다. \n\n> 객체는 전역적으로 알려진 함수 대신에 자신이 사용할 메서드에 대한 포인터를 가지고 다녀야 한다. 따라서 객체 내의 데이터가 데이터만 저장하는 데이터 구조처럼 꽉 짜여 있지 않다. 성능적으로 결정적으로 중요할 때는 전통적인 배열을 활용하라.","source":"_posts/CS/한권으로읽는컴퓨터구조와프로그래밍.md","raw":"---\ntitle: 한권으로읽는컴퓨터구조와프로그래밍\ndate: 2021/6/20 00:00:00\ncategories:\n- CS\n---\n\n# 한권으로읽는컴퓨터구조와프로그래밍\n## UTF-8, P.81 ~ 83\n- [유니코드](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C_0000~0FFF)를 2진수로 인코딩하는 방식. **쉽게 말해, 글자를 2진수로 매핑해둔 코드들 전체를 가리켜 유니코드라고 부르는 것이다.**\n- UTF-8은 가변바이트 사용한다. 예를 들어, 1바이트로 표현이 충분한 A같은 경우는 0x41로 표현하며 한글의 경우 3바이트로 표현한다. 아스키코드 호환의 1바이트(8비트)부터 4바이트(32비트) 영역까지 [유니코드](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C_0000~0FFF)가 존재하며, 코드는 U+로 시작하며 이는 유니코드를 뜻하는 프리픽스이며 이후에 16진수로 표현된다.\n- 유니코드의 U+C546과 같은 코드 Index를 가리켜 `CodePoint` 혹은 `CodeUnit`라 부르기도 한다.\n- 한글로 예를 들면, 유니코드에서 U+C000 코드부터 시작하며 아래는 변환하는 예제이다.\n  |한글|유니코드|2진수|\n  |------|------|---|\n  |안|U+C548|(1110)1100 (10)010101 (10)001000|\n  |오|U+C624|(1110)1100 (10)011000 (10)100100|\n  |네|U+B124|(1110)1011 (10)000100 (10)100100|\n- 바이트별로 비트 배열이 조금씩 달라지는데, 이건 다른 복잡한 이유가 있는 것이 아니라 `규칙`이다.\n  - 1바이트의 경우 MSB(Most Significant Bit)를 0으로 고정 => 7bit에 해당하는 부분이 `유효비트`\n  - 2바이트의 경우 첫 번째 MSB를 110, 2번째 MSB를 10으로 고정 => 11bit에 해당하는 부분이 코`유효비트`\n  - 3바이트의 경우 첫 번째 MSB를 1110, 나머지 MSB는 10으로 고정 => bit에 해당하는 부분이 `유효비트`\n  - 4바이트의 경우 첫 번째 MSB를 11110, 나머지 MSB는 10으로 고정 => bit에 해당하는 부분이 `유효비트`\n\n## 객체지향의 함정, P.311\n> 객체에는 함수에 해당하는 메서드와 데이터에 해당하는 프로퍼티가 들어 있다. 정수값 등 크기가 작은 데이터를 저장하는 프로퍼티는 객체 구조체 안에 들어가고 메모리 할당이 더 필요한 프로퍼티는 객체 구조체 안에 포인터를 통하여 참조된다. 메서드가 아주 많거나 하면 이 구조체가 아주 커질수 있는데, 이를 별도의 데이터 구조에 나눠 담으면 이런 문제는 해결할 수 있다. 시간/공간/트레이드 오프의 예라고 할 수 있다. \n\n> 객체는 전역적으로 알려진 함수 대신에 자신이 사용할 메서드에 대한 포인터를 가지고 다녀야 한다. 따라서 객체 내의 데이터가 데이터만 저장하는 데이터 구조처럼 꽉 짜여 있지 않다. 성능적으로 결정적으로 중요할 때는 전통적인 배열을 활용하라.","slug":"CS/한권으로읽는컴퓨터구조와프로그래밍","published":1,"updated":"2021-08-02T12:20:43.968Z","_id":"ckrsup4zt0008tjhv72dd4oh9","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"한권으로읽는컴퓨터구조와프로그래밍\"><a href=\"#한권으로읽는컴퓨터구조와프로그래밍\" class=\"headerlink\" title=\"한권으로읽는컴퓨터구조와프로그래밍\"></a>한권으로읽는컴퓨터구조와프로그래밍</h1><h2 id=\"UTF-8-P-81-83\"><a href=\"#UTF-8-P-81-83\" class=\"headerlink\" title=\"UTF-8, P.81 ~ 83\"></a>UTF-8, P.81 ~ 83</h2><ul>\n<li><a href=\"https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C_0000~0FFF\">유니코드</a>를 2진수로 인코딩하는 방식. <strong>쉽게 말해, 글자를 2진수로 매핑해둔 코드들 전체를 가리켜 유니코드라고 부르는 것이다.</strong></li>\n<li>UTF-8은 가변바이트 사용한다. 예를 들어, 1바이트로 표현이 충분한 A같은 경우는 0x41로 표현하며 한글의 경우 3바이트로 표현한다. 아스키코드 호환의 1바이트(8비트)부터 4바이트(32비트) 영역까지 <a href=\"https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C_0000~0FFF\">유니코드</a>가 존재하며, 코드는 U+로 시작하며 이는 유니코드를 뜻하는 프리픽스이며 이후에 16진수로 표현된다.</li>\n<li>유니코드의 U+C546과 같은 코드 Index를 가리켜 <code>CodePoint</code> 혹은 <code>CodeUnit</code>라 부르기도 한다.</li>\n<li>한글로 예를 들면, 유니코드에서 U+C000 코드부터 시작하며 아래는 변환하는 예제이다.<table>\n<thead>\n<tr>\n<th>한글</th>\n<th>유니코드</th>\n<th>2진수</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>안</td>\n<td>U+C548</td>\n<td>(1110)1100 (10)010101 (10)001000</td>\n</tr>\n<tr>\n<td>오</td>\n<td>U+C624</td>\n<td>(1110)1100 (10)011000 (10)100100</td>\n</tr>\n<tr>\n<td>네</td>\n<td>U+B124</td>\n<td>(1110)1011 (10)000100 (10)100100</td>\n</tr>\n</tbody></table>\n</li>\n<li>바이트별로 비트 배열이 조금씩 달라지는데, 이건 다른 복잡한 이유가 있는 것이 아니라 <code>규칙</code>이다.<ul>\n<li>1바이트의 경우 MSB(Most Significant Bit)를 0으로 고정 =&gt; 7bit에 해당하는 부분이 <code>유효비트</code></li>\n<li>2바이트의 경우 첫 번째 MSB를 110, 2번째 MSB를 10으로 고정 =&gt; 11bit에 해당하는 부분이 코<code>유효비트</code></li>\n<li>3바이트의 경우 첫 번째 MSB를 1110, 나머지 MSB는 10으로 고정 =&gt; bit에 해당하는 부분이 <code>유효비트</code></li>\n<li>4바이트의 경우 첫 번째 MSB를 11110, 나머지 MSB는 10으로 고정 =&gt; bit에 해당하는 부분이 <code>유효비트</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"객체지향의-함정-P-311\"><a href=\"#객체지향의-함정-P-311\" class=\"headerlink\" title=\"객체지향의 함정, P.311\"></a>객체지향의 함정, P.311</h2><blockquote>\n<p>객체에는 함수에 해당하는 메서드와 데이터에 해당하는 프로퍼티가 들어 있다. 정수값 등 크기가 작은 데이터를 저장하는 프로퍼티는 객체 구조체 안에 들어가고 메모리 할당이 더 필요한 프로퍼티는 객체 구조체 안에 포인터를 통하여 참조된다. 메서드가 아주 많거나 하면 이 구조체가 아주 커질수 있는데, 이를 별도의 데이터 구조에 나눠 담으면 이런 문제는 해결할 수 있다. 시간/공간/트레이드 오프의 예라고 할 수 있다. </p>\n</blockquote>\n<blockquote>\n<p>객체는 전역적으로 알려진 함수 대신에 자신이 사용할 메서드에 대한 포인터를 가지고 다녀야 한다. 따라서 객체 내의 데이터가 데이터만 저장하는 데이터 구조처럼 꽉 짜여 있지 않다. 성능적으로 결정적으로 중요할 때는 전통적인 배열을 활용하라.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"한권으로읽는컴퓨터구조와프로그래밍\"><a href=\"#한권으로읽는컴퓨터구조와프로그래밍\" class=\"headerlink\" title=\"한권으로읽는컴퓨터구조와프로그래밍\"></a>한권으로읽는컴퓨터구조와프로그래밍</h1><h2 id=\"UTF-8-P-81-83\"><a href=\"#UTF-8-P-81-83\" class=\"headerlink\" title=\"UTF-8, P.81 ~ 83\"></a>UTF-8, P.81 ~ 83</h2><ul>\n<li><a href=\"https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C_0000~0FFF\">유니코드</a>를 2진수로 인코딩하는 방식. <strong>쉽게 말해, 글자를 2진수로 매핑해둔 코드들 전체를 가리켜 유니코드라고 부르는 것이다.</strong></li>\n<li>UTF-8은 가변바이트 사용한다. 예를 들어, 1바이트로 표현이 충분한 A같은 경우는 0x41로 표현하며 한글의 경우 3바이트로 표현한다. 아스키코드 호환의 1바이트(8비트)부터 4바이트(32비트) 영역까지 <a href=\"https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C_0000~0FFF\">유니코드</a>가 존재하며, 코드는 U+로 시작하며 이는 유니코드를 뜻하는 프리픽스이며 이후에 16진수로 표현된다.</li>\n<li>유니코드의 U+C546과 같은 코드 Index를 가리켜 <code>CodePoint</code> 혹은 <code>CodeUnit</code>라 부르기도 한다.</li>\n<li>한글로 예를 들면, 유니코드에서 U+C000 코드부터 시작하며 아래는 변환하는 예제이다.<table>\n<thead>\n<tr>\n<th>한글</th>\n<th>유니코드</th>\n<th>2진수</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>안</td>\n<td>U+C548</td>\n<td>(1110)1100 (10)010101 (10)001000</td>\n</tr>\n<tr>\n<td>오</td>\n<td>U+C624</td>\n<td>(1110)1100 (10)011000 (10)100100</td>\n</tr>\n<tr>\n<td>네</td>\n<td>U+B124</td>\n<td>(1110)1011 (10)000100 (10)100100</td>\n</tr>\n</tbody></table>\n</li>\n<li>바이트별로 비트 배열이 조금씩 달라지는데, 이건 다른 복잡한 이유가 있는 것이 아니라 <code>규칙</code>이다.<ul>\n<li>1바이트의 경우 MSB(Most Significant Bit)를 0으로 고정 =&gt; 7bit에 해당하는 부분이 <code>유효비트</code></li>\n<li>2바이트의 경우 첫 번째 MSB를 110, 2번째 MSB를 10으로 고정 =&gt; 11bit에 해당하는 부분이 코<code>유효비트</code></li>\n<li>3바이트의 경우 첫 번째 MSB를 1110, 나머지 MSB는 10으로 고정 =&gt; bit에 해당하는 부분이 <code>유효비트</code></li>\n<li>4바이트의 경우 첫 번째 MSB를 11110, 나머지 MSB는 10으로 고정 =&gt; bit에 해당하는 부분이 <code>유효비트</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"객체지향의-함정-P-311\"><a href=\"#객체지향의-함정-P-311\" class=\"headerlink\" title=\"객체지향의 함정, P.311\"></a>객체지향의 함정, P.311</h2><blockquote>\n<p>객체에는 함수에 해당하는 메서드와 데이터에 해당하는 프로퍼티가 들어 있다. 정수값 등 크기가 작은 데이터를 저장하는 프로퍼티는 객체 구조체 안에 들어가고 메모리 할당이 더 필요한 프로퍼티는 객체 구조체 안에 포인터를 통하여 참조된다. 메서드가 아주 많거나 하면 이 구조체가 아주 커질수 있는데, 이를 별도의 데이터 구조에 나눠 담으면 이런 문제는 해결할 수 있다. 시간/공간/트레이드 오프의 예라고 할 수 있다. </p>\n</blockquote>\n<blockquote>\n<p>객체는 전역적으로 알려진 함수 대신에 자신이 사용할 메서드에 대한 포인터를 가지고 다녀야 한다. 따라서 객체 내의 데이터가 데이터만 저장하는 데이터 구조처럼 꽉 짜여 있지 않다. 성능적으로 결정적으로 중요할 때는 전통적인 배열을 활용하라.</p>\n</blockquote>\n"},{"title":"DDD Start - 2장","date":"2019-06-08T11:55:00.000Z","_content":"\n# DDD Start - 2장\n\n> DDD Start의 2장 내용을 정리\n\n## 아키텍처 / 네 개의 영역? / 계층 구조 아키텍처\n```puml\n@startuml\nactor Client as A\nparticipant Presentation as B\nparticipant Application as C\nparticipant Domain as D\nparticipant Infrastructure as I\nA -> B : HTTP 요청\nB -> B : [표현]\\n - 유효성 검사\\n - 응용 영역에 필요한 객체 변환/생성\n\nB -> C : Application Layer 호출\nC -> C : [응용]\\n - 적절한 도메인 서비스 호출 \\n - 트랜잭션 시작\nC -> D : - 도메인에 필요한 도메인 엔티티 조회 \\n- 매소드/로직 호출\nD -> D : [도메인]\\n - 도메인에 필요한 객체를 표현\\n - 도메인에 관련된 구현을 담당\nD -> I : 구현기술을 다루는 부분은 \\n인프라스트럭쳐 레이어를 참조한다.\nI -> I : 구현 기술을 다루는 부분을 책임지며\\nRDB, NoSQL 등 실제 구현을 다루게 됨\n@enduml\n```\n\n아키텍처를 구성하는 요소는 크게 4가지로 나뉠 수 있다. `표현`, `응용`, `도메인` 및 `인프라스트럭처`로 나뉠 수 있으며, 각 계층별로 가져야 할 책임은 위 다이어그램을 통하여 확인이 가능하다.\n\n- **표현 레이어**의 경우, 사용자 혹은 외부 클라이언트의 요청을 받는 첫 관문이며, 해당 레이어에서는 요청에 대한 유효성 검사 및 응용 레이어 호출을 위한 객체 생성 및 변환 작업이 주로 이뤄진다.\n\n- **응용 레이어**는 도메인 서비스를 호출하며 대부분의 경우 응용 서비스에 대한 트랜잭션이 시작되는 지점이다. 도메인에 필요한 구현을 직접 수행하진 않으며, 도메인 영역의 객체에 이를 위임하게 된다\n\n- **도메인 레이어**는 도메인에 필요한 데이터를 표현하고 도메인과 관련된 구현을 담당하게 된다.\n- **인프라스트럭쳐 레이어**는 실제 구현을 담당하게 되는데, 구현 기술과 아주 밀접한 연관이 있는 레이어이다. 응용 레이어 및 도메인 레이어는 구현기술과 관련된 부분은 인프라스트럭처 레이어에 의존하게 된다.\n\n> 각 계층은 표현 -> 응용 -> 도메인 -> 인프라스트럭쳐 순으로 의존하게 하게 되지만, 구현의 편리함을 위하여 응용 -> 인프라스트럭쳐 혹은 도메인 -> 인프라스트럭쳐를 참조하는 방식으로 의존할 수도 있다.\n\n\n응용, 도메인 계층이 직접적으로 인프라스트럭처 레이어에 의존적이게 되면 실제 구현 부분에 대한 변경이 어려워지며, 테스트하기 어려워지는 문제점이 발생하게 된다. **DIP를 이용하면 저수준의 구현 모듈이 고수준의 모듈에 의존하도록 변경하여 위에서 발생하는 문제를 해결할 수 있는 실마리를 제공해준다.**\n\n## DIP\n\n> 객체지향 원칙 SOLID에서의 DIP\n> 추상을 매개(인터페이스)로 메시지를 주고 받음(메서드 호출)으로써 관계를 최대한 느슨(인터페이스를 사용함에 따라 구현에 대한 변경이 용이)하게 만드는 원칙\n> - [나무위키, 객체 지향 프로그래밍 원칙 중 DIP](https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99#s-2.5)\n> - [Nextree, DIP](http://www.nextree.co.kr/p6960/)\n\nDIP를 적용하게 되면 아래와 같이 구현 기술과 관련된 종속성을 쉽게 제거할 수 있는데, 저수준의 모듈이 고수준의 모듈을 참조하도록 구성하는 방법. 즉 인터페이스를 참조하게 되면 실제 인터페이스의 구현 부분에서 사용하는 구현 기술이 어떤 종류의 것인지와 상관없이 도메인에서 필요한 기능 자체에만 집중한 표현이 가능하다.\n\n```mermaid\ngraph LR\nCalculateDiscountService --> RuleDiscounter\nRuleDiscounter --> RDB/JPA\nRuleDiscounter --> SearchEngine\n```\n\n- 위 이미지에서 볼 수 있듯이 실제 구현이 RDB로 되어 있던지, 검색엔진을 통하여 되어 있던지 이는 중요하지 않고 실제 구현하고자 하는 `가격할인`이라는 목적에만 집중 할 수 있다. \n- 인터페이스를 사용함에 따라 실제 테스트 코드 작성 시, 쉽게 목(Mock) 구현을 할 수 있으며 또한 구현 변경에 따른 부담이 줄게 될 것이다.\n\n> 위 설명에서 말하는 저수준과 고수준을 나누는 기준은 구현 기술에 좀 더 특화되어 있는 모듈이라면 저수준으로 판단하며, 응용 혹은 도메인 영역에서 사용하는 모듈은 고수준으로 분류한다. \n> 실제 도메인에서 표현하는 추상화 된 응용 혹은 도메인 계층을 고수준의 모듈이라고 보는 것이 타당하다고 생각한다. 다시 말해, 실제 도메인이 해결해야 할 문제에 대한 추상화가 이뤄지는 구간정도로 요약하면 좋을꺼 같다.\n\n> *DDD Start 59P 중 일부*\n> *인프라스트럭처에 위치한 클래스가 도메인이나 응용 영역에 정의한 `인터페이스`를 상속받아 구현하는 구조가 되므로 도메인과 응용 영역에 대한 영향을 주지 않거나 최소화하면서 구현 기술을 변경하는 것이 가능하다.*\n\n## 도메인 영역의 구성요소는?\n| 요소  | 설명 |\n|---|---|\n| **엔티티**  | 식별자를 가지는 객체. 라이프 사이클을 가진다.  |\n| **벨류**  | 완전한 하나의 값을 표현. 도메인의 속성을 표현하는 목적으로 주로 사용한다.  |\n| **애그리거트**  | 연관 객체의 집합을 가리킨다. 다시 말해, 관련된 엔티티와 벨류 객체를 개념적으로 하나로 묶어 놓은 것이다.  |\n| **레파지토리**  | 도메인 모델의 영속성을 처리한다.  |\n| **도메인 서비스**  | 특정 엔티티에 종속적이지 않은 도메인의 로직을 제공  |\n\n위에서 설명한 내용을 간단하게 패키지 구조로 표현하면 아래와 같이 표현할 수 있다.\n```\n|-- order\n    |-- domain\n        |-- Order(Aggregate, Root-Entity)\n        |-- OrderLine(Entity)\n        |-- Orderer(Entity)\n        |-- OrderRepository(Repository)\n        |-- Address(Value)\n```\n\n> `DB 테이블의 엔티티` vs `도메인 모델의 엔티티`\n> 가장 큰 차이점은 바로 도메인 모델 엔티티는 데이터와 도메인의 기능을 함께 표현하는 것이다. 테이블의 엔티티는 말 그대로 테이블의 데이터만을 표현하게 되는데, 비슷하면서 미묘하게 다른 지점이 생기는데, 여기서 반드시 중심을 잡고 알아야 할 사실은 바로 **도메인 모델은 데이터와 도메인의 기능을 함께 표현한다는 점이다.**\n\n\n도메인 모델의 엔티티를 집중하여 살펴보면 위에서 말한대로 도메인의 데이터 담고 있으며 또한 도메인의 관점에서 기능을 구현해놓은 객체이다. 데이터에 대한 변경을 철저하게 도메인 관점에서 구현해야 하며 임의로 해당 엔티티의 상태 값이 변경되도록 하면 안된다. 이를 달성하기 위해서는 아래와 같은 점을 명심하면 좋을거 같다.\n- ***세터(setter)의 지양***, 무분별한 상태 변경은 `지양`해야 하며, 객체의 세터를 만들더라도 `private` 접근자를 할당하며 외부에서 접근이 안되도록 해야 한다.\n\n- **도메인 엔티티 생성 시, `정적 팩토리 매서드` 혹은 `팩토리 클래스`를 사용**, 도메인 객체의 생성은 반드시 완전한 상태로 이뤄져야 한다. 객체의 생성 규칙 일정하다면 `정적 팩토리 메서드`를 활용하는 방법이 좋고, 만약 객체를 생성하는 규칙이 다양하면 별도의 `팩토리 클래스`를 구현하는 방법도 좋다.\n\n\n- **의미 혹은 개념적으로 하나로 표현할 수 있는 상황이라면 `벨류(Value)` 객체를 적극적으로 활용하는게 좋다.** 이에 대한 구현은 불변(Immutable)한 접근을 통하여 객체 자체를 완전히 교체하는 전략을 취하자\n\n### 애그리거트(Aggregate)\n- 비슷한 도메인 모델을 상위 수준에서 접근. 다시 말해, ***연관/관련 객체를 하나로 묶은 군집.***\n- 예를 들어, 주문이라는 도메인 모델은 배송지, 주문자, 주문 목록 등의 하위 모델로 구성되는데 이 모든 모델을 하나의 군집 형태로 표현하여 `주문`이라는 상위 개념으로 표현할 수 있게 된다.\n- 애그리거트는 연관된 객체/도메인 모델을 관리하는 루트 엔티티를 가지게 되는데, 루트 엔티티는 연관 객체와 벨류 등을 사용하여 도메인에서 표현해야 할 혹은 구현해야 할 기능을 제공하게 된다.\n- 하위 객체 혹은 벨류에 대한 접근은 루트 엔티티를 통하여 간접적으로 이뤄져야 하며, 실제 구현을 내부로 숨길 수 있게 됨에 따라 애그리거트 단위로 캡슐화할 수 있도록 돕는다.\n\n### 레파지토리(Repository)\n- **구현을 위한 도메인 모델**로 도메인 객체를 영속성 있게 즉, 지속적으로 사용하려면 별도의 보관이 필요하게 된다. 이런 보관을 위하여 존재하는 것이 바로 레파지토리이다.\n- 저장은 주로 RDB, NoSQL 등의 구현 기술을 사용하게 된다.\n- 주로, ***에그리거트 단위로 객체를 저장하고 조회하는 기능을 구현하게 된다.***\n- 레파지토리 인터페이스는 주로 도메인 영역에 속하게 되며, 해당 인터페이스의 구현체는 실제 구현 기술을 사용하게 됨에 따라 인프라스트럭처 영역에 속하게 된다.\n- *응용영역과 밀접한 관련*이 있으며, 응용 영역에서는 필요한 도메인 객체를 조회하거나 저장 할때 레파지토리를 참조하게 된다. 또한, 응용 영역의 트랜잭션 관리는 레파지토리를 구현하는 기술에 영향을 받을 수 밖에 없다.\n\n## 인프라스트럭처\n- 표현, 응용, 도메인을 영역을 지원하는 역할을 수행\n- 위에서 설명한 DIP처럼, 인프라스트럭처 레이어의 기능을 바로 사용하는 것이 아니라 인터페이스를 통하여 참조/구현하는 것이 테스트 하기 쉽게 만들어주며 변경에 용이하게 해준다.\n\n## 모듈 구성/패키지 구조는?\n### 영역별로 구성\n- 응용/도메인 모듈에서는 연관 서비스/엔티티끼리 묶어서 다시 패키징을 할 수 있다.\n```\n|-- presentation\n|-- domain\n    |-- order\n    |-- member\n|-- application\n    |-- order\n    |-- member\n|-- infrastructure\n```\n\n### 도메인별로 구성\n- 도메인이 크다면 서브 도메인(하위 도메인)별로 나뉘는 전략\n```\n|-- order\n    |-- presentation\n    |-- domain\n    |-- application\n    |-- infrastructure\n|-- member\n    |-- presentation\n    |-- domain\n    |-- application\n    |-- infrastructure\n```\n\n\n### Spring 프로젝트에서의 일반 구조는?\n위에서 정리한 패키지 구조/명칭을 그대로 따라는 것도 좋은 접근이지만 여태까지 겪어봤던 구조도 한번 다시 정리해보는 것이 좋을거 같아 아래에 기술해봤다. \n\n#### 레이어 패키지 단위 구조\n- 레이어 단위로 구성하는 방법\n- 개인적으로 적절한 팀에서의 가이드가 존재하지 않는다면 선호하지 않는 방법이다. 왜냐하면, 무분별한 DI가 쉽게 발생 할 수 있으며, 각 레이어에서 개별 모듈이 관심사가 다른 레이어의 모듈이나 객체를 쉽게 참조할 수 있게 되기 때문이다. \n```\n|-- controller\n|-- service\n|-- repository\n|-- model\n|-- config\n|-- Application.java\n```\n\n#### 도메인 단위의 패키지 구조\n- 관심 도메인별로 패키지 구조를 작성\n- 위에서도 언급한 내용대로 개별 도메인별로 타입의 개수가 늘어나거나 관심사별로 다시 분리해야 할 경우 도메인 패키지내에서 다시 분리하는 전략도 취해볼 수 있다.\n```\n|-- order\n    |-- OrderController.java\n    |-- OrderService.java\n    |-- OrderRepository.java\n    |-- Order.java\n    |-- OrderLine.java\n    |-- Orderer.java\n|-- member\n|-- config\n|-- Application.java\n```\n\n> 결국 레이어 단위로 두느냐 아니면 도메인 단위로 두느냐는 같이 프로젝트를 수행하는 구성원들의 호불호에 의해서도 달라질 수 있고, 도메인별로 상호간에 참조가 아예 안되는 상황인지 아닌지 유무도 중요하게 된다. 무분별하게 어떤 접근이 맞다는 의견보다는 상황과 요구사항 그리고 팀원들의 이해도에 집중하여 접근하는 것이 중요하다고 할수 있다.\n","source":"_posts/DDD/DDD_START_2.md","raw":"---\ntitle: DDD Start - 2장\ndate: 2019.6.8. 20:55:00\ncategories:\n- DDD\n---\n\n# DDD Start - 2장\n\n> DDD Start의 2장 내용을 정리\n\n## 아키텍처 / 네 개의 영역? / 계층 구조 아키텍처\n```puml\n@startuml\nactor Client as A\nparticipant Presentation as B\nparticipant Application as C\nparticipant Domain as D\nparticipant Infrastructure as I\nA -> B : HTTP 요청\nB -> B : [표현]\\n - 유효성 검사\\n - 응용 영역에 필요한 객체 변환/생성\n\nB -> C : Application Layer 호출\nC -> C : [응용]\\n - 적절한 도메인 서비스 호출 \\n - 트랜잭션 시작\nC -> D : - 도메인에 필요한 도메인 엔티티 조회 \\n- 매소드/로직 호출\nD -> D : [도메인]\\n - 도메인에 필요한 객체를 표현\\n - 도메인에 관련된 구현을 담당\nD -> I : 구현기술을 다루는 부분은 \\n인프라스트럭쳐 레이어를 참조한다.\nI -> I : 구현 기술을 다루는 부분을 책임지며\\nRDB, NoSQL 등 실제 구현을 다루게 됨\n@enduml\n```\n\n아키텍처를 구성하는 요소는 크게 4가지로 나뉠 수 있다. `표현`, `응용`, `도메인` 및 `인프라스트럭처`로 나뉠 수 있으며, 각 계층별로 가져야 할 책임은 위 다이어그램을 통하여 확인이 가능하다.\n\n- **표현 레이어**의 경우, 사용자 혹은 외부 클라이언트의 요청을 받는 첫 관문이며, 해당 레이어에서는 요청에 대한 유효성 검사 및 응용 레이어 호출을 위한 객체 생성 및 변환 작업이 주로 이뤄진다.\n\n- **응용 레이어**는 도메인 서비스를 호출하며 대부분의 경우 응용 서비스에 대한 트랜잭션이 시작되는 지점이다. 도메인에 필요한 구현을 직접 수행하진 않으며, 도메인 영역의 객체에 이를 위임하게 된다\n\n- **도메인 레이어**는 도메인에 필요한 데이터를 표현하고 도메인과 관련된 구현을 담당하게 된다.\n- **인프라스트럭쳐 레이어**는 실제 구현을 담당하게 되는데, 구현 기술과 아주 밀접한 연관이 있는 레이어이다. 응용 레이어 및 도메인 레이어는 구현기술과 관련된 부분은 인프라스트럭처 레이어에 의존하게 된다.\n\n> 각 계층은 표현 -> 응용 -> 도메인 -> 인프라스트럭쳐 순으로 의존하게 하게 되지만, 구현의 편리함을 위하여 응용 -> 인프라스트럭쳐 혹은 도메인 -> 인프라스트럭쳐를 참조하는 방식으로 의존할 수도 있다.\n\n\n응용, 도메인 계층이 직접적으로 인프라스트럭처 레이어에 의존적이게 되면 실제 구현 부분에 대한 변경이 어려워지며, 테스트하기 어려워지는 문제점이 발생하게 된다. **DIP를 이용하면 저수준의 구현 모듈이 고수준의 모듈에 의존하도록 변경하여 위에서 발생하는 문제를 해결할 수 있는 실마리를 제공해준다.**\n\n## DIP\n\n> 객체지향 원칙 SOLID에서의 DIP\n> 추상을 매개(인터페이스)로 메시지를 주고 받음(메서드 호출)으로써 관계를 최대한 느슨(인터페이스를 사용함에 따라 구현에 대한 변경이 용이)하게 만드는 원칙\n> - [나무위키, 객체 지향 프로그래밍 원칙 중 DIP](https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99#s-2.5)\n> - [Nextree, DIP](http://www.nextree.co.kr/p6960/)\n\nDIP를 적용하게 되면 아래와 같이 구현 기술과 관련된 종속성을 쉽게 제거할 수 있는데, 저수준의 모듈이 고수준의 모듈을 참조하도록 구성하는 방법. 즉 인터페이스를 참조하게 되면 실제 인터페이스의 구현 부분에서 사용하는 구현 기술이 어떤 종류의 것인지와 상관없이 도메인에서 필요한 기능 자체에만 집중한 표현이 가능하다.\n\n```mermaid\ngraph LR\nCalculateDiscountService --> RuleDiscounter\nRuleDiscounter --> RDB/JPA\nRuleDiscounter --> SearchEngine\n```\n\n- 위 이미지에서 볼 수 있듯이 실제 구현이 RDB로 되어 있던지, 검색엔진을 통하여 되어 있던지 이는 중요하지 않고 실제 구현하고자 하는 `가격할인`이라는 목적에만 집중 할 수 있다. \n- 인터페이스를 사용함에 따라 실제 테스트 코드 작성 시, 쉽게 목(Mock) 구현을 할 수 있으며 또한 구현 변경에 따른 부담이 줄게 될 것이다.\n\n> 위 설명에서 말하는 저수준과 고수준을 나누는 기준은 구현 기술에 좀 더 특화되어 있는 모듈이라면 저수준으로 판단하며, 응용 혹은 도메인 영역에서 사용하는 모듈은 고수준으로 분류한다. \n> 실제 도메인에서 표현하는 추상화 된 응용 혹은 도메인 계층을 고수준의 모듈이라고 보는 것이 타당하다고 생각한다. 다시 말해, 실제 도메인이 해결해야 할 문제에 대한 추상화가 이뤄지는 구간정도로 요약하면 좋을꺼 같다.\n\n> *DDD Start 59P 중 일부*\n> *인프라스트럭처에 위치한 클래스가 도메인이나 응용 영역에 정의한 `인터페이스`를 상속받아 구현하는 구조가 되므로 도메인과 응용 영역에 대한 영향을 주지 않거나 최소화하면서 구현 기술을 변경하는 것이 가능하다.*\n\n## 도메인 영역의 구성요소는?\n| 요소  | 설명 |\n|---|---|\n| **엔티티**  | 식별자를 가지는 객체. 라이프 사이클을 가진다.  |\n| **벨류**  | 완전한 하나의 값을 표현. 도메인의 속성을 표현하는 목적으로 주로 사용한다.  |\n| **애그리거트**  | 연관 객체의 집합을 가리킨다. 다시 말해, 관련된 엔티티와 벨류 객체를 개념적으로 하나로 묶어 놓은 것이다.  |\n| **레파지토리**  | 도메인 모델의 영속성을 처리한다.  |\n| **도메인 서비스**  | 특정 엔티티에 종속적이지 않은 도메인의 로직을 제공  |\n\n위에서 설명한 내용을 간단하게 패키지 구조로 표현하면 아래와 같이 표현할 수 있다.\n```\n|-- order\n    |-- domain\n        |-- Order(Aggregate, Root-Entity)\n        |-- OrderLine(Entity)\n        |-- Orderer(Entity)\n        |-- OrderRepository(Repository)\n        |-- Address(Value)\n```\n\n> `DB 테이블의 엔티티` vs `도메인 모델의 엔티티`\n> 가장 큰 차이점은 바로 도메인 모델 엔티티는 데이터와 도메인의 기능을 함께 표현하는 것이다. 테이블의 엔티티는 말 그대로 테이블의 데이터만을 표현하게 되는데, 비슷하면서 미묘하게 다른 지점이 생기는데, 여기서 반드시 중심을 잡고 알아야 할 사실은 바로 **도메인 모델은 데이터와 도메인의 기능을 함께 표현한다는 점이다.**\n\n\n도메인 모델의 엔티티를 집중하여 살펴보면 위에서 말한대로 도메인의 데이터 담고 있으며 또한 도메인의 관점에서 기능을 구현해놓은 객체이다. 데이터에 대한 변경을 철저하게 도메인 관점에서 구현해야 하며 임의로 해당 엔티티의 상태 값이 변경되도록 하면 안된다. 이를 달성하기 위해서는 아래와 같은 점을 명심하면 좋을거 같다.\n- ***세터(setter)의 지양***, 무분별한 상태 변경은 `지양`해야 하며, 객체의 세터를 만들더라도 `private` 접근자를 할당하며 외부에서 접근이 안되도록 해야 한다.\n\n- **도메인 엔티티 생성 시, `정적 팩토리 매서드` 혹은 `팩토리 클래스`를 사용**, 도메인 객체의 생성은 반드시 완전한 상태로 이뤄져야 한다. 객체의 생성 규칙 일정하다면 `정적 팩토리 메서드`를 활용하는 방법이 좋고, 만약 객체를 생성하는 규칙이 다양하면 별도의 `팩토리 클래스`를 구현하는 방법도 좋다.\n\n\n- **의미 혹은 개념적으로 하나로 표현할 수 있는 상황이라면 `벨류(Value)` 객체를 적극적으로 활용하는게 좋다.** 이에 대한 구현은 불변(Immutable)한 접근을 통하여 객체 자체를 완전히 교체하는 전략을 취하자\n\n### 애그리거트(Aggregate)\n- 비슷한 도메인 모델을 상위 수준에서 접근. 다시 말해, ***연관/관련 객체를 하나로 묶은 군집.***\n- 예를 들어, 주문이라는 도메인 모델은 배송지, 주문자, 주문 목록 등의 하위 모델로 구성되는데 이 모든 모델을 하나의 군집 형태로 표현하여 `주문`이라는 상위 개념으로 표현할 수 있게 된다.\n- 애그리거트는 연관된 객체/도메인 모델을 관리하는 루트 엔티티를 가지게 되는데, 루트 엔티티는 연관 객체와 벨류 등을 사용하여 도메인에서 표현해야 할 혹은 구현해야 할 기능을 제공하게 된다.\n- 하위 객체 혹은 벨류에 대한 접근은 루트 엔티티를 통하여 간접적으로 이뤄져야 하며, 실제 구현을 내부로 숨길 수 있게 됨에 따라 애그리거트 단위로 캡슐화할 수 있도록 돕는다.\n\n### 레파지토리(Repository)\n- **구현을 위한 도메인 모델**로 도메인 객체를 영속성 있게 즉, 지속적으로 사용하려면 별도의 보관이 필요하게 된다. 이런 보관을 위하여 존재하는 것이 바로 레파지토리이다.\n- 저장은 주로 RDB, NoSQL 등의 구현 기술을 사용하게 된다.\n- 주로, ***에그리거트 단위로 객체를 저장하고 조회하는 기능을 구현하게 된다.***\n- 레파지토리 인터페이스는 주로 도메인 영역에 속하게 되며, 해당 인터페이스의 구현체는 실제 구현 기술을 사용하게 됨에 따라 인프라스트럭처 영역에 속하게 된다.\n- *응용영역과 밀접한 관련*이 있으며, 응용 영역에서는 필요한 도메인 객체를 조회하거나 저장 할때 레파지토리를 참조하게 된다. 또한, 응용 영역의 트랜잭션 관리는 레파지토리를 구현하는 기술에 영향을 받을 수 밖에 없다.\n\n## 인프라스트럭처\n- 표현, 응용, 도메인을 영역을 지원하는 역할을 수행\n- 위에서 설명한 DIP처럼, 인프라스트럭처 레이어의 기능을 바로 사용하는 것이 아니라 인터페이스를 통하여 참조/구현하는 것이 테스트 하기 쉽게 만들어주며 변경에 용이하게 해준다.\n\n## 모듈 구성/패키지 구조는?\n### 영역별로 구성\n- 응용/도메인 모듈에서는 연관 서비스/엔티티끼리 묶어서 다시 패키징을 할 수 있다.\n```\n|-- presentation\n|-- domain\n    |-- order\n    |-- member\n|-- application\n    |-- order\n    |-- member\n|-- infrastructure\n```\n\n### 도메인별로 구성\n- 도메인이 크다면 서브 도메인(하위 도메인)별로 나뉘는 전략\n```\n|-- order\n    |-- presentation\n    |-- domain\n    |-- application\n    |-- infrastructure\n|-- member\n    |-- presentation\n    |-- domain\n    |-- application\n    |-- infrastructure\n```\n\n\n### Spring 프로젝트에서의 일반 구조는?\n위에서 정리한 패키지 구조/명칭을 그대로 따라는 것도 좋은 접근이지만 여태까지 겪어봤던 구조도 한번 다시 정리해보는 것이 좋을거 같아 아래에 기술해봤다. \n\n#### 레이어 패키지 단위 구조\n- 레이어 단위로 구성하는 방법\n- 개인적으로 적절한 팀에서의 가이드가 존재하지 않는다면 선호하지 않는 방법이다. 왜냐하면, 무분별한 DI가 쉽게 발생 할 수 있으며, 각 레이어에서 개별 모듈이 관심사가 다른 레이어의 모듈이나 객체를 쉽게 참조할 수 있게 되기 때문이다. \n```\n|-- controller\n|-- service\n|-- repository\n|-- model\n|-- config\n|-- Application.java\n```\n\n#### 도메인 단위의 패키지 구조\n- 관심 도메인별로 패키지 구조를 작성\n- 위에서도 언급한 내용대로 개별 도메인별로 타입의 개수가 늘어나거나 관심사별로 다시 분리해야 할 경우 도메인 패키지내에서 다시 분리하는 전략도 취해볼 수 있다.\n```\n|-- order\n    |-- OrderController.java\n    |-- OrderService.java\n    |-- OrderRepository.java\n    |-- Order.java\n    |-- OrderLine.java\n    |-- Orderer.java\n|-- member\n|-- config\n|-- Application.java\n```\n\n> 결국 레이어 단위로 두느냐 아니면 도메인 단위로 두느냐는 같이 프로젝트를 수행하는 구성원들의 호불호에 의해서도 달라질 수 있고, 도메인별로 상호간에 참조가 아예 안되는 상황인지 아닌지 유무도 중요하게 된다. 무분별하게 어떤 접근이 맞다는 의견보다는 상황과 요구사항 그리고 팀원들의 이해도에 집중하여 접근하는 것이 중요하다고 할수 있다.\n","slug":"DDD/DDD_START_2","published":1,"updated":"2021-08-02T12:02:55.150Z","_id":"ckrsup4zu0009tjhv8j08asxy","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"DDD-Start-2장\"><a href=\"#DDD-Start-2장\" class=\"headerlink\" title=\"DDD Start - 2장\"></a>DDD Start - 2장</h1><blockquote>\n<p>DDD Start의 2장 내용을 정리</p>\n</blockquote>\n<h2 id=\"아키텍처-네-개의-영역-계층-구조-아키텍처\"><a href=\"#아키텍처-네-개의-영역-계층-구조-아키텍처\" class=\"headerlink\" title=\"아키텍처 / 네 개의 영역? / 계층 구조 아키텍처\"></a>아키텍처 / 네 개의 영역? / 계층 구조 아키텍처</h2><img src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U2NyaXB0VHlwZT0iYXBwbGljYXRpb24vZWNtYXNjcmlwdCIgY29udGVudFN0eWxlVHlwZT0idGV4dC9jc3MiIGhlaWdodD0iNjEzcHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDoxMDY4cHg7aGVpZ2h0OjYxM3B4O2JhY2tncm91bmQ6I0ZGRkZGRjsiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDEwNjggNjEzIiB3aWR0aD0iMTA2OHB4IiB6b29tQW5kUGFuPSJtYWduaWZ5Ij48ZGVmcz48ZmlsdGVyIGhlaWdodD0iMzAwJSIgaWQ9ImYxcWM5dGRhdjRxNmowIiB3aWR0aD0iMzAwJSIgeD0iLTEiIHk9Ii0xIj48ZmVHYXVzc2lhbkJsdXIgcmVzdWx0PSJibHVyT3V0IiBzdGREZXZpYXRpb249IjIuMCIvPjxmZUNvbG9yTWF0cml4IGluPSJibHVyT3V0IiByZXN1bHQ9ImJsdXJPdXQyIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgLjQgMCIvPjxmZU9mZnNldCBkeD0iNC4wIiBkeT0iNC4wIiBpbj0iYmx1ck91dDIiIHJlc3VsdD0iYmx1ck91dDMiLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJibHVyT3V0MyIgbW9kZT0ibm9ybWFsIi8+PC9maWx0ZXI+PC9kZWZzPjxnPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6NS4wLDUuMDsiIHgxPSIyOSIgeDI9IjI5IiB5MT0iODguMjk2OSIgeTI9IjUyOS41NTQ3Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9IjExOSIgeDI9IjExOSIgeTE9Ijg4LjI5NjkiIHkyPSI1MjkuNTU0NyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6NS4wLDUuMDsiIHgxPSIzNDgiIHgyPSIzNDgiIHkxPSI4OC4yOTY5IiB5Mj0iNTI5LjU1NDciLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjUuMCw1LjA7IiB4MT0iNTk2IiB4Mj0iNTk2IiB5MT0iODguMjk2OSIgeTI9IjUyOS41NTQ3Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9IjgyNyIgeDI9IjgyNyIgeTE9Ijg4LjI5NjkiIHkyPSI1MjkuNTU0NyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQzIiB4PSI1IiB5PSI4NC45OTUxIj5DbGllbnQ8L3RleHQ+PGVsbGlwc2UgY3g9IjI5LjUiIGN5PSIxNSIgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxcWM5dGRhdjRxNmowKSIgcng9IjgiIHJ5PSI4IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48cGF0aCBkPSJNMjkuNSwyMyBMMjkuNSw1MCBNMTYuNSwzMSBMNDIuNSwzMSBNMjkuNSw1MCBMMTYuNSw2NSBNMjkuNSw1MCBMNDIuNSw2NSAiIGZpbGw9Im5vbmUiIGZpbHRlcj0idXJsKCNmMXFjOXRkYXY0cTZqMCkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6Mi4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQzIiB4PSI1IiB5PSI1NDEuNTQ5OCI+Q2xpZW50PC90ZXh0PjxlbGxpcHNlIGN4PSIyOS41IiBjeT0iNTU0Ljg1MTYiIGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMXFjOXRkYXY0cTZqMCkiIHJ4PSI4IiByeT0iOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHBhdGggZD0iTTI5LjUsNTYyLjg1MTYgTDI5LjUsNTg5Ljg1MTYgTTE2LjUsNTcwLjg1MTYgTDQyLjUsNTcwLjg1MTYgTTI5LjUsNTg5Ljg1MTYgTDE2LjUsNjA0Ljg1MTYgTTI5LjUsNTg5Ljg1MTYgTDQyLjUsNjA0Ljg1MTYgIiBmaWxsPSJub25lIiBmaWx0ZXI9InVybCgjZjFxYzl0ZGF2NHE2ajApIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjFxYzl0ZGF2NHE2ajApIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEwNyIgeD0iNjQiIHk9IjUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTMiIHg9IjcxIiB5PSI3Mi45OTUxIj5QcmVzZW50YXRpb248L3RleHQ+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxcWM5dGRhdjRxNmowKSIgaGVpZ2h0PSIzMC4yOTY5IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMDciIHg9IjY0IiB5PSI1MjguNTU0NyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkzIiB4PSI3MSIgeT0iNTQ4LjU0OTgiPlByZXNlbnRhdGlvbjwvdGV4dD48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjFxYzl0ZGF2NHE2ajApIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijk3IiB4PSIyOTgiIHk9IjUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODMiIHg9IjMwNSIgeT0iNzIuOTk1MSI+QXBwbGljYXRpb248L3RleHQ+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxcWM5dGRhdjRxNmowKSIgaGVpZ2h0PSIzMC4yOTY5IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI5NyIgeD0iMjk4IiB5PSI1MjguNTU0NyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgzIiB4PSIzMDUiIHk9IjU0OC41NDk4Ij5BcHBsaWNhdGlvbjwvdGV4dD48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjFxYzl0ZGF2NHE2ajApIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjY5IiB4PSI1NjAiIHk9IjUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUiIHg9IjU2NyIgeT0iNzIuOTk1MSI+RG9tYWluPC90ZXh0PjxyZWN0IGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMXFjOXRkYXY0cTZqMCkiIGhlaWdodD0iMzAuMjk2OSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNjkiIHg9IjU2MCIgeT0iNTI4LjU1NDciLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NSIgeD0iNTY3IiB5PSI1NDguNTQ5OCI+RG9tYWluPC90ZXh0PjxyZWN0IGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMXFjOXRkYXY0cTZqMCkiIGhlaWdodD0iMzAuMjk2OSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTEzIiB4PSI3NjkiIHk9IjUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTkiIHg9Ijc3NiIgeT0iNzIuOTk1MSI+SW5mcmFzdHJ1Y3R1cmU8L3RleHQ+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxcWM5dGRhdjRxNmowKSIgaGVpZ2h0PSIzMC4yOTY5IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMTMiIHg9Ijc2OSIgeT0iNTI4LjU1NDciLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5OSIgeD0iNzc2IiB5PSI1NDguNTQ5OCI+SW5mcmFzdHJ1Y3R1cmU8L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIxMDcuNSwxMTUuNDI5NywxMTcuNSwxMTkuNDI5NywxMDcuNSwxMjMuNDI5NywxMTEuNSwxMTkuNDI5NyIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMjkuNSIgeDI9IjExMy41IiB5MT0iMTE5LjQyOTciIHkyPSIxMTkuNDI5NyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjYzIiB4PSIzNi41IiB5PSIxMTQuMzYzOCI+SFRUUCDsmpTssq08L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMTE5LjUiIHgyPSIxNjEuNSIgeTE9IjE3OC44MjgxIiB5Mj0iMTc4LjgyODEiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIxNjEuNSIgeDI9IjE2MS41IiB5MT0iMTc4LjgyODEiIHkyPSIxOTEuODI4MSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjEyMC41IiB4Mj0iMTYxLjUiIHkxPSIxOTEuODI4MSIgeTI9IjE5MS44MjgxIi8+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIxMzAuNSwxODcuODI4MSwxMjAuNSwxOTEuODI4MSwxMzAuNSwxOTUuODI4MSwxMjYuNSwxOTEuODI4MSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzYiIHg9IjEyNi41IiB5PSIxNDMuNDk2NiI+W+2RnO2YhF08L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNzgiIHg9IjEzMC41IiB5PSIxNTguNjI5NCI+LSDsnKDtmqjshLEg6rKA7IKsPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIxMSIgeD0iMTMwLjUiIHk9IjE3My43NjIyIj4tIOydkeyaqSDsmIHsl63sl5Ag7ZWE7JqU7ZWcIOqwneyytCDrs4DtmZgv7IOd7ISxPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMzM2LjUsMjE2Ljk2MDksMzQ2LjUsMjIwLjk2MDksMzM2LjUsMjI0Ljk2MDksMzQwLjUsMjIwLjk2MDkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjExOS41IiB4Mj0iMzQyLjUiIHkxPSIyMjAuOTYwOSIgeTI9IjIyMC45NjA5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTQwIiB4PSIxMjYuNSIgeT0iMjE1Ljg5NSI+QXBwbGljYXRpb24gTGF5ZXIg7Zi47LacPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjM0OC41IiB4Mj0iMzkwLjUiIHkxPSIyODAuMzU5NCIgeTI9IjI4MC4zNTk0Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMzkwLjUiIHgyPSIzOTAuNSIgeTE9IjI4MC4zNTk0IiB5Mj0iMjkzLjM1OTQiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIzNDkuNSIgeDI9IjM5MC41IiB5MT0iMjkzLjM1OTQiIHkyPSIyOTMuMzU5NCIvPjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMzU5LjUsMjg5LjM1OTQsMzQ5LjUsMjkzLjM1OTQsMzU5LjUsMjk3LjM1OTQsMzU1LjUsMjkzLjM1OTQiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjM2IiB4PSIzNTUuNSIgeT0iMjQ1LjAyNzgiPlvsnZHsmqldPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE2NCIgeD0iMzU5LjUiIHk9IjI2MC4xNjA2Ij4tIOyggeygiO2VnCDrj4TrqZTsnbgg7ISc67mE7IqkIO2YuOy2nDwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5MSIgeD0iMzU5LjUiIHk9IjI3NS4yOTM1Ij4tIO2KuOuenOyereyFmCDsi5zsnpE8L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSI1ODQuNSwzMzMuNjI1LDU5NC41LDMzNy42MjUsNTg0LjUsMzQxLjYyNSw1ODguNSwzMzcuNjI1IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIzNDguNSIgeDI9IjU5MC41IiB5MT0iMzM3LjYyNSIgeTI9IjMzNy42MjUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMjAiIHg9IjM1NS41IiB5PSIzMTcuNDI2MyI+LSDrj4TrqZTsnbjsl5Ag7ZWE7JqU7ZWcIOuPhOuplOyduCDsl5Tti7Dti7Ag7KGw7ZqMPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEwOCIgeD0iMzU1LjUiIHk9IjMzMi41NTkxIj4tIOunpOyGjOuTnC/roZzsp4Eg7Zi47LacPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjU5Ni41IiB4Mj0iNjM4LjUiIHkxPSIzOTcuMDIzNCIgeTI9IjM5Ny4wMjM0Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iNjM4LjUiIHgyPSI2MzguNSIgeTE9IjM5Ny4wMjM0IiB5Mj0iNDEwLjAyMzQiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI1OTcuNSIgeDI9IjYzOC41IiB5MT0iNDEwLjAyMzQiIHkyPSI0MTAuMDIzNCIvPjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNjA3LjUsNDA2LjAyMzQsNTk3LjUsNDEwLjAyMzQsNjA3LjUsNDE0LjAyMzQsNjAzLjUsNDEwLjAyMzQiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQ5IiB4PSI2MDMuNSIgeT0iMzYxLjY5MTkiPlvrj4TrqZTsnbhdPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE3NyIgeD0iNjA3LjUiIHk9IjM3Ni44MjQ3Ij4tIOuPhOuplOyduOyXkCDtlYTsmpTtlZwg6rCd7LK066W8IO2RnO2YhDwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNzciIHg9IjYwNy41IiB5PSIzOTEuOTU3NSI+LSDrj4TrqZTsnbjsl5Ag6rSA66Co65CcIOq1rO2YhOydhCDri7Tri7k8L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSI4MTUuNSw0NTAuMjg5MSw4MjUuNSw0NTQuMjg5MSw4MTUuNSw0NTguMjg5MSw4MTkuNSw0NTQuMjg5MSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iNTk2LjUiIHgyPSI4MjEuNSIgeTE9IjQ1NC4yODkxIiB5Mj0iNDU0LjI4OTEiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNTEiIHg9IjYwMy41IiB5PSI0MzQuMDkwMyI+6rWs7ZiE6riw7Iig7J2EIOuLpOujqOuKlCDrtoDrtoTsnYA8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjA3IiB4PSI2MDMuNSIgeT0iNDQ5LjIyMzEiPuyduO2UhOudvOyKpO2KuOufreyzkCDroIjsnbTslrTrpbwg7LC47KGw7ZWc64ukLjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI4MjcuNSIgeDI9Ijg2OS41IiB5MT0iNDk4LjU1NDciIHkyPSI0OTguNTU0NyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9Ijg2OS41IiB4Mj0iODY5LjUiIHkxPSI0OTguNTU0NyIgeTI9IjUxMS41NTQ3Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iODI4LjUiIHgyPSI4NjkuNSIgeTE9IjUxMS41NTQ3IiB5Mj0iNTExLjU1NDciLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjgzOC41LDUwNy41NTQ3LDgyOC41LDUxMS41NTQ3LDgzOC41LDUxNS41NTQ3LDgzNC41LDUxMS41NTQ3IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMTEiIHg9IjgzNC41IiB5PSI0NzguMzU2Ij7qtaztmIQg6riw7Iig7J2EIOuLpOujqOuKlCDrtoDrtoTsnYQg7LGF7J6E7KeA66mwPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIyNyIgeD0iODM0LjUiIHk9IjQ5My40ODg4Ij5SREIsIE5vU1FMIOuTsSDsi6TsoJwg6rWs7ZiE7J2EIOuLpOujqOqyjCDrkKg8L3RleHQ+PCEtLU1ENT1bOTFjMWQ2OTNmYmVmY2VkZWUzNjY3NjY0MWE3YWNhMjhdCkBzdGFydHVtbA0KYWN0b3IgQ2xpZW50IGFzIEENCnBhcnRpY2lwYW50IFByZXNlbnRhdGlvbiBhcyBCDQpwYXJ0aWNpcGFudCBBcHBsaWNhdGlvbiBhcyBDDQpwYXJ0aWNpcGFudCBEb21haW4gYXMgRA0KcGFydGljaXBhbnQgSW5mcmFzdHJ1Y3R1cmUgYXMgSQ0KQSAtPiBCIDogSFRUUCDsmpTssq0NCkIgLT4gQiA6IFvtkZztmIRdXG4gLSDsnKDtmqjshLEg6rKA7IKsXG4gLSDsnZHsmqkg7JiB7Jet7JeQIO2VhOyalO2VnCDqsJ3ssrQg67OA7ZmYL+yDneyEsQ0KDQpCIC0+IEMgOiBBcHBsaWNhdGlvbiBMYXllciDtmLjstpwNCkMgLT4gQyA6IFvsnZHsmqldXG4gLSDsoIHsoIjtlZwg64+E66mU7J24IOyEnOu5hOyKpCDtmLjstpwgXG4gLSDtirjrnpzsnq3shZgg7Iuc7J6RDQpDIC0+IEQgOiAtIOuPhOuplOyduOyXkCDtlYTsmpTtlZwg64+E66mU7J24IOyXlO2LsO2LsCDsobDtmowgXG4tIOunpOyGjOuTnC/roZzsp4Eg7Zi47LacDQpEIC0+IEQgOiBb64+E66mU7J24XVxuIC0g64+E66mU7J247JeQIO2VhOyalO2VnCDqsJ3ssrTrpbwg7ZGc7ZiEXG4gLSDrj4TrqZTsnbjsl5Ag6rSA66Co65CcIOq1rO2YhOydhCDri7Tri7kNCkQgLT4gSSA6IOq1rO2YhOq4sOyIoOydhCDri6Tro6jripQg67aA67aE7J2AIFxu7J247ZSE65287Iqk7Yq465+t7LOQIOugiOydtOyWtOulvCDssLjsobDtlZzri6QuDQpJIC0+IEkgOiDqtaztmIQg6riw7Iig7J2EIOuLpOujqOuKlCDrtoDrtoTsnYQg7LGF7J6E7KeA66mwXG5SREIsIE5vU1FMIOuTsSDsi6TsoJwg6rWs7ZiE7J2EIOuLpOujqOqyjCDrkKgNCkBlbmR1bWwNCgpQbGFudFVNTCB2ZXJzaW9uIDEuMjAyMS4xMGJldGEyKFVua25vd24gY29tcGlsZSB0aW1lKQooR1BMIHNvdXJjZSBkaXN0cmlidXRpb24pCkphdmEgUnVudGltZTogSmF2YShUTSkgU0UgUnVudGltZSBFbnZpcm9ubWVudApKVk06IEphdmEgSG90U3BvdChUTSkgNjQtQml0IFNlcnZlciBWTQpEZWZhdWx0IEVuY29kaW5nOiBVVEYtOApMYW5ndWFnZTogZW4KQ291bnRyeTogVVMKLS0+PC9nPjwvc3ZnPg=='>\n\n<p>아키텍처를 구성하는 요소는 크게 4가지로 나뉠 수 있다. <code>표현</code>, <code>응용</code>, <code>도메인</code> 및 <code>인프라스트럭처</code>로 나뉠 수 있으며, 각 계층별로 가져야 할 책임은 위 다이어그램을 통하여 확인이 가능하다.</p>\n<ul>\n<li><p><strong>표현 레이어</strong>의 경우, 사용자 혹은 외부 클라이언트의 요청을 받는 첫 관문이며, 해당 레이어에서는 요청에 대한 유효성 검사 및 응용 레이어 호출을 위한 객체 생성 및 변환 작업이 주로 이뤄진다.</p>\n</li>\n<li><p><strong>응용 레이어</strong>는 도메인 서비스를 호출하며 대부분의 경우 응용 서비스에 대한 트랜잭션이 시작되는 지점이다. 도메인에 필요한 구현을 직접 수행하진 않으며, 도메인 영역의 객체에 이를 위임하게 된다</p>\n</li>\n<li><p><strong>도메인 레이어</strong>는 도메인에 필요한 데이터를 표현하고 도메인과 관련된 구현을 담당하게 된다.</p>\n</li>\n<li><p><strong>인프라스트럭쳐 레이어</strong>는 실제 구현을 담당하게 되는데, 구현 기술과 아주 밀접한 연관이 있는 레이어이다. 응용 레이어 및 도메인 레이어는 구현기술과 관련된 부분은 인프라스트럭처 레이어에 의존하게 된다.</p>\n</li>\n</ul>\n<blockquote>\n<p>각 계층은 표현 -&gt; 응용 -&gt; 도메인 -&gt; 인프라스트럭쳐 순으로 의존하게 하게 되지만, 구현의 편리함을 위하여 응용 -&gt; 인프라스트럭쳐 혹은 도메인 -&gt; 인프라스트럭쳐를 참조하는 방식으로 의존할 수도 있다.</p>\n</blockquote>\n<p>응용, 도메인 계층이 직접적으로 인프라스트럭처 레이어에 의존적이게 되면 실제 구현 부분에 대한 변경이 어려워지며, 테스트하기 어려워지는 문제점이 발생하게 된다. <strong>DIP를 이용하면 저수준의 구현 모듈이 고수준의 모듈에 의존하도록 변경하여 위에서 발생하는 문제를 해결할 수 있는 실마리를 제공해준다.</strong></p>\n<h2 id=\"DIP\"><a href=\"#DIP\" class=\"headerlink\" title=\"DIP\"></a>DIP</h2><blockquote>\n<p>객체지향 원칙 SOLID에서의 DIP<br>추상을 매개(인터페이스)로 메시지를 주고 받음(메서드 호출)으로써 관계를 최대한 느슨(인터페이스를 사용함에 따라 구현에 대한 변경이 용이)하게 만드는 원칙</p>\n<ul>\n<li><a href=\"https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99#s-2.5\">나무위키, 객체 지향 프로그래밍 원칙 중 DIP</a></li>\n<li><a href=\"http://www.nextree.co.kr/p6960/\">Nextree, DIP</a></li>\n</ul>\n</blockquote>\n<p>DIP를 적용하게 되면 아래와 같이 구현 기술과 관련된 종속성을 쉽게 제거할 수 있는데, 저수준의 모듈이 고수준의 모듈을 참조하도록 구성하는 방법. 즉 인터페이스를 참조하게 되면 실제 인터페이스의 구현 부분에서 사용하는 구현 기술이 어떤 종류의 것인지와 상관없이 도메인에서 필요한 기능 자체에만 집중한 표현이 가능하다.</p>\n<pre class=\"mermaid\">graph LR\nCalculateDiscountService --> RuleDiscounter\nRuleDiscounter --> RDB/JPA\nRuleDiscounter --> SearchEngine</pre>\n\n<ul>\n<li>위 이미지에서 볼 수 있듯이 실제 구현이 RDB로 되어 있던지, 검색엔진을 통하여 되어 있던지 이는 중요하지 않고 실제 구현하고자 하는 <code>가격할인</code>이라는 목적에만 집중 할 수 있다. </li>\n<li>인터페이스를 사용함에 따라 실제 테스트 코드 작성 시, 쉽게 목(Mock) 구현을 할 수 있으며 또한 구현 변경에 따른 부담이 줄게 될 것이다.</li>\n</ul>\n<blockquote>\n<p>위 설명에서 말하는 저수준과 고수준을 나누는 기준은 구현 기술에 좀 더 특화되어 있는 모듈이라면 저수준으로 판단하며, 응용 혹은 도메인 영역에서 사용하는 모듈은 고수준으로 분류한다.<br>실제 도메인에서 표현하는 추상화 된 응용 혹은 도메인 계층을 고수준의 모듈이라고 보는 것이 타당하다고 생각한다. 다시 말해, 실제 도메인이 해결해야 할 문제에 대한 추상화가 이뤄지는 구간정도로 요약하면 좋을꺼 같다.</p>\n</blockquote>\n<blockquote>\n<p><em>DDD Start 59P 중 일부</em><br><em>인프라스트럭처에 위치한 클래스가 도메인이나 응용 영역에 정의한 <code>인터페이스</code>를 상속받아 구현하는 구조가 되므로 도메인과 응용 영역에 대한 영향을 주지 않거나 최소화하면서 구현 기술을 변경하는 것이 가능하다.</em></p>\n</blockquote>\n<h2 id=\"도메인-영역의-구성요소는\"><a href=\"#도메인-영역의-구성요소는\" class=\"headerlink\" title=\"도메인 영역의 구성요소는?\"></a>도메인 영역의 구성요소는?</h2><table>\n<thead>\n<tr>\n<th>요소</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>엔티티</strong></td>\n<td>식별자를 가지는 객체. 라이프 사이클을 가진다.</td>\n</tr>\n<tr>\n<td><strong>벨류</strong></td>\n<td>완전한 하나의 값을 표현. 도메인의 속성을 표현하는 목적으로 주로 사용한다.</td>\n</tr>\n<tr>\n<td><strong>애그리거트</strong></td>\n<td>연관 객체의 집합을 가리킨다. 다시 말해, 관련된 엔티티와 벨류 객체를 개념적으로 하나로 묶어 놓은 것이다.</td>\n</tr>\n<tr>\n<td><strong>레파지토리</strong></td>\n<td>도메인 모델의 영속성을 처리한다.</td>\n</tr>\n<tr>\n<td><strong>도메인 서비스</strong></td>\n<td>특정 엔티티에 종속적이지 않은 도메인의 로직을 제공</td>\n</tr>\n</tbody></table>\n<p>위에서 설명한 내용을 간단하게 패키지 구조로 표현하면 아래와 같이 표현할 수 있다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-- order</span><br><span class=\"line\">    |-- domain</span><br><span class=\"line\">        |-- Order(Aggregate, Root-Entity)</span><br><span class=\"line\">        |-- OrderLine(Entity)</span><br><span class=\"line\">        |-- Orderer(Entity)</span><br><span class=\"line\">        |-- OrderRepository(Repository)</span><br><span class=\"line\">        |-- Address(Value)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>DB 테이블의 엔티티</code> vs <code>도메인 모델의 엔티티</code><br>가장 큰 차이점은 바로 도메인 모델 엔티티는 데이터와 도메인의 기능을 함께 표현하는 것이다. 테이블의 엔티티는 말 그대로 테이블의 데이터만을 표현하게 되는데, 비슷하면서 미묘하게 다른 지점이 생기는데, 여기서 반드시 중심을 잡고 알아야 할 사실은 바로 <strong>도메인 모델은 데이터와 도메인의 기능을 함께 표현한다는 점이다.</strong></p>\n</blockquote>\n<p>도메인 모델의 엔티티를 집중하여 살펴보면 위에서 말한대로 도메인의 데이터 담고 있으며 또한 도메인의 관점에서 기능을 구현해놓은 객체이다. 데이터에 대한 변경을 철저하게 도메인 관점에서 구현해야 하며 임의로 해당 엔티티의 상태 값이 변경되도록 하면 안된다. 이를 달성하기 위해서는 아래와 같은 점을 명심하면 좋을거 같다.</p>\n<ul>\n<li><p><em><strong>세터(setter)의 지양</strong></em>, 무분별한 상태 변경은 <code>지양</code>해야 하며, 객체의 세터를 만들더라도 <code>private</code> 접근자를 할당하며 외부에서 접근이 안되도록 해야 한다.</p>\n</li>\n<li><p><strong>도메인 엔티티 생성 시, <code>정적 팩토리 매서드</code> 혹은 <code>팩토리 클래스</code>를 사용</strong>, 도메인 객체의 생성은 반드시 완전한 상태로 이뤄져야 한다. 객체의 생성 규칙 일정하다면 <code>정적 팩토리 메서드</code>를 활용하는 방법이 좋고, 만약 객체를 생성하는 규칙이 다양하면 별도의 <code>팩토리 클래스</code>를 구현하는 방법도 좋다.</p>\n</li>\n</ul>\n<ul>\n<li><strong>의미 혹은 개념적으로 하나로 표현할 수 있는 상황이라면 <code>벨류(Value)</code> 객체를 적극적으로 활용하는게 좋다.</strong> 이에 대한 구현은 불변(Immutable)한 접근을 통하여 객체 자체를 완전히 교체하는 전략을 취하자</li>\n</ul>\n<h3 id=\"애그리거트-Aggregate\"><a href=\"#애그리거트-Aggregate\" class=\"headerlink\" title=\"애그리거트(Aggregate)\"></a>애그리거트(Aggregate)</h3><ul>\n<li>비슷한 도메인 모델을 상위 수준에서 접근. 다시 말해, <em><strong>연관/관련 객체를 하나로 묶은 군집.</strong></em></li>\n<li>예를 들어, 주문이라는 도메인 모델은 배송지, 주문자, 주문 목록 등의 하위 모델로 구성되는데 이 모든 모델을 하나의 군집 형태로 표현하여 <code>주문</code>이라는 상위 개념으로 표현할 수 있게 된다.</li>\n<li>애그리거트는 연관된 객체/도메인 모델을 관리하는 루트 엔티티를 가지게 되는데, 루트 엔티티는 연관 객체와 벨류 등을 사용하여 도메인에서 표현해야 할 혹은 구현해야 할 기능을 제공하게 된다.</li>\n<li>하위 객체 혹은 벨류에 대한 접근은 루트 엔티티를 통하여 간접적으로 이뤄져야 하며, 실제 구현을 내부로 숨길 수 있게 됨에 따라 애그리거트 단위로 캡슐화할 수 있도록 돕는다.</li>\n</ul>\n<h3 id=\"레파지토리-Repository\"><a href=\"#레파지토리-Repository\" class=\"headerlink\" title=\"레파지토리(Repository)\"></a>레파지토리(Repository)</h3><ul>\n<li><strong>구현을 위한 도메인 모델</strong>로 도메인 객체를 영속성 있게 즉, 지속적으로 사용하려면 별도의 보관이 필요하게 된다. 이런 보관을 위하여 존재하는 것이 바로 레파지토리이다.</li>\n<li>저장은 주로 RDB, NoSQL 등의 구현 기술을 사용하게 된다.</li>\n<li>주로, <em><strong>에그리거트 단위로 객체를 저장하고 조회하는 기능을 구현하게 된다.</strong></em></li>\n<li>레파지토리 인터페이스는 주로 도메인 영역에 속하게 되며, 해당 인터페이스의 구현체는 실제 구현 기술을 사용하게 됨에 따라 인프라스트럭처 영역에 속하게 된다.</li>\n<li><em>응용영역과 밀접한 관련</em>이 있으며, 응용 영역에서는 필요한 도메인 객체를 조회하거나 저장 할때 레파지토리를 참조하게 된다. 또한, 응용 영역의 트랜잭션 관리는 레파지토리를 구현하는 기술에 영향을 받을 수 밖에 없다.</li>\n</ul>\n<h2 id=\"인프라스트럭처\"><a href=\"#인프라스트럭처\" class=\"headerlink\" title=\"인프라스트럭처\"></a>인프라스트럭처</h2><ul>\n<li>표현, 응용, 도메인을 영역을 지원하는 역할을 수행</li>\n<li>위에서 설명한 DIP처럼, 인프라스트럭처 레이어의 기능을 바로 사용하는 것이 아니라 인터페이스를 통하여 참조/구현하는 것이 테스트 하기 쉽게 만들어주며 변경에 용이하게 해준다.</li>\n</ul>\n<h2 id=\"모듈-구성-패키지-구조는\"><a href=\"#모듈-구성-패키지-구조는\" class=\"headerlink\" title=\"모듈 구성/패키지 구조는?\"></a>모듈 구성/패키지 구조는?</h2><h3 id=\"영역별로-구성\"><a href=\"#영역별로-구성\" class=\"headerlink\" title=\"영역별로 구성\"></a>영역별로 구성</h3><ul>\n<li>응용/도메인 모듈에서는 연관 서비스/엔티티끼리 묶어서 다시 패키징을 할 수 있다.<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-- presentation</span><br><span class=\"line\">|-- domain</span><br><span class=\"line\">    |-- order</span><br><span class=\"line\">    |-- member</span><br><span class=\"line\">|-- application</span><br><span class=\"line\">    |-- order</span><br><span class=\"line\">    |-- member</span><br><span class=\"line\">|-- infrastructure</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"도메인별로-구성\"><a href=\"#도메인별로-구성\" class=\"headerlink\" title=\"도메인별로 구성\"></a>도메인별로 구성</h3><ul>\n<li>도메인이 크다면 서브 도메인(하위 도메인)별로 나뉘는 전략<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-- order</span><br><span class=\"line\">    |-- presentation</span><br><span class=\"line\">    |-- domain</span><br><span class=\"line\">    |-- application</span><br><span class=\"line\">    |-- infrastructure</span><br><span class=\"line\">|-- member</span><br><span class=\"line\">    |-- presentation</span><br><span class=\"line\">    |-- domain</span><br><span class=\"line\">    |-- application</span><br><span class=\"line\">    |-- infrastructure</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"Spring-프로젝트에서의-일반-구조는\"><a href=\"#Spring-프로젝트에서의-일반-구조는\" class=\"headerlink\" title=\"Spring 프로젝트에서의 일반 구조는?\"></a>Spring 프로젝트에서의 일반 구조는?</h3><p>위에서 정리한 패키지 구조/명칭을 그대로 따라는 것도 좋은 접근이지만 여태까지 겪어봤던 구조도 한번 다시 정리해보는 것이 좋을거 같아 아래에 기술해봤다. </p>\n<h4 id=\"레이어-패키지-단위-구조\"><a href=\"#레이어-패키지-단위-구조\" class=\"headerlink\" title=\"레이어 패키지 단위 구조\"></a>레이어 패키지 단위 구조</h4><ul>\n<li>레이어 단위로 구성하는 방법</li>\n<li>개인적으로 적절한 팀에서의 가이드가 존재하지 않는다면 선호하지 않는 방법이다. 왜냐하면, 무분별한 DI가 쉽게 발생 할 수 있으며, 각 레이어에서 개별 모듈이 관심사가 다른 레이어의 모듈이나 객체를 쉽게 참조할 수 있게 되기 때문이다. <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-- controller</span><br><span class=\"line\">|-- service</span><br><span class=\"line\">|-- repository</span><br><span class=\"line\">|-- model</span><br><span class=\"line\">|-- config</span><br><span class=\"line\">|-- Application.java</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"도메인-단위의-패키지-구조\"><a href=\"#도메인-단위의-패키지-구조\" class=\"headerlink\" title=\"도메인 단위의 패키지 구조\"></a>도메인 단위의 패키지 구조</h4><ul>\n<li>관심 도메인별로 패키지 구조를 작성</li>\n<li>위에서도 언급한 내용대로 개별 도메인별로 타입의 개수가 늘어나거나 관심사별로 다시 분리해야 할 경우 도메인 패키지내에서 다시 분리하는 전략도 취해볼 수 있다.<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-- order</span><br><span class=\"line\">    |-- OrderController.java</span><br><span class=\"line\">    |-- OrderService.java</span><br><span class=\"line\">    |-- OrderRepository.java</span><br><span class=\"line\">    |-- Order.java</span><br><span class=\"line\">    |-- OrderLine.java</span><br><span class=\"line\">    |-- Orderer.java</span><br><span class=\"line\">|-- member</span><br><span class=\"line\">|-- config</span><br><span class=\"line\">|-- Application.java</span><br></pre></td></tr></table></figure></li>\n</ul>\n<blockquote>\n<p>결국 레이어 단위로 두느냐 아니면 도메인 단위로 두느냐는 같이 프로젝트를 수행하는 구성원들의 호불호에 의해서도 달라질 수 있고, 도메인별로 상호간에 참조가 아예 안되는 상황인지 아닌지 유무도 중요하게 된다. 무분별하게 어떤 접근이 맞다는 의견보다는 상황과 요구사항 그리고 팀원들의 이해도에 집중하여 접근하는 것이 중요하다고 할수 있다.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"DDD-Start-2장\"><a href=\"#DDD-Start-2장\" class=\"headerlink\" title=\"DDD Start - 2장\"></a>DDD Start - 2장</h1><blockquote>\n<p>DDD Start의 2장 내용을 정리</p>\n</blockquote>\n<h2 id=\"아키텍처-네-개의-영역-계층-구조-아키텍처\"><a href=\"#아키텍처-네-개의-영역-계층-구조-아키텍처\" class=\"headerlink\" title=\"아키텍처 / 네 개의 영역? / 계층 구조 아키텍처\"></a>아키텍처 / 네 개의 영역? / 계층 구조 아키텍처</h2><img src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U2NyaXB0VHlwZT0iYXBwbGljYXRpb24vZWNtYXNjcmlwdCIgY29udGVudFN0eWxlVHlwZT0idGV4dC9jc3MiIGhlaWdodD0iNjEzcHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDoxMDY4cHg7aGVpZ2h0OjYxM3B4O2JhY2tncm91bmQ6I0ZGRkZGRjsiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDEwNjggNjEzIiB3aWR0aD0iMTA2OHB4IiB6b29tQW5kUGFuPSJtYWduaWZ5Ij48ZGVmcz48ZmlsdGVyIGhlaWdodD0iMzAwJSIgaWQ9ImYxcWM5dGRhdjRxNmowIiB3aWR0aD0iMzAwJSIgeD0iLTEiIHk9Ii0xIj48ZmVHYXVzc2lhbkJsdXIgcmVzdWx0PSJibHVyT3V0IiBzdGREZXZpYXRpb249IjIuMCIvPjxmZUNvbG9yTWF0cml4IGluPSJibHVyT3V0IiByZXN1bHQ9ImJsdXJPdXQyIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgLjQgMCIvPjxmZU9mZnNldCBkeD0iNC4wIiBkeT0iNC4wIiBpbj0iYmx1ck91dDIiIHJlc3VsdD0iYmx1ck91dDMiLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJibHVyT3V0MyIgbW9kZT0ibm9ybWFsIi8+PC9maWx0ZXI+PC9kZWZzPjxnPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6NS4wLDUuMDsiIHgxPSIyOSIgeDI9IjI5IiB5MT0iODguMjk2OSIgeTI9IjUyOS41NTQ3Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9IjExOSIgeDI9IjExOSIgeTE9Ijg4LjI5NjkiIHkyPSI1MjkuNTU0NyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6NS4wLDUuMDsiIHgxPSIzNDgiIHgyPSIzNDgiIHkxPSI4OC4yOTY5IiB5Mj0iNTI5LjU1NDciLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjUuMCw1LjA7IiB4MT0iNTk2IiB4Mj0iNTk2IiB5MT0iODguMjk2OSIgeTI9IjUyOS41NTQ3Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9IjgyNyIgeDI9IjgyNyIgeTE9Ijg4LjI5NjkiIHkyPSI1MjkuNTU0NyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQzIiB4PSI1IiB5PSI4NC45OTUxIj5DbGllbnQ8L3RleHQ+PGVsbGlwc2UgY3g9IjI5LjUiIGN5PSIxNSIgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxcWM5dGRhdjRxNmowKSIgcng9IjgiIHJ5PSI4IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48cGF0aCBkPSJNMjkuNSwyMyBMMjkuNSw1MCBNMTYuNSwzMSBMNDIuNSwzMSBNMjkuNSw1MCBMMTYuNSw2NSBNMjkuNSw1MCBMNDIuNSw2NSAiIGZpbGw9Im5vbmUiIGZpbHRlcj0idXJsKCNmMXFjOXRkYXY0cTZqMCkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6Mi4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQzIiB4PSI1IiB5PSI1NDEuNTQ5OCI+Q2xpZW50PC90ZXh0PjxlbGxpcHNlIGN4PSIyOS41IiBjeT0iNTU0Ljg1MTYiIGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMXFjOXRkYXY0cTZqMCkiIHJ4PSI4IiByeT0iOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHBhdGggZD0iTTI5LjUsNTYyLjg1MTYgTDI5LjUsNTg5Ljg1MTYgTTE2LjUsNTcwLjg1MTYgTDQyLjUsNTcwLjg1MTYgTTI5LjUsNTg5Ljg1MTYgTDE2LjUsNjA0Ljg1MTYgTTI5LjUsNTg5Ljg1MTYgTDQyLjUsNjA0Ljg1MTYgIiBmaWxsPSJub25lIiBmaWx0ZXI9InVybCgjZjFxYzl0ZGF2NHE2ajApIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjFxYzl0ZGF2NHE2ajApIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEwNyIgeD0iNjQiIHk9IjUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTMiIHg9IjcxIiB5PSI3Mi45OTUxIj5QcmVzZW50YXRpb248L3RleHQ+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxcWM5dGRhdjRxNmowKSIgaGVpZ2h0PSIzMC4yOTY5IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMDciIHg9IjY0IiB5PSI1MjguNTU0NyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkzIiB4PSI3MSIgeT0iNTQ4LjU0OTgiPlByZXNlbnRhdGlvbjwvdGV4dD48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjFxYzl0ZGF2NHE2ajApIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijk3IiB4PSIyOTgiIHk9IjUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODMiIHg9IjMwNSIgeT0iNzIuOTk1MSI+QXBwbGljYXRpb248L3RleHQ+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxcWM5dGRhdjRxNmowKSIgaGVpZ2h0PSIzMC4yOTY5IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI5NyIgeD0iMjk4IiB5PSI1MjguNTU0NyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgzIiB4PSIzMDUiIHk9IjU0OC41NDk4Ij5BcHBsaWNhdGlvbjwvdGV4dD48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjFxYzl0ZGF2NHE2ajApIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjY5IiB4PSI1NjAiIHk9IjUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUiIHg9IjU2NyIgeT0iNzIuOTk1MSI+RG9tYWluPC90ZXh0PjxyZWN0IGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMXFjOXRkYXY0cTZqMCkiIGhlaWdodD0iMzAuMjk2OSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNjkiIHg9IjU2MCIgeT0iNTI4LjU1NDciLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NSIgeD0iNTY3IiB5PSI1NDguNTQ5OCI+RG9tYWluPC90ZXh0PjxyZWN0IGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMXFjOXRkYXY0cTZqMCkiIGhlaWdodD0iMzAuMjk2OSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTEzIiB4PSI3NjkiIHk9IjUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTkiIHg9Ijc3NiIgeT0iNzIuOTk1MSI+SW5mcmFzdHJ1Y3R1cmU8L3RleHQ+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxcWM5dGRhdjRxNmowKSIgaGVpZ2h0PSIzMC4yOTY5IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMTMiIHg9Ijc2OSIgeT0iNTI4LjU1NDciLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5OSIgeD0iNzc2IiB5PSI1NDguNTQ5OCI+SW5mcmFzdHJ1Y3R1cmU8L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIxMDcuNSwxMTUuNDI5NywxMTcuNSwxMTkuNDI5NywxMDcuNSwxMjMuNDI5NywxMTEuNSwxMTkuNDI5NyIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMjkuNSIgeDI9IjExMy41IiB5MT0iMTE5LjQyOTciIHkyPSIxMTkuNDI5NyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjYzIiB4PSIzNi41IiB5PSIxMTQuMzYzOCI+SFRUUCDsmpTssq08L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMTE5LjUiIHgyPSIxNjEuNSIgeTE9IjE3OC44MjgxIiB5Mj0iMTc4LjgyODEiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIxNjEuNSIgeDI9IjE2MS41IiB5MT0iMTc4LjgyODEiIHkyPSIxOTEuODI4MSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjEyMC41IiB4Mj0iMTYxLjUiIHkxPSIxOTEuODI4MSIgeTI9IjE5MS44MjgxIi8+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIxMzAuNSwxODcuODI4MSwxMjAuNSwxOTEuODI4MSwxMzAuNSwxOTUuODI4MSwxMjYuNSwxOTEuODI4MSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzYiIHg9IjEyNi41IiB5PSIxNDMuNDk2NiI+W+2RnO2YhF08L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNzgiIHg9IjEzMC41IiB5PSIxNTguNjI5NCI+LSDsnKDtmqjshLEg6rKA7IKsPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIxMSIgeD0iMTMwLjUiIHk9IjE3My43NjIyIj4tIOydkeyaqSDsmIHsl63sl5Ag7ZWE7JqU7ZWcIOqwneyytCDrs4DtmZgv7IOd7ISxPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMzM2LjUsMjE2Ljk2MDksMzQ2LjUsMjIwLjk2MDksMzM2LjUsMjI0Ljk2MDksMzQwLjUsMjIwLjk2MDkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjExOS41IiB4Mj0iMzQyLjUiIHkxPSIyMjAuOTYwOSIgeTI9IjIyMC45NjA5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTQwIiB4PSIxMjYuNSIgeT0iMjE1Ljg5NSI+QXBwbGljYXRpb24gTGF5ZXIg7Zi47LacPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjM0OC41IiB4Mj0iMzkwLjUiIHkxPSIyODAuMzU5NCIgeTI9IjI4MC4zNTk0Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMzkwLjUiIHgyPSIzOTAuNSIgeTE9IjI4MC4zNTk0IiB5Mj0iMjkzLjM1OTQiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIzNDkuNSIgeDI9IjM5MC41IiB5MT0iMjkzLjM1OTQiIHkyPSIyOTMuMzU5NCIvPjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMzU5LjUsMjg5LjM1OTQsMzQ5LjUsMjkzLjM1OTQsMzU5LjUsMjk3LjM1OTQsMzU1LjUsMjkzLjM1OTQiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjM2IiB4PSIzNTUuNSIgeT0iMjQ1LjAyNzgiPlvsnZHsmqldPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE2NCIgeD0iMzU5LjUiIHk9IjI2MC4xNjA2Ij4tIOyggeygiO2VnCDrj4TrqZTsnbgg7ISc67mE7IqkIO2YuOy2nDwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5MSIgeD0iMzU5LjUiIHk9IjI3NS4yOTM1Ij4tIO2KuOuenOyereyFmCDsi5zsnpE8L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSI1ODQuNSwzMzMuNjI1LDU5NC41LDMzNy42MjUsNTg0LjUsMzQxLjYyNSw1ODguNSwzMzcuNjI1IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIzNDguNSIgeDI9IjU5MC41IiB5MT0iMzM3LjYyNSIgeTI9IjMzNy42MjUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMjAiIHg9IjM1NS41IiB5PSIzMTcuNDI2MyI+LSDrj4TrqZTsnbjsl5Ag7ZWE7JqU7ZWcIOuPhOuplOyduCDsl5Tti7Dti7Ag7KGw7ZqMPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEwOCIgeD0iMzU1LjUiIHk9IjMzMi41NTkxIj4tIOunpOyGjOuTnC/roZzsp4Eg7Zi47LacPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjU5Ni41IiB4Mj0iNjM4LjUiIHkxPSIzOTcuMDIzNCIgeTI9IjM5Ny4wMjM0Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iNjM4LjUiIHgyPSI2MzguNSIgeTE9IjM5Ny4wMjM0IiB5Mj0iNDEwLjAyMzQiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI1OTcuNSIgeDI9IjYzOC41IiB5MT0iNDEwLjAyMzQiIHkyPSI0MTAuMDIzNCIvPjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNjA3LjUsNDA2LjAyMzQsNTk3LjUsNDEwLjAyMzQsNjA3LjUsNDE0LjAyMzQsNjAzLjUsNDEwLjAyMzQiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQ5IiB4PSI2MDMuNSIgeT0iMzYxLjY5MTkiPlvrj4TrqZTsnbhdPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE3NyIgeD0iNjA3LjUiIHk9IjM3Ni44MjQ3Ij4tIOuPhOuplOyduOyXkCDtlYTsmpTtlZwg6rCd7LK066W8IO2RnO2YhDwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNzciIHg9IjYwNy41IiB5PSIzOTEuOTU3NSI+LSDrj4TrqZTsnbjsl5Ag6rSA66Co65CcIOq1rO2YhOydhCDri7Tri7k8L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSI4MTUuNSw0NTAuMjg5MSw4MjUuNSw0NTQuMjg5MSw4MTUuNSw0NTguMjg5MSw4MTkuNSw0NTQuMjg5MSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iNTk2LjUiIHgyPSI4MjEuNSIgeTE9IjQ1NC4yODkxIiB5Mj0iNDU0LjI4OTEiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNTEiIHg9IjYwMy41IiB5PSI0MzQuMDkwMyI+6rWs7ZiE6riw7Iig7J2EIOuLpOujqOuKlCDrtoDrtoTsnYA8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjA3IiB4PSI2MDMuNSIgeT0iNDQ5LjIyMzEiPuyduO2UhOudvOyKpO2KuOufreyzkCDroIjsnbTslrTrpbwg7LC47KGw7ZWc64ukLjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI4MjcuNSIgeDI9Ijg2OS41IiB5MT0iNDk4LjU1NDciIHkyPSI0OTguNTU0NyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9Ijg2OS41IiB4Mj0iODY5LjUiIHkxPSI0OTguNTU0NyIgeTI9IjUxMS41NTQ3Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iODI4LjUiIHgyPSI4NjkuNSIgeTE9IjUxMS41NTQ3IiB5Mj0iNTExLjU1NDciLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjgzOC41LDUwNy41NTQ3LDgyOC41LDUxMS41NTQ3LDgzOC41LDUxNS41NTQ3LDgzNC41LDUxMS41NTQ3IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMTEiIHg9IjgzNC41IiB5PSI0NzguMzU2Ij7qtaztmIQg6riw7Iig7J2EIOuLpOujqOuKlCDrtoDrtoTsnYQg7LGF7J6E7KeA66mwPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIyNyIgeD0iODM0LjUiIHk9IjQ5My40ODg4Ij5SREIsIE5vU1FMIOuTsSDsi6TsoJwg6rWs7ZiE7J2EIOuLpOujqOqyjCDrkKg8L3RleHQ+PCEtLU1ENT1bOTFjMWQ2OTNmYmVmY2VkZWUzNjY3NjY0MWE3YWNhMjhdCkBzdGFydHVtbA0KYWN0b3IgQ2xpZW50IGFzIEENCnBhcnRpY2lwYW50IFByZXNlbnRhdGlvbiBhcyBCDQpwYXJ0aWNpcGFudCBBcHBsaWNhdGlvbiBhcyBDDQpwYXJ0aWNpcGFudCBEb21haW4gYXMgRA0KcGFydGljaXBhbnQgSW5mcmFzdHJ1Y3R1cmUgYXMgSQ0KQSAtPiBCIDogSFRUUCDsmpTssq0NCkIgLT4gQiA6IFvtkZztmIRdXG4gLSDsnKDtmqjshLEg6rKA7IKsXG4gLSDsnZHsmqkg7JiB7Jet7JeQIO2VhOyalO2VnCDqsJ3ssrQg67OA7ZmYL+yDneyEsQ0KDQpCIC0+IEMgOiBBcHBsaWNhdGlvbiBMYXllciDtmLjstpwNCkMgLT4gQyA6IFvsnZHsmqldXG4gLSDsoIHsoIjtlZwg64+E66mU7J24IOyEnOu5hOyKpCDtmLjstpwgXG4gLSDtirjrnpzsnq3shZgg7Iuc7J6RDQpDIC0+IEQgOiAtIOuPhOuplOyduOyXkCDtlYTsmpTtlZwg64+E66mU7J24IOyXlO2LsO2LsCDsobDtmowgXG4tIOunpOyGjOuTnC/roZzsp4Eg7Zi47LacDQpEIC0+IEQgOiBb64+E66mU7J24XVxuIC0g64+E66mU7J247JeQIO2VhOyalO2VnCDqsJ3ssrTrpbwg7ZGc7ZiEXG4gLSDrj4TrqZTsnbjsl5Ag6rSA66Co65CcIOq1rO2YhOydhCDri7Tri7kNCkQgLT4gSSA6IOq1rO2YhOq4sOyIoOydhCDri6Tro6jripQg67aA67aE7J2AIFxu7J247ZSE65287Iqk7Yq465+t7LOQIOugiOydtOyWtOulvCDssLjsobDtlZzri6QuDQpJIC0+IEkgOiDqtaztmIQg6riw7Iig7J2EIOuLpOujqOuKlCDrtoDrtoTsnYQg7LGF7J6E7KeA66mwXG5SREIsIE5vU1FMIOuTsSDsi6TsoJwg6rWs7ZiE7J2EIOuLpOujqOqyjCDrkKgNCkBlbmR1bWwNCgpQbGFudFVNTCB2ZXJzaW9uIDEuMjAyMS4xMGJldGEyKFVua25vd24gY29tcGlsZSB0aW1lKQooR1BMIHNvdXJjZSBkaXN0cmlidXRpb24pCkphdmEgUnVudGltZTogSmF2YShUTSkgU0UgUnVudGltZSBFbnZpcm9ubWVudApKVk06IEphdmEgSG90U3BvdChUTSkgNjQtQml0IFNlcnZlciBWTQpEZWZhdWx0IEVuY29kaW5nOiBVVEYtOApMYW5ndWFnZTogZW4KQ291bnRyeTogVVMKLS0+PC9nPjwvc3ZnPg=='>\n\n<p>아키텍처를 구성하는 요소는 크게 4가지로 나뉠 수 있다. <code>표현</code>, <code>응용</code>, <code>도메인</code> 및 <code>인프라스트럭처</code>로 나뉠 수 있으며, 각 계층별로 가져야 할 책임은 위 다이어그램을 통하여 확인이 가능하다.</p>\n<ul>\n<li><p><strong>표현 레이어</strong>의 경우, 사용자 혹은 외부 클라이언트의 요청을 받는 첫 관문이며, 해당 레이어에서는 요청에 대한 유효성 검사 및 응용 레이어 호출을 위한 객체 생성 및 변환 작업이 주로 이뤄진다.</p>\n</li>\n<li><p><strong>응용 레이어</strong>는 도메인 서비스를 호출하며 대부분의 경우 응용 서비스에 대한 트랜잭션이 시작되는 지점이다. 도메인에 필요한 구현을 직접 수행하진 않으며, 도메인 영역의 객체에 이를 위임하게 된다</p>\n</li>\n<li><p><strong>도메인 레이어</strong>는 도메인에 필요한 데이터를 표현하고 도메인과 관련된 구현을 담당하게 된다.</p>\n</li>\n<li><p><strong>인프라스트럭쳐 레이어</strong>는 실제 구현을 담당하게 되는데, 구현 기술과 아주 밀접한 연관이 있는 레이어이다. 응용 레이어 및 도메인 레이어는 구현기술과 관련된 부분은 인프라스트럭처 레이어에 의존하게 된다.</p>\n</li>\n</ul>\n<blockquote>\n<p>각 계층은 표현 -&gt; 응용 -&gt; 도메인 -&gt; 인프라스트럭쳐 순으로 의존하게 하게 되지만, 구현의 편리함을 위하여 응용 -&gt; 인프라스트럭쳐 혹은 도메인 -&gt; 인프라스트럭쳐를 참조하는 방식으로 의존할 수도 있다.</p>\n</blockquote>\n<p>응용, 도메인 계층이 직접적으로 인프라스트럭처 레이어에 의존적이게 되면 실제 구현 부분에 대한 변경이 어려워지며, 테스트하기 어려워지는 문제점이 발생하게 된다. <strong>DIP를 이용하면 저수준의 구현 모듈이 고수준의 모듈에 의존하도록 변경하여 위에서 발생하는 문제를 해결할 수 있는 실마리를 제공해준다.</strong></p>\n<h2 id=\"DIP\"><a href=\"#DIP\" class=\"headerlink\" title=\"DIP\"></a>DIP</h2><blockquote>\n<p>객체지향 원칙 SOLID에서의 DIP<br>추상을 매개(인터페이스)로 메시지를 주고 받음(메서드 호출)으로써 관계를 최대한 느슨(인터페이스를 사용함에 따라 구현에 대한 변경이 용이)하게 만드는 원칙</p>\n<ul>\n<li><a href=\"https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99#s-2.5\">나무위키, 객체 지향 프로그래밍 원칙 중 DIP</a></li>\n<li><a href=\"http://www.nextree.co.kr/p6960/\">Nextree, DIP</a></li>\n</ul>\n</blockquote>\n<p>DIP를 적용하게 되면 아래와 같이 구현 기술과 관련된 종속성을 쉽게 제거할 수 있는데, 저수준의 모듈이 고수준의 모듈을 참조하도록 구성하는 방법. 즉 인터페이스를 참조하게 되면 실제 인터페이스의 구현 부분에서 사용하는 구현 기술이 어떤 종류의 것인지와 상관없이 도메인에서 필요한 기능 자체에만 집중한 표현이 가능하다.</p>\n<pre class=\"mermaid\">graph LR\nCalculateDiscountService --> RuleDiscounter\nRuleDiscounter --> RDB/JPA\nRuleDiscounter --> SearchEngine</pre>\n\n<ul>\n<li>위 이미지에서 볼 수 있듯이 실제 구현이 RDB로 되어 있던지, 검색엔진을 통하여 되어 있던지 이는 중요하지 않고 실제 구현하고자 하는 <code>가격할인</code>이라는 목적에만 집중 할 수 있다. </li>\n<li>인터페이스를 사용함에 따라 실제 테스트 코드 작성 시, 쉽게 목(Mock) 구현을 할 수 있으며 또한 구현 변경에 따른 부담이 줄게 될 것이다.</li>\n</ul>\n<blockquote>\n<p>위 설명에서 말하는 저수준과 고수준을 나누는 기준은 구현 기술에 좀 더 특화되어 있는 모듈이라면 저수준으로 판단하며, 응용 혹은 도메인 영역에서 사용하는 모듈은 고수준으로 분류한다.<br>실제 도메인에서 표현하는 추상화 된 응용 혹은 도메인 계층을 고수준의 모듈이라고 보는 것이 타당하다고 생각한다. 다시 말해, 실제 도메인이 해결해야 할 문제에 대한 추상화가 이뤄지는 구간정도로 요약하면 좋을꺼 같다.</p>\n</blockquote>\n<blockquote>\n<p><em>DDD Start 59P 중 일부</em><br><em>인프라스트럭처에 위치한 클래스가 도메인이나 응용 영역에 정의한 <code>인터페이스</code>를 상속받아 구현하는 구조가 되므로 도메인과 응용 영역에 대한 영향을 주지 않거나 최소화하면서 구현 기술을 변경하는 것이 가능하다.</em></p>\n</blockquote>\n<h2 id=\"도메인-영역의-구성요소는\"><a href=\"#도메인-영역의-구성요소는\" class=\"headerlink\" title=\"도메인 영역의 구성요소는?\"></a>도메인 영역의 구성요소는?</h2><table>\n<thead>\n<tr>\n<th>요소</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>엔티티</strong></td>\n<td>식별자를 가지는 객체. 라이프 사이클을 가진다.</td>\n</tr>\n<tr>\n<td><strong>벨류</strong></td>\n<td>완전한 하나의 값을 표현. 도메인의 속성을 표현하는 목적으로 주로 사용한다.</td>\n</tr>\n<tr>\n<td><strong>애그리거트</strong></td>\n<td>연관 객체의 집합을 가리킨다. 다시 말해, 관련된 엔티티와 벨류 객체를 개념적으로 하나로 묶어 놓은 것이다.</td>\n</tr>\n<tr>\n<td><strong>레파지토리</strong></td>\n<td>도메인 모델의 영속성을 처리한다.</td>\n</tr>\n<tr>\n<td><strong>도메인 서비스</strong></td>\n<td>특정 엔티티에 종속적이지 않은 도메인의 로직을 제공</td>\n</tr>\n</tbody></table>\n<p>위에서 설명한 내용을 간단하게 패키지 구조로 표현하면 아래와 같이 표현할 수 있다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-- order</span><br><span class=\"line\">    |-- domain</span><br><span class=\"line\">        |-- Order(Aggregate, Root-Entity)</span><br><span class=\"line\">        |-- OrderLine(Entity)</span><br><span class=\"line\">        |-- Orderer(Entity)</span><br><span class=\"line\">        |-- OrderRepository(Repository)</span><br><span class=\"line\">        |-- Address(Value)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>DB 테이블의 엔티티</code> vs <code>도메인 모델의 엔티티</code><br>가장 큰 차이점은 바로 도메인 모델 엔티티는 데이터와 도메인의 기능을 함께 표현하는 것이다. 테이블의 엔티티는 말 그대로 테이블의 데이터만을 표현하게 되는데, 비슷하면서 미묘하게 다른 지점이 생기는데, 여기서 반드시 중심을 잡고 알아야 할 사실은 바로 <strong>도메인 모델은 데이터와 도메인의 기능을 함께 표현한다는 점이다.</strong></p>\n</blockquote>\n<p>도메인 모델의 엔티티를 집중하여 살펴보면 위에서 말한대로 도메인의 데이터 담고 있으며 또한 도메인의 관점에서 기능을 구현해놓은 객체이다. 데이터에 대한 변경을 철저하게 도메인 관점에서 구현해야 하며 임의로 해당 엔티티의 상태 값이 변경되도록 하면 안된다. 이를 달성하기 위해서는 아래와 같은 점을 명심하면 좋을거 같다.</p>\n<ul>\n<li><p><em><strong>세터(setter)의 지양</strong></em>, 무분별한 상태 변경은 <code>지양</code>해야 하며, 객체의 세터를 만들더라도 <code>private</code> 접근자를 할당하며 외부에서 접근이 안되도록 해야 한다.</p>\n</li>\n<li><p><strong>도메인 엔티티 생성 시, <code>정적 팩토리 매서드</code> 혹은 <code>팩토리 클래스</code>를 사용</strong>, 도메인 객체의 생성은 반드시 완전한 상태로 이뤄져야 한다. 객체의 생성 규칙 일정하다면 <code>정적 팩토리 메서드</code>를 활용하는 방법이 좋고, 만약 객체를 생성하는 규칙이 다양하면 별도의 <code>팩토리 클래스</code>를 구현하는 방법도 좋다.</p>\n</li>\n</ul>\n<ul>\n<li><strong>의미 혹은 개념적으로 하나로 표현할 수 있는 상황이라면 <code>벨류(Value)</code> 객체를 적극적으로 활용하는게 좋다.</strong> 이에 대한 구현은 불변(Immutable)한 접근을 통하여 객체 자체를 완전히 교체하는 전략을 취하자</li>\n</ul>\n<h3 id=\"애그리거트-Aggregate\"><a href=\"#애그리거트-Aggregate\" class=\"headerlink\" title=\"애그리거트(Aggregate)\"></a>애그리거트(Aggregate)</h3><ul>\n<li>비슷한 도메인 모델을 상위 수준에서 접근. 다시 말해, <em><strong>연관/관련 객체를 하나로 묶은 군집.</strong></em></li>\n<li>예를 들어, 주문이라는 도메인 모델은 배송지, 주문자, 주문 목록 등의 하위 모델로 구성되는데 이 모든 모델을 하나의 군집 형태로 표현하여 <code>주문</code>이라는 상위 개념으로 표현할 수 있게 된다.</li>\n<li>애그리거트는 연관된 객체/도메인 모델을 관리하는 루트 엔티티를 가지게 되는데, 루트 엔티티는 연관 객체와 벨류 등을 사용하여 도메인에서 표현해야 할 혹은 구현해야 할 기능을 제공하게 된다.</li>\n<li>하위 객체 혹은 벨류에 대한 접근은 루트 엔티티를 통하여 간접적으로 이뤄져야 하며, 실제 구현을 내부로 숨길 수 있게 됨에 따라 애그리거트 단위로 캡슐화할 수 있도록 돕는다.</li>\n</ul>\n<h3 id=\"레파지토리-Repository\"><a href=\"#레파지토리-Repository\" class=\"headerlink\" title=\"레파지토리(Repository)\"></a>레파지토리(Repository)</h3><ul>\n<li><strong>구현을 위한 도메인 모델</strong>로 도메인 객체를 영속성 있게 즉, 지속적으로 사용하려면 별도의 보관이 필요하게 된다. 이런 보관을 위하여 존재하는 것이 바로 레파지토리이다.</li>\n<li>저장은 주로 RDB, NoSQL 등의 구현 기술을 사용하게 된다.</li>\n<li>주로, <em><strong>에그리거트 단위로 객체를 저장하고 조회하는 기능을 구현하게 된다.</strong></em></li>\n<li>레파지토리 인터페이스는 주로 도메인 영역에 속하게 되며, 해당 인터페이스의 구현체는 실제 구현 기술을 사용하게 됨에 따라 인프라스트럭처 영역에 속하게 된다.</li>\n<li><em>응용영역과 밀접한 관련</em>이 있으며, 응용 영역에서는 필요한 도메인 객체를 조회하거나 저장 할때 레파지토리를 참조하게 된다. 또한, 응용 영역의 트랜잭션 관리는 레파지토리를 구현하는 기술에 영향을 받을 수 밖에 없다.</li>\n</ul>\n<h2 id=\"인프라스트럭처\"><a href=\"#인프라스트럭처\" class=\"headerlink\" title=\"인프라스트럭처\"></a>인프라스트럭처</h2><ul>\n<li>표현, 응용, 도메인을 영역을 지원하는 역할을 수행</li>\n<li>위에서 설명한 DIP처럼, 인프라스트럭처 레이어의 기능을 바로 사용하는 것이 아니라 인터페이스를 통하여 참조/구현하는 것이 테스트 하기 쉽게 만들어주며 변경에 용이하게 해준다.</li>\n</ul>\n<h2 id=\"모듈-구성-패키지-구조는\"><a href=\"#모듈-구성-패키지-구조는\" class=\"headerlink\" title=\"모듈 구성/패키지 구조는?\"></a>모듈 구성/패키지 구조는?</h2><h3 id=\"영역별로-구성\"><a href=\"#영역별로-구성\" class=\"headerlink\" title=\"영역별로 구성\"></a>영역별로 구성</h3><ul>\n<li>응용/도메인 모듈에서는 연관 서비스/엔티티끼리 묶어서 다시 패키징을 할 수 있다.<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-- presentation</span><br><span class=\"line\">|-- domain</span><br><span class=\"line\">    |-- order</span><br><span class=\"line\">    |-- member</span><br><span class=\"line\">|-- application</span><br><span class=\"line\">    |-- order</span><br><span class=\"line\">    |-- member</span><br><span class=\"line\">|-- infrastructure</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"도메인별로-구성\"><a href=\"#도메인별로-구성\" class=\"headerlink\" title=\"도메인별로 구성\"></a>도메인별로 구성</h3><ul>\n<li>도메인이 크다면 서브 도메인(하위 도메인)별로 나뉘는 전략<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-- order</span><br><span class=\"line\">    |-- presentation</span><br><span class=\"line\">    |-- domain</span><br><span class=\"line\">    |-- application</span><br><span class=\"line\">    |-- infrastructure</span><br><span class=\"line\">|-- member</span><br><span class=\"line\">    |-- presentation</span><br><span class=\"line\">    |-- domain</span><br><span class=\"line\">    |-- application</span><br><span class=\"line\">    |-- infrastructure</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"Spring-프로젝트에서의-일반-구조는\"><a href=\"#Spring-프로젝트에서의-일반-구조는\" class=\"headerlink\" title=\"Spring 프로젝트에서의 일반 구조는?\"></a>Spring 프로젝트에서의 일반 구조는?</h3><p>위에서 정리한 패키지 구조/명칭을 그대로 따라는 것도 좋은 접근이지만 여태까지 겪어봤던 구조도 한번 다시 정리해보는 것이 좋을거 같아 아래에 기술해봤다. </p>\n<h4 id=\"레이어-패키지-단위-구조\"><a href=\"#레이어-패키지-단위-구조\" class=\"headerlink\" title=\"레이어 패키지 단위 구조\"></a>레이어 패키지 단위 구조</h4><ul>\n<li>레이어 단위로 구성하는 방법</li>\n<li>개인적으로 적절한 팀에서의 가이드가 존재하지 않는다면 선호하지 않는 방법이다. 왜냐하면, 무분별한 DI가 쉽게 발생 할 수 있으며, 각 레이어에서 개별 모듈이 관심사가 다른 레이어의 모듈이나 객체를 쉽게 참조할 수 있게 되기 때문이다. <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-- controller</span><br><span class=\"line\">|-- service</span><br><span class=\"line\">|-- repository</span><br><span class=\"line\">|-- model</span><br><span class=\"line\">|-- config</span><br><span class=\"line\">|-- Application.java</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"도메인-단위의-패키지-구조\"><a href=\"#도메인-단위의-패키지-구조\" class=\"headerlink\" title=\"도메인 단위의 패키지 구조\"></a>도메인 단위의 패키지 구조</h4><ul>\n<li>관심 도메인별로 패키지 구조를 작성</li>\n<li>위에서도 언급한 내용대로 개별 도메인별로 타입의 개수가 늘어나거나 관심사별로 다시 분리해야 할 경우 도메인 패키지내에서 다시 분리하는 전략도 취해볼 수 있다.<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-- order</span><br><span class=\"line\">    |-- OrderController.java</span><br><span class=\"line\">    |-- OrderService.java</span><br><span class=\"line\">    |-- OrderRepository.java</span><br><span class=\"line\">    |-- Order.java</span><br><span class=\"line\">    |-- OrderLine.java</span><br><span class=\"line\">    |-- Orderer.java</span><br><span class=\"line\">|-- member</span><br><span class=\"line\">|-- config</span><br><span class=\"line\">|-- Application.java</span><br></pre></td></tr></table></figure></li>\n</ul>\n<blockquote>\n<p>결국 레이어 단위로 두느냐 아니면 도메인 단위로 두느냐는 같이 프로젝트를 수행하는 구성원들의 호불호에 의해서도 달라질 수 있고, 도메인별로 상호간에 참조가 아예 안되는 상황인지 아닌지 유무도 중요하게 된다. 무분별하게 어떤 접근이 맞다는 의견보다는 상황과 요구사항 그리고 팀원들의 이해도에 집중하여 접근하는 것이 중요하다고 할수 있다.</p>\n</blockquote>\n"},{"title":"20190304","date":"2019-03-03T15:00:00.000Z","_content":"\n# 20190304\n\n# 1. Effective-Java-3e 읽기/실습\n\n![effectiveJava](https://i.imgur.com/4P2MqzJ.jpg)\n\n- 아이템 18. 상속보다는 컴포지션을 사용하라\n- 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라\n\n# 2. 함수형 코틀린\n\n![arrow](https://i.imgur.com/kgoUbmH.jpg)\n\n* 11장. 코틀린에서 스트림 작업\n    - Collection vs Stream\n    - Stream vs Observable\n    - Push Model vs Pull Model\n    - 코틀린에서 Stream 생성\n    - Termianl Method\n* 12장. 애로우 시작\n    - 함수 합성(Compose)\n    - 부분 적용\n    - Pipe\n    - Curry\n    - Arrow 구현체를 활용한 불변객체 lense 방법\n\n# 3.  Bean Validation 2.0\n* `@RequestBody`를 활용한 요청 본문 Validation 중 해당 구현에 대해 조금 더 살펴보고자 [링크](https://beanvalidation.org/2.0/spec/#constraintdeclarationvalidationprocess-containerelementconstraints)를 살펴보게 되었다.\n* API 개발을 하면서 모르는 내용을 틈틈히 읽어보고 이렇게 글로 남기는 것이 중요한거 같다.","source":"_posts/DIARY/20190304.md","raw":"---\ntitle: 20190304\ndate: 2019/3/4 00:00:00\ncategories:\n- DIARY\n---\n\n# 20190304\n\n# 1. Effective-Java-3e 읽기/실습\n\n![effectiveJava](https://i.imgur.com/4P2MqzJ.jpg)\n\n- 아이템 18. 상속보다는 컴포지션을 사용하라\n- 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라\n\n# 2. 함수형 코틀린\n\n![arrow](https://i.imgur.com/kgoUbmH.jpg)\n\n* 11장. 코틀린에서 스트림 작업\n    - Collection vs Stream\n    - Stream vs Observable\n    - Push Model vs Pull Model\n    - 코틀린에서 Stream 생성\n    - Termianl Method\n* 12장. 애로우 시작\n    - 함수 합성(Compose)\n    - 부분 적용\n    - Pipe\n    - Curry\n    - Arrow 구현체를 활용한 불변객체 lense 방법\n\n# 3.  Bean Validation 2.0\n* `@RequestBody`를 활용한 요청 본문 Validation 중 해당 구현에 대해 조금 더 살펴보고자 [링크](https://beanvalidation.org/2.0/spec/#constraintdeclarationvalidationprocess-containerelementconstraints)를 살펴보게 되었다.\n* API 개발을 하면서 모르는 내용을 틈틈히 읽어보고 이렇게 글로 남기는 것이 중요한거 같다.","slug":"DIARY/20190304","published":1,"updated":"2021-08-02T12:02:04.038Z","_id":"ckrsup4zv000atjhv99hzf6km","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20190304\"><a href=\"#20190304\" class=\"headerlink\" title=\"20190304\"></a>20190304</h1><h1 id=\"1-Effective-Java-3e-읽기-실습\"><a href=\"#1-Effective-Java-3e-읽기-실습\" class=\"headerlink\" title=\"1. Effective-Java-3e 읽기/실습\"></a>1. Effective-Java-3e 읽기/실습</h1><p><img src=\"https://i.imgur.com/4P2MqzJ.jpg\" alt=\"effectiveJava\"></p>\n<ul>\n<li>아이템 18. 상속보다는 컴포지션을 사용하라</li>\n<li>아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라</li>\n</ul>\n<h1 id=\"2-함수형-코틀린\"><a href=\"#2-함수형-코틀린\" class=\"headerlink\" title=\"2. 함수형 코틀린\"></a>2. 함수형 코틀린</h1><p><img src=\"https://i.imgur.com/kgoUbmH.jpg\" alt=\"arrow\"></p>\n<ul>\n<li>11장. 코틀린에서 스트림 작업<ul>\n<li>Collection vs Stream</li>\n<li>Stream vs Observable</li>\n<li>Push Model vs Pull Model</li>\n<li>코틀린에서 Stream 생성</li>\n<li>Termianl Method</li>\n</ul>\n</li>\n<li>12장. 애로우 시작<ul>\n<li>함수 합성(Compose)</li>\n<li>부분 적용</li>\n<li>Pipe</li>\n<li>Curry</li>\n<li>Arrow 구현체를 활용한 불변객체 lense 방법</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"3-Bean-Validation-2-0\"><a href=\"#3-Bean-Validation-2-0\" class=\"headerlink\" title=\"3.  Bean Validation 2.0\"></a>3.  Bean Validation 2.0</h1><ul>\n<li><code>@RequestBody</code>를 활용한 요청 본문 Validation 중 해당 구현에 대해 조금 더 살펴보고자 <a href=\"https://beanvalidation.org/2.0/spec/#constraintdeclarationvalidationprocess-containerelementconstraints\">링크</a>를 살펴보게 되었다.</li>\n<li>API 개발을 하면서 모르는 내용을 틈틈히 읽어보고 이렇게 글로 남기는 것이 중요한거 같다.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20190304\"><a href=\"#20190304\" class=\"headerlink\" title=\"20190304\"></a>20190304</h1><h1 id=\"1-Effective-Java-3e-읽기-실습\"><a href=\"#1-Effective-Java-3e-읽기-실습\" class=\"headerlink\" title=\"1. Effective-Java-3e 읽기/실습\"></a>1. Effective-Java-3e 읽기/실습</h1><p><img src=\"https://i.imgur.com/4P2MqzJ.jpg\" alt=\"effectiveJava\"></p>\n<ul>\n<li>아이템 18. 상속보다는 컴포지션을 사용하라</li>\n<li>아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라</li>\n</ul>\n<h1 id=\"2-함수형-코틀린\"><a href=\"#2-함수형-코틀린\" class=\"headerlink\" title=\"2. 함수형 코틀린\"></a>2. 함수형 코틀린</h1><p><img src=\"https://i.imgur.com/kgoUbmH.jpg\" alt=\"arrow\"></p>\n<ul>\n<li>11장. 코틀린에서 스트림 작업<ul>\n<li>Collection vs Stream</li>\n<li>Stream vs Observable</li>\n<li>Push Model vs Pull Model</li>\n<li>코틀린에서 Stream 생성</li>\n<li>Termianl Method</li>\n</ul>\n</li>\n<li>12장. 애로우 시작<ul>\n<li>함수 합성(Compose)</li>\n<li>부분 적용</li>\n<li>Pipe</li>\n<li>Curry</li>\n<li>Arrow 구현체를 활용한 불변객체 lense 방법</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"3-Bean-Validation-2-0\"><a href=\"#3-Bean-Validation-2-0\" class=\"headerlink\" title=\"3.  Bean Validation 2.0\"></a>3.  Bean Validation 2.0</h1><ul>\n<li><code>@RequestBody</code>를 활용한 요청 본문 Validation 중 해당 구현에 대해 조금 더 살펴보고자 <a href=\"https://beanvalidation.org/2.0/spec/#constraintdeclarationvalidationprocess-containerelementconstraints\">링크</a>를 살펴보게 되었다.</li>\n<li>API 개발을 하면서 모르는 내용을 틈틈히 읽어보고 이렇게 글로 남기는 것이 중요한거 같다.</li>\n</ul>\n"},{"title":"20190305","date":"2019-03-04T15:00:00.000Z","_content":"\n# 20190305\n# 1. Effective-Java-3e 읽기/실습\n- 아이템 20. 추상 클래스보다는 인터페이스를 우선하라 \n- 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라 \n\n자바8의 디폴트 메소드에 대한 언급과 더불어 추상화를 위한 구현 방법으로 인터페이스 단독으로 사용하는 경우와 추상클래스를 인터페이스의 구현으로 사용하고 조금 더 확장성 있는 클래스 구조를 가질 수 있도록 설명하는 구절이 인상적이었다. 인터페이스 역시 앞에서의 아이템 설명처럼 충분히 문서화하고 구현에 설명을 자세히 써주는 것이 중요한 구절 역시 보면서 무릎을 탁!\n\n# 2. @JsonView\n```kotlin\nclass LoanContractViews {\n    interface Simple\n    interface Detailed : Simple\n}\n```\njson 반환 데이터를 다이나믹하게 해줘야 할 요구사항이 생겼는데, 이를 처리 하려고 생각하다보니 이전에 사용했던 @JsonView가 얼핏 생각나서 기억을 꺼내서 다시 사용해봤다. 역시 편리하다\n\n# 3. @ReqeustBody Setter 관련\n[링크](https://jojoldu.tistory.com/407)를 읽고 새삼 반성하는 부분이 많았다. 당연히 getter/setter를 만들어서 작업했었고, 이에 대한 값 바인딩이 당연히 setter 기준으로 진행되리라 생각하고 있었는데, 실제로 @ReqeustBody에 대해서는 세터 주입이 안일어나고 Jackson2HttpMessageConverter를 이용한 값 바인딩이 이뤄진다는 사실을 알았다. 근데, Get 요청에 대한 QueryParameter에 대해서는 반드시 setter가 필요하다 by WebDataBinder","source":"_posts/DIARY/20190305.md","raw":"---\ntitle: 20190305\ndate: 2019/3/5 00:00:00\ncategories:\n- DIARY\n---\n\n# 20190305\n# 1. Effective-Java-3e 읽기/실습\n- 아이템 20. 추상 클래스보다는 인터페이스를 우선하라 \n- 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라 \n\n자바8의 디폴트 메소드에 대한 언급과 더불어 추상화를 위한 구현 방법으로 인터페이스 단독으로 사용하는 경우와 추상클래스를 인터페이스의 구현으로 사용하고 조금 더 확장성 있는 클래스 구조를 가질 수 있도록 설명하는 구절이 인상적이었다. 인터페이스 역시 앞에서의 아이템 설명처럼 충분히 문서화하고 구현에 설명을 자세히 써주는 것이 중요한 구절 역시 보면서 무릎을 탁!\n\n# 2. @JsonView\n```kotlin\nclass LoanContractViews {\n    interface Simple\n    interface Detailed : Simple\n}\n```\njson 반환 데이터를 다이나믹하게 해줘야 할 요구사항이 생겼는데, 이를 처리 하려고 생각하다보니 이전에 사용했던 @JsonView가 얼핏 생각나서 기억을 꺼내서 다시 사용해봤다. 역시 편리하다\n\n# 3. @ReqeustBody Setter 관련\n[링크](https://jojoldu.tistory.com/407)를 읽고 새삼 반성하는 부분이 많았다. 당연히 getter/setter를 만들어서 작업했었고, 이에 대한 값 바인딩이 당연히 setter 기준으로 진행되리라 생각하고 있었는데, 실제로 @ReqeustBody에 대해서는 세터 주입이 안일어나고 Jackson2HttpMessageConverter를 이용한 값 바인딩이 이뤄진다는 사실을 알았다. 근데, Get 요청에 대한 QueryParameter에 대해서는 반드시 setter가 필요하다 by WebDataBinder","slug":"DIARY/20190305","published":1,"updated":"2021-08-02T12:03:29.952Z","_id":"ckrsup4zw000btjhv05uwayxc","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20190305\"><a href=\"#20190305\" class=\"headerlink\" title=\"20190305\"></a>20190305</h1><h1 id=\"1-Effective-Java-3e-읽기-실습\"><a href=\"#1-Effective-Java-3e-읽기-실습\" class=\"headerlink\" title=\"1. Effective-Java-3e 읽기/실습\"></a>1. Effective-Java-3e 읽기/실습</h1><ul>\n<li>아이템 20. 추상 클래스보다는 인터페이스를 우선하라 </li>\n<li>아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라 </li>\n</ul>\n<p>자바8의 디폴트 메소드에 대한 언급과 더불어 추상화를 위한 구현 방법으로 인터페이스 단독으로 사용하는 경우와 추상클래스를 인터페이스의 구현으로 사용하고 조금 더 확장성 있는 클래스 구조를 가질 수 있도록 설명하는 구절이 인상적이었다. 인터페이스 역시 앞에서의 아이템 설명처럼 충분히 문서화하고 구현에 설명을 자세히 써주는 것이 중요한 구절 역시 보면서 무릎을 탁!</p>\n<h1 id=\"2-JsonView\"><a href=\"#2-JsonView\" class=\"headerlink\" title=\"2. @JsonView\"></a>2. @JsonView</h1><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoanContractViews</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Simple</span></span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Detailed</span> : <span class=\"type\">Simple</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>json 반환 데이터를 다이나믹하게 해줘야 할 요구사항이 생겼는데, 이를 처리 하려고 생각하다보니 이전에 사용했던 @JsonView가 얼핏 생각나서 기억을 꺼내서 다시 사용해봤다. 역시 편리하다</p>\n<h1 id=\"3-ReqeustBody-Setter-관련\"><a href=\"#3-ReqeustBody-Setter-관련\" class=\"headerlink\" title=\"3. @ReqeustBody Setter 관련\"></a>3. @ReqeustBody Setter 관련</h1><p><a href=\"https://jojoldu.tistory.com/407\">링크</a>를 읽고 새삼 반성하는 부분이 많았다. 당연히 getter/setter를 만들어서 작업했었고, 이에 대한 값 바인딩이 당연히 setter 기준으로 진행되리라 생각하고 있었는데, 실제로 @ReqeustBody에 대해서는 세터 주입이 안일어나고 Jackson2HttpMessageConverter를 이용한 값 바인딩이 이뤄진다는 사실을 알았다. 근데, Get 요청에 대한 QueryParameter에 대해서는 반드시 setter가 필요하다 by WebDataBinder</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20190305\"><a href=\"#20190305\" class=\"headerlink\" title=\"20190305\"></a>20190305</h1><h1 id=\"1-Effective-Java-3e-읽기-실습\"><a href=\"#1-Effective-Java-3e-읽기-실습\" class=\"headerlink\" title=\"1. Effective-Java-3e 읽기/실습\"></a>1. Effective-Java-3e 읽기/실습</h1><ul>\n<li>아이템 20. 추상 클래스보다는 인터페이스를 우선하라 </li>\n<li>아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라 </li>\n</ul>\n<p>자바8의 디폴트 메소드에 대한 언급과 더불어 추상화를 위한 구현 방법으로 인터페이스 단독으로 사용하는 경우와 추상클래스를 인터페이스의 구현으로 사용하고 조금 더 확장성 있는 클래스 구조를 가질 수 있도록 설명하는 구절이 인상적이었다. 인터페이스 역시 앞에서의 아이템 설명처럼 충분히 문서화하고 구현에 설명을 자세히 써주는 것이 중요한 구절 역시 보면서 무릎을 탁!</p>\n<h1 id=\"2-JsonView\"><a href=\"#2-JsonView\" class=\"headerlink\" title=\"2. @JsonView\"></a>2. @JsonView</h1><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoanContractViews</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Simple</span></span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Detailed</span> : <span class=\"type\">Simple</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>json 반환 데이터를 다이나믹하게 해줘야 할 요구사항이 생겼는데, 이를 처리 하려고 생각하다보니 이전에 사용했던 @JsonView가 얼핏 생각나서 기억을 꺼내서 다시 사용해봤다. 역시 편리하다</p>\n<h1 id=\"3-ReqeustBody-Setter-관련\"><a href=\"#3-ReqeustBody-Setter-관련\" class=\"headerlink\" title=\"3. @ReqeustBody Setter 관련\"></a>3. @ReqeustBody Setter 관련</h1><p><a href=\"https://jojoldu.tistory.com/407\">링크</a>를 읽고 새삼 반성하는 부분이 많았다. 당연히 getter/setter를 만들어서 작업했었고, 이에 대한 값 바인딩이 당연히 setter 기준으로 진행되리라 생각하고 있었는데, 실제로 @ReqeustBody에 대해서는 세터 주입이 안일어나고 Jackson2HttpMessageConverter를 이용한 값 바인딩이 이뤄진다는 사실을 알았다. 근데, Get 요청에 대한 QueryParameter에 대해서는 반드시 setter가 필요하다 by WebDataBinder</p>\n"},{"title":"20190307","date":"2019-03-06T15:00:00.000Z","_content":"\n# 20190305\n# Spring-Cloud-Feign 관련 삽질\n```kotlin\n\n```\n\nFeign Client로 RequestBody가 있는 자\n\n","source":"_posts/DIARY/20190307.md","raw":"---\ntitle: 20190307\ndate: 2019/3/7 00:00:00\ncategories:\n- DIARY\n---\n\n# 20190305\n# Spring-Cloud-Feign 관련 삽질\n```kotlin\n\n```\n\nFeign Client로 RequestBody가 있는 자\n\n","slug":"DIARY/20190307","published":1,"updated":"2021-08-02T12:01:52.935Z","_id":"ckrsup4zw000ctjhv8w020z6o","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20190305\"><a href=\"#20190305\" class=\"headerlink\" title=\"20190305\"></a>20190305</h1><h1 id=\"Spring-Cloud-Feign-관련-삽질\"><a href=\"#Spring-Cloud-Feign-관련-삽질\" class=\"headerlink\" title=\"Spring-Cloud-Feign 관련 삽질\"></a>Spring-Cloud-Feign 관련 삽질</h1><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Feign Client로 RequestBody가 있는 자</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20190305\"><a href=\"#20190305\" class=\"headerlink\" title=\"20190305\"></a>20190305</h1><h1 id=\"Spring-Cloud-Feign-관련-삽질\"><a href=\"#Spring-Cloud-Feign-관련-삽질\" class=\"headerlink\" title=\"Spring-Cloud-Feign 관련 삽질\"></a>Spring-Cloud-Feign 관련 삽질</h1><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Feign Client로 RequestBody가 있는 자</p>\n"},{"title":"20190311","date":"2019-03-10T15:00:00.000Z","_content":"\n# 20190311\n## 1. 함께 자라기 애자일로 가는길\n- [링크](https://book.naver.com/bookdb/book_detail.nhn?bid=14341885)\n\n회사 교육비로 구매한 책이다. 매번 기술 서적만 목을 매어 읽어왔는데, 이번에는 기술 서적이 개발과 관련된 여러 가지 이야기가 담긴 책을 읽어보고 싶었다. 그래서 선택한 책이다. 책은 반 정도 읽은 거 같은데, 나 말고 주변 다른 사람들과 함께 잘 성장하는 방법 그리고 의식적인 학습을 어떻게 잘 할 것인가에 대해 써놓은 글이 매우 인상 깊었다. 두꺼운 책은 아니라서 끝까지 읽는 것에는 부담이 크게 없을 거 같으니 틈틈이 읽어 봐야겠다.\n\n## 2. JPA And Database Lock\n회사 업무 중 복잡한 데이터 처리 과정이 담긴 API를 개발하고 있다. 기존 레거시 시스템을 개선하는 작업이기도 하고 신규 솔루션과 연동해야 하는 업무라서 은근 골치가 아프다. 특히 Lock을 제어해야 하는 코드가 생기고 있는데, 여태까지 데이터베이스를 쓰면서 크게 락에 대한 고민이나 학습을 깊게 안하고 코딩을 했었던 것 같아 스스로에게 반성을 많이 했던 하루였다. \n\n현재 회사에서 데이터베이스에 대한 접근을 JPA + QueryDsl 조합으로 사용하고 있는데 Lock에 대한 접근을 데이터베이스에서의 Read Lock, Write Lock 정도의 구분으로 접근하는 것이 아니라 `낙관적인 락` 그리고 `비관적인 락`으로 크게 나누어서 분류하고 있으며, 이에 대한 세부 구현도 달라지는 것을 오늘 처음 알았다.\n\n영속성 컨텍스트가 관리해주는 락도 존재하고 있었는데, 이 부분에 대해서는 좀 더 깊게 공부를 해봐야 할거 같다. JPA를 사용하면서 이것저것 재미있게 공부해볼 수 있는 주제가 많은 거 같아서 기쁜 마음도 들지만 한편으로 해야 할 공부가 점점 많아지는 거 같아 괜스레 마음이 더 무거워진다.","source":"_posts/DIARY/20190311.md","raw":"---\ntitle: 20190311\ndate: 2019/3/11 00:00:00\ncategories:\n- DIARY\n---\n\n# 20190311\n## 1. 함께 자라기 애자일로 가는길\n- [링크](https://book.naver.com/bookdb/book_detail.nhn?bid=14341885)\n\n회사 교육비로 구매한 책이다. 매번 기술 서적만 목을 매어 읽어왔는데, 이번에는 기술 서적이 개발과 관련된 여러 가지 이야기가 담긴 책을 읽어보고 싶었다. 그래서 선택한 책이다. 책은 반 정도 읽은 거 같은데, 나 말고 주변 다른 사람들과 함께 잘 성장하는 방법 그리고 의식적인 학습을 어떻게 잘 할 것인가에 대해 써놓은 글이 매우 인상 깊었다. 두꺼운 책은 아니라서 끝까지 읽는 것에는 부담이 크게 없을 거 같으니 틈틈이 읽어 봐야겠다.\n\n## 2. JPA And Database Lock\n회사 업무 중 복잡한 데이터 처리 과정이 담긴 API를 개발하고 있다. 기존 레거시 시스템을 개선하는 작업이기도 하고 신규 솔루션과 연동해야 하는 업무라서 은근 골치가 아프다. 특히 Lock을 제어해야 하는 코드가 생기고 있는데, 여태까지 데이터베이스를 쓰면서 크게 락에 대한 고민이나 학습을 깊게 안하고 코딩을 했었던 것 같아 스스로에게 반성을 많이 했던 하루였다. \n\n현재 회사에서 데이터베이스에 대한 접근을 JPA + QueryDsl 조합으로 사용하고 있는데 Lock에 대한 접근을 데이터베이스에서의 Read Lock, Write Lock 정도의 구분으로 접근하는 것이 아니라 `낙관적인 락` 그리고 `비관적인 락`으로 크게 나누어서 분류하고 있으며, 이에 대한 세부 구현도 달라지는 것을 오늘 처음 알았다.\n\n영속성 컨텍스트가 관리해주는 락도 존재하고 있었는데, 이 부분에 대해서는 좀 더 깊게 공부를 해봐야 할거 같다. JPA를 사용하면서 이것저것 재미있게 공부해볼 수 있는 주제가 많은 거 같아서 기쁜 마음도 들지만 한편으로 해야 할 공부가 점점 많아지는 거 같아 괜스레 마음이 더 무거워진다.","slug":"DIARY/20190311","published":1,"updated":"2021-08-02T12:01:46.840Z","_id":"ckrsup4zx000dtjhve6uk9pxy","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20190311\"><a href=\"#20190311\" class=\"headerlink\" title=\"20190311\"></a>20190311</h1><h2 id=\"1-함께-자라기-애자일로-가는길\"><a href=\"#1-함께-자라기-애자일로-가는길\" class=\"headerlink\" title=\"1. 함께 자라기 애자일로 가는길\"></a>1. 함께 자라기 애자일로 가는길</h2><ul>\n<li><a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=14341885\">링크</a></li>\n</ul>\n<p>회사 교육비로 구매한 책이다. 매번 기술 서적만 목을 매어 읽어왔는데, 이번에는 기술 서적이 개발과 관련된 여러 가지 이야기가 담긴 책을 읽어보고 싶었다. 그래서 선택한 책이다. 책은 반 정도 읽은 거 같은데, 나 말고 주변 다른 사람들과 함께 잘 성장하는 방법 그리고 의식적인 학습을 어떻게 잘 할 것인가에 대해 써놓은 글이 매우 인상 깊었다. 두꺼운 책은 아니라서 끝까지 읽는 것에는 부담이 크게 없을 거 같으니 틈틈이 읽어 봐야겠다.</p>\n<h2 id=\"2-JPA-And-Database-Lock\"><a href=\"#2-JPA-And-Database-Lock\" class=\"headerlink\" title=\"2. JPA And Database Lock\"></a>2. JPA And Database Lock</h2><p>회사 업무 중 복잡한 데이터 처리 과정이 담긴 API를 개발하고 있다. 기존 레거시 시스템을 개선하는 작업이기도 하고 신규 솔루션과 연동해야 하는 업무라서 은근 골치가 아프다. 특히 Lock을 제어해야 하는 코드가 생기고 있는데, 여태까지 데이터베이스를 쓰면서 크게 락에 대한 고민이나 학습을 깊게 안하고 코딩을 했었던 것 같아 스스로에게 반성을 많이 했던 하루였다. </p>\n<p>현재 회사에서 데이터베이스에 대한 접근을 JPA + QueryDsl 조합으로 사용하고 있는데 Lock에 대한 접근을 데이터베이스에서의 Read Lock, Write Lock 정도의 구분으로 접근하는 것이 아니라 <code>낙관적인 락</code> 그리고 <code>비관적인 락</code>으로 크게 나누어서 분류하고 있으며, 이에 대한 세부 구현도 달라지는 것을 오늘 처음 알았다.</p>\n<p>영속성 컨텍스트가 관리해주는 락도 존재하고 있었는데, 이 부분에 대해서는 좀 더 깊게 공부를 해봐야 할거 같다. JPA를 사용하면서 이것저것 재미있게 공부해볼 수 있는 주제가 많은 거 같아서 기쁜 마음도 들지만 한편으로 해야 할 공부가 점점 많아지는 거 같아 괜스레 마음이 더 무거워진다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20190311\"><a href=\"#20190311\" class=\"headerlink\" title=\"20190311\"></a>20190311</h1><h2 id=\"1-함께-자라기-애자일로-가는길\"><a href=\"#1-함께-자라기-애자일로-가는길\" class=\"headerlink\" title=\"1. 함께 자라기 애자일로 가는길\"></a>1. 함께 자라기 애자일로 가는길</h2><ul>\n<li><a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=14341885\">링크</a></li>\n</ul>\n<p>회사 교육비로 구매한 책이다. 매번 기술 서적만 목을 매어 읽어왔는데, 이번에는 기술 서적이 개발과 관련된 여러 가지 이야기가 담긴 책을 읽어보고 싶었다. 그래서 선택한 책이다. 책은 반 정도 읽은 거 같은데, 나 말고 주변 다른 사람들과 함께 잘 성장하는 방법 그리고 의식적인 학습을 어떻게 잘 할 것인가에 대해 써놓은 글이 매우 인상 깊었다. 두꺼운 책은 아니라서 끝까지 읽는 것에는 부담이 크게 없을 거 같으니 틈틈이 읽어 봐야겠다.</p>\n<h2 id=\"2-JPA-And-Database-Lock\"><a href=\"#2-JPA-And-Database-Lock\" class=\"headerlink\" title=\"2. JPA And Database Lock\"></a>2. JPA And Database Lock</h2><p>회사 업무 중 복잡한 데이터 처리 과정이 담긴 API를 개발하고 있다. 기존 레거시 시스템을 개선하는 작업이기도 하고 신규 솔루션과 연동해야 하는 업무라서 은근 골치가 아프다. 특히 Lock을 제어해야 하는 코드가 생기고 있는데, 여태까지 데이터베이스를 쓰면서 크게 락에 대한 고민이나 학습을 깊게 안하고 코딩을 했었던 것 같아 스스로에게 반성을 많이 했던 하루였다. </p>\n<p>현재 회사에서 데이터베이스에 대한 접근을 JPA + QueryDsl 조합으로 사용하고 있는데 Lock에 대한 접근을 데이터베이스에서의 Read Lock, Write Lock 정도의 구분으로 접근하는 것이 아니라 <code>낙관적인 락</code> 그리고 <code>비관적인 락</code>으로 크게 나누어서 분류하고 있으며, 이에 대한 세부 구현도 달라지는 것을 오늘 처음 알았다.</p>\n<p>영속성 컨텍스트가 관리해주는 락도 존재하고 있었는데, 이 부분에 대해서는 좀 더 깊게 공부를 해봐야 할거 같다. JPA를 사용하면서 이것저것 재미있게 공부해볼 수 있는 주제가 많은 거 같아서 기쁜 마음도 들지만 한편으로 해야 할 공부가 점점 많아지는 거 같아 괜스레 마음이 더 무거워진다.</p>\n"},{"title":"20190501","date":"2019-04-30T15:00:00.000Z","_content":"\n# 20190511\n## 1. 유럽여행\n3월 중순부터 4월 초까지 여행을 다녀왔었다. 1년 가까이 쌓였던 업무 관련 스트레스 때문에 쉴 타이밍이라고 생각했고, 과감하게 20여 일의 시간을 유럽여행으로 시간을 보냈다. 직업병인지는 몰라도 여행을 다니면서도 공부를 안 하면 생기는 일종의 불안한 감정 같은게 없진 않았으나, 그래도 재충전의 시간을 보내고 돌아오니 한결 마음이 가볍다.\n\n\n## 2. RxJava, RxKotlin\n여행을 다녀오고 공부의 방향성에 대해 생각을 해봤다. 부족한 기본기에 대한 공부도 중요하지만, 내가 흥미를 가지고 지속적으로 할 수 있는 공부 역시 중요하다고 생각했다. 그래서 흥미를 가질 수 있는 주제에 대해 고민을 해보다 Reactive 관련 공부를 해보는 게 좋을 거 같아서 책을 바로 구매했다. \n\n- [RxJava 리액티브 프로그래밍](https://book.naver.com/bookdb/book_detail.nhn?bid=14689555)\n\nKotlin을 주력으로 사용하고 있긴 하지만, 실제 JVM에서 돌아가기 때문에 자바에 대한 공부도 빼놓을 수 없다고 늘 생각해왔다. 이러한 연장선상에서 Reactive Stream 구현체인 RxJava를 공부하고 이를 확장하여 Reactor까지 공부하면 좋겠다고 생각했다.\n\n이전에도 Rx에 대한 서적을 안 읽은 것은 아니지만, 이번에 공부하고 있는 책은 아직까지 내용이 꽤 알찬 느낌이다. Publisher/Subscriber 모델에 대한 설명도 꽤 자세하게 해주는 편이고, Reactive Stream 표준 규약부터 이를 구현한 구현체에 대한 상세한 설명까지 덧붙여주고 있어서 나 같이 이쪽 공부를 막 시작한 사람들에게는 많은 도움이 되리라 생각한다.\n\n\n\n\n","source":"_posts/DIARY/20190501.md","raw":"---\ntitle: 20190501\ndate: 2019/5/1 00:00:00\ncategories:\n- DIARY\n---\n\n# 20190511\n## 1. 유럽여행\n3월 중순부터 4월 초까지 여행을 다녀왔었다. 1년 가까이 쌓였던 업무 관련 스트레스 때문에 쉴 타이밍이라고 생각했고, 과감하게 20여 일의 시간을 유럽여행으로 시간을 보냈다. 직업병인지는 몰라도 여행을 다니면서도 공부를 안 하면 생기는 일종의 불안한 감정 같은게 없진 않았으나, 그래도 재충전의 시간을 보내고 돌아오니 한결 마음이 가볍다.\n\n\n## 2. RxJava, RxKotlin\n여행을 다녀오고 공부의 방향성에 대해 생각을 해봤다. 부족한 기본기에 대한 공부도 중요하지만, 내가 흥미를 가지고 지속적으로 할 수 있는 공부 역시 중요하다고 생각했다. 그래서 흥미를 가질 수 있는 주제에 대해 고민을 해보다 Reactive 관련 공부를 해보는 게 좋을 거 같아서 책을 바로 구매했다. \n\n- [RxJava 리액티브 프로그래밍](https://book.naver.com/bookdb/book_detail.nhn?bid=14689555)\n\nKotlin을 주력으로 사용하고 있긴 하지만, 실제 JVM에서 돌아가기 때문에 자바에 대한 공부도 빼놓을 수 없다고 늘 생각해왔다. 이러한 연장선상에서 Reactive Stream 구현체인 RxJava를 공부하고 이를 확장하여 Reactor까지 공부하면 좋겠다고 생각했다.\n\n이전에도 Rx에 대한 서적을 안 읽은 것은 아니지만, 이번에 공부하고 있는 책은 아직까지 내용이 꽤 알찬 느낌이다. Publisher/Subscriber 모델에 대한 설명도 꽤 자세하게 해주는 편이고, Reactive Stream 표준 규약부터 이를 구현한 구현체에 대한 상세한 설명까지 덧붙여주고 있어서 나 같이 이쪽 공부를 막 시작한 사람들에게는 많은 도움이 되리라 생각한다.\n\n\n\n\n","slug":"DIARY/20190501","published":1,"updated":"2021-08-02T12:01:40.448Z","_id":"ckrsup4zy000etjhvb7s607r0","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20190511\"><a href=\"#20190511\" class=\"headerlink\" title=\"20190511\"></a>20190511</h1><h2 id=\"1-유럽여행\"><a href=\"#1-유럽여행\" class=\"headerlink\" title=\"1. 유럽여행\"></a>1. 유럽여행</h2><p>3월 중순부터 4월 초까지 여행을 다녀왔었다. 1년 가까이 쌓였던 업무 관련 스트레스 때문에 쉴 타이밍이라고 생각했고, 과감하게 20여 일의 시간을 유럽여행으로 시간을 보냈다. 직업병인지는 몰라도 여행을 다니면서도 공부를 안 하면 생기는 일종의 불안한 감정 같은게 없진 않았으나, 그래도 재충전의 시간을 보내고 돌아오니 한결 마음이 가볍다.</p>\n<h2 id=\"2-RxJava-RxKotlin\"><a href=\"#2-RxJava-RxKotlin\" class=\"headerlink\" title=\"2. RxJava, RxKotlin\"></a>2. RxJava, RxKotlin</h2><p>여행을 다녀오고 공부의 방향성에 대해 생각을 해봤다. 부족한 기본기에 대한 공부도 중요하지만, 내가 흥미를 가지고 지속적으로 할 수 있는 공부 역시 중요하다고 생각했다. 그래서 흥미를 가질 수 있는 주제에 대해 고민을 해보다 Reactive 관련 공부를 해보는 게 좋을 거 같아서 책을 바로 구매했다. </p>\n<ul>\n<li><a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=14689555\">RxJava 리액티브 프로그래밍</a></li>\n</ul>\n<p>Kotlin을 주력으로 사용하고 있긴 하지만, 실제 JVM에서 돌아가기 때문에 자바에 대한 공부도 빼놓을 수 없다고 늘 생각해왔다. 이러한 연장선상에서 Reactive Stream 구현체인 RxJava를 공부하고 이를 확장하여 Reactor까지 공부하면 좋겠다고 생각했다.</p>\n<p>이전에도 Rx에 대한 서적을 안 읽은 것은 아니지만, 이번에 공부하고 있는 책은 아직까지 내용이 꽤 알찬 느낌이다. Publisher/Subscriber 모델에 대한 설명도 꽤 자세하게 해주는 편이고, Reactive Stream 표준 규약부터 이를 구현한 구현체에 대한 상세한 설명까지 덧붙여주고 있어서 나 같이 이쪽 공부를 막 시작한 사람들에게는 많은 도움이 되리라 생각한다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20190511\"><a href=\"#20190511\" class=\"headerlink\" title=\"20190511\"></a>20190511</h1><h2 id=\"1-유럽여행\"><a href=\"#1-유럽여행\" class=\"headerlink\" title=\"1. 유럽여행\"></a>1. 유럽여행</h2><p>3월 중순부터 4월 초까지 여행을 다녀왔었다. 1년 가까이 쌓였던 업무 관련 스트레스 때문에 쉴 타이밍이라고 생각했고, 과감하게 20여 일의 시간을 유럽여행으로 시간을 보냈다. 직업병인지는 몰라도 여행을 다니면서도 공부를 안 하면 생기는 일종의 불안한 감정 같은게 없진 않았으나, 그래도 재충전의 시간을 보내고 돌아오니 한결 마음이 가볍다.</p>\n<h2 id=\"2-RxJava-RxKotlin\"><a href=\"#2-RxJava-RxKotlin\" class=\"headerlink\" title=\"2. RxJava, RxKotlin\"></a>2. RxJava, RxKotlin</h2><p>여행을 다녀오고 공부의 방향성에 대해 생각을 해봤다. 부족한 기본기에 대한 공부도 중요하지만, 내가 흥미를 가지고 지속적으로 할 수 있는 공부 역시 중요하다고 생각했다. 그래서 흥미를 가질 수 있는 주제에 대해 고민을 해보다 Reactive 관련 공부를 해보는 게 좋을 거 같아서 책을 바로 구매했다. </p>\n<ul>\n<li><a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=14689555\">RxJava 리액티브 프로그래밍</a></li>\n</ul>\n<p>Kotlin을 주력으로 사용하고 있긴 하지만, 실제 JVM에서 돌아가기 때문에 자바에 대한 공부도 빼놓을 수 없다고 늘 생각해왔다. 이러한 연장선상에서 Reactive Stream 구현체인 RxJava를 공부하고 이를 확장하여 Reactor까지 공부하면 좋겠다고 생각했다.</p>\n<p>이전에도 Rx에 대한 서적을 안 읽은 것은 아니지만, 이번에 공부하고 있는 책은 아직까지 내용이 꽤 알찬 느낌이다. Publisher/Subscriber 모델에 대한 설명도 꽤 자세하게 해주는 편이고, Reactive Stream 표준 규약부터 이를 구현한 구현체에 대한 상세한 설명까지 덧붙여주고 있어서 나 같이 이쪽 공부를 막 시작한 사람들에게는 많은 도움이 되리라 생각한다.</p>\n"},{"title":"20190507","date":"2019-05-06T15:00:00.000Z","_content":"\n# 20190507\n## 1. RxJava 리액티브 프로그래밍 읽기/실습\n- 4장, RxJava 연산자\n\n> RxJava와 RxKotlin는 Reactive Stream 구현체에 해당하는 `Flowable`과 `Observable`을 생성할 수 있는 다양한 연산자를 제공하고 있는데, 생성하는 연산자뿐만 아니라 `변환`, `필터`, `결합`, `상태 통지`, `집계` 등의 다양한 연산자를 제공하고 있다. 다양한 연산자는 메서드 체인(MethodChain) 혹은 FluentAPI 방식으로 실제 소비자에게 전달해야 하는 최종 형태의 데이터로 쉽게 변환이 가능하다. 연산자의 종류별로 기본적으로 실행하는 스레드가 달라질 수 있으며, 이에 대한 지정은 별도 스캐줄러 지정을 통하여 변경이 가능하다.\n\n1~3장을 통하여 Flowable/Observable을 생성하는 연산자 예제 코드를 통하여 실습을 하나도 안 빼놓고 해봐서 그런지 4장 첫 부분인 Flowable/Observable을 생성하는 연산자까지는 크게 막힘이 없었다. 변환 연산자를 다루는 부분부터 신경 써서 봐야 할 부분이 많이 보인다. 특히 `flatMap` 연산자를 다루는 여러 가지 방법들 그리고 `concatMap`과 `concatMapEager`의 처리 방식은 비슷하지만 내부 메커니즘은 버퍼를 사용하냐 안하냐로 생각보다 크게 다름을 알 수 있었다.  책에서 설명을 일부러 갈게 안달아 놓은 부분은 잘 안쓰이나? 이런 생각도 들었지만 어차피 한땀 한땀 예제를 작성한다고 해도 실제 업무나 코드를 작성할 때는 까먹는 일이 다반사이니 일단 예제 코드 하나씩 다 타이핑해보면서 개념이랑 감을 익히는게 중요할거 같다.\n\n## 2. 테이블 설계\n한 달 전에 테이블 설계를 할 일이 있어서 작성했던 스키마와 시퀀스 문서를 보면서 급함으로 발생한 오타와 실제 설계를 하면서 놓친 부분에 대해서 수정하여 github에 다시 올려두었다. plantuml을 사용하면서 느끼는 거지만, 편리하면서도 실제로 복잡한 도메인을 그릴 때는 이게 코드를 작성하는 거나 크게 다름이 없음을 매번 느끼곤 한다. 그래도 마우스로 일일이 그리는 수고를 덜어주니 그것만으로도 얼마나 감사한 일인가!\n\n설계를 해놓고 나서 보니, 히스토리 성격의 데이터에 대해 JSON serialize 후 단일 레코드로 보관하는 설계 방법을 선택한 부분이 마음에 걸린다. 차라리, JSON 컬럼을 활용해서 써보는 건 어땠을까 하는 생각도 든다.","source":"_posts/DIARY/20190507.md","raw":"---\ntitle: 20190507\ndate: 2019/5/7 00:00:00\ncategories:\n- DIARY\n---\n\n# 20190507\n## 1. RxJava 리액티브 프로그래밍 읽기/실습\n- 4장, RxJava 연산자\n\n> RxJava와 RxKotlin는 Reactive Stream 구현체에 해당하는 `Flowable`과 `Observable`을 생성할 수 있는 다양한 연산자를 제공하고 있는데, 생성하는 연산자뿐만 아니라 `변환`, `필터`, `결합`, `상태 통지`, `집계` 등의 다양한 연산자를 제공하고 있다. 다양한 연산자는 메서드 체인(MethodChain) 혹은 FluentAPI 방식으로 실제 소비자에게 전달해야 하는 최종 형태의 데이터로 쉽게 변환이 가능하다. 연산자의 종류별로 기본적으로 실행하는 스레드가 달라질 수 있으며, 이에 대한 지정은 별도 스캐줄러 지정을 통하여 변경이 가능하다.\n\n1~3장을 통하여 Flowable/Observable을 생성하는 연산자 예제 코드를 통하여 실습을 하나도 안 빼놓고 해봐서 그런지 4장 첫 부분인 Flowable/Observable을 생성하는 연산자까지는 크게 막힘이 없었다. 변환 연산자를 다루는 부분부터 신경 써서 봐야 할 부분이 많이 보인다. 특히 `flatMap` 연산자를 다루는 여러 가지 방법들 그리고 `concatMap`과 `concatMapEager`의 처리 방식은 비슷하지만 내부 메커니즘은 버퍼를 사용하냐 안하냐로 생각보다 크게 다름을 알 수 있었다.  책에서 설명을 일부러 갈게 안달아 놓은 부분은 잘 안쓰이나? 이런 생각도 들었지만 어차피 한땀 한땀 예제를 작성한다고 해도 실제 업무나 코드를 작성할 때는 까먹는 일이 다반사이니 일단 예제 코드 하나씩 다 타이핑해보면서 개념이랑 감을 익히는게 중요할거 같다.\n\n## 2. 테이블 설계\n한 달 전에 테이블 설계를 할 일이 있어서 작성했던 스키마와 시퀀스 문서를 보면서 급함으로 발생한 오타와 실제 설계를 하면서 놓친 부분에 대해서 수정하여 github에 다시 올려두었다. plantuml을 사용하면서 느끼는 거지만, 편리하면서도 실제로 복잡한 도메인을 그릴 때는 이게 코드를 작성하는 거나 크게 다름이 없음을 매번 느끼곤 한다. 그래도 마우스로 일일이 그리는 수고를 덜어주니 그것만으로도 얼마나 감사한 일인가!\n\n설계를 해놓고 나서 보니, 히스토리 성격의 데이터에 대해 JSON serialize 후 단일 레코드로 보관하는 설계 방법을 선택한 부분이 마음에 걸린다. 차라리, JSON 컬럼을 활용해서 써보는 건 어땠을까 하는 생각도 든다.","slug":"DIARY/20190507","published":1,"updated":"2021-08-02T12:01:29.073Z","_id":"ckrsup4zy000ftjhv09ii5wdi","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20190507\"><a href=\"#20190507\" class=\"headerlink\" title=\"20190507\"></a>20190507</h1><h2 id=\"1-RxJava-리액티브-프로그래밍-읽기-실습\"><a href=\"#1-RxJava-리액티브-프로그래밍-읽기-실습\" class=\"headerlink\" title=\"1. RxJava 리액티브 프로그래밍 읽기/실습\"></a>1. RxJava 리액티브 프로그래밍 읽기/실습</h2><ul>\n<li>4장, RxJava 연산자</li>\n</ul>\n<blockquote>\n<p>RxJava와 RxKotlin는 Reactive Stream 구현체에 해당하는 <code>Flowable</code>과 <code>Observable</code>을 생성할 수 있는 다양한 연산자를 제공하고 있는데, 생성하는 연산자뿐만 아니라 <code>변환</code>, <code>필터</code>, <code>결합</code>, <code>상태 통지</code>, <code>집계</code> 등의 다양한 연산자를 제공하고 있다. 다양한 연산자는 메서드 체인(MethodChain) 혹은 FluentAPI 방식으로 실제 소비자에게 전달해야 하는 최종 형태의 데이터로 쉽게 변환이 가능하다. 연산자의 종류별로 기본적으로 실행하는 스레드가 달라질 수 있으며, 이에 대한 지정은 별도 스캐줄러 지정을 통하여 변경이 가능하다.</p>\n</blockquote>\n<p>1~3장을 통하여 Flowable/Observable을 생성하는 연산자 예제 코드를 통하여 실습을 하나도 안 빼놓고 해봐서 그런지 4장 첫 부분인 Flowable/Observable을 생성하는 연산자까지는 크게 막힘이 없었다. 변환 연산자를 다루는 부분부터 신경 써서 봐야 할 부분이 많이 보인다. 특히 <code>flatMap</code> 연산자를 다루는 여러 가지 방법들 그리고 <code>concatMap</code>과 <code>concatMapEager</code>의 처리 방식은 비슷하지만 내부 메커니즘은 버퍼를 사용하냐 안하냐로 생각보다 크게 다름을 알 수 있었다.  책에서 설명을 일부러 갈게 안달아 놓은 부분은 잘 안쓰이나? 이런 생각도 들었지만 어차피 한땀 한땀 예제를 작성한다고 해도 실제 업무나 코드를 작성할 때는 까먹는 일이 다반사이니 일단 예제 코드 하나씩 다 타이핑해보면서 개념이랑 감을 익히는게 중요할거 같다.</p>\n<h2 id=\"2-테이블-설계\"><a href=\"#2-테이블-설계\" class=\"headerlink\" title=\"2. 테이블 설계\"></a>2. 테이블 설계</h2><p>한 달 전에 테이블 설계를 할 일이 있어서 작성했던 스키마와 시퀀스 문서를 보면서 급함으로 발생한 오타와 실제 설계를 하면서 놓친 부분에 대해서 수정하여 github에 다시 올려두었다. plantuml을 사용하면서 느끼는 거지만, 편리하면서도 실제로 복잡한 도메인을 그릴 때는 이게 코드를 작성하는 거나 크게 다름이 없음을 매번 느끼곤 한다. 그래도 마우스로 일일이 그리는 수고를 덜어주니 그것만으로도 얼마나 감사한 일인가!</p>\n<p>설계를 해놓고 나서 보니, 히스토리 성격의 데이터에 대해 JSON serialize 후 단일 레코드로 보관하는 설계 방법을 선택한 부분이 마음에 걸린다. 차라리, JSON 컬럼을 활용해서 써보는 건 어땠을까 하는 생각도 든다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20190507\"><a href=\"#20190507\" class=\"headerlink\" title=\"20190507\"></a>20190507</h1><h2 id=\"1-RxJava-리액티브-프로그래밍-읽기-실습\"><a href=\"#1-RxJava-리액티브-프로그래밍-읽기-실습\" class=\"headerlink\" title=\"1. RxJava 리액티브 프로그래밍 읽기/실습\"></a>1. RxJava 리액티브 프로그래밍 읽기/실습</h2><ul>\n<li>4장, RxJava 연산자</li>\n</ul>\n<blockquote>\n<p>RxJava와 RxKotlin는 Reactive Stream 구현체에 해당하는 <code>Flowable</code>과 <code>Observable</code>을 생성할 수 있는 다양한 연산자를 제공하고 있는데, 생성하는 연산자뿐만 아니라 <code>변환</code>, <code>필터</code>, <code>결합</code>, <code>상태 통지</code>, <code>집계</code> 등의 다양한 연산자를 제공하고 있다. 다양한 연산자는 메서드 체인(MethodChain) 혹은 FluentAPI 방식으로 실제 소비자에게 전달해야 하는 최종 형태의 데이터로 쉽게 변환이 가능하다. 연산자의 종류별로 기본적으로 실행하는 스레드가 달라질 수 있으며, 이에 대한 지정은 별도 스캐줄러 지정을 통하여 변경이 가능하다.</p>\n</blockquote>\n<p>1~3장을 통하여 Flowable/Observable을 생성하는 연산자 예제 코드를 통하여 실습을 하나도 안 빼놓고 해봐서 그런지 4장 첫 부분인 Flowable/Observable을 생성하는 연산자까지는 크게 막힘이 없었다. 변환 연산자를 다루는 부분부터 신경 써서 봐야 할 부분이 많이 보인다. 특히 <code>flatMap</code> 연산자를 다루는 여러 가지 방법들 그리고 <code>concatMap</code>과 <code>concatMapEager</code>의 처리 방식은 비슷하지만 내부 메커니즘은 버퍼를 사용하냐 안하냐로 생각보다 크게 다름을 알 수 있었다.  책에서 설명을 일부러 갈게 안달아 놓은 부분은 잘 안쓰이나? 이런 생각도 들었지만 어차피 한땀 한땀 예제를 작성한다고 해도 실제 업무나 코드를 작성할 때는 까먹는 일이 다반사이니 일단 예제 코드 하나씩 다 타이핑해보면서 개념이랑 감을 익히는게 중요할거 같다.</p>\n<h2 id=\"2-테이블-설계\"><a href=\"#2-테이블-설계\" class=\"headerlink\" title=\"2. 테이블 설계\"></a>2. 테이블 설계</h2><p>한 달 전에 테이블 설계를 할 일이 있어서 작성했던 스키마와 시퀀스 문서를 보면서 급함으로 발생한 오타와 실제 설계를 하면서 놓친 부분에 대해서 수정하여 github에 다시 올려두었다. plantuml을 사용하면서 느끼는 거지만, 편리하면서도 실제로 복잡한 도메인을 그릴 때는 이게 코드를 작성하는 거나 크게 다름이 없음을 매번 느끼곤 한다. 그래도 마우스로 일일이 그리는 수고를 덜어주니 그것만으로도 얼마나 감사한 일인가!</p>\n<p>설계를 해놓고 나서 보니, 히스토리 성격의 데이터에 대해 JSON serialize 후 단일 레코드로 보관하는 설계 방법을 선택한 부분이 마음에 걸린다. 차라리, JSON 컬럼을 활용해서 써보는 건 어땠을까 하는 생각도 든다.</p>\n"},{"title":"20190526","date":"2019-05-25T15:00:00.000Z","_content":"\n\n# 20190526\n## 1. Rx에 대한 공부 일단 중지!\n최근 약 한달 가량 틈틈히 Rx에 대한 공부를 지속해왔다. 결론부터 말하자면 당분간은 Rx가 아닌 다른 공부에 집중해야 할거 같다. 물론 Rx 자체도 쓰임새가 무척 좋은 생태계라는 점은 부정 할 수 없다. 하지만, 당장 모자란 기본에 대한 공부나 업무와 관련된 학습에 좀 더 투자하는 것이 앞으로 더 크게 도움이 되리라 생각했다. 그만 두는 이유를 간단하게 써보면 아래와 같다.\n- RDB에 대한 지원 부실, 추후에 R2DBC에 대한 생태계가 충분하게 확보되면 그때 시작해도 늦지 않다고 생각했다.\n- Kotlin Coroutine으로도 Rx에서의 처리를 충분히 보완할 수 있다! 역시 비동기와 관련된 코드는 async~await가 최고가 아닐까라고 생각한다. coroutine 자체가 제공해주는 강력한 서포트가 있다면 굳이 Rx가 필요 없을 수 있다!\n## 2. DDD에 대한 공부를 시작해보자\n- DDD Start! 1장, 도메인 모델 시작\n\n아마 DDD를 처음 들어본건 몇 년전의 일인거 같다. 꼭 한번은 책을 읽어보고 업무에서도 어느 정도 적용을 해봐야지 하는 생각만 가지고 있었지 실제로 행동으로 옮기진 못했었다. 책은 DDD Start라는 책을 구매했고, 1장을 정독했는데 책이 어렵지 않고 잘 읽혀서 좋았다. 특히, 도메인 이라는 단어 자체에 대한 이해도가 좀 더 높아져서 좋았고 실제 이를 코드 레벨로 조금씩 구현해보는 책의 전개가 특히 맘에 들었다. 물론, 용어에 대한 정리도 잘되어 있다! 당분간은 관련 개념을 적용하여 포스팅을 작성해볼 생각이고, 이해가 안되는 부분은 별도로 자료를 찾아서 보완하는 방식으로 공부를 진행하면 좋겠다는 생각이 들었다.\n","source":"_posts/DIARY/20190526.md","raw":"---\ntitle: 20190526\ndate: 2019/5/26 00:00:00\ncategories:\n- DIARY\n---\n\n\n# 20190526\n## 1. Rx에 대한 공부 일단 중지!\n최근 약 한달 가량 틈틈히 Rx에 대한 공부를 지속해왔다. 결론부터 말하자면 당분간은 Rx가 아닌 다른 공부에 집중해야 할거 같다. 물론 Rx 자체도 쓰임새가 무척 좋은 생태계라는 점은 부정 할 수 없다. 하지만, 당장 모자란 기본에 대한 공부나 업무와 관련된 학습에 좀 더 투자하는 것이 앞으로 더 크게 도움이 되리라 생각했다. 그만 두는 이유를 간단하게 써보면 아래와 같다.\n- RDB에 대한 지원 부실, 추후에 R2DBC에 대한 생태계가 충분하게 확보되면 그때 시작해도 늦지 않다고 생각했다.\n- Kotlin Coroutine으로도 Rx에서의 처리를 충분히 보완할 수 있다! 역시 비동기와 관련된 코드는 async~await가 최고가 아닐까라고 생각한다. coroutine 자체가 제공해주는 강력한 서포트가 있다면 굳이 Rx가 필요 없을 수 있다!\n## 2. DDD에 대한 공부를 시작해보자\n- DDD Start! 1장, 도메인 모델 시작\n\n아마 DDD를 처음 들어본건 몇 년전의 일인거 같다. 꼭 한번은 책을 읽어보고 업무에서도 어느 정도 적용을 해봐야지 하는 생각만 가지고 있었지 실제로 행동으로 옮기진 못했었다. 책은 DDD Start라는 책을 구매했고, 1장을 정독했는데 책이 어렵지 않고 잘 읽혀서 좋았다. 특히, 도메인 이라는 단어 자체에 대한 이해도가 좀 더 높아져서 좋았고 실제 이를 코드 레벨로 조금씩 구현해보는 책의 전개가 특히 맘에 들었다. 물론, 용어에 대한 정리도 잘되어 있다! 당분간은 관련 개념을 적용하여 포스팅을 작성해볼 생각이고, 이해가 안되는 부분은 별도로 자료를 찾아서 보완하는 방식으로 공부를 진행하면 좋겠다는 생각이 들었다.\n","slug":"DIARY/20190526","published":1,"updated":"2021-08-02T12:01:22.274Z","_id":"ckrsup4zz000gtjhv67zb2wiv","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20190526\"><a href=\"#20190526\" class=\"headerlink\" title=\"20190526\"></a>20190526</h1><h2 id=\"1-Rx에-대한-공부-일단-중지\"><a href=\"#1-Rx에-대한-공부-일단-중지\" class=\"headerlink\" title=\"1. Rx에 대한 공부 일단 중지!\"></a>1. Rx에 대한 공부 일단 중지!</h2><p>최근 약 한달 가량 틈틈히 Rx에 대한 공부를 지속해왔다. 결론부터 말하자면 당분간은 Rx가 아닌 다른 공부에 집중해야 할거 같다. 물론 Rx 자체도 쓰임새가 무척 좋은 생태계라는 점은 부정 할 수 없다. 하지만, 당장 모자란 기본에 대한 공부나 업무와 관련된 학습에 좀 더 투자하는 것이 앞으로 더 크게 도움이 되리라 생각했다. 그만 두는 이유를 간단하게 써보면 아래와 같다.</p>\n<ul>\n<li>RDB에 대한 지원 부실, 추후에 R2DBC에 대한 생태계가 충분하게 확보되면 그때 시작해도 늦지 않다고 생각했다.</li>\n<li>Kotlin Coroutine으로도 Rx에서의 처리를 충분히 보완할 수 있다! 역시 비동기와 관련된 코드는 async~await가 최고가 아닐까라고 생각한다. coroutine 자체가 제공해주는 강력한 서포트가 있다면 굳이 Rx가 필요 없을 수 있다!<h2 id=\"2-DDD에-대한-공부를-시작해보자\"><a href=\"#2-DDD에-대한-공부를-시작해보자\" class=\"headerlink\" title=\"2. DDD에 대한 공부를 시작해보자\"></a>2. DDD에 대한 공부를 시작해보자</h2></li>\n<li>DDD Start! 1장, 도메인 모델 시작</li>\n</ul>\n<p>아마 DDD를 처음 들어본건 몇 년전의 일인거 같다. 꼭 한번은 책을 읽어보고 업무에서도 어느 정도 적용을 해봐야지 하는 생각만 가지고 있었지 실제로 행동으로 옮기진 못했었다. 책은 DDD Start라는 책을 구매했고, 1장을 정독했는데 책이 어렵지 않고 잘 읽혀서 좋았다. 특히, 도메인 이라는 단어 자체에 대한 이해도가 좀 더 높아져서 좋았고 실제 이를 코드 레벨로 조금씩 구현해보는 책의 전개가 특히 맘에 들었다. 물론, 용어에 대한 정리도 잘되어 있다! 당분간은 관련 개념을 적용하여 포스팅을 작성해볼 생각이고, 이해가 안되는 부분은 별도로 자료를 찾아서 보완하는 방식으로 공부를 진행하면 좋겠다는 생각이 들었다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20190526\"><a href=\"#20190526\" class=\"headerlink\" title=\"20190526\"></a>20190526</h1><h2 id=\"1-Rx에-대한-공부-일단-중지\"><a href=\"#1-Rx에-대한-공부-일단-중지\" class=\"headerlink\" title=\"1. Rx에 대한 공부 일단 중지!\"></a>1. Rx에 대한 공부 일단 중지!</h2><p>최근 약 한달 가량 틈틈히 Rx에 대한 공부를 지속해왔다. 결론부터 말하자면 당분간은 Rx가 아닌 다른 공부에 집중해야 할거 같다. 물론 Rx 자체도 쓰임새가 무척 좋은 생태계라는 점은 부정 할 수 없다. 하지만, 당장 모자란 기본에 대한 공부나 업무와 관련된 학습에 좀 더 투자하는 것이 앞으로 더 크게 도움이 되리라 생각했다. 그만 두는 이유를 간단하게 써보면 아래와 같다.</p>\n<ul>\n<li>RDB에 대한 지원 부실, 추후에 R2DBC에 대한 생태계가 충분하게 확보되면 그때 시작해도 늦지 않다고 생각했다.</li>\n<li>Kotlin Coroutine으로도 Rx에서의 처리를 충분히 보완할 수 있다! 역시 비동기와 관련된 코드는 async~await가 최고가 아닐까라고 생각한다. coroutine 자체가 제공해주는 강력한 서포트가 있다면 굳이 Rx가 필요 없을 수 있다!<h2 id=\"2-DDD에-대한-공부를-시작해보자\"><a href=\"#2-DDD에-대한-공부를-시작해보자\" class=\"headerlink\" title=\"2. DDD에 대한 공부를 시작해보자\"></a>2. DDD에 대한 공부를 시작해보자</h2></li>\n<li>DDD Start! 1장, 도메인 모델 시작</li>\n</ul>\n<p>아마 DDD를 처음 들어본건 몇 년전의 일인거 같다. 꼭 한번은 책을 읽어보고 업무에서도 어느 정도 적용을 해봐야지 하는 생각만 가지고 있었지 실제로 행동으로 옮기진 못했었다. 책은 DDD Start라는 책을 구매했고, 1장을 정독했는데 책이 어렵지 않고 잘 읽혀서 좋았다. 특히, 도메인 이라는 단어 자체에 대한 이해도가 좀 더 높아져서 좋았고 실제 이를 코드 레벨로 조금씩 구현해보는 책의 전개가 특히 맘에 들었다. 물론, 용어에 대한 정리도 잘되어 있다! 당분간은 관련 개념을 적용하여 포스팅을 작성해볼 생각이고, 이해가 안되는 부분은 별도로 자료를 찾아서 보완하는 방식으로 공부를 진행하면 좋겠다는 생각이 들었다.</p>\n"},{"title":"20190504","date":"2019-05-03T15:00:00.000Z","_content":"\n# 20190504\n## 1. RxJava 리액티브 프로그래밍 읽기/실습\n- 3장, RxJava 메커니즘\n\n에러처리에 대한 부분부터 배압(Backpressure)까지 학습을 하였고, 에러 처리에 대한 매커니즘부터 배압까지 자연스럽게 내용이 연결되어 있어서 이해하는데에는 크게 무리가 없었다. 다만, 책을 읽으면 읽을수록 봐야 할 API와 구현체에 대한 개수가 늘어나는거 같아서, 책에서만 제공해주는 예제 외에도 실제 구현을 어떻게 하는지에 대해서는 깃헙을 돌아다니면서 코드를 좀 살펴봐야 좀 더 이해가 높아질 수 있을거 같았다. \n\n- 여러개의 생산자와 소비자가 공유 객체를 가질 경우에는?\n  - merge 연산자를 사용하여 다수의 생산자/소비자가 순차접근을 할 수 있도록 동기화 처리 해야 한다.\n\n- 에러처리\n  - 에러처리에 대한 통보\n  - 재시도(retryXX Method)\n  - 대체 데이터 통보(onErrorXX Method)\n\n- 배압 정책/전략 지정\n  - Flowable/Observable 생성 시 지정\n  - 매소드로 지정\n  - 생산자측, 스캐줄러 지정 시(observeOn()) 버퍼 사이즈를 지정\n\n- 배압 정책의 종류\n  - BUFFER\n  - DROP\n  - LATEST\n  - ERROR\n  - NONE\n\n## 2. Effective-Java-3e 읽기/실습\n- 아이템 26, Raw Type은 사용하지 말아라\n\n제네릭을 사용했을 때, 반드시 알아야 할 개념에 대해 소개해주고 있어서, 다른 문서나 글을 읽었을 때 몰랐던 여러 개념을 파악 할 수 있어서 좋았다. 그리고 RawType의 컬렉션 사용에 대한 자바의 히스토리에 대해 알 수 있었고, 제네릭이 도입됨에 따라 가질 수 있는 컴파일 타임의 타입 안전성과 런타임에서의 타입소거 등에 대해서도 예제와 설명를 통하여 확인 할 수 있어서 좋았다. 아래는 책에 나와 있는 내용을 일부 발췌하여 나중에라도 까먹을 경우(??)에 다시 보고자 기록을 해둘려고 한다.\n\n| 용어  | 예  |\n|---|---|\n| 매개변수화 타입(Parameterized Type)  | `List<String>`  |\n| 실제 타입 매개변수(Actual Type Parameter)  | `String`  |\n|  제네릭 타입(Generic Type) | `List<E>`  |\n| 정규 타입 매개변수(Formal Type Parameter)  | `E`  |\n| 비한정적 타입 매개변수(Bounded Type Parameter)  |  `List<?>` |\n| 로우 타입(Raw Type)  | `List`  |\n| 한정적 타입 매개변수(Bounded Type Parameter)  | `List<E extends Number>`  |\n| 재귀적 타입 한정(Recursive Type Bound)  | `<T extends Comparable<T>>`  |\n| 한정적 와일드카드 타입(Bounded Wildcard Type)  | `List<? extends Number>`  |\n| 제네릭 매서드(Generic Method) | `static <E> List<E> asList(E[] a)`  |\n| 타입 토큰(Type Token) | `String.class`  |","source":"_posts/DIARY/20190504.md","raw":"---\ntitle: 20190504\ndate: 2019/5/4 00:00:00\ncategories:\n- DIARY\n---\n\n# 20190504\n## 1. RxJava 리액티브 프로그래밍 읽기/실습\n- 3장, RxJava 메커니즘\n\n에러처리에 대한 부분부터 배압(Backpressure)까지 학습을 하였고, 에러 처리에 대한 매커니즘부터 배압까지 자연스럽게 내용이 연결되어 있어서 이해하는데에는 크게 무리가 없었다. 다만, 책을 읽으면 읽을수록 봐야 할 API와 구현체에 대한 개수가 늘어나는거 같아서, 책에서만 제공해주는 예제 외에도 실제 구현을 어떻게 하는지에 대해서는 깃헙을 돌아다니면서 코드를 좀 살펴봐야 좀 더 이해가 높아질 수 있을거 같았다. \n\n- 여러개의 생산자와 소비자가 공유 객체를 가질 경우에는?\n  - merge 연산자를 사용하여 다수의 생산자/소비자가 순차접근을 할 수 있도록 동기화 처리 해야 한다.\n\n- 에러처리\n  - 에러처리에 대한 통보\n  - 재시도(retryXX Method)\n  - 대체 데이터 통보(onErrorXX Method)\n\n- 배압 정책/전략 지정\n  - Flowable/Observable 생성 시 지정\n  - 매소드로 지정\n  - 생산자측, 스캐줄러 지정 시(observeOn()) 버퍼 사이즈를 지정\n\n- 배압 정책의 종류\n  - BUFFER\n  - DROP\n  - LATEST\n  - ERROR\n  - NONE\n\n## 2. Effective-Java-3e 읽기/실습\n- 아이템 26, Raw Type은 사용하지 말아라\n\n제네릭을 사용했을 때, 반드시 알아야 할 개념에 대해 소개해주고 있어서, 다른 문서나 글을 읽었을 때 몰랐던 여러 개념을 파악 할 수 있어서 좋았다. 그리고 RawType의 컬렉션 사용에 대한 자바의 히스토리에 대해 알 수 있었고, 제네릭이 도입됨에 따라 가질 수 있는 컴파일 타임의 타입 안전성과 런타임에서의 타입소거 등에 대해서도 예제와 설명를 통하여 확인 할 수 있어서 좋았다. 아래는 책에 나와 있는 내용을 일부 발췌하여 나중에라도 까먹을 경우(??)에 다시 보고자 기록을 해둘려고 한다.\n\n| 용어  | 예  |\n|---|---|\n| 매개변수화 타입(Parameterized Type)  | `List<String>`  |\n| 실제 타입 매개변수(Actual Type Parameter)  | `String`  |\n|  제네릭 타입(Generic Type) | `List<E>`  |\n| 정규 타입 매개변수(Formal Type Parameter)  | `E`  |\n| 비한정적 타입 매개변수(Bounded Type Parameter)  |  `List<?>` |\n| 로우 타입(Raw Type)  | `List`  |\n| 한정적 타입 매개변수(Bounded Type Parameter)  | `List<E extends Number>`  |\n| 재귀적 타입 한정(Recursive Type Bound)  | `<T extends Comparable<T>>`  |\n| 한정적 와일드카드 타입(Bounded Wildcard Type)  | `List<? extends Number>`  |\n| 제네릭 매서드(Generic Method) | `static <E> List<E> asList(E[] a)`  |\n| 타입 토큰(Type Token) | `String.class`  |","slug":"DIARY/20190504","published":1,"updated":"2021-08-02T12:01:35.136Z","_id":"ckrsup4zz000htjhvc3338ue3","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20190504\"><a href=\"#20190504\" class=\"headerlink\" title=\"20190504\"></a>20190504</h1><h2 id=\"1-RxJava-리액티브-프로그래밍-읽기-실습\"><a href=\"#1-RxJava-리액티브-프로그래밍-읽기-실습\" class=\"headerlink\" title=\"1. RxJava 리액티브 프로그래밍 읽기/실습\"></a>1. RxJava 리액티브 프로그래밍 읽기/실습</h2><ul>\n<li>3장, RxJava 메커니즘</li>\n</ul>\n<p>에러처리에 대한 부분부터 배압(Backpressure)까지 학습을 하였고, 에러 처리에 대한 매커니즘부터 배압까지 자연스럽게 내용이 연결되어 있어서 이해하는데에는 크게 무리가 없었다. 다만, 책을 읽으면 읽을수록 봐야 할 API와 구현체에 대한 개수가 늘어나는거 같아서, 책에서만 제공해주는 예제 외에도 실제 구현을 어떻게 하는지에 대해서는 깃헙을 돌아다니면서 코드를 좀 살펴봐야 좀 더 이해가 높아질 수 있을거 같았다. </p>\n<ul>\n<li><p>여러개의 생산자와 소비자가 공유 객체를 가질 경우에는?</p>\n<ul>\n<li>merge 연산자를 사용하여 다수의 생산자/소비자가 순차접근을 할 수 있도록 동기화 처리 해야 한다.</li>\n</ul>\n</li>\n<li><p>에러처리</p>\n<ul>\n<li>에러처리에 대한 통보</li>\n<li>재시도(retryXX Method)</li>\n<li>대체 데이터 통보(onErrorXX Method)</li>\n</ul>\n</li>\n<li><p>배압 정책/전략 지정</p>\n<ul>\n<li>Flowable/Observable 생성 시 지정</li>\n<li>매소드로 지정</li>\n<li>생산자측, 스캐줄러 지정 시(observeOn()) 버퍼 사이즈를 지정</li>\n</ul>\n</li>\n<li><p>배압 정책의 종류</p>\n<ul>\n<li>BUFFER</li>\n<li>DROP</li>\n<li>LATEST</li>\n<li>ERROR</li>\n<li>NONE</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-Effective-Java-3e-읽기-실습\"><a href=\"#2-Effective-Java-3e-읽기-실습\" class=\"headerlink\" title=\"2. Effective-Java-3e 읽기/실습\"></a>2. Effective-Java-3e 읽기/실습</h2><ul>\n<li>아이템 26, Raw Type은 사용하지 말아라</li>\n</ul>\n<p>제네릭을 사용했을 때, 반드시 알아야 할 개념에 대해 소개해주고 있어서, 다른 문서나 글을 읽었을 때 몰랐던 여러 개념을 파악 할 수 있어서 좋았다. 그리고 RawType의 컬렉션 사용에 대한 자바의 히스토리에 대해 알 수 있었고, 제네릭이 도입됨에 따라 가질 수 있는 컴파일 타임의 타입 안전성과 런타임에서의 타입소거 등에 대해서도 예제와 설명를 통하여 확인 할 수 있어서 좋았다. 아래는 책에 나와 있는 내용을 일부 발췌하여 나중에라도 까먹을 경우(??)에 다시 보고자 기록을 해둘려고 한다.</p>\n<table>\n<thead>\n<tr>\n<th>용어</th>\n<th>예</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>매개변수화 타입(Parameterized Type)</td>\n<td><code>List&lt;String&gt;</code></td>\n</tr>\n<tr>\n<td>실제 타입 매개변수(Actual Type Parameter)</td>\n<td><code>String</code></td>\n</tr>\n<tr>\n<td>제네릭 타입(Generic Type)</td>\n<td><code>List&lt;E&gt;</code></td>\n</tr>\n<tr>\n<td>정규 타입 매개변수(Formal Type Parameter)</td>\n<td><code>E</code></td>\n</tr>\n<tr>\n<td>비한정적 타입 매개변수(Bounded Type Parameter)</td>\n<td><code>List&lt;?&gt;</code></td>\n</tr>\n<tr>\n<td>로우 타입(Raw Type)</td>\n<td><code>List</code></td>\n</tr>\n<tr>\n<td>한정적 타입 매개변수(Bounded Type Parameter)</td>\n<td><code>List&lt;E extends Number&gt;</code></td>\n</tr>\n<tr>\n<td>재귀적 타입 한정(Recursive Type Bound)</td>\n<td><code>&lt;T extends Comparable&lt;T&gt;&gt;</code></td>\n</tr>\n<tr>\n<td>한정적 와일드카드 타입(Bounded Wildcard Type)</td>\n<td><code>List&lt;? extends Number&gt;</code></td>\n</tr>\n<tr>\n<td>제네릭 매서드(Generic Method)</td>\n<td><code>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</code></td>\n</tr>\n<tr>\n<td>타입 토큰(Type Token)</td>\n<td><code>String.class</code></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20190504\"><a href=\"#20190504\" class=\"headerlink\" title=\"20190504\"></a>20190504</h1><h2 id=\"1-RxJava-리액티브-프로그래밍-읽기-실습\"><a href=\"#1-RxJava-리액티브-프로그래밍-읽기-실습\" class=\"headerlink\" title=\"1. RxJava 리액티브 프로그래밍 읽기/실습\"></a>1. RxJava 리액티브 프로그래밍 읽기/실습</h2><ul>\n<li>3장, RxJava 메커니즘</li>\n</ul>\n<p>에러처리에 대한 부분부터 배압(Backpressure)까지 학습을 하였고, 에러 처리에 대한 매커니즘부터 배압까지 자연스럽게 내용이 연결되어 있어서 이해하는데에는 크게 무리가 없었다. 다만, 책을 읽으면 읽을수록 봐야 할 API와 구현체에 대한 개수가 늘어나는거 같아서, 책에서만 제공해주는 예제 외에도 실제 구현을 어떻게 하는지에 대해서는 깃헙을 돌아다니면서 코드를 좀 살펴봐야 좀 더 이해가 높아질 수 있을거 같았다. </p>\n<ul>\n<li><p>여러개의 생산자와 소비자가 공유 객체를 가질 경우에는?</p>\n<ul>\n<li>merge 연산자를 사용하여 다수의 생산자/소비자가 순차접근을 할 수 있도록 동기화 처리 해야 한다.</li>\n</ul>\n</li>\n<li><p>에러처리</p>\n<ul>\n<li>에러처리에 대한 통보</li>\n<li>재시도(retryXX Method)</li>\n<li>대체 데이터 통보(onErrorXX Method)</li>\n</ul>\n</li>\n<li><p>배압 정책/전략 지정</p>\n<ul>\n<li>Flowable/Observable 생성 시 지정</li>\n<li>매소드로 지정</li>\n<li>생산자측, 스캐줄러 지정 시(observeOn()) 버퍼 사이즈를 지정</li>\n</ul>\n</li>\n<li><p>배압 정책의 종류</p>\n<ul>\n<li>BUFFER</li>\n<li>DROP</li>\n<li>LATEST</li>\n<li>ERROR</li>\n<li>NONE</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-Effective-Java-3e-읽기-실습\"><a href=\"#2-Effective-Java-3e-읽기-실습\" class=\"headerlink\" title=\"2. Effective-Java-3e 읽기/실습\"></a>2. Effective-Java-3e 읽기/실습</h2><ul>\n<li>아이템 26, Raw Type은 사용하지 말아라</li>\n</ul>\n<p>제네릭을 사용했을 때, 반드시 알아야 할 개념에 대해 소개해주고 있어서, 다른 문서나 글을 읽었을 때 몰랐던 여러 개념을 파악 할 수 있어서 좋았다. 그리고 RawType의 컬렉션 사용에 대한 자바의 히스토리에 대해 알 수 있었고, 제네릭이 도입됨에 따라 가질 수 있는 컴파일 타임의 타입 안전성과 런타임에서의 타입소거 등에 대해서도 예제와 설명를 통하여 확인 할 수 있어서 좋았다. 아래는 책에 나와 있는 내용을 일부 발췌하여 나중에라도 까먹을 경우(??)에 다시 보고자 기록을 해둘려고 한다.</p>\n<table>\n<thead>\n<tr>\n<th>용어</th>\n<th>예</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>매개변수화 타입(Parameterized Type)</td>\n<td><code>List&lt;String&gt;</code></td>\n</tr>\n<tr>\n<td>실제 타입 매개변수(Actual Type Parameter)</td>\n<td><code>String</code></td>\n</tr>\n<tr>\n<td>제네릭 타입(Generic Type)</td>\n<td><code>List&lt;E&gt;</code></td>\n</tr>\n<tr>\n<td>정규 타입 매개변수(Formal Type Parameter)</td>\n<td><code>E</code></td>\n</tr>\n<tr>\n<td>비한정적 타입 매개변수(Bounded Type Parameter)</td>\n<td><code>List&lt;?&gt;</code></td>\n</tr>\n<tr>\n<td>로우 타입(Raw Type)</td>\n<td><code>List</code></td>\n</tr>\n<tr>\n<td>한정적 타입 매개변수(Bounded Type Parameter)</td>\n<td><code>List&lt;E extends Number&gt;</code></td>\n</tr>\n<tr>\n<td>재귀적 타입 한정(Recursive Type Bound)</td>\n<td><code>&lt;T extends Comparable&lt;T&gt;&gt;</code></td>\n</tr>\n<tr>\n<td>한정적 와일드카드 타입(Bounded Wildcard Type)</td>\n<td><code>List&lt;? extends Number&gt;</code></td>\n</tr>\n<tr>\n<td>제네릭 매서드(Generic Method)</td>\n<td><code>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</code></td>\n</tr>\n<tr>\n<td>타입 토큰(Type Token)</td>\n<td><code>String.class</code></td>\n</tr>\n</tbody></table>\n"},{"title":"20190528","date":"2019-05-27T15:00:00.000Z","_content":"\n# 20190528\n## 1. @Transactional\n회사 업무 중, 테스트 환경에서 적절하게 @Transactional을 부여하지 못해서 실수한 부분이 있어서 메모하려고 한다. \n\n**Repository를 의존하고 있는 서비스 레이어에서 명시적으로 @Transactional을 서비스 매서드에 마킹 해놓지 않은 상태에서 해당 서비스 메서드의 호출이 종료된 시점에 @OneToMany(FetchType.Lazy)로 마킹된 하위 모델 엔티티가 조회를 시도하게 되면서 생기는 문제였다.**\n\n기본적으로 Data JPA에서의 Repository는 CRUD 오퍼레이션에 대해 트랜잭션을 가져가게 되는데, 문제가 되는 상황은 엔티티에서 FetchType.Lazy를 사용했을 때, 즉 지연 로딩을 사용할 때가 문제가 되는 듯 했다. 만약 레파지토리에서의 트랜잭션을 재정의하고 싶다면 아래와 같이 재정의를 하면 되고, 또한 `readOnly` 와 같은 속성을 사용하여 Replication 구조상에서 해당 트랜잭션이 Read Replication을 참조하도록 변경하는 것도 가능하다.\n\n \n\n```java\npublic interface UserRepository extends CrudRepository<User, Long> {\n\n  @Override\n  @Transactional(timeout = 10)\n  public List<User> findAll();\n}\n```\n\n또한, 만약 클래스 레벨에서의 @Transactional의 속성 값이 readOnly=true로 지정되어 있고, 매서드가 READ 오퍼레이션이 아닌 CUD 오퍼레이션을 취한다면 아래와 같이 `@Modifying`을 붙여서 트랜잭션을 재정의 하는 것이 가능하다고 한다.\n```java\n@Transactional(readOnly = true)\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n  List<User> findByLastname(String lastname);\n\n  @Modifying\n  @Transactional\n  @Query(\"delete from User u where u.active = false\")\n  void deleteInactiveUsers();\n}\n```\n","source":"_posts/DIARY/20190528.md","raw":"---\ntitle: 20190528\ndate: 2019/5/28 00:00:00\ncategories:\n- DIARY\n---\n\n# 20190528\n## 1. @Transactional\n회사 업무 중, 테스트 환경에서 적절하게 @Transactional을 부여하지 못해서 실수한 부분이 있어서 메모하려고 한다. \n\n**Repository를 의존하고 있는 서비스 레이어에서 명시적으로 @Transactional을 서비스 매서드에 마킹 해놓지 않은 상태에서 해당 서비스 메서드의 호출이 종료된 시점에 @OneToMany(FetchType.Lazy)로 마킹된 하위 모델 엔티티가 조회를 시도하게 되면서 생기는 문제였다.**\n\n기본적으로 Data JPA에서의 Repository는 CRUD 오퍼레이션에 대해 트랜잭션을 가져가게 되는데, 문제가 되는 상황은 엔티티에서 FetchType.Lazy를 사용했을 때, 즉 지연 로딩을 사용할 때가 문제가 되는 듯 했다. 만약 레파지토리에서의 트랜잭션을 재정의하고 싶다면 아래와 같이 재정의를 하면 되고, 또한 `readOnly` 와 같은 속성을 사용하여 Replication 구조상에서 해당 트랜잭션이 Read Replication을 참조하도록 변경하는 것도 가능하다.\n\n \n\n```java\npublic interface UserRepository extends CrudRepository<User, Long> {\n\n  @Override\n  @Transactional(timeout = 10)\n  public List<User> findAll();\n}\n```\n\n또한, 만약 클래스 레벨에서의 @Transactional의 속성 값이 readOnly=true로 지정되어 있고, 매서드가 READ 오퍼레이션이 아닌 CUD 오퍼레이션을 취한다면 아래와 같이 `@Modifying`을 붙여서 트랜잭션을 재정의 하는 것이 가능하다고 한다.\n```java\n@Transactional(readOnly = true)\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n  List<User> findByLastname(String lastname);\n\n  @Modifying\n  @Transactional\n  @Query(\"delete from User u where u.active = false\")\n  void deleteInactiveUsers();\n}\n```\n","slug":"DIARY/20190528","published":1,"updated":"2021-08-02T12:01:15.724Z","_id":"ckrsup500000itjhveblw28v5","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20190528\"><a href=\"#20190528\" class=\"headerlink\" title=\"20190528\"></a>20190528</h1><h2 id=\"1-Transactional\"><a href=\"#1-Transactional\" class=\"headerlink\" title=\"1. @Transactional\"></a>1. @Transactional</h2><p>회사 업무 중, 테스트 환경에서 적절하게 @Transactional을 부여하지 못해서 실수한 부분이 있어서 메모하려고 한다. </p>\n<p><strong>Repository를 의존하고 있는 서비스 레이어에서 명시적으로 @Transactional을 서비스 매서드에 마킹 해놓지 않은 상태에서 해당 서비스 메서드의 호출이 종료된 시점에 @OneToMany(FetchType.Lazy)로 마킹된 하위 모델 엔티티가 조회를 시도하게 되면서 생기는 문제였다.</strong></p>\n<p>기본적으로 Data JPA에서의 Repository는 CRUD 오퍼레이션에 대해 트랜잭션을 가져가게 되는데, 문제가 되는 상황은 엔티티에서 FetchType.Lazy를 사용했을 때, 즉 지연 로딩을 사용할 때가 문제가 되는 듯 했다. 만약 레파지토리에서의 트랜잭션을 재정의하고 싶다면 아래와 같이 재정의를 하면 되고, 또한 <code>readOnly</code> 와 같은 속성을 사용하여 Replication 구조상에서 해당 트랜잭션이 Read Replication을 참조하도록 변경하는 것도 가능하다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">CrudRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"meta\">@Transactional(timeout = 10)</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title\">findAll</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>또한, 만약 클래스 레벨에서의 @Transactional의 속성 값이 readOnly=true로 지정되어 있고, 매서드가 READ 오퍼레이션이 아닌 CUD 오퍼레이션을 취한다면 아래와 같이 <code>@Modifying</code>을 붙여서 트랜잭션을 재정의 하는 것이 가능하다고 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(readOnly = true)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">List&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Modifying</span></span><br><span class=\"line\">  <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">  <span class=\"meta\">@Query(&quot;delete from User u where u.active = false&quot;)</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">deleteInactiveUsers</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20190528\"><a href=\"#20190528\" class=\"headerlink\" title=\"20190528\"></a>20190528</h1><h2 id=\"1-Transactional\"><a href=\"#1-Transactional\" class=\"headerlink\" title=\"1. @Transactional\"></a>1. @Transactional</h2><p>회사 업무 중, 테스트 환경에서 적절하게 @Transactional을 부여하지 못해서 실수한 부분이 있어서 메모하려고 한다. </p>\n<p><strong>Repository를 의존하고 있는 서비스 레이어에서 명시적으로 @Transactional을 서비스 매서드에 마킹 해놓지 않은 상태에서 해당 서비스 메서드의 호출이 종료된 시점에 @OneToMany(FetchType.Lazy)로 마킹된 하위 모델 엔티티가 조회를 시도하게 되면서 생기는 문제였다.</strong></p>\n<p>기본적으로 Data JPA에서의 Repository는 CRUD 오퍼레이션에 대해 트랜잭션을 가져가게 되는데, 문제가 되는 상황은 엔티티에서 FetchType.Lazy를 사용했을 때, 즉 지연 로딩을 사용할 때가 문제가 되는 듯 했다. 만약 레파지토리에서의 트랜잭션을 재정의하고 싶다면 아래와 같이 재정의를 하면 되고, 또한 <code>readOnly</code> 와 같은 속성을 사용하여 Replication 구조상에서 해당 트랜잭션이 Read Replication을 참조하도록 변경하는 것도 가능하다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">CrudRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"meta\">@Transactional(timeout = 10)</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title\">findAll</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>또한, 만약 클래스 레벨에서의 @Transactional의 속성 값이 readOnly=true로 지정되어 있고, 매서드가 READ 오퍼레이션이 아닌 CUD 오퍼레이션을 취한다면 아래와 같이 <code>@Modifying</code>을 붙여서 트랜잭션을 재정의 하는 것이 가능하다고 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(readOnly = true)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">List&lt;User&gt; <span class=\"title\">findByLastname</span><span class=\"params\">(String lastname)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Modifying</span></span><br><span class=\"line\">  <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">  <span class=\"meta\">@Query(&quot;delete from User u where u.active = false&quot;)</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">deleteInactiveUsers</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"20190603","date":"2019-06-02T15:00:00.000Z","_content":"\n# 20190603\n## 1. H2 데이터베이스 사용 중 소소한 삽질\n신규 서비스 API 개발에 H2 데이터베이스를 적극적으로 사용하고 있는데, 컬럼명에 예약어를 사용하여 생각보다 오랜 시간 삽질을 하게 되었다. 실제 에러 스택트레이스에 예악어라는 메세지가 보이질 않아서 더 해맨 부분도 있었던거 같다. \n- [Keywords / Reserved Words\n](http://www.h2database.com/html/advanced.html#keywords)\n\n \n## 2. DDD 1장 ~ 2장 학습\nDDD Start 책을 읽으면서 내용을 계속 정리하고 있다. 책이 참 좋다고 생각이 들었는데, 실제 구현 코드도 같이 예제 형식으로 보여주고 있어서 실제 JPA-Hibernate를 주로 사용하는 나로서는 참 공감이 가면서도 부족한 부분이 무엇인지 정확하게 알게 해주는거 같아 좋았다. \n- 엔티티 vs 벨류\n- 무분별한 세터는 무조건 `지양`\n- 의미 있는 도메인 용어 선정 그리고 이를 코드에 충분히 표현\n- 계층 구조 아키텍처\n- DIP\n- 도메인 영역의 주요 키워드\n  - 엔티티\n  - 벨류\n  - 애그리거트\n  - 레파지토리\n  - 도메인 서비스\n\n일단 공부한 내용이라 키워드 위주로 나열해봤는데, 기존 코드에 대한 리팩토링을 진행하면서 책에서 봤던 내용을 일부 적용해보면 좀 더 의미 있는 접근이 가능할거 같아 나름 수확이 있다고 생각하고 있다 :)\n","source":"_posts/DIARY/20190603.md","raw":"---\ntitle: 20190603\ndate: 2019/6/3 00:00:00\ncategories:\n- DIARY\n---\n\n# 20190603\n## 1. H2 데이터베이스 사용 중 소소한 삽질\n신규 서비스 API 개발에 H2 데이터베이스를 적극적으로 사용하고 있는데, 컬럼명에 예약어를 사용하여 생각보다 오랜 시간 삽질을 하게 되었다. 실제 에러 스택트레이스에 예악어라는 메세지가 보이질 않아서 더 해맨 부분도 있었던거 같다. \n- [Keywords / Reserved Words\n](http://www.h2database.com/html/advanced.html#keywords)\n\n \n## 2. DDD 1장 ~ 2장 학습\nDDD Start 책을 읽으면서 내용을 계속 정리하고 있다. 책이 참 좋다고 생각이 들었는데, 실제 구현 코드도 같이 예제 형식으로 보여주고 있어서 실제 JPA-Hibernate를 주로 사용하는 나로서는 참 공감이 가면서도 부족한 부분이 무엇인지 정확하게 알게 해주는거 같아 좋았다. \n- 엔티티 vs 벨류\n- 무분별한 세터는 무조건 `지양`\n- 의미 있는 도메인 용어 선정 그리고 이를 코드에 충분히 표현\n- 계층 구조 아키텍처\n- DIP\n- 도메인 영역의 주요 키워드\n  - 엔티티\n  - 벨류\n  - 애그리거트\n  - 레파지토리\n  - 도메인 서비스\n\n일단 공부한 내용이라 키워드 위주로 나열해봤는데, 기존 코드에 대한 리팩토링을 진행하면서 책에서 봤던 내용을 일부 적용해보면 좀 더 의미 있는 접근이 가능할거 같아 나름 수확이 있다고 생각하고 있다 :)\n","slug":"DIARY/20190603","published":1,"updated":"2021-08-02T12:01:08.548Z","_id":"ckrsup501000jtjhvcxm45qzf","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20190603\"><a href=\"#20190603\" class=\"headerlink\" title=\"20190603\"></a>20190603</h1><h2 id=\"1-H2-데이터베이스-사용-중-소소한-삽질\"><a href=\"#1-H2-데이터베이스-사용-중-소소한-삽질\" class=\"headerlink\" title=\"1. H2 데이터베이스 사용 중 소소한 삽질\"></a>1. H2 데이터베이스 사용 중 소소한 삽질</h2><p>신규 서비스 API 개발에 H2 데이터베이스를 적극적으로 사용하고 있는데, 컬럼명에 예약어를 사용하여 생각보다 오랜 시간 삽질을 하게 되었다. 실제 에러 스택트레이스에 예악어라는 메세지가 보이질 않아서 더 해맨 부분도 있었던거 같다. </p>\n<ul>\n<li><a href=\"http://www.h2database.com/html/advanced.html#keywords\">Keywords / Reserved Words\n</a></li>\n</ul>\n<h2 id=\"2-DDD-1장-2장-학습\"><a href=\"#2-DDD-1장-2장-학습\" class=\"headerlink\" title=\"2. DDD 1장 ~ 2장 학습\"></a>2. DDD 1장 ~ 2장 학습</h2><p>DDD Start 책을 읽으면서 내용을 계속 정리하고 있다. 책이 참 좋다고 생각이 들었는데, 실제 구현 코드도 같이 예제 형식으로 보여주고 있어서 실제 JPA-Hibernate를 주로 사용하는 나로서는 참 공감이 가면서도 부족한 부분이 무엇인지 정확하게 알게 해주는거 같아 좋았다. </p>\n<ul>\n<li>엔티티 vs 벨류</li>\n<li>무분별한 세터는 무조건 <code>지양</code></li>\n<li>의미 있는 도메인 용어 선정 그리고 이를 코드에 충분히 표현</li>\n<li>계층 구조 아키텍처</li>\n<li>DIP</li>\n<li>도메인 영역의 주요 키워드<ul>\n<li>엔티티</li>\n<li>벨류</li>\n<li>애그리거트</li>\n<li>레파지토리</li>\n<li>도메인 서비스</li>\n</ul>\n</li>\n</ul>\n<p>일단 공부한 내용이라 키워드 위주로 나열해봤는데, 기존 코드에 대한 리팩토링을 진행하면서 책에서 봤던 내용을 일부 적용해보면 좀 더 의미 있는 접근이 가능할거 같아 나름 수확이 있다고 생각하고 있다 :)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20190603\"><a href=\"#20190603\" class=\"headerlink\" title=\"20190603\"></a>20190603</h1><h2 id=\"1-H2-데이터베이스-사용-중-소소한-삽질\"><a href=\"#1-H2-데이터베이스-사용-중-소소한-삽질\" class=\"headerlink\" title=\"1. H2 데이터베이스 사용 중 소소한 삽질\"></a>1. H2 데이터베이스 사용 중 소소한 삽질</h2><p>신규 서비스 API 개발에 H2 데이터베이스를 적극적으로 사용하고 있는데, 컬럼명에 예약어를 사용하여 생각보다 오랜 시간 삽질을 하게 되었다. 실제 에러 스택트레이스에 예악어라는 메세지가 보이질 않아서 더 해맨 부분도 있었던거 같다. </p>\n<ul>\n<li><a href=\"http://www.h2database.com/html/advanced.html#keywords\">Keywords / Reserved Words\n</a></li>\n</ul>\n<h2 id=\"2-DDD-1장-2장-학습\"><a href=\"#2-DDD-1장-2장-학습\" class=\"headerlink\" title=\"2. DDD 1장 ~ 2장 학습\"></a>2. DDD 1장 ~ 2장 학습</h2><p>DDD Start 책을 읽으면서 내용을 계속 정리하고 있다. 책이 참 좋다고 생각이 들었는데, 실제 구현 코드도 같이 예제 형식으로 보여주고 있어서 실제 JPA-Hibernate를 주로 사용하는 나로서는 참 공감이 가면서도 부족한 부분이 무엇인지 정확하게 알게 해주는거 같아 좋았다. </p>\n<ul>\n<li>엔티티 vs 벨류</li>\n<li>무분별한 세터는 무조건 <code>지양</code></li>\n<li>의미 있는 도메인 용어 선정 그리고 이를 코드에 충분히 표현</li>\n<li>계층 구조 아키텍처</li>\n<li>DIP</li>\n<li>도메인 영역의 주요 키워드<ul>\n<li>엔티티</li>\n<li>벨류</li>\n<li>애그리거트</li>\n<li>레파지토리</li>\n<li>도메인 서비스</li>\n</ul>\n</li>\n</ul>\n<p>일단 공부한 내용이라 키워드 위주로 나열해봤는데, 기존 코드에 대한 리팩토링을 진행하면서 책에서 봤던 내용을 일부 적용해보면 좀 더 의미 있는 접근이 가능할거 같아 나름 수확이 있다고 생각하고 있다 :)</p>\n"},{"title":"20190609","date":"2019-06-08T15:00:00.000Z","_content":"\n# 20190609\n## DDD Start 3,4장 학습\n\n1~2장을 통하여 DDD와 관련된 주요 개념과 키워드들을 살펴보았고, 3장부터는 도메인의 영역을 큰 그림을 통하여 세부 그림을 이해하는 법부터 시작하여 애그리거트를 구성하는 방법과 주의해야 할 부분이 대하여 조금 더 깊게 볼 수 있어서 좋았다. 4장에서는 실제 JPA를 이용하여 엔티티 매핑과 벨류 매핑을 직접 실습 해볼 수 있었는데, 자바로 되어 있는 매핑 코드를 코틀린 베이스로 옮겨서 작성해야 하니 생각보다 걸리는 지점이 있어서 조금 시간을 소모 할수 밖에 없었다. JPA를 공부하고 바로 이 책을 봤었더라면 좀 더 업무 코드에서도 의미 있는 엔티티 구성과 로직을 만들어 낼 수 있었겠다는 아쉬움도 들긴 하지만, 지금이라도 모자란 부분이 무엇인지 확인해볼 수 있는 좋은 기회인거 같아 나름 수확이 있다고 할 수 있다.\n\n- 3장\n  - 트랜잭션 범위 지정: 애그리거트 단위로 지정\n  - 레파지토리/애그리거트\n    - 레파지토리는 `애그리거트` 단위로 작성\n    - 레파지토리의 인터페이스는 도메인 레이어에 그리고 이를 구현하는 클래스는 인프라스트럭처 레이어로 배치\n  - 애그리거트 간 연관 관계 참조 전략\n    - 필드 매핑의 경우, 경계가 애매해질 수 있음\n    - ID값을 매핑하는 전략을 사용할 경우 조금 더 명료해짐\n  - 애매한 경계에서의 요구사항일 경우, 별도의 조회 도메인을 작성하는 것도 좋다.\n- 4장\n  - 루트 엔티티(애그리거트 루트) 매핑\n  - 레파지토리의 주요 역할\n  - 다양한 매핑 방법\n    - ID값 매핑(@EmbeddedId)\n    - 컬렉션 데이터 매핑(컬럼, 테이블)\n    - @Convert, AttributeConvert를 활용한 데이터 컨버터 생성 및 적용\n  - 벨류 객체에 대한 매핑 전략\n    - 같은 라이프사이클 내에 존재하는 연관 객체라면 벨류 객체 매핑을 통하여 충분히 해결이 가능하다.\n    - `@Embeddable`, `@Embedded`을 사용한 불변 객체 활용 및 `@AttributeOverrides`, `@AttributeOverride`를 활용한 컬럼 데이터 재지정 및 매핑\n    - 도메인 상황에 따른 엔티티 객체로 매핑\n      - 연관 객체라고 하여 모든 것을 엔티티로 매핑 할 이유는 없다. 객체의 라이프사이클이 엔티티로 지정 해야 할 라이프사이클인지 그리고 확실하게 애그리거트내에 존재해야 하는지 도메인 상황에 맞는 정확한 판단을 해야 한다. \n    - `@ElementCollection`, `@CollectionTable`을 별도 테이블 벨류 매핑\n  - 로딩 전략(Eager/Lazy)\n    - N+1\n    - Eager와 Lazy를 사용해야 할 시점에 대한 고민\n    - Lazy 사용 시, 트랜잭션 범위 내에서 사용\n  - 영속성 전파/식별자 생성 전략\n    - Cascade, orphanRemoval","source":"_posts/DIARY/20190609.md","raw":"---\ntitle: 20190609\ndate: 2019/6/9 00:00:00\ncategories:\n- DIARY\n---\n\n# 20190609\n## DDD Start 3,4장 학습\n\n1~2장을 통하여 DDD와 관련된 주요 개념과 키워드들을 살펴보았고, 3장부터는 도메인의 영역을 큰 그림을 통하여 세부 그림을 이해하는 법부터 시작하여 애그리거트를 구성하는 방법과 주의해야 할 부분이 대하여 조금 더 깊게 볼 수 있어서 좋았다. 4장에서는 실제 JPA를 이용하여 엔티티 매핑과 벨류 매핑을 직접 실습 해볼 수 있었는데, 자바로 되어 있는 매핑 코드를 코틀린 베이스로 옮겨서 작성해야 하니 생각보다 걸리는 지점이 있어서 조금 시간을 소모 할수 밖에 없었다. JPA를 공부하고 바로 이 책을 봤었더라면 좀 더 업무 코드에서도 의미 있는 엔티티 구성과 로직을 만들어 낼 수 있었겠다는 아쉬움도 들긴 하지만, 지금이라도 모자란 부분이 무엇인지 확인해볼 수 있는 좋은 기회인거 같아 나름 수확이 있다고 할 수 있다.\n\n- 3장\n  - 트랜잭션 범위 지정: 애그리거트 단위로 지정\n  - 레파지토리/애그리거트\n    - 레파지토리는 `애그리거트` 단위로 작성\n    - 레파지토리의 인터페이스는 도메인 레이어에 그리고 이를 구현하는 클래스는 인프라스트럭처 레이어로 배치\n  - 애그리거트 간 연관 관계 참조 전략\n    - 필드 매핑의 경우, 경계가 애매해질 수 있음\n    - ID값을 매핑하는 전략을 사용할 경우 조금 더 명료해짐\n  - 애매한 경계에서의 요구사항일 경우, 별도의 조회 도메인을 작성하는 것도 좋다.\n- 4장\n  - 루트 엔티티(애그리거트 루트) 매핑\n  - 레파지토리의 주요 역할\n  - 다양한 매핑 방법\n    - ID값 매핑(@EmbeddedId)\n    - 컬렉션 데이터 매핑(컬럼, 테이블)\n    - @Convert, AttributeConvert를 활용한 데이터 컨버터 생성 및 적용\n  - 벨류 객체에 대한 매핑 전략\n    - 같은 라이프사이클 내에 존재하는 연관 객체라면 벨류 객체 매핑을 통하여 충분히 해결이 가능하다.\n    - `@Embeddable`, `@Embedded`을 사용한 불변 객체 활용 및 `@AttributeOverrides`, `@AttributeOverride`를 활용한 컬럼 데이터 재지정 및 매핑\n    - 도메인 상황에 따른 엔티티 객체로 매핑\n      - 연관 객체라고 하여 모든 것을 엔티티로 매핑 할 이유는 없다. 객체의 라이프사이클이 엔티티로 지정 해야 할 라이프사이클인지 그리고 확실하게 애그리거트내에 존재해야 하는지 도메인 상황에 맞는 정확한 판단을 해야 한다. \n    - `@ElementCollection`, `@CollectionTable`을 별도 테이블 벨류 매핑\n  - 로딩 전략(Eager/Lazy)\n    - N+1\n    - Eager와 Lazy를 사용해야 할 시점에 대한 고민\n    - Lazy 사용 시, 트랜잭션 범위 내에서 사용\n  - 영속성 전파/식별자 생성 전략\n    - Cascade, orphanRemoval","slug":"DIARY/20190609","published":1,"updated":"2021-08-02T12:01:00.986Z","_id":"ckrsup501000ktjhvared5ynw","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20190609\"><a href=\"#20190609\" class=\"headerlink\" title=\"20190609\"></a>20190609</h1><h2 id=\"DDD-Start-3-4장-학습\"><a href=\"#DDD-Start-3-4장-학습\" class=\"headerlink\" title=\"DDD Start 3,4장 학습\"></a>DDD Start 3,4장 학습</h2><p>1~2장을 통하여 DDD와 관련된 주요 개념과 키워드들을 살펴보았고, 3장부터는 도메인의 영역을 큰 그림을 통하여 세부 그림을 이해하는 법부터 시작하여 애그리거트를 구성하는 방법과 주의해야 할 부분이 대하여 조금 더 깊게 볼 수 있어서 좋았다. 4장에서는 실제 JPA를 이용하여 엔티티 매핑과 벨류 매핑을 직접 실습 해볼 수 있었는데, 자바로 되어 있는 매핑 코드를 코틀린 베이스로 옮겨서 작성해야 하니 생각보다 걸리는 지점이 있어서 조금 시간을 소모 할수 밖에 없었다. JPA를 공부하고 바로 이 책을 봤었더라면 좀 더 업무 코드에서도 의미 있는 엔티티 구성과 로직을 만들어 낼 수 있었겠다는 아쉬움도 들긴 하지만, 지금이라도 모자란 부분이 무엇인지 확인해볼 수 있는 좋은 기회인거 같아 나름 수확이 있다고 할 수 있다.</p>\n<ul>\n<li>3장<ul>\n<li>트랜잭션 범위 지정: 애그리거트 단위로 지정</li>\n<li>레파지토리/애그리거트<ul>\n<li>레파지토리는 <code>애그리거트</code> 단위로 작성</li>\n<li>레파지토리의 인터페이스는 도메인 레이어에 그리고 이를 구현하는 클래스는 인프라스트럭처 레이어로 배치</li>\n</ul>\n</li>\n<li>애그리거트 간 연관 관계 참조 전략<ul>\n<li>필드 매핑의 경우, 경계가 애매해질 수 있음</li>\n<li>ID값을 매핑하는 전략을 사용할 경우 조금 더 명료해짐</li>\n</ul>\n</li>\n<li>애매한 경계에서의 요구사항일 경우, 별도의 조회 도메인을 작성하는 것도 좋다.</li>\n</ul>\n</li>\n<li>4장<ul>\n<li>루트 엔티티(애그리거트 루트) 매핑</li>\n<li>레파지토리의 주요 역할</li>\n<li>다양한 매핑 방법<ul>\n<li>ID값 매핑(@EmbeddedId)</li>\n<li>컬렉션 데이터 매핑(컬럼, 테이블)</li>\n<li>@Convert, AttributeConvert를 활용한 데이터 컨버터 생성 및 적용</li>\n</ul>\n</li>\n<li>벨류 객체에 대한 매핑 전략<ul>\n<li>같은 라이프사이클 내에 존재하는 연관 객체라면 벨류 객체 매핑을 통하여 충분히 해결이 가능하다.</li>\n<li><code>@Embeddable</code>, <code>@Embedded</code>을 사용한 불변 객체 활용 및 <code>@AttributeOverrides</code>, <code>@AttributeOverride</code>를 활용한 컬럼 데이터 재지정 및 매핑</li>\n<li>도메인 상황에 따른 엔티티 객체로 매핑<ul>\n<li>연관 객체라고 하여 모든 것을 엔티티로 매핑 할 이유는 없다. 객체의 라이프사이클이 엔티티로 지정 해야 할 라이프사이클인지 그리고 확실하게 애그리거트내에 존재해야 하는지 도메인 상황에 맞는 정확한 판단을 해야 한다. </li>\n</ul>\n</li>\n<li><code>@ElementCollection</code>, <code>@CollectionTable</code>을 별도 테이블 벨류 매핑</li>\n</ul>\n</li>\n<li>로딩 전략(Eager/Lazy)<ul>\n<li>N+1</li>\n<li>Eager와 Lazy를 사용해야 할 시점에 대한 고민</li>\n<li>Lazy 사용 시, 트랜잭션 범위 내에서 사용</li>\n</ul>\n</li>\n<li>영속성 전파/식별자 생성 전략<ul>\n<li>Cascade, orphanRemoval</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20190609\"><a href=\"#20190609\" class=\"headerlink\" title=\"20190609\"></a>20190609</h1><h2 id=\"DDD-Start-3-4장-학습\"><a href=\"#DDD-Start-3-4장-학습\" class=\"headerlink\" title=\"DDD Start 3,4장 학습\"></a>DDD Start 3,4장 학습</h2><p>1~2장을 통하여 DDD와 관련된 주요 개념과 키워드들을 살펴보았고, 3장부터는 도메인의 영역을 큰 그림을 통하여 세부 그림을 이해하는 법부터 시작하여 애그리거트를 구성하는 방법과 주의해야 할 부분이 대하여 조금 더 깊게 볼 수 있어서 좋았다. 4장에서는 실제 JPA를 이용하여 엔티티 매핑과 벨류 매핑을 직접 실습 해볼 수 있었는데, 자바로 되어 있는 매핑 코드를 코틀린 베이스로 옮겨서 작성해야 하니 생각보다 걸리는 지점이 있어서 조금 시간을 소모 할수 밖에 없었다. JPA를 공부하고 바로 이 책을 봤었더라면 좀 더 업무 코드에서도 의미 있는 엔티티 구성과 로직을 만들어 낼 수 있었겠다는 아쉬움도 들긴 하지만, 지금이라도 모자란 부분이 무엇인지 확인해볼 수 있는 좋은 기회인거 같아 나름 수확이 있다고 할 수 있다.</p>\n<ul>\n<li>3장<ul>\n<li>트랜잭션 범위 지정: 애그리거트 단위로 지정</li>\n<li>레파지토리/애그리거트<ul>\n<li>레파지토리는 <code>애그리거트</code> 단위로 작성</li>\n<li>레파지토리의 인터페이스는 도메인 레이어에 그리고 이를 구현하는 클래스는 인프라스트럭처 레이어로 배치</li>\n</ul>\n</li>\n<li>애그리거트 간 연관 관계 참조 전략<ul>\n<li>필드 매핑의 경우, 경계가 애매해질 수 있음</li>\n<li>ID값을 매핑하는 전략을 사용할 경우 조금 더 명료해짐</li>\n</ul>\n</li>\n<li>애매한 경계에서의 요구사항일 경우, 별도의 조회 도메인을 작성하는 것도 좋다.</li>\n</ul>\n</li>\n<li>4장<ul>\n<li>루트 엔티티(애그리거트 루트) 매핑</li>\n<li>레파지토리의 주요 역할</li>\n<li>다양한 매핑 방법<ul>\n<li>ID값 매핑(@EmbeddedId)</li>\n<li>컬렉션 데이터 매핑(컬럼, 테이블)</li>\n<li>@Convert, AttributeConvert를 활용한 데이터 컨버터 생성 및 적용</li>\n</ul>\n</li>\n<li>벨류 객체에 대한 매핑 전략<ul>\n<li>같은 라이프사이클 내에 존재하는 연관 객체라면 벨류 객체 매핑을 통하여 충분히 해결이 가능하다.</li>\n<li><code>@Embeddable</code>, <code>@Embedded</code>을 사용한 불변 객체 활용 및 <code>@AttributeOverrides</code>, <code>@AttributeOverride</code>를 활용한 컬럼 데이터 재지정 및 매핑</li>\n<li>도메인 상황에 따른 엔티티 객체로 매핑<ul>\n<li>연관 객체라고 하여 모든 것을 엔티티로 매핑 할 이유는 없다. 객체의 라이프사이클이 엔티티로 지정 해야 할 라이프사이클인지 그리고 확실하게 애그리거트내에 존재해야 하는지 도메인 상황에 맞는 정확한 판단을 해야 한다. </li>\n</ul>\n</li>\n<li><code>@ElementCollection</code>, <code>@CollectionTable</code>을 별도 테이블 벨류 매핑</li>\n</ul>\n</li>\n<li>로딩 전략(Eager/Lazy)<ul>\n<li>N+1</li>\n<li>Eager와 Lazy를 사용해야 할 시점에 대한 고민</li>\n<li>Lazy 사용 시, 트랜잭션 범위 내에서 사용</li>\n</ul>\n</li>\n<li>영속성 전파/식별자 생성 전략<ul>\n<li>Cascade, orphanRemoval</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"20190622","date":"2019-06-21T15:00:00.000Z","_content":"\n# 20190622\n## 1. DDD Start 8장 읽기\n애그리거트 트랜잭션 처리에 대한 내용으로 애그리거트 수정이 동시에 발생했을 경우, 이를 어떻게 처리 할지에 대한 내용을 담고 있다. DB 레벨에서의 선점 락과 선점 락으로 인해 발생할 수 있는 문제(데드락)을 회피하기 위한 비선점 락에 대한 전략(JPA-Hibernate의 @Version을 활용한 업데이트 전략) 그리고 오프라인 락을 통하여 락에 대한 선점을 미리 하는 방법까지 간단하게 학습할 수 있었다. \n\n다시 읽어보면서 내용 정리를 해보고 좀 더 깊게 생각해봐야겠지만, 실제 업무에서는 대부분 DB 레벨에서의 선점 락을 사용하는 경우가 많았는데, 디비 레벨에서의 선점 락을 사용할 경우, 락을 대기하는 스레드가 발생하여 실제 동시성에 크게 영향을 주면서 개발을 할 수 밖에 없었다. 하지만, 비선점 락을 잘 연구해보고 활용할 수 있다면 굳이 선점 락을 사용하지 않고도 Update 성격의 데이터 처리를 할 수 있겠다라는 생각이 들었다.\n\n이번 장을 읽으면서 좀 더 와닿은 예제는 아틀라시안 컨플루언스의 사례였다. 회사에서도 컨플루언스를 사용하면서 실제 같은 페이지를 수정하는 경우가 종종 있는데 여기서 적용된 락에 대한 정책이 바로 오프라인 락 정책이었다는 사실에 내가 모르고 못 보는 여러 개발에서 실제 책에서 본 그런 내용들이 적용되어 있음에 스스로가 아직 한참 멀었구나 하는 생각이 들었다.\n\n## 2. 백기선님 REST API 강좌 듣기\n[그런 REST API로 괜찮은가](https://www.youtube.com/watch?v=RP_f5dMoHFc)을 보고 내가 여태까지 개발해놓고 스스로 REST라고 불렀던 API들은 사실 그냥 WEB API 혹은 HTTP API 정도가 되는 것을 알게 되었다. 사실 이전에 REST라고 하면 그저 자원을 URI로 식별하고 자원에 대한 행위를 HTTP METHOD로 하며 HTTP 명세에 있는 헤더 값을 잘 활용하는 정도라고 생각했는데, 내가 생각 정의한 내용은 말그래도 REST 모델에서 아주 일부분에 불과한 사실...\n\n그래서 좀 더 내가 만든 API 그리고 앞으로 개발할 내용에서 보다 충실한 REST한 API를 만들고 싶다는 생각이 들어서 강의나 리소스를 찾아보다가 발견한 것이 백기선님 강의이다. 사실 Spring Boot에 대한 내용보다는 실제 REST한 구현에 필요한 방법론이나 접근 방식이 더 궁금해서 강의를 구매한 이유가 더 컸다. 7강까지 들었는데 서두에서 예제로 보여줬던 다양한 API들(네이버, 카카오, Github)의 예시를 들었던 것도 좋았고 컨퍼런스에서 발표하셨던 내용을 한번 복기 해주는 것도 좋았다.\n\n시간이야 늘 없다지만, 짬짬히 듣고 예제코드까지 완성해야겠다.","source":"_posts/DIARY/20190622.md","raw":"---\ntitle: 20190622\ndate: 2019/6/22 00:00:00\ncategories:\n- DIARY\n---\n\n# 20190622\n## 1. DDD Start 8장 읽기\n애그리거트 트랜잭션 처리에 대한 내용으로 애그리거트 수정이 동시에 발생했을 경우, 이를 어떻게 처리 할지에 대한 내용을 담고 있다. DB 레벨에서의 선점 락과 선점 락으로 인해 발생할 수 있는 문제(데드락)을 회피하기 위한 비선점 락에 대한 전략(JPA-Hibernate의 @Version을 활용한 업데이트 전략) 그리고 오프라인 락을 통하여 락에 대한 선점을 미리 하는 방법까지 간단하게 학습할 수 있었다. \n\n다시 읽어보면서 내용 정리를 해보고 좀 더 깊게 생각해봐야겠지만, 실제 업무에서는 대부분 DB 레벨에서의 선점 락을 사용하는 경우가 많았는데, 디비 레벨에서의 선점 락을 사용할 경우, 락을 대기하는 스레드가 발생하여 실제 동시성에 크게 영향을 주면서 개발을 할 수 밖에 없었다. 하지만, 비선점 락을 잘 연구해보고 활용할 수 있다면 굳이 선점 락을 사용하지 않고도 Update 성격의 데이터 처리를 할 수 있겠다라는 생각이 들었다.\n\n이번 장을 읽으면서 좀 더 와닿은 예제는 아틀라시안 컨플루언스의 사례였다. 회사에서도 컨플루언스를 사용하면서 실제 같은 페이지를 수정하는 경우가 종종 있는데 여기서 적용된 락에 대한 정책이 바로 오프라인 락 정책이었다는 사실에 내가 모르고 못 보는 여러 개발에서 실제 책에서 본 그런 내용들이 적용되어 있음에 스스로가 아직 한참 멀었구나 하는 생각이 들었다.\n\n## 2. 백기선님 REST API 강좌 듣기\n[그런 REST API로 괜찮은가](https://www.youtube.com/watch?v=RP_f5dMoHFc)을 보고 내가 여태까지 개발해놓고 스스로 REST라고 불렀던 API들은 사실 그냥 WEB API 혹은 HTTP API 정도가 되는 것을 알게 되었다. 사실 이전에 REST라고 하면 그저 자원을 URI로 식별하고 자원에 대한 행위를 HTTP METHOD로 하며 HTTP 명세에 있는 헤더 값을 잘 활용하는 정도라고 생각했는데, 내가 생각 정의한 내용은 말그래도 REST 모델에서 아주 일부분에 불과한 사실...\n\n그래서 좀 더 내가 만든 API 그리고 앞으로 개발할 내용에서 보다 충실한 REST한 API를 만들고 싶다는 생각이 들어서 강의나 리소스를 찾아보다가 발견한 것이 백기선님 강의이다. 사실 Spring Boot에 대한 내용보다는 실제 REST한 구현에 필요한 방법론이나 접근 방식이 더 궁금해서 강의를 구매한 이유가 더 컸다. 7강까지 들었는데 서두에서 예제로 보여줬던 다양한 API들(네이버, 카카오, Github)의 예시를 들었던 것도 좋았고 컨퍼런스에서 발표하셨던 내용을 한번 복기 해주는 것도 좋았다.\n\n시간이야 늘 없다지만, 짬짬히 듣고 예제코드까지 완성해야겠다.","slug":"DIARY/20190622","published":1,"updated":"2021-08-02T12:00:54.046Z","_id":"ckrsup502000ltjhv761m87nf","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20190622\"><a href=\"#20190622\" class=\"headerlink\" title=\"20190622\"></a>20190622</h1><h2 id=\"1-DDD-Start-8장-읽기\"><a href=\"#1-DDD-Start-8장-읽기\" class=\"headerlink\" title=\"1. DDD Start 8장 읽기\"></a>1. DDD Start 8장 읽기</h2><p>애그리거트 트랜잭션 처리에 대한 내용으로 애그리거트 수정이 동시에 발생했을 경우, 이를 어떻게 처리 할지에 대한 내용을 담고 있다. DB 레벨에서의 선점 락과 선점 락으로 인해 발생할 수 있는 문제(데드락)을 회피하기 위한 비선점 락에 대한 전략(JPA-Hibernate의 @Version을 활용한 업데이트 전략) 그리고 오프라인 락을 통하여 락에 대한 선점을 미리 하는 방법까지 간단하게 학습할 수 있었다. </p>\n<p>다시 읽어보면서 내용 정리를 해보고 좀 더 깊게 생각해봐야겠지만, 실제 업무에서는 대부분 DB 레벨에서의 선점 락을 사용하는 경우가 많았는데, 디비 레벨에서의 선점 락을 사용할 경우, 락을 대기하는 스레드가 발생하여 실제 동시성에 크게 영향을 주면서 개발을 할 수 밖에 없었다. 하지만, 비선점 락을 잘 연구해보고 활용할 수 있다면 굳이 선점 락을 사용하지 않고도 Update 성격의 데이터 처리를 할 수 있겠다라는 생각이 들었다.</p>\n<p>이번 장을 읽으면서 좀 더 와닿은 예제는 아틀라시안 컨플루언스의 사례였다. 회사에서도 컨플루언스를 사용하면서 실제 같은 페이지를 수정하는 경우가 종종 있는데 여기서 적용된 락에 대한 정책이 바로 오프라인 락 정책이었다는 사실에 내가 모르고 못 보는 여러 개발에서 실제 책에서 본 그런 내용들이 적용되어 있음에 스스로가 아직 한참 멀었구나 하는 생각이 들었다.</p>\n<h2 id=\"2-백기선님-REST-API-강좌-듣기\"><a href=\"#2-백기선님-REST-API-강좌-듣기\" class=\"headerlink\" title=\"2. 백기선님 REST API 강좌 듣기\"></a>2. 백기선님 REST API 강좌 듣기</h2><p><a href=\"https://www.youtube.com/watch?v=RP_f5dMoHFc\">그런 REST API로 괜찮은가</a>을 보고 내가 여태까지 개발해놓고 스스로 REST라고 불렀던 API들은 사실 그냥 WEB API 혹은 HTTP API 정도가 되는 것을 알게 되었다. 사실 이전에 REST라고 하면 그저 자원을 URI로 식별하고 자원에 대한 행위를 HTTP METHOD로 하며 HTTP 명세에 있는 헤더 값을 잘 활용하는 정도라고 생각했는데, 내가 생각 정의한 내용은 말그래도 REST 모델에서 아주 일부분에 불과한 사실…</p>\n<p>그래서 좀 더 내가 만든 API 그리고 앞으로 개발할 내용에서 보다 충실한 REST한 API를 만들고 싶다는 생각이 들어서 강의나 리소스를 찾아보다가 발견한 것이 백기선님 강의이다. 사실 Spring Boot에 대한 내용보다는 실제 REST한 구현에 필요한 방법론이나 접근 방식이 더 궁금해서 강의를 구매한 이유가 더 컸다. 7강까지 들었는데 서두에서 예제로 보여줬던 다양한 API들(네이버, 카카오, Github)의 예시를 들었던 것도 좋았고 컨퍼런스에서 발표하셨던 내용을 한번 복기 해주는 것도 좋았다.</p>\n<p>시간이야 늘 없다지만, 짬짬히 듣고 예제코드까지 완성해야겠다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20190622\"><a href=\"#20190622\" class=\"headerlink\" title=\"20190622\"></a>20190622</h1><h2 id=\"1-DDD-Start-8장-읽기\"><a href=\"#1-DDD-Start-8장-읽기\" class=\"headerlink\" title=\"1. DDD Start 8장 읽기\"></a>1. DDD Start 8장 읽기</h2><p>애그리거트 트랜잭션 처리에 대한 내용으로 애그리거트 수정이 동시에 발생했을 경우, 이를 어떻게 처리 할지에 대한 내용을 담고 있다. DB 레벨에서의 선점 락과 선점 락으로 인해 발생할 수 있는 문제(데드락)을 회피하기 위한 비선점 락에 대한 전략(JPA-Hibernate의 @Version을 활용한 업데이트 전략) 그리고 오프라인 락을 통하여 락에 대한 선점을 미리 하는 방법까지 간단하게 학습할 수 있었다. </p>\n<p>다시 읽어보면서 내용 정리를 해보고 좀 더 깊게 생각해봐야겠지만, 실제 업무에서는 대부분 DB 레벨에서의 선점 락을 사용하는 경우가 많았는데, 디비 레벨에서의 선점 락을 사용할 경우, 락을 대기하는 스레드가 발생하여 실제 동시성에 크게 영향을 주면서 개발을 할 수 밖에 없었다. 하지만, 비선점 락을 잘 연구해보고 활용할 수 있다면 굳이 선점 락을 사용하지 않고도 Update 성격의 데이터 처리를 할 수 있겠다라는 생각이 들었다.</p>\n<p>이번 장을 읽으면서 좀 더 와닿은 예제는 아틀라시안 컨플루언스의 사례였다. 회사에서도 컨플루언스를 사용하면서 실제 같은 페이지를 수정하는 경우가 종종 있는데 여기서 적용된 락에 대한 정책이 바로 오프라인 락 정책이었다는 사실에 내가 모르고 못 보는 여러 개발에서 실제 책에서 본 그런 내용들이 적용되어 있음에 스스로가 아직 한참 멀었구나 하는 생각이 들었다.</p>\n<h2 id=\"2-백기선님-REST-API-강좌-듣기\"><a href=\"#2-백기선님-REST-API-강좌-듣기\" class=\"headerlink\" title=\"2. 백기선님 REST API 강좌 듣기\"></a>2. 백기선님 REST API 강좌 듣기</h2><p><a href=\"https://www.youtube.com/watch?v=RP_f5dMoHFc\">그런 REST API로 괜찮은가</a>을 보고 내가 여태까지 개발해놓고 스스로 REST라고 불렀던 API들은 사실 그냥 WEB API 혹은 HTTP API 정도가 되는 것을 알게 되었다. 사실 이전에 REST라고 하면 그저 자원을 URI로 식별하고 자원에 대한 행위를 HTTP METHOD로 하며 HTTP 명세에 있는 헤더 값을 잘 활용하는 정도라고 생각했는데, 내가 생각 정의한 내용은 말그래도 REST 모델에서 아주 일부분에 불과한 사실…</p>\n<p>그래서 좀 더 내가 만든 API 그리고 앞으로 개발할 내용에서 보다 충실한 REST한 API를 만들고 싶다는 생각이 들어서 강의나 리소스를 찾아보다가 발견한 것이 백기선님 강의이다. 사실 Spring Boot에 대한 내용보다는 실제 REST한 구현에 필요한 방법론이나 접근 방식이 더 궁금해서 강의를 구매한 이유가 더 컸다. 7강까지 들었는데 서두에서 예제로 보여줬던 다양한 API들(네이버, 카카오, Github)의 예시를 들었던 것도 좋았고 컨퍼런스에서 발표하셨던 내용을 한번 복기 해주는 것도 좋았다.</p>\n<p>시간이야 늘 없다지만, 짬짬히 듣고 예제코드까지 완성해야겠다.</p>\n"},{"title":"20190714","date":"2019-07-13T15:00:00.000Z","_content":"\n# 20190714\n## 1. DDD Start 다 읽음\n간만에 끝까지 다 읽은 책이다. 책 내용이 너무 흡입력이 좋았다. 기존에 API를 개발하면서 늘 고민하던 설계적인 부분 혹은 구현 패턴에 대한 100%까지는 아니지만 어느정도의 답을 준거 같아서 나름 만족스러운 독서였다고 평하고 싶다. 마지막 부분이라 크게 기억이 남는 것인지는 몰라도 `도메인 이벤트` 처리하는 방법이나 `CQRS`에 대한 부분 그리고 `락`(선점, 비선점, 오프라인)에 대한 구현과 소개도 너무 좋았었다. 이제 내용을 정리해서 마크다운과 블로그에 올리는 일만 남았는데, 3장까지밖에 정리하지 못해서 할일이 많이 남은거 같아 이거도 일종의 기술부채인가 하는 생각이 들었다.\n\n## 2. MySQL 5.7\nMySQL 5.7 관련 신간이 출시하기도 했고, 스터디에서 해당 책을 가지고 공부하자는 의견이 나와서 리플리케이션 부분은 일주일정도해서 짬짬이 읽고 내용을 정리했다. 결과적으로 내용 이해를 많이 못했다. 내부 구현에 대한 부분이라 지루하기도 했고 모르는 용어와 옵션들이 많이 보여서 아무래도 집중력 있게 하지 못한거 같아 시간을 들여서 다시 읽는 작업을 해야 될거 같다.\n","source":"_posts/DIARY/20190714.md","raw":"---\ntitle: 20190714\ndate: 2019/7/14 00:00:00\ncategories:\n- DIARY\n---\n\n# 20190714\n## 1. DDD Start 다 읽음\n간만에 끝까지 다 읽은 책이다. 책 내용이 너무 흡입력이 좋았다. 기존에 API를 개발하면서 늘 고민하던 설계적인 부분 혹은 구현 패턴에 대한 100%까지는 아니지만 어느정도의 답을 준거 같아서 나름 만족스러운 독서였다고 평하고 싶다. 마지막 부분이라 크게 기억이 남는 것인지는 몰라도 `도메인 이벤트` 처리하는 방법이나 `CQRS`에 대한 부분 그리고 `락`(선점, 비선점, 오프라인)에 대한 구현과 소개도 너무 좋았었다. 이제 내용을 정리해서 마크다운과 블로그에 올리는 일만 남았는데, 3장까지밖에 정리하지 못해서 할일이 많이 남은거 같아 이거도 일종의 기술부채인가 하는 생각이 들었다.\n\n## 2. MySQL 5.7\nMySQL 5.7 관련 신간이 출시하기도 했고, 스터디에서 해당 책을 가지고 공부하자는 의견이 나와서 리플리케이션 부분은 일주일정도해서 짬짬이 읽고 내용을 정리했다. 결과적으로 내용 이해를 많이 못했다. 내부 구현에 대한 부분이라 지루하기도 했고 모르는 용어와 옵션들이 많이 보여서 아무래도 집중력 있게 하지 못한거 같아 시간을 들여서 다시 읽는 작업을 해야 될거 같다.\n","slug":"DIARY/20190714","published":1,"updated":"2021-08-02T12:00:47.809Z","_id":"ckrsup502000mtjhv62kp72qj","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20190714\"><a href=\"#20190714\" class=\"headerlink\" title=\"20190714\"></a>20190714</h1><h2 id=\"1-DDD-Start-다-읽음\"><a href=\"#1-DDD-Start-다-읽음\" class=\"headerlink\" title=\"1. DDD Start 다 읽음\"></a>1. DDD Start 다 읽음</h2><p>간만에 끝까지 다 읽은 책이다. 책 내용이 너무 흡입력이 좋았다. 기존에 API를 개발하면서 늘 고민하던 설계적인 부분 혹은 구현 패턴에 대한 100%까지는 아니지만 어느정도의 답을 준거 같아서 나름 만족스러운 독서였다고 평하고 싶다. 마지막 부분이라 크게 기억이 남는 것인지는 몰라도 <code>도메인 이벤트</code> 처리하는 방법이나 <code>CQRS</code>에 대한 부분 그리고 <code>락</code>(선점, 비선점, 오프라인)에 대한 구현과 소개도 너무 좋았었다. 이제 내용을 정리해서 마크다운과 블로그에 올리는 일만 남았는데, 3장까지밖에 정리하지 못해서 할일이 많이 남은거 같아 이거도 일종의 기술부채인가 하는 생각이 들었다.</p>\n<h2 id=\"2-MySQL-5-7\"><a href=\"#2-MySQL-5-7\" class=\"headerlink\" title=\"2. MySQL 5.7\"></a>2. MySQL 5.7</h2><p>MySQL 5.7 관련 신간이 출시하기도 했고, 스터디에서 해당 책을 가지고 공부하자는 의견이 나와서 리플리케이션 부분은 일주일정도해서 짬짬이 읽고 내용을 정리했다. 결과적으로 내용 이해를 많이 못했다. 내부 구현에 대한 부분이라 지루하기도 했고 모르는 용어와 옵션들이 많이 보여서 아무래도 집중력 있게 하지 못한거 같아 시간을 들여서 다시 읽는 작업을 해야 될거 같다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20190714\"><a href=\"#20190714\" class=\"headerlink\" title=\"20190714\"></a>20190714</h1><h2 id=\"1-DDD-Start-다-읽음\"><a href=\"#1-DDD-Start-다-읽음\" class=\"headerlink\" title=\"1. DDD Start 다 읽음\"></a>1. DDD Start 다 읽음</h2><p>간만에 끝까지 다 읽은 책이다. 책 내용이 너무 흡입력이 좋았다. 기존에 API를 개발하면서 늘 고민하던 설계적인 부분 혹은 구현 패턴에 대한 100%까지는 아니지만 어느정도의 답을 준거 같아서 나름 만족스러운 독서였다고 평하고 싶다. 마지막 부분이라 크게 기억이 남는 것인지는 몰라도 <code>도메인 이벤트</code> 처리하는 방법이나 <code>CQRS</code>에 대한 부분 그리고 <code>락</code>(선점, 비선점, 오프라인)에 대한 구현과 소개도 너무 좋았었다. 이제 내용을 정리해서 마크다운과 블로그에 올리는 일만 남았는데, 3장까지밖에 정리하지 못해서 할일이 많이 남은거 같아 이거도 일종의 기술부채인가 하는 생각이 들었다.</p>\n<h2 id=\"2-MySQL-5-7\"><a href=\"#2-MySQL-5-7\" class=\"headerlink\" title=\"2. MySQL 5.7\"></a>2. MySQL 5.7</h2><p>MySQL 5.7 관련 신간이 출시하기도 했고, 스터디에서 해당 책을 가지고 공부하자는 의견이 나와서 리플리케이션 부분은 일주일정도해서 짬짬이 읽고 내용을 정리했다. 결과적으로 내용 이해를 많이 못했다. 내부 구현에 대한 부분이라 지루하기도 했고 모르는 용어와 옵션들이 많이 보여서 아무래도 집중력 있게 하지 못한거 같아 시간을 들여서 다시 읽는 작업을 해야 될거 같다.</p>\n"},{"title":"20190810","date":"2019-08-10T11:48:00.000Z","_content":"\n# 20190810\n## 1. 휴식?\n회사를 그만두었기 때문에 누릴 수 있는 가장 큰 사치는 아마 늘어지게 잘 수 있는 늦잠 그리고 자유로운 시간일 것이다. 최근 한달 가량을 그렇게 보내고자 맘을 먹었지만, 불행인지 다행인지 정말로 한번쯤은 도전해보고 싶은 회사에서 공채를 시작하여 거기에 매달려 한달 가량 아니 한 3주 가량의 시간을 전력의 삶(?)을 살다보니 시간이 어느덧 8월 가량이 되었다. 사실 저번달에는 공부도하고 공채 준비도 했으니 이번달에는 전력으로 쉬고자 하는 마음이 가장 크다. 하지만 공채 결과가 어떻게 될지는 모르겠지만, 그래도 좋은 방향으로 흐르고 있는거 같아. 어쩌면 지금의 휴식이 길어지지만은 않겠구나 하는 생각도 든다.\n\n뭐 다시 개발 이야기로 돌아와서 보자면 과제를 준비하면서 해볼 수 있는 건 모두 했다라고 생각하고 있다. \n프론트엔드에 그렇게 큰 관심을 두고 있는 건 아니지만, vue.js를 이용하여 간단한 어플리케이션을 만들어 볼 수 있어 추후에 다시 한다고 하더라도 근거는 없지만 조금은 어렵지 않게 접근할 수 있겠다는 생각이 들었기 때문이다.\n또한, 최근 계속 코틀린으로만 서버 어플리케이션을 작성했었는데, 다시 자바로 작성하면서 잃어버렸던 감 아닌 감을 조금은 찾을 수 있어서 좋았고, 코틀린에 맛을 들려버린 탓인지는 몰라도 이전에는 부수효과처럼 느껴졌던 롬복 같은 구현체도 이게 없으면 정말 불편하겠다 싶은 생각도 들었다. \n\n물론 자바와 코틀린 둘다 공부를 해야 하는 상황으로 갈거 같지만, 그래도 여유를 느낄 수 있는 지금의 상황도 너무 좋다. 쉬고 싶으면 그 마음 가는대로 쉬면 그만이고, 공부하고 싶고 책이 읽고 싶으면 내 마음 가는대로 할 수 있는 지금의 자유가 너무 좋은거 같다. 길어질거 같진 않지만 그래도 지금을 즐기고 충분하게 휴식하자!\n\n## 2. 그래서 뭘 공부하지?\n못했던 공부에 대해 어느정도 TODO 리스트는 작성하는 것이 좋을거 같다. 물론, 휴식기간 동안 다 못할 수 있다. 하지만, 4개 파트 중 두개... 아니 하나만 제대로 한다면 그거 나름대로의 의미가 있다고 생각한다.\n\n- DDD Start 나머지 파트 정리\n  * 책을 다 읽었지만, 정리 못한 부분이 존재함\n- JPA\n  * JPA 심화 파트 부분을 공부\n  * JPQL, 2차 캐시 등\n- 코틀린\n  * 기본 확장 함수, JVM 상호 운용\n  * 코루틴\n  * Spring, JPA를 함께 사용하면서 꼭 알아야 할 내용\n- 쉘 스크립트\n  * 이건 이번에 반드시 공부한다.\n\n\n\n","source":"_posts/DIARY/20190810.md","raw":"---\ntitle: 20190810\ndate: 2019.8.10. 20:48\ncategories:\n- DIARY\n---\n\n# 20190810\n## 1. 휴식?\n회사를 그만두었기 때문에 누릴 수 있는 가장 큰 사치는 아마 늘어지게 잘 수 있는 늦잠 그리고 자유로운 시간일 것이다. 최근 한달 가량을 그렇게 보내고자 맘을 먹었지만, 불행인지 다행인지 정말로 한번쯤은 도전해보고 싶은 회사에서 공채를 시작하여 거기에 매달려 한달 가량 아니 한 3주 가량의 시간을 전력의 삶(?)을 살다보니 시간이 어느덧 8월 가량이 되었다. 사실 저번달에는 공부도하고 공채 준비도 했으니 이번달에는 전력으로 쉬고자 하는 마음이 가장 크다. 하지만 공채 결과가 어떻게 될지는 모르겠지만, 그래도 좋은 방향으로 흐르고 있는거 같아. 어쩌면 지금의 휴식이 길어지지만은 않겠구나 하는 생각도 든다.\n\n뭐 다시 개발 이야기로 돌아와서 보자면 과제를 준비하면서 해볼 수 있는 건 모두 했다라고 생각하고 있다. \n프론트엔드에 그렇게 큰 관심을 두고 있는 건 아니지만, vue.js를 이용하여 간단한 어플리케이션을 만들어 볼 수 있어 추후에 다시 한다고 하더라도 근거는 없지만 조금은 어렵지 않게 접근할 수 있겠다는 생각이 들었기 때문이다.\n또한, 최근 계속 코틀린으로만 서버 어플리케이션을 작성했었는데, 다시 자바로 작성하면서 잃어버렸던 감 아닌 감을 조금은 찾을 수 있어서 좋았고, 코틀린에 맛을 들려버린 탓인지는 몰라도 이전에는 부수효과처럼 느껴졌던 롬복 같은 구현체도 이게 없으면 정말 불편하겠다 싶은 생각도 들었다. \n\n물론 자바와 코틀린 둘다 공부를 해야 하는 상황으로 갈거 같지만, 그래도 여유를 느낄 수 있는 지금의 상황도 너무 좋다. 쉬고 싶으면 그 마음 가는대로 쉬면 그만이고, 공부하고 싶고 책이 읽고 싶으면 내 마음 가는대로 할 수 있는 지금의 자유가 너무 좋은거 같다. 길어질거 같진 않지만 그래도 지금을 즐기고 충분하게 휴식하자!\n\n## 2. 그래서 뭘 공부하지?\n못했던 공부에 대해 어느정도 TODO 리스트는 작성하는 것이 좋을거 같다. 물론, 휴식기간 동안 다 못할 수 있다. 하지만, 4개 파트 중 두개... 아니 하나만 제대로 한다면 그거 나름대로의 의미가 있다고 생각한다.\n\n- DDD Start 나머지 파트 정리\n  * 책을 다 읽었지만, 정리 못한 부분이 존재함\n- JPA\n  * JPA 심화 파트 부분을 공부\n  * JPQL, 2차 캐시 등\n- 코틀린\n  * 기본 확장 함수, JVM 상호 운용\n  * 코루틴\n  * Spring, JPA를 함께 사용하면서 꼭 알아야 할 내용\n- 쉘 스크립트\n  * 이건 이번에 반드시 공부한다.\n\n\n\n","slug":"DIARY/20190810","published":1,"updated":"2021-08-02T12:00:11.596Z","_id":"ckrsup503000ntjhv6j7g0irn","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20190810\"><a href=\"#20190810\" class=\"headerlink\" title=\"20190810\"></a>20190810</h1><h2 id=\"1-휴식\"><a href=\"#1-휴식\" class=\"headerlink\" title=\"1. 휴식?\"></a>1. 휴식?</h2><p>회사를 그만두었기 때문에 누릴 수 있는 가장 큰 사치는 아마 늘어지게 잘 수 있는 늦잠 그리고 자유로운 시간일 것이다. 최근 한달 가량을 그렇게 보내고자 맘을 먹었지만, 불행인지 다행인지 정말로 한번쯤은 도전해보고 싶은 회사에서 공채를 시작하여 거기에 매달려 한달 가량 아니 한 3주 가량의 시간을 전력의 삶(?)을 살다보니 시간이 어느덧 8월 가량이 되었다. 사실 저번달에는 공부도하고 공채 준비도 했으니 이번달에는 전력으로 쉬고자 하는 마음이 가장 크다. 하지만 공채 결과가 어떻게 될지는 모르겠지만, 그래도 좋은 방향으로 흐르고 있는거 같아. 어쩌면 지금의 휴식이 길어지지만은 않겠구나 하는 생각도 든다.</p>\n<p>뭐 다시 개발 이야기로 돌아와서 보자면 과제를 준비하면서 해볼 수 있는 건 모두 했다라고 생각하고 있다.<br>프론트엔드에 그렇게 큰 관심을 두고 있는 건 아니지만, vue.js를 이용하여 간단한 어플리케이션을 만들어 볼 수 있어 추후에 다시 한다고 하더라도 근거는 없지만 조금은 어렵지 않게 접근할 수 있겠다는 생각이 들었기 때문이다.<br>또한, 최근 계속 코틀린으로만 서버 어플리케이션을 작성했었는데, 다시 자바로 작성하면서 잃어버렸던 감 아닌 감을 조금은 찾을 수 있어서 좋았고, 코틀린에 맛을 들려버린 탓인지는 몰라도 이전에는 부수효과처럼 느껴졌던 롬복 같은 구현체도 이게 없으면 정말 불편하겠다 싶은 생각도 들었다. </p>\n<p>물론 자바와 코틀린 둘다 공부를 해야 하는 상황으로 갈거 같지만, 그래도 여유를 느낄 수 있는 지금의 상황도 너무 좋다. 쉬고 싶으면 그 마음 가는대로 쉬면 그만이고, 공부하고 싶고 책이 읽고 싶으면 내 마음 가는대로 할 수 있는 지금의 자유가 너무 좋은거 같다. 길어질거 같진 않지만 그래도 지금을 즐기고 충분하게 휴식하자!</p>\n<h2 id=\"2-그래서-뭘-공부하지\"><a href=\"#2-그래서-뭘-공부하지\" class=\"headerlink\" title=\"2. 그래서 뭘 공부하지?\"></a>2. 그래서 뭘 공부하지?</h2><p>못했던 공부에 대해 어느정도 TODO 리스트는 작성하는 것이 좋을거 같다. 물론, 휴식기간 동안 다 못할 수 있다. 하지만, 4개 파트 중 두개… 아니 하나만 제대로 한다면 그거 나름대로의 의미가 있다고 생각한다.</p>\n<ul>\n<li>DDD Start 나머지 파트 정리<ul>\n<li>책을 다 읽었지만, 정리 못한 부분이 존재함</li>\n</ul>\n</li>\n<li>JPA<ul>\n<li>JPA 심화 파트 부분을 공부</li>\n<li>JPQL, 2차 캐시 등</li>\n</ul>\n</li>\n<li>코틀린<ul>\n<li>기본 확장 함수, JVM 상호 운용</li>\n<li>코루틴</li>\n<li>Spring, JPA를 함께 사용하면서 꼭 알아야 할 내용</li>\n</ul>\n</li>\n<li>쉘 스크립트<ul>\n<li>이건 이번에 반드시 공부한다.</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20190810\"><a href=\"#20190810\" class=\"headerlink\" title=\"20190810\"></a>20190810</h1><h2 id=\"1-휴식\"><a href=\"#1-휴식\" class=\"headerlink\" title=\"1. 휴식?\"></a>1. 휴식?</h2><p>회사를 그만두었기 때문에 누릴 수 있는 가장 큰 사치는 아마 늘어지게 잘 수 있는 늦잠 그리고 자유로운 시간일 것이다. 최근 한달 가량을 그렇게 보내고자 맘을 먹었지만, 불행인지 다행인지 정말로 한번쯤은 도전해보고 싶은 회사에서 공채를 시작하여 거기에 매달려 한달 가량 아니 한 3주 가량의 시간을 전력의 삶(?)을 살다보니 시간이 어느덧 8월 가량이 되었다. 사실 저번달에는 공부도하고 공채 준비도 했으니 이번달에는 전력으로 쉬고자 하는 마음이 가장 크다. 하지만 공채 결과가 어떻게 될지는 모르겠지만, 그래도 좋은 방향으로 흐르고 있는거 같아. 어쩌면 지금의 휴식이 길어지지만은 않겠구나 하는 생각도 든다.</p>\n<p>뭐 다시 개발 이야기로 돌아와서 보자면 과제를 준비하면서 해볼 수 있는 건 모두 했다라고 생각하고 있다.<br>프론트엔드에 그렇게 큰 관심을 두고 있는 건 아니지만, vue.js를 이용하여 간단한 어플리케이션을 만들어 볼 수 있어 추후에 다시 한다고 하더라도 근거는 없지만 조금은 어렵지 않게 접근할 수 있겠다는 생각이 들었기 때문이다.<br>또한, 최근 계속 코틀린으로만 서버 어플리케이션을 작성했었는데, 다시 자바로 작성하면서 잃어버렸던 감 아닌 감을 조금은 찾을 수 있어서 좋았고, 코틀린에 맛을 들려버린 탓인지는 몰라도 이전에는 부수효과처럼 느껴졌던 롬복 같은 구현체도 이게 없으면 정말 불편하겠다 싶은 생각도 들었다. </p>\n<p>물론 자바와 코틀린 둘다 공부를 해야 하는 상황으로 갈거 같지만, 그래도 여유를 느낄 수 있는 지금의 상황도 너무 좋다. 쉬고 싶으면 그 마음 가는대로 쉬면 그만이고, 공부하고 싶고 책이 읽고 싶으면 내 마음 가는대로 할 수 있는 지금의 자유가 너무 좋은거 같다. 길어질거 같진 않지만 그래도 지금을 즐기고 충분하게 휴식하자!</p>\n<h2 id=\"2-그래서-뭘-공부하지\"><a href=\"#2-그래서-뭘-공부하지\" class=\"headerlink\" title=\"2. 그래서 뭘 공부하지?\"></a>2. 그래서 뭘 공부하지?</h2><p>못했던 공부에 대해 어느정도 TODO 리스트는 작성하는 것이 좋을거 같다. 물론, 휴식기간 동안 다 못할 수 있다. 하지만, 4개 파트 중 두개… 아니 하나만 제대로 한다면 그거 나름대로의 의미가 있다고 생각한다.</p>\n<ul>\n<li>DDD Start 나머지 파트 정리<ul>\n<li>책을 다 읽었지만, 정리 못한 부분이 존재함</li>\n</ul>\n</li>\n<li>JPA<ul>\n<li>JPA 심화 파트 부분을 공부</li>\n<li>JPQL, 2차 캐시 등</li>\n</ul>\n</li>\n<li>코틀린<ul>\n<li>기본 확장 함수, JVM 상호 운용</li>\n<li>코루틴</li>\n<li>Spring, JPA를 함께 사용하면서 꼭 알아야 할 내용</li>\n</ul>\n</li>\n<li>쉘 스크립트<ul>\n<li>이건 이번에 반드시 공부한다.</li>\n</ul>\n</li>\n</ul>\n"},{"title":"20200305","date":"2020-03-04T15:00:00.000Z","_content":"\n# 20200305\n## RabbitMQ 학습\n- AMQP 프로토콜에서의 RPC콜이 서버와 클라이언트 사이에서 어떤 명령과 어떤 메세지를 주거니 받거니 하는지에 대한 간단한 학습\n  - 채널과 프레임의 개념\n  - 프레임의 종류\n    - 헤더 프레임\n    - 메소드 프레임\n    - 컨텐츠 헤더 프레임\n    - 바디 프레임\n    - 하트비트 프레임\n  - 프레임의 역할과 기능\n- 간단한 실습 예제 작성\n  - Spring Boot + Spring AMQP를 사용하여 메세지 전송 및 리스너에서 Consume 해보기\n\n## Spring Application Context Hierachy\n- 스프링 부트를 사용하여 Application Context의 하이라키를 구성하여 작성해봄\n- 목적은 서브 도메인 혹은 개별 모듈에서 상호간 DI를 하지 못하도록 하여, 도메인의 Context 경계를 명확하게 해보려는 것이 목적\n- Spring Boot를 활용하다 보니 AutoConfiguration이 되는 부분이 많아서 설정에 쫌 애를 먹은듯\n\n\n\n","source":"_posts/DIARY/20200305.md","raw":"---\ntitle: 20200305\ndate: 2020/3/5 00:00:00\ncategories:\n- DIARY\n---\n\n# 20200305\n## RabbitMQ 학습\n- AMQP 프로토콜에서의 RPC콜이 서버와 클라이언트 사이에서 어떤 명령과 어떤 메세지를 주거니 받거니 하는지에 대한 간단한 학습\n  - 채널과 프레임의 개념\n  - 프레임의 종류\n    - 헤더 프레임\n    - 메소드 프레임\n    - 컨텐츠 헤더 프레임\n    - 바디 프레임\n    - 하트비트 프레임\n  - 프레임의 역할과 기능\n- 간단한 실습 예제 작성\n  - Spring Boot + Spring AMQP를 사용하여 메세지 전송 및 리스너에서 Consume 해보기\n\n## Spring Application Context Hierachy\n- 스프링 부트를 사용하여 Application Context의 하이라키를 구성하여 작성해봄\n- 목적은 서브 도메인 혹은 개별 모듈에서 상호간 DI를 하지 못하도록 하여, 도메인의 Context 경계를 명확하게 해보려는 것이 목적\n- Spring Boot를 활용하다 보니 AutoConfiguration이 되는 부분이 많아서 설정에 쫌 애를 먹은듯\n\n\n\n","slug":"DIARY/20200305","published":1,"updated":"2021-08-02T12:03:39.281Z","_id":"ckrsup503000otjhv8p735t39","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20200305\"><a href=\"#20200305\" class=\"headerlink\" title=\"20200305\"></a>20200305</h1><h2 id=\"RabbitMQ-학습\"><a href=\"#RabbitMQ-학습\" class=\"headerlink\" title=\"RabbitMQ 학습\"></a>RabbitMQ 학습</h2><ul>\n<li>AMQP 프로토콜에서의 RPC콜이 서버와 클라이언트 사이에서 어떤 명령과 어떤 메세지를 주거니 받거니 하는지에 대한 간단한 학습<ul>\n<li>채널과 프레임의 개념</li>\n<li>프레임의 종류<ul>\n<li>헤더 프레임</li>\n<li>메소드 프레임</li>\n<li>컨텐츠 헤더 프레임</li>\n<li>바디 프레임</li>\n<li>하트비트 프레임</li>\n</ul>\n</li>\n<li>프레임의 역할과 기능</li>\n</ul>\n</li>\n<li>간단한 실습 예제 작성<ul>\n<li>Spring Boot + Spring AMQP를 사용하여 메세지 전송 및 리스너에서 Consume 해보기</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Spring-Application-Context-Hierachy\"><a href=\"#Spring-Application-Context-Hierachy\" class=\"headerlink\" title=\"Spring Application Context Hierachy\"></a>Spring Application Context Hierachy</h2><ul>\n<li>스프링 부트를 사용하여 Application Context의 하이라키를 구성하여 작성해봄</li>\n<li>목적은 서브 도메인 혹은 개별 모듈에서 상호간 DI를 하지 못하도록 하여, 도메인의 Context 경계를 명확하게 해보려는 것이 목적</li>\n<li>Spring Boot를 활용하다 보니 AutoConfiguration이 되는 부분이 많아서 설정에 쫌 애를 먹은듯</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20200305\"><a href=\"#20200305\" class=\"headerlink\" title=\"20200305\"></a>20200305</h1><h2 id=\"RabbitMQ-학습\"><a href=\"#RabbitMQ-학습\" class=\"headerlink\" title=\"RabbitMQ 학습\"></a>RabbitMQ 학습</h2><ul>\n<li>AMQP 프로토콜에서의 RPC콜이 서버와 클라이언트 사이에서 어떤 명령과 어떤 메세지를 주거니 받거니 하는지에 대한 간단한 학습<ul>\n<li>채널과 프레임의 개념</li>\n<li>프레임의 종류<ul>\n<li>헤더 프레임</li>\n<li>메소드 프레임</li>\n<li>컨텐츠 헤더 프레임</li>\n<li>바디 프레임</li>\n<li>하트비트 프레임</li>\n</ul>\n</li>\n<li>프레임의 역할과 기능</li>\n</ul>\n</li>\n<li>간단한 실습 예제 작성<ul>\n<li>Spring Boot + Spring AMQP를 사용하여 메세지 전송 및 리스너에서 Consume 해보기</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Spring-Application-Context-Hierachy\"><a href=\"#Spring-Application-Context-Hierachy\" class=\"headerlink\" title=\"Spring Application Context Hierachy\"></a>Spring Application Context Hierachy</h2><ul>\n<li>스프링 부트를 사용하여 Application Context의 하이라키를 구성하여 작성해봄</li>\n<li>목적은 서브 도메인 혹은 개별 모듈에서 상호간 DI를 하지 못하도록 하여, 도메인의 Context 경계를 명확하게 해보려는 것이 목적</li>\n<li>Spring Boot를 활용하다 보니 AutoConfiguration이 되는 부분이 많아서 설정에 쫌 애를 먹은듯</li>\n</ul>\n"},{"title":"20200922","date":"2020-09-21T15:00:00.000Z","_content":"\n# 20200922\n## 코틀린 인 액션 읽기\n- 코틀린 + 스프링 관련 12장 내용 읽고 정리\n- 코루틴 관련 13장 전체 읽고 내용 정리 중","source":"_posts/DIARY/20200922.md","raw":"---\ntitle: 20200922\ndate: 2020/9/22 00:00:00\ncategories:\n- DIARY\n---\n\n# 20200922\n## 코틀린 인 액션 읽기\n- 코틀린 + 스프링 관련 12장 내용 읽고 정리\n- 코루틴 관련 13장 전체 읽고 내용 정리 중","slug":"DIARY/20200922","published":1,"updated":"2021-08-02T12:00:31.674Z","_id":"ckrsup504000ptjhv8078ctmv","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20200922\"><a href=\"#20200922\" class=\"headerlink\" title=\"20200922\"></a>20200922</h1><h2 id=\"코틀린-인-액션-읽기\"><a href=\"#코틀린-인-액션-읽기\" class=\"headerlink\" title=\"코틀린 인 액션 읽기\"></a>코틀린 인 액션 읽기</h2><ul>\n<li>코틀린 + 스프링 관련 12장 내용 읽고 정리</li>\n<li>코루틴 관련 13장 전체 읽고 내용 정리 중</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20200922\"><a href=\"#20200922\" class=\"headerlink\" title=\"20200922\"></a>20200922</h1><h2 id=\"코틀린-인-액션-읽기\"><a href=\"#코틀린-인-액션-읽기\" class=\"headerlink\" title=\"코틀린 인 액션 읽기\"></a>코틀린 인 액션 읽기</h2><ul>\n<li>코틀린 + 스프링 관련 12장 내용 읽고 정리</li>\n<li>코루틴 관련 13장 전체 읽고 내용 정리 중</li>\n</ul>\n"},{"title":"20210727","date":"2021-07-27T14:28:00.000Z","_content":"\n# 20210727\n## 블로그 정리\n- [MINIMAL SKIN](https://memostack.tistory.com/98?category=806129) 적용\n- 불필요 글 비공개 처리 및 태그 삭제\n- KotlinInAction 제네릭스 관련 글 업로드\n- @RequestParam 관련 요약 정리\n\n## 데이터 중심 어플리케이션 설계 - 07장 트랜잭션 읽기\n- 트랜잭션은 어플리케이션 구현 혹은 프로그래밍 모델의 난이도를 낮추기 위한 데이터 저장소의 장치\n- 현대적 의미에서의 트랜잭션은 과거와 많은 차이가 있다.\n  - 분산 저장소를 지원하는 데이터베이스 고가용성과 높은 성능을 위해서 트랜잭션은 확장성을 해치는 안티테제로 여기는 믿음이 생김\n  - 기존 데이터베이스 벤더에서는 \"값진 데이터\"와 \"중요 데이터\"를 필수적인 요건이라고 말하고 있음\n- ACID의 의미 해석\n  - 데이터베이스별로 ACID에 대한 구현은 다음\n  - 상위 개념은 동일하지만 악마는 세부사항에 숨겨져 있음\n  - 일관성(Consistency)는 어플리케이션 종속적인 개념. 예를 들어 트랜잭션을 제대로 선언하지 않은 상황이라면 데이터베이스는 일관성을 유지 할 수 없음. 결국 데이터베이스를 사용하는 어플리케이션에서 데이터에 관한 선언이 우선되어야 함.\n","source":"_posts/DIARY/20210727.md","raw":"---\ntitle: 20210727\ndate: 2021.7.27. 23:28\ncategories:\n- DIARY\n---\n\n# 20210727\n## 블로그 정리\n- [MINIMAL SKIN](https://memostack.tistory.com/98?category=806129) 적용\n- 불필요 글 비공개 처리 및 태그 삭제\n- KotlinInAction 제네릭스 관련 글 업로드\n- @RequestParam 관련 요약 정리\n\n## 데이터 중심 어플리케이션 설계 - 07장 트랜잭션 읽기\n- 트랜잭션은 어플리케이션 구현 혹은 프로그래밍 모델의 난이도를 낮추기 위한 데이터 저장소의 장치\n- 현대적 의미에서의 트랜잭션은 과거와 많은 차이가 있다.\n  - 분산 저장소를 지원하는 데이터베이스 고가용성과 높은 성능을 위해서 트랜잭션은 확장성을 해치는 안티테제로 여기는 믿음이 생김\n  - 기존 데이터베이스 벤더에서는 \"값진 데이터\"와 \"중요 데이터\"를 필수적인 요건이라고 말하고 있음\n- ACID의 의미 해석\n  - 데이터베이스별로 ACID에 대한 구현은 다음\n  - 상위 개념은 동일하지만 악마는 세부사항에 숨겨져 있음\n  - 일관성(Consistency)는 어플리케이션 종속적인 개념. 예를 들어 트랜잭션을 제대로 선언하지 않은 상황이라면 데이터베이스는 일관성을 유지 할 수 없음. 결국 데이터베이스를 사용하는 어플리케이션에서 데이터에 관한 선언이 우선되어야 함.\n","slug":"DIARY/20210727","published":1,"updated":"2021-08-02T11:58:47.260Z","_id":"ckrsup504000qtjhvcvvg5332","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20210727\"><a href=\"#20210727\" class=\"headerlink\" title=\"20210727\"></a>20210727</h1><h2 id=\"블로그-정리\"><a href=\"#블로그-정리\" class=\"headerlink\" title=\"블로그 정리\"></a>블로그 정리</h2><ul>\n<li><a href=\"https://memostack.tistory.com/98?category=806129\">MINIMAL SKIN</a> 적용</li>\n<li>불필요 글 비공개 처리 및 태그 삭제</li>\n<li>KotlinInAction 제네릭스 관련 글 업로드</li>\n<li>@RequestParam 관련 요약 정리</li>\n</ul>\n<h2 id=\"데이터-중심-어플리케이션-설계-07장-트랜잭션-읽기\"><a href=\"#데이터-중심-어플리케이션-설계-07장-트랜잭션-읽기\" class=\"headerlink\" title=\"데이터 중심 어플리케이션 설계 - 07장 트랜잭션 읽기\"></a>데이터 중심 어플리케이션 설계 - 07장 트랜잭션 읽기</h2><ul>\n<li>트랜잭션은 어플리케이션 구현 혹은 프로그래밍 모델의 난이도를 낮추기 위한 데이터 저장소의 장치</li>\n<li>현대적 의미에서의 트랜잭션은 과거와 많은 차이가 있다.<ul>\n<li>분산 저장소를 지원하는 데이터베이스 고가용성과 높은 성능을 위해서 트랜잭션은 확장성을 해치는 안티테제로 여기는 믿음이 생김</li>\n<li>기존 데이터베이스 벤더에서는 “값진 데이터”와 “중요 데이터”를 필수적인 요건이라고 말하고 있음</li>\n</ul>\n</li>\n<li>ACID의 의미 해석<ul>\n<li>데이터베이스별로 ACID에 대한 구현은 다음</li>\n<li>상위 개념은 동일하지만 악마는 세부사항에 숨겨져 있음</li>\n<li>일관성(Consistency)는 어플리케이션 종속적인 개념. 예를 들어 트랜잭션을 제대로 선언하지 않은 상황이라면 데이터베이스는 일관성을 유지 할 수 없음. 결국 데이터베이스를 사용하는 어플리케이션에서 데이터에 관한 선언이 우선되어야 함.</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20210727\"><a href=\"#20210727\" class=\"headerlink\" title=\"20210727\"></a>20210727</h1><h2 id=\"블로그-정리\"><a href=\"#블로그-정리\" class=\"headerlink\" title=\"블로그 정리\"></a>블로그 정리</h2><ul>\n<li><a href=\"https://memostack.tistory.com/98?category=806129\">MINIMAL SKIN</a> 적용</li>\n<li>불필요 글 비공개 처리 및 태그 삭제</li>\n<li>KotlinInAction 제네릭스 관련 글 업로드</li>\n<li>@RequestParam 관련 요약 정리</li>\n</ul>\n<h2 id=\"데이터-중심-어플리케이션-설계-07장-트랜잭션-읽기\"><a href=\"#데이터-중심-어플리케이션-설계-07장-트랜잭션-읽기\" class=\"headerlink\" title=\"데이터 중심 어플리케이션 설계 - 07장 트랜잭션 읽기\"></a>데이터 중심 어플리케이션 설계 - 07장 트랜잭션 읽기</h2><ul>\n<li>트랜잭션은 어플리케이션 구현 혹은 프로그래밍 모델의 난이도를 낮추기 위한 데이터 저장소의 장치</li>\n<li>현대적 의미에서의 트랜잭션은 과거와 많은 차이가 있다.<ul>\n<li>분산 저장소를 지원하는 데이터베이스 고가용성과 높은 성능을 위해서 트랜잭션은 확장성을 해치는 안티테제로 여기는 믿음이 생김</li>\n<li>기존 데이터베이스 벤더에서는 “값진 데이터”와 “중요 데이터”를 필수적인 요건이라고 말하고 있음</li>\n</ul>\n</li>\n<li>ACID의 의미 해석<ul>\n<li>데이터베이스별로 ACID에 대한 구현은 다음</li>\n<li>상위 개념은 동일하지만 악마는 세부사항에 숨겨져 있음</li>\n<li>일관성(Consistency)는 어플리케이션 종속적인 개념. 예를 들어 트랜잭션을 제대로 선언하지 않은 상황이라면 데이터베이스는 일관성을 유지 할 수 없음. 결국 데이터베이스를 사용하는 어플리케이션에서 데이터에 관한 선언이 우선되어야 함.</li>\n</ul>\n</li>\n</ul>\n"},{"title":"20210730","date":"2021-07-29T15:00:00.000Z","_content":"\n# 20210730\n## Vuepress 기반 블로그 제작\n- 기존 Tistory 블로그가 너무 불편\n- 마크다운 렌더링이 너무 중구난방이라 답답한게 많았음\n- 결국 직접 만드는걸로 결론을 내리고, 여러 후보군을 살펴보다가 `Vuepress`로 결정\n- 플러그인 설정 / 컴포넌트 제작 등 손이 많이 감. 그래도 2~3일정도 소요가 된듯.\n","source":"_posts/DIARY/20210730.md","raw":"---\ntitle: 20210730\ndate: 2021/7/30 00:00:00\ncategories:\n- DIARY\n---\n\n# 20210730\n## Vuepress 기반 블로그 제작\n- 기존 Tistory 블로그가 너무 불편\n- 마크다운 렌더링이 너무 중구난방이라 답답한게 많았음\n- 결국 직접 만드는걸로 결론을 내리고, 여러 후보군을 살펴보다가 `Vuepress`로 결정\n- 플러그인 설정 / 컴포넌트 제작 등 손이 많이 감. 그래도 2~3일정도 소요가 된듯.\n","slug":"DIARY/20210730","published":1,"updated":"2021-08-02T12:31:39.077Z","_id":"ckrsup505000rtjhv5bnbax10","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20210730\"><a href=\"#20210730\" class=\"headerlink\" title=\"20210730\"></a>20210730</h1><h2 id=\"Vuepress-기반-블로그-제작\"><a href=\"#Vuepress-기반-블로그-제작\" class=\"headerlink\" title=\"Vuepress 기반 블로그 제작\"></a>Vuepress 기반 블로그 제작</h2><ul>\n<li>기존 Tistory 블로그가 너무 불편</li>\n<li>마크다운 렌더링이 너무 중구난방이라 답답한게 많았음</li>\n<li>결국 직접 만드는걸로 결론을 내리고, 여러 후보군을 살펴보다가 <code>Vuepress</code>로 결정</li>\n<li>플러그인 설정 / 컴포넌트 제작 등 손이 많이 감. 그래도 2~3일정도 소요가 된듯.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20210730\"><a href=\"#20210730\" class=\"headerlink\" title=\"20210730\"></a>20210730</h1><h2 id=\"Vuepress-기반-블로그-제작\"><a href=\"#Vuepress-기반-블로그-제작\" class=\"headerlink\" title=\"Vuepress 기반 블로그 제작\"></a>Vuepress 기반 블로그 제작</h2><ul>\n<li>기존 Tistory 블로그가 너무 불편</li>\n<li>마크다운 렌더링이 너무 중구난방이라 답답한게 많았음</li>\n<li>결국 직접 만드는걸로 결론을 내리고, 여러 후보군을 살펴보다가 <code>Vuepress</code>로 결정</li>\n<li>플러그인 설정 / 컴포넌트 제작 등 손이 많이 감. 그래도 2~3일정도 소요가 된듯.</li>\n</ul>\n"},{"title":"20210728","date":"2021-07-28T14:21:00.000Z","_content":"\n# 20210728\n## 데이터 중심 어플리케이션 설계 - 07장 트랜잭션 읽기\n- 격리성\n  - 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미\n  - 고전적인 데이터베이스 용어에서는 `격리성 == 직렬성`의 의미를 가지기도 함\n  - 직렬성(`serializable`)이란 실제로 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션 커밋의 결과가 트랜잭션이 순차 실행됐을때와 동일하도록 보장\n  - 직렬성(`serializable`) 격리는 일반적으로 성능 손해를 동반할 수 밖에 없기 때문에 거의 사용하지 않음. 실제는 보다 약한 스냅샷 격리를 구현\n- 지속성\n  - 트랜잭션이 성공적으로 커밋되었다면 하드웨어 결함/데이터베이스가 죽더라도 트랜잭션에 기록한 데이터는 손실되지 않아야 함을 뜻함\n  > 예를 들어 쓰기 전 로그(write-ahead log) 혹은 비슷한 수단을 통하여 쓰기 저장소가 오염될 경우 복원 처리\n  - 지속성을 보장하려면 커밋 전에 쓰기/복제가 완료될 때까지 기다려야 한다.\n- 더티 리드(Dirty Read)\n  - 다른 트랜잭션에서 커밋되지 않은 데이터를 읽는 현상\n- RDB에서는 트랜잭션을 통하여 다중 객체(ROW)에 대한 어떤 읽기 연산/쓰기 연산이 있는지 식별하게 됨.\n- 비관계형 데이터베이스에서는 트랜잭션과 같은 연산을 묶는 방법이 없는 경우가 많은데, 대신 비슷하게 보이는 연산을 묶는 오퍼레이션을 제공하기도 함(예를 들어 레디스의 MULTI) 하지만, 원자성을 보장하는 연산은 아니라서 예를 들어 1과 2의 연산이 있을 때 1이 실패하더라도 2는 그대로 실행하게 된다.\n\n| Isolation Level  | Dirty Read  | Non-Repeatable Read  | Phantom Read  |\n| --- | --- | --- | --- | --- |\n| Read Uncommitted  | 가능  | 가능  | 가능  |\n| Read Committed  | 불가능  | 가능  | 가능  |\n| Repeatable Read  | 불가능  | 불가능  | 가능  |\n| Serializable  | 불가능  | 불가능  | 불가능  |\n\n- 고립수준은 Read Uncomitted 가 가장 낮고 Serializable이 가장 높음\n- 동시성 수준은 위와 반대","source":"_posts/DIARY/20210728.md","raw":"---\ntitle: 20210728\ndate: 2021.7.28. 23:21\ncategories:\n- DIARY\n---\n\n# 20210728\n## 데이터 중심 어플리케이션 설계 - 07장 트랜잭션 읽기\n- 격리성\n  - 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미\n  - 고전적인 데이터베이스 용어에서는 `격리성 == 직렬성`의 의미를 가지기도 함\n  - 직렬성(`serializable`)이란 실제로 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션 커밋의 결과가 트랜잭션이 순차 실행됐을때와 동일하도록 보장\n  - 직렬성(`serializable`) 격리는 일반적으로 성능 손해를 동반할 수 밖에 없기 때문에 거의 사용하지 않음. 실제는 보다 약한 스냅샷 격리를 구현\n- 지속성\n  - 트랜잭션이 성공적으로 커밋되었다면 하드웨어 결함/데이터베이스가 죽더라도 트랜잭션에 기록한 데이터는 손실되지 않아야 함을 뜻함\n  > 예를 들어 쓰기 전 로그(write-ahead log) 혹은 비슷한 수단을 통하여 쓰기 저장소가 오염될 경우 복원 처리\n  - 지속성을 보장하려면 커밋 전에 쓰기/복제가 완료될 때까지 기다려야 한다.\n- 더티 리드(Dirty Read)\n  - 다른 트랜잭션에서 커밋되지 않은 데이터를 읽는 현상\n- RDB에서는 트랜잭션을 통하여 다중 객체(ROW)에 대한 어떤 읽기 연산/쓰기 연산이 있는지 식별하게 됨.\n- 비관계형 데이터베이스에서는 트랜잭션과 같은 연산을 묶는 방법이 없는 경우가 많은데, 대신 비슷하게 보이는 연산을 묶는 오퍼레이션을 제공하기도 함(예를 들어 레디스의 MULTI) 하지만, 원자성을 보장하는 연산은 아니라서 예를 들어 1과 2의 연산이 있을 때 1이 실패하더라도 2는 그대로 실행하게 된다.\n\n| Isolation Level  | Dirty Read  | Non-Repeatable Read  | Phantom Read  |\n| --- | --- | --- | --- | --- |\n| Read Uncommitted  | 가능  | 가능  | 가능  |\n| Read Committed  | 불가능  | 가능  | 가능  |\n| Repeatable Read  | 불가능  | 불가능  | 가능  |\n| Serializable  | 불가능  | 불가능  | 불가능  |\n\n- 고립수준은 Read Uncomitted 가 가장 낮고 Serializable이 가장 높음\n- 동시성 수준은 위와 반대","slug":"DIARY/20210728","published":1,"updated":"2021-08-02T11:58:14.270Z","_id":"ckrsup506000stjhvafsk67n8","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"20210728\"><a href=\"#20210728\" class=\"headerlink\" title=\"20210728\"></a>20210728</h1><h2 id=\"데이터-중심-어플리케이션-설계-07장-트랜잭션-읽기\"><a href=\"#데이터-중심-어플리케이션-설계-07장-트랜잭션-읽기\" class=\"headerlink\" title=\"데이터 중심 어플리케이션 설계 - 07장 트랜잭션 읽기\"></a>데이터 중심 어플리케이션 설계 - 07장 트랜잭션 읽기</h2><ul>\n<li>격리성<ul>\n<li>동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미</li>\n<li>고전적인 데이터베이스 용어에서는 <code>격리성 == 직렬성</code>의 의미를 가지기도 함</li>\n<li>직렬성(<code>serializable</code>)이란 실제로 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션 커밋의 결과가 트랜잭션이 순차 실행됐을때와 동일하도록 보장</li>\n<li>직렬성(<code>serializable</code>) 격리는 일반적으로 성능 손해를 동반할 수 밖에 없기 때문에 거의 사용하지 않음. 실제는 보다 약한 스냅샷 격리를 구현</li>\n</ul>\n</li>\n<li>지속성<ul>\n<li>트랜잭션이 성공적으로 커밋되었다면 하드웨어 결함/데이터베이스가 죽더라도 트랜잭션에 기록한 데이터는 손실되지 않아야 함을 뜻함<blockquote>\n<p>예를 들어 쓰기 전 로그(write-ahead log) 혹은 비슷한 수단을 통하여 쓰기 저장소가 오염될 경우 복원 처리</p>\n</blockquote>\n</li>\n<li>지속성을 보장하려면 커밋 전에 쓰기/복제가 완료될 때까지 기다려야 한다.</li>\n</ul>\n</li>\n<li>더티 리드(Dirty Read)<ul>\n<li>다른 트랜잭션에서 커밋되지 않은 데이터를 읽는 현상</li>\n</ul>\n</li>\n<li>RDB에서는 트랜잭션을 통하여 다중 객체(ROW)에 대한 어떤 읽기 연산/쓰기 연산이 있는지 식별하게 됨.</li>\n<li>비관계형 데이터베이스에서는 트랜잭션과 같은 연산을 묶는 방법이 없는 경우가 많은데, 대신 비슷하게 보이는 연산을 묶는 오퍼레이션을 제공하기도 함(예를 들어 레디스의 MULTI) 하지만, 원자성을 보장하는 연산은 아니라서 예를 들어 1과 2의 연산이 있을 때 1이 실패하더라도 2는 그대로 실행하게 된다.</li>\n</ul>\n<p>| Isolation Level  | Dirty Read  | Non-Repeatable Read  | Phantom Read  |<br>| — | — | — | — | — |<br>| Read Uncommitted  | 가능  | 가능  | 가능  |<br>| Read Committed  | 불가능  | 가능  | 가능  |<br>| Repeatable Read  | 불가능  | 불가능  | 가능  |<br>| Serializable  | 불가능  | 불가능  | 불가능  |</p>\n<ul>\n<li>고립수준은 Read Uncomitted 가 가장 낮고 Serializable이 가장 높음</li>\n<li>동시성 수준은 위와 반대</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"20210728\"><a href=\"#20210728\" class=\"headerlink\" title=\"20210728\"></a>20210728</h1><h2 id=\"데이터-중심-어플리케이션-설계-07장-트랜잭션-읽기\"><a href=\"#데이터-중심-어플리케이션-설계-07장-트랜잭션-읽기\" class=\"headerlink\" title=\"데이터 중심 어플리케이션 설계 - 07장 트랜잭션 읽기\"></a>데이터 중심 어플리케이션 설계 - 07장 트랜잭션 읽기</h2><ul>\n<li>격리성<ul>\n<li>동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미</li>\n<li>고전적인 데이터베이스 용어에서는 <code>격리성 == 직렬성</code>의 의미를 가지기도 함</li>\n<li>직렬성(<code>serializable</code>)이란 실제로 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션 커밋의 결과가 트랜잭션이 순차 실행됐을때와 동일하도록 보장</li>\n<li>직렬성(<code>serializable</code>) 격리는 일반적으로 성능 손해를 동반할 수 밖에 없기 때문에 거의 사용하지 않음. 실제는 보다 약한 스냅샷 격리를 구현</li>\n</ul>\n</li>\n<li>지속성<ul>\n<li>트랜잭션이 성공적으로 커밋되었다면 하드웨어 결함/데이터베이스가 죽더라도 트랜잭션에 기록한 데이터는 손실되지 않아야 함을 뜻함<blockquote>\n<p>예를 들어 쓰기 전 로그(write-ahead log) 혹은 비슷한 수단을 통하여 쓰기 저장소가 오염될 경우 복원 처리</p>\n</blockquote>\n</li>\n<li>지속성을 보장하려면 커밋 전에 쓰기/복제가 완료될 때까지 기다려야 한다.</li>\n</ul>\n</li>\n<li>더티 리드(Dirty Read)<ul>\n<li>다른 트랜잭션에서 커밋되지 않은 데이터를 읽는 현상</li>\n</ul>\n</li>\n<li>RDB에서는 트랜잭션을 통하여 다중 객체(ROW)에 대한 어떤 읽기 연산/쓰기 연산이 있는지 식별하게 됨.</li>\n<li>비관계형 데이터베이스에서는 트랜잭션과 같은 연산을 묶는 방법이 없는 경우가 많은데, 대신 비슷하게 보이는 연산을 묶는 오퍼레이션을 제공하기도 함(예를 들어 레디스의 MULTI) 하지만, 원자성을 보장하는 연산은 아니라서 예를 들어 1과 2의 연산이 있을 때 1이 실패하더라도 2는 그대로 실행하게 된다.</li>\n</ul>\n<p>| Isolation Level  | Dirty Read  | Non-Repeatable Read  | Phantom Read  |<br>| — | — | — | — | — |<br>| Read Uncommitted  | 가능  | 가능  | 가능  |<br>| Read Committed  | 불가능  | 가능  | 가능  |<br>| Repeatable Read  | 불가능  | 불가능  | 가능  |<br>| Serializable  | 불가능  | 불가능  | 불가능  |</p>\n<ul>\n<li>고립수준은 Read Uncomitted 가 가장 낮고 Serializable이 가장 높음</li>\n<li>동시성 수준은 위와 반대</li>\n</ul>\n"},{"title":"그림으로배우는HTTP - 6. HTTP 헤더","date":"2020-02-04T15:00:00.000Z","_content":"\n# 그림으로배우는HTTP - 6. HTTP 헤더\n\n부가적으로 중요한 정보를 담고 있는 역할\nHTTP 메시지 크기, 사용하는 언어, 인증, 브라우저 정보 등\n\n\n## 용도에 따른 구분\n- General Header Field\nHTTP Reqeust와 Response에 모두 사용하는 공용 헤더 필드\n- Request Header Field\n- Response Header Field\n- Entity Header Field\n\n## 캐시 혹은 비캐시 동작에 따른 구분\n### End-To-End Header\n최종 수신자(클라이언트, 서버)에게 전달해야 할 헤더\n### Hop-By-Hop Header\n한 번 전송에 유효한 헤더, 프록시나 캐시에 의해 전송되지 않을 수 있음. HTTP/1.1 이후에는 Hop-By-Hop 헤더는 Connection 헤더 필드에 열거해야 함.\n- Connection\n- Keep-Alive\n- Proxy-Authenitcate\n- Proxy-Authorization\n- Trailer\n- TE\n- Transfer-Encoding\n- Upgrade\n\n    \n## General Header Field\n### Cache-Control\nDirective를 사용하여 캐싱 동작 지정 가능, Directive는 파라메터 지정이 가능한 것과 아닌 것이 존재함.\n#### 캐시 가능 여부 디렉티브\n- public: 전체 대상\n- private: 특정 대상\n- no-cache: 캐싱 정책 사용 안함, 헤더명을 지정하면 해당 헤더 값은 캐싱 안함.\n#### 보존 가능 여부 제어\n- no-store: 기밀 정보 포함에 따른 캐싱 정책 사용 안함을 명시\n#### 캐시 기한 혹은 검증\n- s-maxage\n    - max-age와 역할은 동일, 다른 점은 다수에게 적용할 수 있는 캐시 서버에 적용\n    - 해당 디렉티브 사용 시, Expires 및 max-age 디렉티브 무시\n\n- max-age\n    - 요청의 경우, 지정한 값이 0이면 매번 오리진 서버에 요청\n    - 응답의 경우, 리소스 캐시를 보관해두는 최대 시간을 나타냄, Expires 헤더와 같이 사용할 경우, Expires 헤더 무시, HTTP/1.0의 경우 반대\n\n- no-transform\n    - 미디어 타입을 변경하지 않도록 지정하며 이미지 등이 압축되는 것을 방지\n\n### Connection\n#### 프록시에 더 이상 전송하지 않을 헤더 필드를 지정\n더 이상 전송하지 않는 헤더 필드를 지정할 수 있음(Hop-By-Hop Header)\n#### 지속적 접속 관리\n- 서버 측에서 명시적으로 접속을 끊고 싶을 경우 Connection 헤더 필드에 Close라고 지정\n- HTTP/1.1 이전에서는 지속적 접속을 디폴트로 사용하지 않았음, 명시적으로 헤더에 포함시켜야 했음.**(HTTP/1.1의 경우 디폴트로 지속적 접속을 사용)**\n```puml\n@startuml\nactor 클라이언트\n== Close ==\n클라이언트 <- 서버: HTTP Response\nnote left\n    Connection: Close\nend note\n== Keep-alive ==\n클라이언트 -> 서버: HTTP Request\nnote right\n    GET / HTTP/1.1\n    Connection: Keep-alive\nend note\n클라이언트 <- 서버: HTTP Response\nnote left\n    HTTP/1.1 200 OK\n    Keep-Alive: timeout=10, max=500\n    Connection: Keep-alive\nend note\n\n@enduml\n```\n\n### Date\n- HTTP 메세지 생성 날짜를 표현\n### Pragma\n- HTTP/1.1 이전 스펙의 헤더, 클라이언트 리퀘스트의 경우에만 사용\n- 클라이언트에서 캐시된 리소스를 원하지 않을 때 아래와 같이 표현\n```http\n...\nPragma: no-cache\n...\n```\n- 일반적으로 요청을 보내는 서버의 HTTP 버젼을 모르는 경우가 많기 때문에 캐시를 허용하지 않을 경우 아래와 같이 헤더 정보를 명시\n```http\nPragma: no-cache\nCache-Control: no-cache\n```\n","source":"_posts/HTTP/그림으로배우는_HTTP_CH6.md","raw":"---\ntitle: 그림으로배우는HTTP - 6. HTTP 헤더\ndate: 2020/2/5 00:00:00\ncategories:\n- HTTP\n---\n\n# 그림으로배우는HTTP - 6. HTTP 헤더\n\n부가적으로 중요한 정보를 담고 있는 역할\nHTTP 메시지 크기, 사용하는 언어, 인증, 브라우저 정보 등\n\n\n## 용도에 따른 구분\n- General Header Field\nHTTP Reqeust와 Response에 모두 사용하는 공용 헤더 필드\n- Request Header Field\n- Response Header Field\n- Entity Header Field\n\n## 캐시 혹은 비캐시 동작에 따른 구분\n### End-To-End Header\n최종 수신자(클라이언트, 서버)에게 전달해야 할 헤더\n### Hop-By-Hop Header\n한 번 전송에 유효한 헤더, 프록시나 캐시에 의해 전송되지 않을 수 있음. HTTP/1.1 이후에는 Hop-By-Hop 헤더는 Connection 헤더 필드에 열거해야 함.\n- Connection\n- Keep-Alive\n- Proxy-Authenitcate\n- Proxy-Authorization\n- Trailer\n- TE\n- Transfer-Encoding\n- Upgrade\n\n    \n## General Header Field\n### Cache-Control\nDirective를 사용하여 캐싱 동작 지정 가능, Directive는 파라메터 지정이 가능한 것과 아닌 것이 존재함.\n#### 캐시 가능 여부 디렉티브\n- public: 전체 대상\n- private: 특정 대상\n- no-cache: 캐싱 정책 사용 안함, 헤더명을 지정하면 해당 헤더 값은 캐싱 안함.\n#### 보존 가능 여부 제어\n- no-store: 기밀 정보 포함에 따른 캐싱 정책 사용 안함을 명시\n#### 캐시 기한 혹은 검증\n- s-maxage\n    - max-age와 역할은 동일, 다른 점은 다수에게 적용할 수 있는 캐시 서버에 적용\n    - 해당 디렉티브 사용 시, Expires 및 max-age 디렉티브 무시\n\n- max-age\n    - 요청의 경우, 지정한 값이 0이면 매번 오리진 서버에 요청\n    - 응답의 경우, 리소스 캐시를 보관해두는 최대 시간을 나타냄, Expires 헤더와 같이 사용할 경우, Expires 헤더 무시, HTTP/1.0의 경우 반대\n\n- no-transform\n    - 미디어 타입을 변경하지 않도록 지정하며 이미지 등이 압축되는 것을 방지\n\n### Connection\n#### 프록시에 더 이상 전송하지 않을 헤더 필드를 지정\n더 이상 전송하지 않는 헤더 필드를 지정할 수 있음(Hop-By-Hop Header)\n#### 지속적 접속 관리\n- 서버 측에서 명시적으로 접속을 끊고 싶을 경우 Connection 헤더 필드에 Close라고 지정\n- HTTP/1.1 이전에서는 지속적 접속을 디폴트로 사용하지 않았음, 명시적으로 헤더에 포함시켜야 했음.**(HTTP/1.1의 경우 디폴트로 지속적 접속을 사용)**\n```puml\n@startuml\nactor 클라이언트\n== Close ==\n클라이언트 <- 서버: HTTP Response\nnote left\n    Connection: Close\nend note\n== Keep-alive ==\n클라이언트 -> 서버: HTTP Request\nnote right\n    GET / HTTP/1.1\n    Connection: Keep-alive\nend note\n클라이언트 <- 서버: HTTP Response\nnote left\n    HTTP/1.1 200 OK\n    Keep-Alive: timeout=10, max=500\n    Connection: Keep-alive\nend note\n\n@enduml\n```\n\n### Date\n- HTTP 메세지 생성 날짜를 표현\n### Pragma\n- HTTP/1.1 이전 스펙의 헤더, 클라이언트 리퀘스트의 경우에만 사용\n- 클라이언트에서 캐시된 리소스를 원하지 않을 때 아래와 같이 표현\n```http\n...\nPragma: no-cache\n...\n```\n- 일반적으로 요청을 보내는 서버의 HTTP 버젼을 모르는 경우가 많기 때문에 캐시를 허용하지 않을 경우 아래와 같이 헤더 정보를 명시\n```http\nPragma: no-cache\nCache-Control: no-cache\n```\n","slug":"HTTP/그림으로배우는_HTTP_CH6","published":1,"updated":"2021-08-02T12:10:43.747Z","_id":"ckrsup506000ttjhv9tuvf9w2","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"그림으로배우는HTTP-6-HTTP-헤더\"><a href=\"#그림으로배우는HTTP-6-HTTP-헤더\" class=\"headerlink\" title=\"그림으로배우는HTTP - 6. HTTP 헤더\"></a>그림으로배우는HTTP - 6. HTTP 헤더</h1><p>부가적으로 중요한 정보를 담고 있는 역할<br>HTTP 메시지 크기, 사용하는 언어, 인증, 브라우저 정보 등</p>\n<h2 id=\"용도에-따른-구분\"><a href=\"#용도에-따른-구분\" class=\"headerlink\" title=\"용도에 따른 구분\"></a>용도에 따른 구분</h2><ul>\n<li>General Header Field<br>HTTP Reqeust와 Response에 모두 사용하는 공용 헤더 필드</li>\n<li>Request Header Field</li>\n<li>Response Header Field</li>\n<li>Entity Header Field</li>\n</ul>\n<h2 id=\"캐시-혹은-비캐시-동작에-따른-구분\"><a href=\"#캐시-혹은-비캐시-동작에-따른-구분\" class=\"headerlink\" title=\"캐시 혹은 비캐시 동작에 따른 구분\"></a>캐시 혹은 비캐시 동작에 따른 구분</h2><h3 id=\"End-To-End-Header\"><a href=\"#End-To-End-Header\" class=\"headerlink\" title=\"End-To-End Header\"></a>End-To-End Header</h3><p>최종 수신자(클라이언트, 서버)에게 전달해야 할 헤더</p>\n<h3 id=\"Hop-By-Hop-Header\"><a href=\"#Hop-By-Hop-Header\" class=\"headerlink\" title=\"Hop-By-Hop Header\"></a>Hop-By-Hop Header</h3><p>한 번 전송에 유효한 헤더, 프록시나 캐시에 의해 전송되지 않을 수 있음. HTTP/1.1 이후에는 Hop-By-Hop 헤더는 Connection 헤더 필드에 열거해야 함.</p>\n<ul>\n<li>Connection</li>\n<li>Keep-Alive</li>\n<li>Proxy-Authenitcate</li>\n<li>Proxy-Authorization</li>\n<li>Trailer</li>\n<li>TE</li>\n<li>Transfer-Encoding</li>\n<li>Upgrade</li>\n</ul>\n<h2 id=\"General-Header-Field\"><a href=\"#General-Header-Field\" class=\"headerlink\" title=\"General Header Field\"></a>General Header Field</h2><h3 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h3><p>Directive를 사용하여 캐싱 동작 지정 가능, Directive는 파라메터 지정이 가능한 것과 아닌 것이 존재함.</p>\n<h4 id=\"캐시-가능-여부-디렉티브\"><a href=\"#캐시-가능-여부-디렉티브\" class=\"headerlink\" title=\"캐시 가능 여부 디렉티브\"></a>캐시 가능 여부 디렉티브</h4><ul>\n<li><p>public: 전체 대상</p>\n</li>\n<li><p>private: 특정 대상</p>\n</li>\n<li><p>no-cache: 캐싱 정책 사용 안함, 헤더명을 지정하면 해당 헤더 값은 캐싱 안함.</p>\n<h4 id=\"보존-가능-여부-제어\"><a href=\"#보존-가능-여부-제어\" class=\"headerlink\" title=\"보존 가능 여부 제어\"></a>보존 가능 여부 제어</h4></li>\n<li><p>no-store: 기밀 정보 포함에 따른 캐싱 정책 사용 안함을 명시</p>\n<h4 id=\"캐시-기한-혹은-검증\"><a href=\"#캐시-기한-혹은-검증\" class=\"headerlink\" title=\"캐시 기한 혹은 검증\"></a>캐시 기한 혹은 검증</h4></li>\n<li><p>s-maxage</p>\n<ul>\n<li>max-age와 역할은 동일, 다른 점은 다수에게 적용할 수 있는 캐시 서버에 적용</li>\n<li>해당 디렉티브 사용 시, Expires 및 max-age 디렉티브 무시</li>\n</ul>\n</li>\n<li><p>max-age</p>\n<ul>\n<li>요청의 경우, 지정한 값이 0이면 매번 오리진 서버에 요청</li>\n<li>응답의 경우, 리소스 캐시를 보관해두는 최대 시간을 나타냄, Expires 헤더와 같이 사용할 경우, Expires 헤더 무시, HTTP/1.0의 경우 반대</li>\n</ul>\n</li>\n<li><p>no-transform</p>\n<ul>\n<li>미디어 타입을 변경하지 않도록 지정하며 이미지 등이 압축되는 것을 방지</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Connection\"><a href=\"#Connection\" class=\"headerlink\" title=\"Connection\"></a>Connection</h3><h4 id=\"프록시에-더-이상-전송하지-않을-헤더-필드를-지정\"><a href=\"#프록시에-더-이상-전송하지-않을-헤더-필드를-지정\" class=\"headerlink\" title=\"프록시에 더 이상 전송하지 않을 헤더 필드를 지정\"></a>프록시에 더 이상 전송하지 않을 헤더 필드를 지정</h4><p>더 이상 전송하지 않는 헤더 필드를 지정할 수 있음(Hop-By-Hop Header)</p>\n<h4 id=\"지속적-접속-관리\"><a href=\"#지속적-접속-관리\" class=\"headerlink\" title=\"지속적 접속 관리\"></a>지속적 접속 관리</h4><ul>\n<li>서버 측에서 명시적으로 접속을 끊고 싶을 경우 Connection 헤더 필드에 Close라고 지정</li>\n<li>HTTP/1.1 이전에서는 지속적 접속을 디폴트로 사용하지 않았음, 명시적으로 헤더에 포함시켜야 했음.<strong>(HTTP/1.1의 경우 디폴트로 지속적 접속을 사용)</strong><img src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U2NyaXB0VHlwZT0iYXBwbGljYXRpb24vZWNtYXNjcmlwdCIgY29udGVudFN0eWxlVHlwZT0idGV4dC9jc3MiIGhlaWdodD0iNDQxcHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDo1NzhweDtoZWlnaHQ6NDQxcHg7YmFja2dyb3VuZDojRkZGRkZGOyIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgNTc4IDQ0MSIgd2lkdGg9IjU3OHB4IiB6b29tQW5kUGFuPSJtYWduaWZ5Ij48ZGVmcz48ZmlsdGVyIGhlaWdodD0iMzAwJSIgaWQ9ImZydzFtNTAzamwyeTgiIHdpZHRoPSIzMDAlIiB4PSItMSIgeT0iLTEiPjxmZUdhdXNzaWFuQmx1ciByZXN1bHQ9ImJsdXJPdXQiIHN0ZERldmlhdGlvbj0iMi4wIi8+PGZlQ29sb3JNYXRyaXggaW49ImJsdXJPdXQiIHJlc3VsdD0iYmx1ck91dDIiIHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAuNCAwIi8+PGZlT2Zmc2V0IGR4PSI0LjAiIGR5PSI0LjAiIGluPSJibHVyT3V0MiIgcmVzdWx0PSJibHVyT3V0MyIvPjxmZUJsZW5kIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9ImJsdXJPdXQzIiBtb2RlPSJub3JtYWwiLz48L2ZpbHRlcj48L2RlZnM+PGc+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9IjI1OSIgeDI9IjI1OSIgeTE9Ijg4LjI5NjkiIHkyPSIzNTcuMzU5NCIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6NS4wLDUuMDsiIHgxPSIzODMiIHgyPSIzODMiIHkxPSI4OC4yOTY5IiB5Mj0iMzU3LjM1OTQiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI3MCIgeD0iMjIxIiB5PSI4NC45OTUxIj7tgbTrnbzsnbTslrjtirg8L3RleHQ+PGVsbGlwc2UgY3g9IjI1OSIgY3k9IjE1IiBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZnJ3MW01MDNqbDJ5OCkiIHJ4PSI4IiByeT0iOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHBhdGggZD0iTTI1OSwyMyBMMjU5LDUwIE0yNDYsMzEgTDI3MiwzMSBNMjU5LDUwIEwyNDYsNjUgTTI1OSw1MCBMMjcyLDY1ICIgZmlsbD0ibm9uZSIgZmlsdGVyPSJ1cmwoI2ZydzFtNTAzamwyeTgpIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI3MCIgeD0iMjIxIiB5PSIzNjkuMzU0NSI+7YG065287J207Ja47Yq4PC90ZXh0PjxlbGxpcHNlIGN4PSIyNTkiIGN5PSIzODIuNjU2MyIgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2ZydzFtNTAzamwyeTgpIiByeD0iOCIgcnk9IjgiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6Mi4wOyIvPjxwYXRoIGQ9Ik0yNTksMzkwLjY1NjMgTDI1OSw0MTcuNjU2MyBNMjQ2LDM5OC42NTYzIEwyNzIsMzk4LjY1NjMgTTI1OSw0MTcuNjU2MyBMMjQ2LDQzMi42NTYzIE0yNTksNDE3LjY1NjMgTDI3Miw0MzIuNjU2MyAiIGZpbGw9Im5vbmUiIGZpbHRlcj0idXJsKCNmcncxbTUwM2psMnk4KSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2ZydzFtNTAzamwyeTgpIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjQyIiB4PSIzNjAiIHk9IjUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjgiIHg9IjM2NyIgeT0iNzIuOTk1MSI+7ISc67KEPC90ZXh0PjxyZWN0IGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmcncxbTUwM2psMnk4KSIgaGVpZ2h0PSIzMC4yOTY5IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI0MiIgeD0iMzYwIiB5PSIzNTYuMzU5NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI4IiB4PSIzNjciIHk9IjM3Ni4zNTQ1Ij7shJzrsoQ8L3RleHQ+PHJlY3QgZmlsbD0iI0VFRUVFRSIgZmlsdGVyPSJ1cmwoI2ZydzFtNTAzamwyeTgpIiBoZWlnaHQ9IjMiIHN0eWxlPSJzdHJva2U6I0VFRUVFRTtzdHJva2Utd2lkdGg6MS4wOyIgd2lkdGg9IjU3MSIgeD0iMCIgeT0iMTE4Ljg2MzMiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIwIiB4Mj0iNTcxIiB5MT0iMTE4Ljg2MzMiIHkyPSIxMTguODYzMyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjAiIHgyPSI1NzEiIHkxPSIxMjEuODYzMyIgeTI9IjEyMS44NjMzIi8+PHJlY3QgZmlsbD0iI0VFRUVFRSIgZmlsdGVyPSJ1cmwoI2ZydzFtNTAzamwyeTgpIiBoZWlnaHQ9IjIzLjEzMjgiIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6Mi4wOyIgd2lkdGg9IjYwIiB4PSIyNTUuNSIgeT0iMTA4LjI5NjkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDEiIHg9IjI2MS41IiB5PSIxMjQuMzYzOCI+Q2xvc2U8L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIyNzAsMTYzLjU2MjUsMjYwLDE2Ny41NjI1LDI3MCwxNzEuNTYyNSwyNjYsMTY3LjU2MjUiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjI2NCIgeDI9IjM4MiIgeTE9IjE2Ny41NjI1IiB5Mj0iMTY3LjU2MjUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMDAiIHg9IjI3NiIgeT0iMTYyLjQ5NjYiPkhUVFAgUmVzcG9uc2U8L3RleHQ+PHBhdGggZD0iTTExMywxNDYuNDI5NyBMMTEzLDE3MS40Mjk3IEwyNTAsMTcxLjQyOTcgTDI1MCwxNTYuNDI5NyBMMjQwLDE0Ni40Mjk3IEwxMTMsMTQ2LjQyOTcgIiBmaWxsPSIjRkJGQjc3IiBmaWx0ZXI9InVybCgjZnJ3MW01MDNqbDJ5OCkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0yNDAsMTQ2LjQyOTcgTDI0MCwxNTYuNDI5NyBMMjUwLDE1Ni40Mjk3IEwyNDAsMTQ2LjQyOTcgIiBmaWxsPSIjRkJGQjc3IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMTYiIHg9IjExOSIgeT0iMTYzLjQ5NjYiPkNvbm5lY3Rpb246IENsb3NlPC90ZXh0PjxyZWN0IGZpbGw9IiNFRUVFRUUiIGZpbHRlcj0idXJsKCNmcncxbTUwM2psMnk4KSIgaGVpZ2h0PSIzIiBzdHlsZT0ic3Ryb2tlOiNFRUVFRUU7c3Ryb2tlLXdpZHRoOjEuMDsiIHdpZHRoPSI1NzEiIHg9IjAiIHk9IjIwMS4xMjg5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMCIgeDI9IjU3MSIgeTE9IjIwMS4xMjg5IiB5Mj0iMjAxLjEyODkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIwIiB4Mj0iNTcxIiB5MT0iMjA0LjEyODkiIHkyPSIyMDQuMTI4OSIvPjxyZWN0IGZpbGw9IiNFRUVFRUUiIGZpbHRlcj0idXJsKCNmcncxbTUwM2psMnk4KSIgaGVpZ2h0PSIyMy4xMzI4IiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjIuMDsiIHdpZHRoPSI5NiIgeD0iMjM3LjUiIHk9IjE5MC41NjI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijc3IiB4PSIyNDMuNSIgeT0iMjA2LjYyOTQiPktlZXAtYWxpdmU8L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIzNzEsMjUzLjM5NDUsMzgxLDI1Ny4zOTQ1LDM3MSwyNjEuMzk0NSwzNzUsMjU3LjM5NDUiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjI1OSIgeDI9IjM3NyIgeTE9IjI1Ny4zOTQ1IiB5Mj0iMjU3LjM5NDUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5MCIgeD0iMjY2IiB5PSIyNTIuMzI4NiI+SFRUUCBSZXF1ZXN0PC90ZXh0PjxwYXRoIGQ9Ik0zODgsMjI4LjY5NTMgTDM4OCwyNjguNjk1MyBMNTU3LDI2OC42OTUzIEw1NTcsMjM4LjY5NTMgTDU0NywyMjguNjk1MyBMMzg4LDIyOC42OTUzICIgZmlsbD0iI0ZCRkI3NyIgZmlsdGVyPSJ1cmwoI2ZydzFtNTAzamwyeTgpIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNNTQ3LDIyOC42OTUzIEw1NDcsMjM4LjY5NTMgTDU1NywyMzguNjk1MyBMNTQ3LDIyOC42OTUzICIgZmlsbD0iI0ZCRkI3NyIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTUiIHg9IjM5NCIgeT0iMjQ1Ljc2MjIiPkdFVCAvIEhUVFAvMS4xPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0OCIgeD0iMzk0IiB5PSIyNjAuODk1Ij5Db25uZWN0aW9uOiBLZWVwLWFsaXZlPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMjcwLDMxNS4yMjY2LDI2MCwzMTkuMjI2NiwyNzAsMzIzLjIyNjYsMjY2LDMxOS4yMjY2IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIyNjQiIHgyPSIzODIiIHkxPSIzMTkuMjI2NiIgeTI9IjMxOS4yMjY2Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTAwIiB4PSIyNzYiIHk9IjMxNC4xNjA2Ij5IVFRQIFJlc3BvbnNlPC90ZXh0PjxwYXRoIGQ9Ik01LDI4Mi45NjA5IEw1LDMzNy45NjA5IEwyNTAsMzM3Ljk2MDkgTDI1MCwyOTIuOTYwOSBMMjQwLDI4Mi45NjA5IEw1LDI4Mi45NjA5ICIgZmlsbD0iI0ZCRkI3NyIgZmlsdGVyPSJ1cmwoI2ZydzFtNTAzamwyeTgpIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjQwLDI4Mi45NjA5IEwyNDAsMjkyLjk2MDkgTDI1MCwyOTIuOTYwOSBMMjQwLDI4Mi45NjA5ICIgZmlsbD0iI0ZCRkI3NyIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTA3IiB4PSIxMSIgeT0iMzAwLjAyNzgiPkhUVFAvMS4xIDIwMCBPSzwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMjQiIHg9IjExIiB5PSIzMTUuMTYwNiI+S2VlcC1BbGl2ZTogdGltZW91dD0xMCwgbWF4PTUwMDwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNDgiIHg9IjExIiB5PSIzMzAuMjkzNSI+Q29ubmVjdGlvbjogS2VlcC1hbGl2ZTwvdGV4dD48IS0tTUQ1PVs0NWRjOTVkNjRmODNiMmZkZDFiMTFiOTVhYjM2NDZkNV0KQHN0YXJ0dW1sDQphY3RvciDtgbTrnbzsnbTslrjtirgNCj09IENsb3NlID09DQrtgbTrnbzsnbTslrjtirggPC0g7ISc67KEOiBIVFRQIFJlc3BvbnNlDQpub3RlIGxlZnQNCiAgICBDb25uZWN0aW9uOiBDbG9zZQ0KZW5kIG5vdGUNCj09IEtlZXAtYWxpdmUgPT0NCu2BtOudvOydtOyWuO2KuCAtPiDshJzrsoQ6IEhUVFAgUmVxdWVzdA0Kbm90ZSByaWdodA0KICAgIEdFVCAvIEhUVFAvMS4xDQogICAgQ29ubmVjdGlvbjogS2VlcC1hbGl2ZQ0KZW5kIG5vdGUNCu2BtOudvOydtOyWuO2KuCA8LSDshJzrsoQ6IEhUVFAgUmVzcG9uc2UNCm5vdGUgbGVmdA0KICAgIEhUVFAvMS4xIDIwMCBPSw0KICAgIEtlZXAtQWxpdmU6IHRpbWVvdXQ9MTAsIG1heD01MDANCiAgICBDb25uZWN0aW9uOiBLZWVwLWFsaXZlDQplbmQgbm90ZQ0KQGVuZHVtbA0KClBsYW50VU1MIHZlcnNpb24gMS4yMDIxLjEwYmV0YTIoVW5rbm93biBjb21waWxlIHRpbWUpCihHUEwgc291cmNlIGRpc3RyaWJ1dGlvbikKSmF2YSBSdW50aW1lOiBKYXZhKFRNKSBTRSBSdW50aW1lIEVudmlyb25tZW50CkpWTTogSmF2YSBIb3RTcG90KFRNKSA2NC1CaXQgU2VydmVyIFZNCkRlZmF1bHQgRW5jb2Rpbmc6IFVURi04Ckxhbmd1YWdlOiBlbgpDb3VudHJ5OiBVUwotLT48L2c+PC9zdmc+'></li>\n</ul>\n<h3 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h3><ul>\n<li>HTTP 메세지 생성 날짜를 표현<h3 id=\"Pragma\"><a href=\"#Pragma\" class=\"headerlink\" title=\"Pragma\"></a>Pragma</h3></li>\n<li>HTTP/1.1 이전 스펙의 헤더, 클라이언트 리퀘스트의 경우에만 사용</li>\n<li>클라이언트에서 캐시된 리소스를 원하지 않을 때 아래와 같이 표현<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"attribute\">Pragma</span><span class=\"punctuation\">: </span>no-cache</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></li>\n<li>일반적으로 요청을 보내는 서버의 HTTP 버젼을 모르는 경우가 많기 때문에 캐시를 허용하지 않을 경우 아래와 같이 헤더 정보를 명시<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Pragma</span><span class=\"punctuation\">: </span>no-cache</span><br><span class=\"line\"><span class=\"attribute\">Cache-Control</span><span class=\"punctuation\">: </span>no-cache</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"그림으로배우는HTTP-6-HTTP-헤더\"><a href=\"#그림으로배우는HTTP-6-HTTP-헤더\" class=\"headerlink\" title=\"그림으로배우는HTTP - 6. HTTP 헤더\"></a>그림으로배우는HTTP - 6. HTTP 헤더</h1><p>부가적으로 중요한 정보를 담고 있는 역할<br>HTTP 메시지 크기, 사용하는 언어, 인증, 브라우저 정보 등</p>\n<h2 id=\"용도에-따른-구분\"><a href=\"#용도에-따른-구분\" class=\"headerlink\" title=\"용도에 따른 구분\"></a>용도에 따른 구분</h2><ul>\n<li>General Header Field<br>HTTP Reqeust와 Response에 모두 사용하는 공용 헤더 필드</li>\n<li>Request Header Field</li>\n<li>Response Header Field</li>\n<li>Entity Header Field</li>\n</ul>\n<h2 id=\"캐시-혹은-비캐시-동작에-따른-구분\"><a href=\"#캐시-혹은-비캐시-동작에-따른-구분\" class=\"headerlink\" title=\"캐시 혹은 비캐시 동작에 따른 구분\"></a>캐시 혹은 비캐시 동작에 따른 구분</h2><h3 id=\"End-To-End-Header\"><a href=\"#End-To-End-Header\" class=\"headerlink\" title=\"End-To-End Header\"></a>End-To-End Header</h3><p>최종 수신자(클라이언트, 서버)에게 전달해야 할 헤더</p>\n<h3 id=\"Hop-By-Hop-Header\"><a href=\"#Hop-By-Hop-Header\" class=\"headerlink\" title=\"Hop-By-Hop Header\"></a>Hop-By-Hop Header</h3><p>한 번 전송에 유효한 헤더, 프록시나 캐시에 의해 전송되지 않을 수 있음. HTTP/1.1 이후에는 Hop-By-Hop 헤더는 Connection 헤더 필드에 열거해야 함.</p>\n<ul>\n<li>Connection</li>\n<li>Keep-Alive</li>\n<li>Proxy-Authenitcate</li>\n<li>Proxy-Authorization</li>\n<li>Trailer</li>\n<li>TE</li>\n<li>Transfer-Encoding</li>\n<li>Upgrade</li>\n</ul>\n<h2 id=\"General-Header-Field\"><a href=\"#General-Header-Field\" class=\"headerlink\" title=\"General Header Field\"></a>General Header Field</h2><h3 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h3><p>Directive를 사용하여 캐싱 동작 지정 가능, Directive는 파라메터 지정이 가능한 것과 아닌 것이 존재함.</p>\n<h4 id=\"캐시-가능-여부-디렉티브\"><a href=\"#캐시-가능-여부-디렉티브\" class=\"headerlink\" title=\"캐시 가능 여부 디렉티브\"></a>캐시 가능 여부 디렉티브</h4><ul>\n<li><p>public: 전체 대상</p>\n</li>\n<li><p>private: 특정 대상</p>\n</li>\n<li><p>no-cache: 캐싱 정책 사용 안함, 헤더명을 지정하면 해당 헤더 값은 캐싱 안함.</p>\n<h4 id=\"보존-가능-여부-제어\"><a href=\"#보존-가능-여부-제어\" class=\"headerlink\" title=\"보존 가능 여부 제어\"></a>보존 가능 여부 제어</h4></li>\n<li><p>no-store: 기밀 정보 포함에 따른 캐싱 정책 사용 안함을 명시</p>\n<h4 id=\"캐시-기한-혹은-검증\"><a href=\"#캐시-기한-혹은-검증\" class=\"headerlink\" title=\"캐시 기한 혹은 검증\"></a>캐시 기한 혹은 검증</h4></li>\n<li><p>s-maxage</p>\n<ul>\n<li>max-age와 역할은 동일, 다른 점은 다수에게 적용할 수 있는 캐시 서버에 적용</li>\n<li>해당 디렉티브 사용 시, Expires 및 max-age 디렉티브 무시</li>\n</ul>\n</li>\n<li><p>max-age</p>\n<ul>\n<li>요청의 경우, 지정한 값이 0이면 매번 오리진 서버에 요청</li>\n<li>응답의 경우, 리소스 캐시를 보관해두는 최대 시간을 나타냄, Expires 헤더와 같이 사용할 경우, Expires 헤더 무시, HTTP/1.0의 경우 반대</li>\n</ul>\n</li>\n<li><p>no-transform</p>\n<ul>\n<li>미디어 타입을 변경하지 않도록 지정하며 이미지 등이 압축되는 것을 방지</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Connection\"><a href=\"#Connection\" class=\"headerlink\" title=\"Connection\"></a>Connection</h3><h4 id=\"프록시에-더-이상-전송하지-않을-헤더-필드를-지정\"><a href=\"#프록시에-더-이상-전송하지-않을-헤더-필드를-지정\" class=\"headerlink\" title=\"프록시에 더 이상 전송하지 않을 헤더 필드를 지정\"></a>프록시에 더 이상 전송하지 않을 헤더 필드를 지정</h4><p>더 이상 전송하지 않는 헤더 필드를 지정할 수 있음(Hop-By-Hop Header)</p>\n<h4 id=\"지속적-접속-관리\"><a href=\"#지속적-접속-관리\" class=\"headerlink\" title=\"지속적 접속 관리\"></a>지속적 접속 관리</h4><ul>\n<li>서버 측에서 명시적으로 접속을 끊고 싶을 경우 Connection 헤더 필드에 Close라고 지정</li>\n<li>HTTP/1.1 이전에서는 지속적 접속을 디폴트로 사용하지 않았음, 명시적으로 헤더에 포함시켜야 했음.<strong>(HTTP/1.1의 경우 디폴트로 지속적 접속을 사용)</strong><img src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U2NyaXB0VHlwZT0iYXBwbGljYXRpb24vZWNtYXNjcmlwdCIgY29udGVudFN0eWxlVHlwZT0idGV4dC9jc3MiIGhlaWdodD0iNDQxcHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDo1NzhweDtoZWlnaHQ6NDQxcHg7YmFja2dyb3VuZDojRkZGRkZGOyIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgNTc4IDQ0MSIgd2lkdGg9IjU3OHB4IiB6b29tQW5kUGFuPSJtYWduaWZ5Ij48ZGVmcz48ZmlsdGVyIGhlaWdodD0iMzAwJSIgaWQ9ImZydzFtNTAzamwyeTgiIHdpZHRoPSIzMDAlIiB4PSItMSIgeT0iLTEiPjxmZUdhdXNzaWFuQmx1ciByZXN1bHQ9ImJsdXJPdXQiIHN0ZERldmlhdGlvbj0iMi4wIi8+PGZlQ29sb3JNYXRyaXggaW49ImJsdXJPdXQiIHJlc3VsdD0iYmx1ck91dDIiIHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAuNCAwIi8+PGZlT2Zmc2V0IGR4PSI0LjAiIGR5PSI0LjAiIGluPSJibHVyT3V0MiIgcmVzdWx0PSJibHVyT3V0MyIvPjxmZUJsZW5kIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9ImJsdXJPdXQzIiBtb2RlPSJub3JtYWwiLz48L2ZpbHRlcj48L2RlZnM+PGc+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9IjI1OSIgeDI9IjI1OSIgeTE9Ijg4LjI5NjkiIHkyPSIzNTcuMzU5NCIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6NS4wLDUuMDsiIHgxPSIzODMiIHgyPSIzODMiIHkxPSI4OC4yOTY5IiB5Mj0iMzU3LjM1OTQiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI3MCIgeD0iMjIxIiB5PSI4NC45OTUxIj7tgbTrnbzsnbTslrjtirg8L3RleHQ+PGVsbGlwc2UgY3g9IjI1OSIgY3k9IjE1IiBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZnJ3MW01MDNqbDJ5OCkiIHJ4PSI4IiByeT0iOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHBhdGggZD0iTTI1OSwyMyBMMjU5LDUwIE0yNDYsMzEgTDI3MiwzMSBNMjU5LDUwIEwyNDYsNjUgTTI1OSw1MCBMMjcyLDY1ICIgZmlsbD0ibm9uZSIgZmlsdGVyPSJ1cmwoI2ZydzFtNTAzamwyeTgpIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI3MCIgeD0iMjIxIiB5PSIzNjkuMzU0NSI+7YG065287J207Ja47Yq4PC90ZXh0PjxlbGxpcHNlIGN4PSIyNTkiIGN5PSIzODIuNjU2MyIgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2ZydzFtNTAzamwyeTgpIiByeD0iOCIgcnk9IjgiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6Mi4wOyIvPjxwYXRoIGQ9Ik0yNTksMzkwLjY1NjMgTDI1OSw0MTcuNjU2MyBNMjQ2LDM5OC42NTYzIEwyNzIsMzk4LjY1NjMgTTI1OSw0MTcuNjU2MyBMMjQ2LDQzMi42NTYzIE0yNTksNDE3LjY1NjMgTDI3Miw0MzIuNjU2MyAiIGZpbGw9Im5vbmUiIGZpbHRlcj0idXJsKCNmcncxbTUwM2psMnk4KSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2ZydzFtNTAzamwyeTgpIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjQyIiB4PSIzNjAiIHk9IjUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjgiIHg9IjM2NyIgeT0iNzIuOTk1MSI+7ISc67KEPC90ZXh0PjxyZWN0IGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmcncxbTUwM2psMnk4KSIgaGVpZ2h0PSIzMC4yOTY5IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI0MiIgeD0iMzYwIiB5PSIzNTYuMzU5NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI4IiB4PSIzNjciIHk9IjM3Ni4zNTQ1Ij7shJzrsoQ8L3RleHQ+PHJlY3QgZmlsbD0iI0VFRUVFRSIgZmlsdGVyPSJ1cmwoI2ZydzFtNTAzamwyeTgpIiBoZWlnaHQ9IjMiIHN0eWxlPSJzdHJva2U6I0VFRUVFRTtzdHJva2Utd2lkdGg6MS4wOyIgd2lkdGg9IjU3MSIgeD0iMCIgeT0iMTE4Ljg2MzMiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIwIiB4Mj0iNTcxIiB5MT0iMTE4Ljg2MzMiIHkyPSIxMTguODYzMyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjAiIHgyPSI1NzEiIHkxPSIxMjEuODYzMyIgeTI9IjEyMS44NjMzIi8+PHJlY3QgZmlsbD0iI0VFRUVFRSIgZmlsdGVyPSJ1cmwoI2ZydzFtNTAzamwyeTgpIiBoZWlnaHQ9IjIzLjEzMjgiIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6Mi4wOyIgd2lkdGg9IjYwIiB4PSIyNTUuNSIgeT0iMTA4LjI5NjkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDEiIHg9IjI2MS41IiB5PSIxMjQuMzYzOCI+Q2xvc2U8L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIyNzAsMTYzLjU2MjUsMjYwLDE2Ny41NjI1LDI3MCwxNzEuNTYyNSwyNjYsMTY3LjU2MjUiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjI2NCIgeDI9IjM4MiIgeTE9IjE2Ny41NjI1IiB5Mj0iMTY3LjU2MjUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMDAiIHg9IjI3NiIgeT0iMTYyLjQ5NjYiPkhUVFAgUmVzcG9uc2U8L3RleHQ+PHBhdGggZD0iTTExMywxNDYuNDI5NyBMMTEzLDE3MS40Mjk3IEwyNTAsMTcxLjQyOTcgTDI1MCwxNTYuNDI5NyBMMjQwLDE0Ni40Mjk3IEwxMTMsMTQ2LjQyOTcgIiBmaWxsPSIjRkJGQjc3IiBmaWx0ZXI9InVybCgjZnJ3MW01MDNqbDJ5OCkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0yNDAsMTQ2LjQyOTcgTDI0MCwxNTYuNDI5NyBMMjUwLDE1Ni40Mjk3IEwyNDAsMTQ2LjQyOTcgIiBmaWxsPSIjRkJGQjc3IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMTYiIHg9IjExOSIgeT0iMTYzLjQ5NjYiPkNvbm5lY3Rpb246IENsb3NlPC90ZXh0PjxyZWN0IGZpbGw9IiNFRUVFRUUiIGZpbHRlcj0idXJsKCNmcncxbTUwM2psMnk4KSIgaGVpZ2h0PSIzIiBzdHlsZT0ic3Ryb2tlOiNFRUVFRUU7c3Ryb2tlLXdpZHRoOjEuMDsiIHdpZHRoPSI1NzEiIHg9IjAiIHk9IjIwMS4xMjg5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMCIgeDI9IjU3MSIgeTE9IjIwMS4xMjg5IiB5Mj0iMjAxLjEyODkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIwIiB4Mj0iNTcxIiB5MT0iMjA0LjEyODkiIHkyPSIyMDQuMTI4OSIvPjxyZWN0IGZpbGw9IiNFRUVFRUUiIGZpbHRlcj0idXJsKCNmcncxbTUwM2psMnk4KSIgaGVpZ2h0PSIyMy4xMzI4IiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjIuMDsiIHdpZHRoPSI5NiIgeD0iMjM3LjUiIHk9IjE5MC41NjI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijc3IiB4PSIyNDMuNSIgeT0iMjA2LjYyOTQiPktlZXAtYWxpdmU8L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIzNzEsMjUzLjM5NDUsMzgxLDI1Ny4zOTQ1LDM3MSwyNjEuMzk0NSwzNzUsMjU3LjM5NDUiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjI1OSIgeDI9IjM3NyIgeTE9IjI1Ny4zOTQ1IiB5Mj0iMjU3LjM5NDUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5MCIgeD0iMjY2IiB5PSIyNTIuMzI4NiI+SFRUUCBSZXF1ZXN0PC90ZXh0PjxwYXRoIGQ9Ik0zODgsMjI4LjY5NTMgTDM4OCwyNjguNjk1MyBMNTU3LDI2OC42OTUzIEw1NTcsMjM4LjY5NTMgTDU0NywyMjguNjk1MyBMMzg4LDIyOC42OTUzICIgZmlsbD0iI0ZCRkI3NyIgZmlsdGVyPSJ1cmwoI2ZydzFtNTAzamwyeTgpIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNNTQ3LDIyOC42OTUzIEw1NDcsMjM4LjY5NTMgTDU1NywyMzguNjk1MyBMNTQ3LDIyOC42OTUzICIgZmlsbD0iI0ZCRkI3NyIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTUiIHg9IjM5NCIgeT0iMjQ1Ljc2MjIiPkdFVCAvIEhUVFAvMS4xPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0OCIgeD0iMzk0IiB5PSIyNjAuODk1Ij5Db25uZWN0aW9uOiBLZWVwLWFsaXZlPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMjcwLDMxNS4yMjY2LDI2MCwzMTkuMjI2NiwyNzAsMzIzLjIyNjYsMjY2LDMxOS4yMjY2IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIyNjQiIHgyPSIzODIiIHkxPSIzMTkuMjI2NiIgeTI9IjMxOS4yMjY2Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTAwIiB4PSIyNzYiIHk9IjMxNC4xNjA2Ij5IVFRQIFJlc3BvbnNlPC90ZXh0PjxwYXRoIGQ9Ik01LDI4Mi45NjA5IEw1LDMzNy45NjA5IEwyNTAsMzM3Ljk2MDkgTDI1MCwyOTIuOTYwOSBMMjQwLDI4Mi45NjA5IEw1LDI4Mi45NjA5ICIgZmlsbD0iI0ZCRkI3NyIgZmlsdGVyPSJ1cmwoI2ZydzFtNTAzamwyeTgpIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjQwLDI4Mi45NjA5IEwyNDAsMjkyLjk2MDkgTDI1MCwyOTIuOTYwOSBMMjQwLDI4Mi45NjA5ICIgZmlsbD0iI0ZCRkI3NyIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTA3IiB4PSIxMSIgeT0iMzAwLjAyNzgiPkhUVFAvMS4xIDIwMCBPSzwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMjQiIHg9IjExIiB5PSIzMTUuMTYwNiI+S2VlcC1BbGl2ZTogdGltZW91dD0xMCwgbWF4PTUwMDwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNDgiIHg9IjExIiB5PSIzMzAuMjkzNSI+Q29ubmVjdGlvbjogS2VlcC1hbGl2ZTwvdGV4dD48IS0tTUQ1PVs0NWRjOTVkNjRmODNiMmZkZDFiMTFiOTVhYjM2NDZkNV0KQHN0YXJ0dW1sDQphY3RvciDtgbTrnbzsnbTslrjtirgNCj09IENsb3NlID09DQrtgbTrnbzsnbTslrjtirggPC0g7ISc67KEOiBIVFRQIFJlc3BvbnNlDQpub3RlIGxlZnQNCiAgICBDb25uZWN0aW9uOiBDbG9zZQ0KZW5kIG5vdGUNCj09IEtlZXAtYWxpdmUgPT0NCu2BtOudvOydtOyWuO2KuCAtPiDshJzrsoQ6IEhUVFAgUmVxdWVzdA0Kbm90ZSByaWdodA0KICAgIEdFVCAvIEhUVFAvMS4xDQogICAgQ29ubmVjdGlvbjogS2VlcC1hbGl2ZQ0KZW5kIG5vdGUNCu2BtOudvOydtOyWuO2KuCA8LSDshJzrsoQ6IEhUVFAgUmVzcG9uc2UNCm5vdGUgbGVmdA0KICAgIEhUVFAvMS4xIDIwMCBPSw0KICAgIEtlZXAtQWxpdmU6IHRpbWVvdXQ9MTAsIG1heD01MDANCiAgICBDb25uZWN0aW9uOiBLZWVwLWFsaXZlDQplbmQgbm90ZQ0KQGVuZHVtbA0KClBsYW50VU1MIHZlcnNpb24gMS4yMDIxLjEwYmV0YTIoVW5rbm93biBjb21waWxlIHRpbWUpCihHUEwgc291cmNlIGRpc3RyaWJ1dGlvbikKSmF2YSBSdW50aW1lOiBKYXZhKFRNKSBTRSBSdW50aW1lIEVudmlyb25tZW50CkpWTTogSmF2YSBIb3RTcG90KFRNKSA2NC1CaXQgU2VydmVyIFZNCkRlZmF1bHQgRW5jb2Rpbmc6IFVURi04Ckxhbmd1YWdlOiBlbgpDb3VudHJ5OiBVUwotLT48L2c+PC9zdmc+'></li>\n</ul>\n<h3 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h3><ul>\n<li>HTTP 메세지 생성 날짜를 표현<h3 id=\"Pragma\"><a href=\"#Pragma\" class=\"headerlink\" title=\"Pragma\"></a>Pragma</h3></li>\n<li>HTTP/1.1 이전 스펙의 헤더, 클라이언트 리퀘스트의 경우에만 사용</li>\n<li>클라이언트에서 캐시된 리소스를 원하지 않을 때 아래와 같이 표현<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"attribute\">Pragma</span><span class=\"punctuation\">: </span>no-cache</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></li>\n<li>일반적으로 요청을 보내는 서버의 HTTP 버젼을 모르는 경우가 많기 때문에 캐시를 허용하지 않을 경우 아래와 같이 헤더 정보를 명시<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Pragma</span><span class=\"punctuation\">: </span>no-cache</span><br><span class=\"line\"><span class=\"attribute\">Cache-Control</span><span class=\"punctuation\">: </span>no-cache</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"그림으로배우는HTTP - 5. HTTP와 연계하는 웹 서버","date":"2020-02-04T15:00:00.000Z","_content":"\n# 그림으로배우는HTTP - 5. HTTP와 연계하는 웹 서버\n## 가상호스트(Virtual Host)\n- HTTP/1.1에서는 하나의 HTTP 서버에 여러 개의 웹 사이트를 실행할 수 있음. 가상호스트(Virtual Host)라는 기능을 사용하면, 서버는 1대지만 가상으로 여러대가 있는 것처럼 설정하는 것이 가능함\n\n- 인터넷에서 도메인명은 DNS에 의하여 IP주소로 변환되고 나서 엑세스하게 되므로, 결국 서버에 도착한 시점에는 IP주소를 기준으로 엑세스하게 됨.\n\n## 프록시, 게이트웨이, 터널\nHTTP는 서버-클라이언트 이외에도 프록시, 게이트웨이, 터널과 같은 통신을 중계 할 수 있는 역할을 수행할 수 있음\n\n### 프록시\n![Reverse Proxy](https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Reverse_proxy_h2g2bob.svg/440px-Reverse_proxy_h2g2bob.svg.png)\n- 클라이언트로부터 받은 요청을 다른 서버로 전송하는 역할을 수행. \n- 클라이언트로 받은 요청 URI를 변경하지 않고 바로 리소스를 가지고 있는 서버(오리진 서버)로 전송함.\n- **프록시 서버를 여러 대 경유하는 것이 가능하며, 경유 시, HTTP Header에 Via 필드를 추가하여 경유한 호스트 정보를 추가해야 한다.**\n\n- **프록시 서버의 구분**\n    - 캐시 여부\n    - 전달 받은 HTTP 메세지를 변경하는지 여부\n\n- **캐싱 프록시(Caching Proxy)**\n프록시 서버 상에 리소스 캐시를 보존해 두는 타입의 프록시, 프록시 서버에 동일한 요청에 들어왔을 경우, 오리진 서버로부터 리소스를 획득하지 않고, 캐시 해둔 리소스를 응답.\n\n- **투명 프록시(Transparent Proxy)**\n메세지를 변경하지 않은 프록시의 유형, 반대로 변경을 가하는 비투과 프록시도 존재함.\n\n- **리버스 프록시(Reverse Proxy)**\n    - 컴퓨터 네트워크에서 클라이언트를 대신해서 한 대 이상의 서버로부터 자원을 추출하는 프록시 서버의 일종.\n    - 웹 서버들은 리버스 프록시 기능을 사용하는 일이 잦으며 취약한 HTTP 기능의 애플리케이션 프레임워크를 보호\n        - 리버스 프록시 서버를 앞에 두고 실제 서비스 서버는 내부망에 위치시키고 프록시 서버만 내부에 있는 서비스 서버와 통신해서 결과를 클라이언트에게 제공하는 방식으로 서비스 하는 경우가 많음\n\n- **포워드 프록시(Forward Proxy)**\n클라이언트의 요청을 프록시 서버가 받아 오리진 서버에 요청하여 반환하는 결과를 다시 클라이언트에 돌려준다. 단순 중계의 역할을 담당한다고 생각하면 된다. 위에서 설명한 캐싱 프록시의 역할을 수행할 수도 있다.\n\n### 게이트웨이\n- 프록시와 유사. 게이트웨이의 경우, 그 다음에 있는 서버가 HTTP 서버 이외의 서비스를 제공하는 서버가 될 수도 있음.\n- 처리 안전성(인증) 및 요청을 집중화 할 수 있는 용도로 많이 사용.\n\n### 터널\n- 다른 서버와의 통신 경로를 확립하며 SSL 같은 암호화 통신을 통해 서버와 안전하게 통신하기 위해 사용\n\n## 캐시\n- 서버 혹은 클라이언트 사이드의 메모리/디스크 등에 보관된 리소스의 임시 사본\n- 캐시를 활용하면, 불필요한 서버 요청을 줄일 수 있음\n- 클라이언트 혹은 서버에 캐시를 가지고 있더라도 갱신 요구 및 유효 기간 만료 등에 의해 원본 리소스를 가지고 있는 오리진 서버에 재요청을 하게 되는 경우가 생길 수 있음.","source":"_posts/HTTP/그림으로배우는_HTTP_CH5.md","raw":"---\ntitle: 그림으로배우는HTTP - 5. HTTP와 연계하는 웹 서버\ndate: 2020/2/5 00:00:00\ncategories:\n- HTTP\n---\n\n# 그림으로배우는HTTP - 5. HTTP와 연계하는 웹 서버\n## 가상호스트(Virtual Host)\n- HTTP/1.1에서는 하나의 HTTP 서버에 여러 개의 웹 사이트를 실행할 수 있음. 가상호스트(Virtual Host)라는 기능을 사용하면, 서버는 1대지만 가상으로 여러대가 있는 것처럼 설정하는 것이 가능함\n\n- 인터넷에서 도메인명은 DNS에 의하여 IP주소로 변환되고 나서 엑세스하게 되므로, 결국 서버에 도착한 시점에는 IP주소를 기준으로 엑세스하게 됨.\n\n## 프록시, 게이트웨이, 터널\nHTTP는 서버-클라이언트 이외에도 프록시, 게이트웨이, 터널과 같은 통신을 중계 할 수 있는 역할을 수행할 수 있음\n\n### 프록시\n![Reverse Proxy](https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Reverse_proxy_h2g2bob.svg/440px-Reverse_proxy_h2g2bob.svg.png)\n- 클라이언트로부터 받은 요청을 다른 서버로 전송하는 역할을 수행. \n- 클라이언트로 받은 요청 URI를 변경하지 않고 바로 리소스를 가지고 있는 서버(오리진 서버)로 전송함.\n- **프록시 서버를 여러 대 경유하는 것이 가능하며, 경유 시, HTTP Header에 Via 필드를 추가하여 경유한 호스트 정보를 추가해야 한다.**\n\n- **프록시 서버의 구분**\n    - 캐시 여부\n    - 전달 받은 HTTP 메세지를 변경하는지 여부\n\n- **캐싱 프록시(Caching Proxy)**\n프록시 서버 상에 리소스 캐시를 보존해 두는 타입의 프록시, 프록시 서버에 동일한 요청에 들어왔을 경우, 오리진 서버로부터 리소스를 획득하지 않고, 캐시 해둔 리소스를 응답.\n\n- **투명 프록시(Transparent Proxy)**\n메세지를 변경하지 않은 프록시의 유형, 반대로 변경을 가하는 비투과 프록시도 존재함.\n\n- **리버스 프록시(Reverse Proxy)**\n    - 컴퓨터 네트워크에서 클라이언트를 대신해서 한 대 이상의 서버로부터 자원을 추출하는 프록시 서버의 일종.\n    - 웹 서버들은 리버스 프록시 기능을 사용하는 일이 잦으며 취약한 HTTP 기능의 애플리케이션 프레임워크를 보호\n        - 리버스 프록시 서버를 앞에 두고 실제 서비스 서버는 내부망에 위치시키고 프록시 서버만 내부에 있는 서비스 서버와 통신해서 결과를 클라이언트에게 제공하는 방식으로 서비스 하는 경우가 많음\n\n- **포워드 프록시(Forward Proxy)**\n클라이언트의 요청을 프록시 서버가 받아 오리진 서버에 요청하여 반환하는 결과를 다시 클라이언트에 돌려준다. 단순 중계의 역할을 담당한다고 생각하면 된다. 위에서 설명한 캐싱 프록시의 역할을 수행할 수도 있다.\n\n### 게이트웨이\n- 프록시와 유사. 게이트웨이의 경우, 그 다음에 있는 서버가 HTTP 서버 이외의 서비스를 제공하는 서버가 될 수도 있음.\n- 처리 안전성(인증) 및 요청을 집중화 할 수 있는 용도로 많이 사용.\n\n### 터널\n- 다른 서버와의 통신 경로를 확립하며 SSL 같은 암호화 통신을 통해 서버와 안전하게 통신하기 위해 사용\n\n## 캐시\n- 서버 혹은 클라이언트 사이드의 메모리/디스크 등에 보관된 리소스의 임시 사본\n- 캐시를 활용하면, 불필요한 서버 요청을 줄일 수 있음\n- 클라이언트 혹은 서버에 캐시를 가지고 있더라도 갱신 요구 및 유효 기간 만료 등에 의해 원본 리소스를 가지고 있는 오리진 서버에 재요청을 하게 되는 경우가 생길 수 있음.","slug":"HTTP/그림으로배우는_HTTP_CH5","published":1,"updated":"2021-08-02T12:10:40.822Z","_id":"ckrsup507000utjhvhwab83cy","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"그림으로배우는HTTP-5-HTTP와-연계하는-웹-서버\"><a href=\"#그림으로배우는HTTP-5-HTTP와-연계하는-웹-서버\" class=\"headerlink\" title=\"그림으로배우는HTTP - 5. HTTP와 연계하는 웹 서버\"></a>그림으로배우는HTTP - 5. HTTP와 연계하는 웹 서버</h1><h2 id=\"가상호스트-Virtual-Host\"><a href=\"#가상호스트-Virtual-Host\" class=\"headerlink\" title=\"가상호스트(Virtual Host)\"></a>가상호스트(Virtual Host)</h2><ul>\n<li><p>HTTP/1.1에서는 하나의 HTTP 서버에 여러 개의 웹 사이트를 실행할 수 있음. 가상호스트(Virtual Host)라는 기능을 사용하면, 서버는 1대지만 가상으로 여러대가 있는 것처럼 설정하는 것이 가능함</p>\n</li>\n<li><p>인터넷에서 도메인명은 DNS에 의하여 IP주소로 변환되고 나서 엑세스하게 되므로, 결국 서버에 도착한 시점에는 IP주소를 기준으로 엑세스하게 됨.</p>\n</li>\n</ul>\n<h2 id=\"프록시-게이트웨이-터널\"><a href=\"#프록시-게이트웨이-터널\" class=\"headerlink\" title=\"프록시, 게이트웨이, 터널\"></a>프록시, 게이트웨이, 터널</h2><p>HTTP는 서버-클라이언트 이외에도 프록시, 게이트웨이, 터널과 같은 통신을 중계 할 수 있는 역할을 수행할 수 있음</p>\n<h3 id=\"프록시\"><a href=\"#프록시\" class=\"headerlink\" title=\"프록시\"></a>프록시</h3><p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Reverse_proxy_h2g2bob.svg/440px-Reverse_proxy_h2g2bob.svg.png\" alt=\"Reverse Proxy\"></p>\n<ul>\n<li><p>클라이언트로부터 받은 요청을 다른 서버로 전송하는 역할을 수행. </p>\n</li>\n<li><p>클라이언트로 받은 요청 URI를 변경하지 않고 바로 리소스를 가지고 있는 서버(오리진 서버)로 전송함.</p>\n</li>\n<li><p><strong>프록시 서버를 여러 대 경유하는 것이 가능하며, 경유 시, HTTP Header에 Via 필드를 추가하여 경유한 호스트 정보를 추가해야 한다.</strong></p>\n</li>\n<li><p><strong>프록시 서버의 구분</strong></p>\n<ul>\n<li>캐시 여부</li>\n<li>전달 받은 HTTP 메세지를 변경하는지 여부</li>\n</ul>\n</li>\n<li><p><strong>캐싱 프록시(Caching Proxy)</strong><br>프록시 서버 상에 리소스 캐시를 보존해 두는 타입의 프록시, 프록시 서버에 동일한 요청에 들어왔을 경우, 오리진 서버로부터 리소스를 획득하지 않고, 캐시 해둔 리소스를 응답.</p>\n</li>\n<li><p><strong>투명 프록시(Transparent Proxy)</strong><br>메세지를 변경하지 않은 프록시의 유형, 반대로 변경을 가하는 비투과 프록시도 존재함.</p>\n</li>\n<li><p><strong>리버스 프록시(Reverse Proxy)</strong></p>\n<ul>\n<li>컴퓨터 네트워크에서 클라이언트를 대신해서 한 대 이상의 서버로부터 자원을 추출하는 프록시 서버의 일종.</li>\n<li>웹 서버들은 리버스 프록시 기능을 사용하는 일이 잦으며 취약한 HTTP 기능의 애플리케이션 프레임워크를 보호<ul>\n<li>리버스 프록시 서버를 앞에 두고 실제 서비스 서버는 내부망에 위치시키고 프록시 서버만 내부에 있는 서비스 서버와 통신해서 결과를 클라이언트에게 제공하는 방식으로 서비스 하는 경우가 많음</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>포워드 프록시(Forward Proxy)</strong><br>클라이언트의 요청을 프록시 서버가 받아 오리진 서버에 요청하여 반환하는 결과를 다시 클라이언트에 돌려준다. 단순 중계의 역할을 담당한다고 생각하면 된다. 위에서 설명한 캐싱 프록시의 역할을 수행할 수도 있다.</p>\n</li>\n</ul>\n<h3 id=\"게이트웨이\"><a href=\"#게이트웨이\" class=\"headerlink\" title=\"게이트웨이\"></a>게이트웨이</h3><ul>\n<li>프록시와 유사. 게이트웨이의 경우, 그 다음에 있는 서버가 HTTP 서버 이외의 서비스를 제공하는 서버가 될 수도 있음.</li>\n<li>처리 안전성(인증) 및 요청을 집중화 할 수 있는 용도로 많이 사용.</li>\n</ul>\n<h3 id=\"터널\"><a href=\"#터널\" class=\"headerlink\" title=\"터널\"></a>터널</h3><ul>\n<li>다른 서버와의 통신 경로를 확립하며 SSL 같은 암호화 통신을 통해 서버와 안전하게 통신하기 위해 사용</li>\n</ul>\n<h2 id=\"캐시\"><a href=\"#캐시\" class=\"headerlink\" title=\"캐시\"></a>캐시</h2><ul>\n<li>서버 혹은 클라이언트 사이드의 메모리/디스크 등에 보관된 리소스의 임시 사본</li>\n<li>캐시를 활용하면, 불필요한 서버 요청을 줄일 수 있음</li>\n<li>클라이언트 혹은 서버에 캐시를 가지고 있더라도 갱신 요구 및 유효 기간 만료 등에 의해 원본 리소스를 가지고 있는 오리진 서버에 재요청을 하게 되는 경우가 생길 수 있음.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"그림으로배우는HTTP-5-HTTP와-연계하는-웹-서버\"><a href=\"#그림으로배우는HTTP-5-HTTP와-연계하는-웹-서버\" class=\"headerlink\" title=\"그림으로배우는HTTP - 5. HTTP와 연계하는 웹 서버\"></a>그림으로배우는HTTP - 5. HTTP와 연계하는 웹 서버</h1><h2 id=\"가상호스트-Virtual-Host\"><a href=\"#가상호스트-Virtual-Host\" class=\"headerlink\" title=\"가상호스트(Virtual Host)\"></a>가상호스트(Virtual Host)</h2><ul>\n<li><p>HTTP/1.1에서는 하나의 HTTP 서버에 여러 개의 웹 사이트를 실행할 수 있음. 가상호스트(Virtual Host)라는 기능을 사용하면, 서버는 1대지만 가상으로 여러대가 있는 것처럼 설정하는 것이 가능함</p>\n</li>\n<li><p>인터넷에서 도메인명은 DNS에 의하여 IP주소로 변환되고 나서 엑세스하게 되므로, 결국 서버에 도착한 시점에는 IP주소를 기준으로 엑세스하게 됨.</p>\n</li>\n</ul>\n<h2 id=\"프록시-게이트웨이-터널\"><a href=\"#프록시-게이트웨이-터널\" class=\"headerlink\" title=\"프록시, 게이트웨이, 터널\"></a>프록시, 게이트웨이, 터널</h2><p>HTTP는 서버-클라이언트 이외에도 프록시, 게이트웨이, 터널과 같은 통신을 중계 할 수 있는 역할을 수행할 수 있음</p>\n<h3 id=\"프록시\"><a href=\"#프록시\" class=\"headerlink\" title=\"프록시\"></a>프록시</h3><p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Reverse_proxy_h2g2bob.svg/440px-Reverse_proxy_h2g2bob.svg.png\" alt=\"Reverse Proxy\"></p>\n<ul>\n<li><p>클라이언트로부터 받은 요청을 다른 서버로 전송하는 역할을 수행. </p>\n</li>\n<li><p>클라이언트로 받은 요청 URI를 변경하지 않고 바로 리소스를 가지고 있는 서버(오리진 서버)로 전송함.</p>\n</li>\n<li><p><strong>프록시 서버를 여러 대 경유하는 것이 가능하며, 경유 시, HTTP Header에 Via 필드를 추가하여 경유한 호스트 정보를 추가해야 한다.</strong></p>\n</li>\n<li><p><strong>프록시 서버의 구분</strong></p>\n<ul>\n<li>캐시 여부</li>\n<li>전달 받은 HTTP 메세지를 변경하는지 여부</li>\n</ul>\n</li>\n<li><p><strong>캐싱 프록시(Caching Proxy)</strong><br>프록시 서버 상에 리소스 캐시를 보존해 두는 타입의 프록시, 프록시 서버에 동일한 요청에 들어왔을 경우, 오리진 서버로부터 리소스를 획득하지 않고, 캐시 해둔 리소스를 응답.</p>\n</li>\n<li><p><strong>투명 프록시(Transparent Proxy)</strong><br>메세지를 변경하지 않은 프록시의 유형, 반대로 변경을 가하는 비투과 프록시도 존재함.</p>\n</li>\n<li><p><strong>리버스 프록시(Reverse Proxy)</strong></p>\n<ul>\n<li>컴퓨터 네트워크에서 클라이언트를 대신해서 한 대 이상의 서버로부터 자원을 추출하는 프록시 서버의 일종.</li>\n<li>웹 서버들은 리버스 프록시 기능을 사용하는 일이 잦으며 취약한 HTTP 기능의 애플리케이션 프레임워크를 보호<ul>\n<li>리버스 프록시 서버를 앞에 두고 실제 서비스 서버는 내부망에 위치시키고 프록시 서버만 내부에 있는 서비스 서버와 통신해서 결과를 클라이언트에게 제공하는 방식으로 서비스 하는 경우가 많음</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>포워드 프록시(Forward Proxy)</strong><br>클라이언트의 요청을 프록시 서버가 받아 오리진 서버에 요청하여 반환하는 결과를 다시 클라이언트에 돌려준다. 단순 중계의 역할을 담당한다고 생각하면 된다. 위에서 설명한 캐싱 프록시의 역할을 수행할 수도 있다.</p>\n</li>\n</ul>\n<h3 id=\"게이트웨이\"><a href=\"#게이트웨이\" class=\"headerlink\" title=\"게이트웨이\"></a>게이트웨이</h3><ul>\n<li>프록시와 유사. 게이트웨이의 경우, 그 다음에 있는 서버가 HTTP 서버 이외의 서비스를 제공하는 서버가 될 수도 있음.</li>\n<li>처리 안전성(인증) 및 요청을 집중화 할 수 있는 용도로 많이 사용.</li>\n</ul>\n<h3 id=\"터널\"><a href=\"#터널\" class=\"headerlink\" title=\"터널\"></a>터널</h3><ul>\n<li>다른 서버와의 통신 경로를 확립하며 SSL 같은 암호화 통신을 통해 서버와 안전하게 통신하기 위해 사용</li>\n</ul>\n<h2 id=\"캐시\"><a href=\"#캐시\" class=\"headerlink\" title=\"캐시\"></a>캐시</h2><ul>\n<li>서버 혹은 클라이언트 사이드의 메모리/디스크 등에 보관된 리소스의 임시 사본</li>\n<li>캐시를 활용하면, 불필요한 서버 요청을 줄일 수 있음</li>\n<li>클라이언트 혹은 서버에 캐시를 가지고 있더라도 갱신 요구 및 유효 기간 만료 등에 의해 원본 리소스를 가지고 있는 오리진 서버에 재요청을 하게 되는 경우가 생길 수 있음.</li>\n</ul>\n"},{"title":"Apache Http Client","date":"2020-08-12T15:00:00.000Z","_content":"\n# Apache Http Client\n#### The target server failed to respond 에러 관련 이슈\n`ConnectionManager`에 의해 관리되는 `Persistent Connection`들은 KeepAlive한 상태를 유지할때 대상 서버는 HttpClient가 해당 이벤트에 반응할 수 없는 상태에서 그 끝에 있는 연결을 종료하고 연결이 유휴 상태가 되어 연결이 반쯤 닫히거나 'stale'이 됩니다. 해당 상태로 빠진 커넥션들은 정리가 필요하며, 이를 처리하기 위해서 HttpClient에서는 idleConnection과 expiredConnection에 대해 별도 스레드에서 정리할 수 있도록 설정할 수 있다. 또한 `ConnectionManager`를 별도로 지정하여 validate 타임을 지정할 수 있다.\n\n```java\nfinal PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager();\nconnectionManager.setMaxTotal(300);\nconnectionManager.setDefaultMaxPerRoute(300);\nconnectionManager.setValidateAfterInactivity(1000 * 5);\n\nfinal CloseableHttpClient client = HttpClientBuilder.create()\n        .setConnectionManager(connectionManager)\n        .evictExpiredConnections()\n        .evictIdleConnections(1000 * 30, TimeUnit.SECONDS)\n        .build();\n```\n**참고 링크**\n- https://www.baeldung.com/httpclient-connection-management\n- https://thingsthis.tistory.com/186\n- https://pchun.tistory.com/60\n- http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d5e659\n- http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html\n- https://stackoverflow.com/questions/10558791/apache-httpclient-interim-error-nohttpresponseexception\n- https://www.hyoyoung.net/103\n- http://coryklein.com/tcp/2015/11/25/custom-configuration-of-tcp-socket-keep-alive-timeouts.html\n- http://docs.likejazz.com/close-wait/#close_wait-%EC%9E%AC%ED%98%84\n- https://12bme.tistory.com/538\n- https://tech.kakao.com/2016/04/21/closewait-timewait/\n- https://kwonnam.pe.kr/wiki/java/apache_http_client#stale_check\n- https://stackoverflow.com/questions/29104643/httpclienterror-the-target-server-failed-to-respond","source":"_posts/Java/APACHE_HTTP_CLIENT.md","raw":"---\ntitle: Apache Http Client\ndate: 2020/8/13 00:00:00\ncategories:\n- Java\n---\n\n# Apache Http Client\n#### The target server failed to respond 에러 관련 이슈\n`ConnectionManager`에 의해 관리되는 `Persistent Connection`들은 KeepAlive한 상태를 유지할때 대상 서버는 HttpClient가 해당 이벤트에 반응할 수 없는 상태에서 그 끝에 있는 연결을 종료하고 연결이 유휴 상태가 되어 연결이 반쯤 닫히거나 'stale'이 됩니다. 해당 상태로 빠진 커넥션들은 정리가 필요하며, 이를 처리하기 위해서 HttpClient에서는 idleConnection과 expiredConnection에 대해 별도 스레드에서 정리할 수 있도록 설정할 수 있다. 또한 `ConnectionManager`를 별도로 지정하여 validate 타임을 지정할 수 있다.\n\n```java\nfinal PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager();\nconnectionManager.setMaxTotal(300);\nconnectionManager.setDefaultMaxPerRoute(300);\nconnectionManager.setValidateAfterInactivity(1000 * 5);\n\nfinal CloseableHttpClient client = HttpClientBuilder.create()\n        .setConnectionManager(connectionManager)\n        .evictExpiredConnections()\n        .evictIdleConnections(1000 * 30, TimeUnit.SECONDS)\n        .build();\n```\n**참고 링크**\n- https://www.baeldung.com/httpclient-connection-management\n- https://thingsthis.tistory.com/186\n- https://pchun.tistory.com/60\n- http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d5e659\n- http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html\n- https://stackoverflow.com/questions/10558791/apache-httpclient-interim-error-nohttpresponseexception\n- https://www.hyoyoung.net/103\n- http://coryklein.com/tcp/2015/11/25/custom-configuration-of-tcp-socket-keep-alive-timeouts.html\n- http://docs.likejazz.com/close-wait/#close_wait-%EC%9E%AC%ED%98%84\n- https://12bme.tistory.com/538\n- https://tech.kakao.com/2016/04/21/closewait-timewait/\n- https://kwonnam.pe.kr/wiki/java/apache_http_client#stale_check\n- https://stackoverflow.com/questions/29104643/httpclienterror-the-target-server-failed-to-respond","slug":"Java/APACHE_HTTP_CLIENT","published":1,"updated":"2021-08-02T12:24:10.246Z","_id":"ckrsup507000vtjhv6joicmti","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Apache-Http-Client\"><a href=\"#Apache-Http-Client\" class=\"headerlink\" title=\"Apache Http Client\"></a>Apache Http Client</h1><h4 id=\"The-target-server-failed-to-respond-에러-관련-이슈\"><a href=\"#The-target-server-failed-to-respond-에러-관련-이슈\" class=\"headerlink\" title=\"The target server failed to respond 에러 관련 이슈\"></a>The target server failed to respond 에러 관련 이슈</h4><p><code>ConnectionManager</code>에 의해 관리되는 <code>Persistent Connection</code>들은 KeepAlive한 상태를 유지할때 대상 서버는 HttpClient가 해당 이벤트에 반응할 수 없는 상태에서 그 끝에 있는 연결을 종료하고 연결이 유휴 상태가 되어 연결이 반쯤 닫히거나 ‘stale’이 됩니다. 해당 상태로 빠진 커넥션들은 정리가 필요하며, 이를 처리하기 위해서 HttpClient에서는 idleConnection과 expiredConnection에 대해 별도 스레드에서 정리할 수 있도록 설정할 수 있다. 또한 <code>ConnectionManager</code>를 별도로 지정하여 validate 타임을 지정할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> PoolingHttpClientConnectionManager connectionManager = <span class=\"keyword\">new</span> PoolingHttpClientConnectionManager();</span><br><span class=\"line\">connectionManager.setMaxTotal(<span class=\"number\">300</span>);</span><br><span class=\"line\">connectionManager.setDefaultMaxPerRoute(<span class=\"number\">300</span>);</span><br><span class=\"line\">connectionManager.setValidateAfterInactivity(<span class=\"number\">1000</span> * <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> CloseableHttpClient client = HttpClientBuilder.create()</span><br><span class=\"line\">        .setConnectionManager(connectionManager)</span><br><span class=\"line\">        .evictExpiredConnections()</span><br><span class=\"line\">        .evictIdleConnections(<span class=\"number\">1000</span> * <span class=\"number\">30</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n<p><strong>참고 링크</strong></p>\n<ul>\n<li><a href=\"https://www.baeldung.com/httpclient-connection-management\">https://www.baeldung.com/httpclient-connection-management</a></li>\n<li><a href=\"https://thingsthis.tistory.com/186\">https://thingsthis.tistory.com/186</a></li>\n<li><a href=\"https://pchun.tistory.com/60\">https://pchun.tistory.com/60</a></li>\n<li><a href=\"http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d5e659\">http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d5e659</a></li>\n<li><a href=\"http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html\">http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html</a></li>\n<li><a href=\"https://stackoverflow.com/questions/10558791/apache-httpclient-interim-error-nohttpresponseexception\">https://stackoverflow.com/questions/10558791/apache-httpclient-interim-error-nohttpresponseexception</a></li>\n<li><a href=\"https://www.hyoyoung.net/103\">https://www.hyoyoung.net/103</a></li>\n<li><a href=\"http://coryklein.com/tcp/2015/11/25/custom-configuration-of-tcp-socket-keep-alive-timeouts.html\">http://coryklein.com/tcp/2015/11/25/custom-configuration-of-tcp-socket-keep-alive-timeouts.html</a></li>\n<li><a href=\"http://docs.likejazz.com/close-wait/#close_wait-%EC%9E%AC%ED%98%84\">http://docs.likejazz.com/close-wait/#close_wait-%EC%9E%AC%ED%98%84</a></li>\n<li><a href=\"https://12bme.tistory.com/538\">https://12bme.tistory.com/538</a></li>\n<li><a href=\"https://tech.kakao.com/2016/04/21/closewait-timewait/\">https://tech.kakao.com/2016/04/21/closewait-timewait/</a></li>\n<li><a href=\"https://kwonnam.pe.kr/wiki/java/apache_http_client#stale_check\">https://kwonnam.pe.kr/wiki/java/apache_http_client#stale_check</a></li>\n<li><a href=\"https://stackoverflow.com/questions/29104643/httpclienterror-the-target-server-failed-to-respond\">https://stackoverflow.com/questions/29104643/httpclienterror-the-target-server-failed-to-respond</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Apache-Http-Client\"><a href=\"#Apache-Http-Client\" class=\"headerlink\" title=\"Apache Http Client\"></a>Apache Http Client</h1><h4 id=\"The-target-server-failed-to-respond-에러-관련-이슈\"><a href=\"#The-target-server-failed-to-respond-에러-관련-이슈\" class=\"headerlink\" title=\"The target server failed to respond 에러 관련 이슈\"></a>The target server failed to respond 에러 관련 이슈</h4><p><code>ConnectionManager</code>에 의해 관리되는 <code>Persistent Connection</code>들은 KeepAlive한 상태를 유지할때 대상 서버는 HttpClient가 해당 이벤트에 반응할 수 없는 상태에서 그 끝에 있는 연결을 종료하고 연결이 유휴 상태가 되어 연결이 반쯤 닫히거나 ‘stale’이 됩니다. 해당 상태로 빠진 커넥션들은 정리가 필요하며, 이를 처리하기 위해서 HttpClient에서는 idleConnection과 expiredConnection에 대해 별도 스레드에서 정리할 수 있도록 설정할 수 있다. 또한 <code>ConnectionManager</code>를 별도로 지정하여 validate 타임을 지정할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> PoolingHttpClientConnectionManager connectionManager = <span class=\"keyword\">new</span> PoolingHttpClientConnectionManager();</span><br><span class=\"line\">connectionManager.setMaxTotal(<span class=\"number\">300</span>);</span><br><span class=\"line\">connectionManager.setDefaultMaxPerRoute(<span class=\"number\">300</span>);</span><br><span class=\"line\">connectionManager.setValidateAfterInactivity(<span class=\"number\">1000</span> * <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> CloseableHttpClient client = HttpClientBuilder.create()</span><br><span class=\"line\">        .setConnectionManager(connectionManager)</span><br><span class=\"line\">        .evictExpiredConnections()</span><br><span class=\"line\">        .evictIdleConnections(<span class=\"number\">1000</span> * <span class=\"number\">30</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n<p><strong>참고 링크</strong></p>\n<ul>\n<li><a href=\"https://www.baeldung.com/httpclient-connection-management\">https://www.baeldung.com/httpclient-connection-management</a></li>\n<li><a href=\"https://thingsthis.tistory.com/186\">https://thingsthis.tistory.com/186</a></li>\n<li><a href=\"https://pchun.tistory.com/60\">https://pchun.tistory.com/60</a></li>\n<li><a href=\"http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d5e659\">http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d5e659</a></li>\n<li><a href=\"http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html\">http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html</a></li>\n<li><a href=\"https://stackoverflow.com/questions/10558791/apache-httpclient-interim-error-nohttpresponseexception\">https://stackoverflow.com/questions/10558791/apache-httpclient-interim-error-nohttpresponseexception</a></li>\n<li><a href=\"https://www.hyoyoung.net/103\">https://www.hyoyoung.net/103</a></li>\n<li><a href=\"http://coryklein.com/tcp/2015/11/25/custom-configuration-of-tcp-socket-keep-alive-timeouts.html\">http://coryklein.com/tcp/2015/11/25/custom-configuration-of-tcp-socket-keep-alive-timeouts.html</a></li>\n<li><a href=\"http://docs.likejazz.com/close-wait/#close_wait-%EC%9E%AC%ED%98%84\">http://docs.likejazz.com/close-wait/#close_wait-%EC%9E%AC%ED%98%84</a></li>\n<li><a href=\"https://12bme.tistory.com/538\">https://12bme.tistory.com/538</a></li>\n<li><a href=\"https://tech.kakao.com/2016/04/21/closewait-timewait/\">https://tech.kakao.com/2016/04/21/closewait-timewait/</a></li>\n<li><a href=\"https://kwonnam.pe.kr/wiki/java/apache_http_client#stale_check\">https://kwonnam.pe.kr/wiki/java/apache_http_client#stale_check</a></li>\n<li><a href=\"https://stackoverflow.com/questions/29104643/httpclienterror-the-target-server-failed-to-respond\">https://stackoverflow.com/questions/29104643/httpclienterror-the-target-server-failed-to-respond</a></li>\n</ul>\n"},{"title":"Effective Java - 2장","date":"2019-02-18T14:00:00.000Z","_content":"\n# Effective Java - 2장\n\n# [2장] 모든 객체의 공통 메서드\n- Objects는 객체를 만들 수 있는 구체 클래스면서 기본적으로 상속하여 사용이 가능\n- equals, hashCode, toString, clone, finalize 모두 재정의를 염두로 두고 설계\n- 일반 규약에 맞도록 재정의(overriding)해야 하며, 잘못 구현하면 오작동을 발생 시킬 수 있음\n\n## ITEM 10 - equals는 일반 규약을 지켜 재정의하라\n* 일반 규약에 맞도록 재정의 하지 않을꺼면 재정의를 안하는 것이 최선. \n\n* 아래 항목이 해당하는 경우 재정의를 하는 것이 크게 의미가 없을 수 있음.\n  * 각 인스턴스는 본질적으로 고유\n  * 인스턴스의 `논리적 동치성`을 검사할 일이 없는 경우\n  * 상위 클래스에서 정의한 `equals`가 하위 클래스에 딱 들어맞는 경우\n  * 클래스가 `private`이거나 `package-private`일 경우, equals를 호출할 일이 없음\n\n* 그럼 언제 재정의 해야 할까?\n  * 객체 간 `논리적 동치성`을 확인해야 하는데 상위 클래스의 `equals`가 이를 비교하도록 정의되지 않았을 경우에 재정의 해야 함.\n  * 주로 값 클래스일 경우가 해당 함.\n\n* `equals`의 일반 규약은 아래와 같다.\n  * 반사성: 자기 자신과 같아야 함.\n  * 대칭성: x가 y와 같다면, y도 x와 같아야 한다.\n  * 추이성: x가 y와 같고, y가 z와 같다면, x는 z와 같아야 한다.\n  * 일관성: x와 y가 같다면, 영원히 같아야 함.\n  * null-아님: null과 비교하는 것은 의미가 없음.\n\n* 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족 시킬 방법은 존재하지 않음.\n  * Point 클래스를 상속한 ColorPoint클래스와 Point클래스의 인스턴스를 비교할 수 없음, Why?\n  * 객체의 동등성 비교 시, 한쪽만 true인 결과를 얻을 수 있기 때문. equals의 대칭성 규약을 지킬 수 없다.\n* 상속이 아닌 컴포지션을 사용하면 우회하여 값을 비교하는 equals를 재정의 하는 것이 가능하다.\n\n* `equals` 메서드를 구현하는 일반적인 방법은 아래와 같다.\n  1. `==` 연산자를 사용하여 자기 자신의 참조 확인\n  2. instanceof 연산자로 올바른 타입인지 체크\n  3. 2번 단계에서 확인한 타입으로 타입 캐스팅\n  4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 검사\n\n* 값 혹은 참조를 비교하는 방법은?\n  - float, double을 제외한 기본 타입의 필드는 `==` 연산자로 비교\n    - float, double은 `Float.compare(float, float)`, `Double.compare(double, double)`로 비교\n    - Float.equals 및 Double.equals는 오토박싱을 수반하므로 성능상 좋지 않음\n  - 참조 타입 필드는 해당 타입의 `equals`를 이용하여 비교\n  - 배열 전체를 비교 할 경우, `Arrays.equals`를 사용\n\n```java\npublic final class PhoneNumber {\n    private final short areaCode, prefix, lineNum;\n\n    public PhoneNumber(short areaCode, short prefix, short lineNum) {\n        this.areaCode = areaCode;\n        this.prefix = prefix;\n        this.lineNum = lineNum;\n    }\n\n    private static short rangeCheck(int val, int max, String arg) {\n        if (val < 0 || val > max) throw new IllegalArgumentException(arg + \": \" + val);\n        return (short) val;\n    }\n\n    @Override\n    // 인자의 타입은 `Object` 타입을 사용하도록 하자\n    public boolean equals(Object o) {\n        // 1. 자기 자신과 같은지 확인\n        if (o == this) return true;\n        // 2. 타입이 같은 체크\n        if (!(o instanceof PhoneNumber)) return false;\n        // 3. 타입 캐스팅\n        PhoneNumber pn = (PhoneNumber)o;\n        // 4. 주요 필드 값에 대해 비교 연산 수행\n        return pn.lineNum == lineNum && pn.areaCode == areaCode && pn.prefix == prefix;\n    }\n}\n```\n\n* `equals`를 구현하고 체크해야 할 세가지\n  - 대칭적인지?, 추이성을 만족하는지?, 일관적인지?\n  - equals를 재정의할 경우 반드시 hashCode도 재정의하자\n  - 인자의 타입은 `Object` 타입을 사용하도록 하자. 만약 구체 타입으로 인자를 받을 경우 아래 그림과 컴파일이 되지 않는다. `@Override` 어노테이션을 일관되게 사용하면 이런 일련의 실수를 예방할 수 있다.\n    ![인자의 타입은 `Object`](https://i.imgur.com/MVYfZTY.png)\n\n## ITEM 11 - equals를 재정의하려거든 hashCode도 재정의하라\n- equals를 재정의 할 경우 반드시 hashCode도 재정의 해야 한다. \n  - 그러지 않으면, HashSet 혹은 HashMap과 같은 콜랙션 구현체에서 사용 시 문제가 발생한다.\n- 아래는 Object 명세의 일부이다.\n  * equals 비교에 사용되는 필드 값이 변경되지 않았다면, 매번 같은 hashCode를 반환해야 한다.\n  * **[중요] equals에서 두 객체가 같다고 판단했다면, hashCode도 같은 값을 반환해야 한다.**\n  * equals에서 두 객체가 다르다고 판단했더라도, 두 객체가 다른 hashCode값을 반환할 필요는 없다. \n  * **[중요] 하지만, 다른 객체에 대해서는 다른 hashCode 값을 반환해야 해시테이블의 성능이 좋아진다.**\n- 해시코드 반환을 올바르게 하지 않을 경우, 수행 시간의 계산이 최대 O(n)까지 늘어날 수 있다.아래는 O(n)까지 늘어나는 사용 금지 해시 코드 구현이다.\n\t```java\n\t@Override\n\tpublic int hashCode() { return 42; }\n\t```\n\n- 좋은 해시 함수는 결국 서로 다른 객체 혹은 인스턴스에 대해 다른 해시코드를 반환해야 한다. 이상적인 해시 함수는 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.\n\n- `hashCode`를 작성하는 요령은?\n  1. 첫 번째 핵심 필드에 대해 hashCode를 생성. 이를 변수 `result`에 할당.\n  2. 나머지 필드에 대해 아래와 같이 해시코드를 구하도록 하자.\n    - 해시코드 c를 아래와 같은 원칙으로 구해보자.\n      - 기본 타입 필드일 경우, 해당 타입의 박싱 클래스 타입의 Type.hashCode(f)를 수행 \n      - 참조 타입 필드일 경우, 해당 클래스의 필드 값들에 대해 hashCode를 재귀적으로 호출하고 복잡해질꺼 같으면 필드의 표준형을 만들어 호출하자. 필드 값이 null이면 0을 사용한다.\n      - 필드가 배열일 경우, 핵심 원소에 대해 각각 필드와 같이 다뤄준다. 핵심 원소가 없을 경우 0으로 다뤄주자.\n    - 첫 번째 단계에서 구한 해시코드 값을 아래와 같이 갱신하도록 하자.\n    ```java\n    result = 31 * result + c\n    ```\n  3. hashCode의 반환 값으로 result를 반환.\n  4. 작성 후 동치 인스턴스에 대해 같은 해시코드 값을 반환하는지 테스트 코드를 작성하도록 하자.\n  ```java\n  @Override\n  public int hashCode() {\n  \tint result = Short.hashCode(areaCode);\n  \tresult = 31 * result + Short.hashCode(prefix);\n  \tresult = 31 * result + Short.hashCode(lineNum);\n  \treturn result;\n  }\n  ```\n  ```java\n  // with Junit\n  @Test\n  public void hashCodeTest() {\n      short areaCode = 10, prefix = 5, lineNum = 1;\n      PhoneNumber p1 = new PhoneNumber(areaCode, prefix, lineNum);\n      PhoneNumber p2 = new PhoneNumber(areaCode, prefix, lineNum);\n      assertEquals(p1.hashCode(), p2.hashCode());\n  }\n  ```\n\n- 해시 충돌이 더 적은 구현을 원한다면 `guava`의 `Hashing` 구현을 참고하자.\n- `Objects` 클래스의 hash 메서드를 이용하면 해쉬 값을 쉽게 구할 수 있으나, 안타깝게도 해당 메서드는 박싱과 언박싱의 과정이 길어서 속도가 더 느리다고 한다. \n- 만약 클래스가 불변인 상황에서 해시코드를 구하는 과정이 길거나 오래걸린다면 캐싱하는 방식을 고려해보면 좋다.\n- 성능 고려한다고 해시코드 계산 시 핵심 필드를 생략하면 안된다. 해당 필드를 생략할 경우 해시 품질이 나빠져 특정 영역으로 몰릴 수 있기 때문이다.\n- 해시코드 생성 규칙을 외부 사용자(API 사용하는)에게 알리지 않아야 추후에 변경이 발생했을 경우에 유연하게 변경이 가능하다.\n\n\n## ITEM 12 - toString을 항상 재정의하라\n별도로 `toString()`을 재정의하지 않으면 `클래스명@16진수의 해시코드`가 반환된다. toString의 일반 규약에서는 `간결하고 읽기 쉬운 형식의 정보를 반환해라`라고 명세되어 있다고 한다. 또한, 모든 하위 클래스에서 toString을 재정의 하라고 말하고 있다.\n쉽게 접할 수 있는 디버깅을 하는 상황이라고 생각해봐도 toString()을 재정의하여 유의미한 정보를 보면서 디버깅 하는 것과 그렇지 않은 경우는 많이 다르다. 결국 유의미한 정보를 반환하는 것이 관례이자 규약이라고 하면 이를 지키는 것이 좋을 것이다.\n\n* 객체가 가지고 있는 정보는 가급적 전부 반환하는 것이 좋다.\n* 반환하는 포맷에 대한 고민도 해봐야 한다.\n  - 포맷의 고정 유무와 상관 없이 `유의미한` 정보를 반환하고 의미를 분명하게 하는 것은 중요하다.\n\n책의 예제에서는 앞의 PhoneNumber 클래스에서 toString()을 재정의한 예시를 보여주고 있는데, 참고하기 좋은 주석과 내용을 담고 있는 듯 하다.\n```java\n    /**\n     * 이 전화번호의 문자열 표현을 반환한다.\n     * 이 문자열은 \"XXX-YYY-ZZZZ\" 형태의 12글자로 구성된다.\n     * XXX는 지역 코드, YYY는 Prefix, ZZZZ는 가입자 번호다.\n     * 각각의 대문자는 10진수 숫자 하나를 나타낸다.\n     *\n     * 전화번호의 각 부분의 값이 너무 작아서 자릿수를 채울 수 없다면,\n     * 앞에서부터 0으로 채워나간다. 예컨대 가입자 번호가 123이라면\n     * 전화번호의 마지막 네 문자는 \"0123\"이 된다.\n     * @return\n     */\n    @Override\n    public String toString() {\n        return String.format(\"%03d-%03d-%04d\", areaCode, prefix, lineNum);\n    }\n```\n\n`Google.AutoValue` 프레임워크에서는 toString을 생성해준다고 하는데, Lombok을 사용했을 때랑 어떻게 차이가 나는지는 직접 해보지 않아서 잘 모르겠다.\n\n## ITEM 13 - clone 재정의는 주의해서 진행하라\n* `Cloneable`는 `마커 인터페이스`로 **이를 구현한 객체는 복제가 가능한 객체**임을 명시하는 용도로 사용한다.\n* `Cloneable` 인터페이스를 구현한 클래스의 인스턴스에서 `clone`을 호출하면 필드 전체를 복사한 객체를 반환한다. 만약 인터페이스를 구현하지 않을 경우 CloneNotSupportedException을 반환한다.\n* **[중요] 메서드 하나 없는 `Cloneable`은 실상 `Object.clone`의 동작 방식을 결정하는데, 이례적인 사용으로 보이는 것이 인터페이스를 구현한 것만으로 상위 클래스 메서드 행위의 변경을 가하고 있기 때문이다.**\n* `Cloneable` 인터페이스를 구현함으로써, 해당 객체를 사용하는 사용자 측에서는 `clone()` 메서드가 public으로 제공되며 이를 통해 복제를 할 수 있으리라 판단할 수 있다.\n* 클래스의 계층 구조를 가지는 상황에서 하위 클래스가 만약 final 클래스라면 더 이상의 하위 클래스 상속은 발생하지 않기 때문에 관례는 무시해도 되겠지만, 만약 final 클래스의 clone 구현이 super.clone()을 호출하지 않는다면 Cloneable 인터페이스를 구현할 이유가 없다. 왜냐하면, 이는 위에서도 설명한대로 `Cloneable` 인터페이스가 Object.clone의 동작 방식을 결정하기 때문이고 이런 동작 방식 자체에 기댈 필요가 없기 때문이다.\n```java\n    @Override\n    public PhoneNumber clone() {\n        try {\n            return (PhoneNumber) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n        }\n    }\n```\n* 위 예제에서는 상위 타입에서 반환하는 `Object`타입이 아닌 `PhoneNumber`타입을 반환하고 있다. 이는 `공변 반환 타이핑(covariant return typing)`을 나타내고 있다. 다시 말해, 재정의한 메서드의 반환 타입은 상위 클래스의 메서드가 반환하는 타입의 하위 타입일 수 있다는 이야기이다.\n* `clone()` 메서드는 사실상 생성자와 같은 효과를 나타낸다. `clone()` 재정의 시 주의해야 하는 부분은 원본 객체에 변경이나 사이드 이펙트가 전달되지 않도록 복제된 객체의 불변성을 보장해야 한다.\n* clone() 재정의 시, 클래스에 배열 필드가 있다면 clone()을 호출해도 런타임 타입과 컴파일타임 타입 모두가 원본 배열과 똑같은 타입의 배열을 반환한다. 하지만, 깊은 복사가 진행되는 것이 아니기 때문에 주의해야 한다. \n```java\n    @Test\n    public void cloneTest() {\n        short areaCode = 10, prefix = 5, lineNum = 1;\n        PhoneNumber[] arr = new PhoneNumber[]{\n            new PhoneNumber(areaCode, prefix, lineNum),\n            new PhoneNumber(areaCode, prefix, lineNum)\n        };\n        PhoneNumber[] cloneArr = arr.clone();\n        // Reference Check\n        assertSame(arr[0], cloneArr[0]);\n    }\n```\n\n* 위의 예제와 같이, 깊은 복사가 필요할 경우 재귀호출을 통하거나 혹은 배열의 요소를 일일이 순회/반복하여 복제하는 작업이 필요하다. \n* 생성자에서는 일반적으로 하위 클래스에서 재정의 가능한 매서드를 호출하지 않는 것이 일반적인데, clone도 마찬가지이다. 재정의 시 변경되는 내용에 의해 원본 객체의 상태가 달라질 가능성이 크기 때문이다.\n* clone을 사용하는 것보다 복사 목적으로 사용하는 정잭 팩토리 메서드 혹은 복사 생성자를 사용하는 방법도 있다. 복사 생성자와 팩토리 메서드는 인터페이스 타입의 인자를 받을 수 있기 때문에, 객체 복사 시 유연한 타입 변경이 가능해진다.\n* **[결론] clone()의 객체 생성 메카니즘은 위험천만하다. 차라리 복사 정적 팩토리 메서드 혹은 복사 목적의 생성자를 사용하자.**\n## ITEM 14 - Comparable을 구현할지 고려하라\n- `Comparable.compareTo()`는 동치성 비교 및 순서까지 비교 가능하다.\n- `Object.equals()`와 마찬가지로 반사성, 대칭성, 추이성을 충족해야 한다. 또한, 해당 원칙을 제대로 지키지 않으면 equals와 마찬가지로 해당 구현을 이용하는 다른 클래스에서 예상하지 못한 결과를 반환할 수 있다.\n- `Comparable`을 구현하지 않은 필드나 표준이 아닌 순서로 비교하고 있는 상황이라면, `Comparator`를 대신 사용하자.\n- `compareTo()`에서 기본 타입을 비교 할때, 해당 기본 타입의 래퍼 타입의 `compare()`를 사용하여 비교하자. <, > 등의 연산자는 거추장스럽고 오류를 유발할 수 있다.\n- 필드가 여러개 있는 클래스의 경우, 핵심 필드부터 차례대로 비교하도록 하자\n```java\n    @Override\n    public int compareTo(PhoneNumber o) {\n        // 첫 번째 핵심 필드\n        int result = Short.compare(areaCode, o.areaCode);\n        if (result == 0) {\n            // 두 번째 핵심 필드\n            result = Short.compare(prefix, o.prefix);\n            if (result == 0) {\n                // 세 번째 핵심 필드\n                result = Short.compare(lineNum, o.lineNum);\n            }\n        }\n        return result;\n    }\n```\n- `Comparator`를 사용하는 방식은 FluentAPI 형식을 사용할 수 있어서 코드 자체가 우아하게 전개되지만, 성능 로스가 있다고 한다.\n- `Comparator`는 보조 메서드를 여러개 제공하고 있다. int보다 작은 타입의 경우 comparingInt를 사용하면 되고 float의 경우는 comparingDouble을 이용하면 된다.\n\n","source":"_posts/Java/EffectiveJava3e_ch2.md","raw":"---\ntitle: Effective Java - 2장\ndate: 2019.2.18. 23:00\ncategories:\n- Java\n---\n\n# Effective Java - 2장\n\n# [2장] 모든 객체의 공통 메서드\n- Objects는 객체를 만들 수 있는 구체 클래스면서 기본적으로 상속하여 사용이 가능\n- equals, hashCode, toString, clone, finalize 모두 재정의를 염두로 두고 설계\n- 일반 규약에 맞도록 재정의(overriding)해야 하며, 잘못 구현하면 오작동을 발생 시킬 수 있음\n\n## ITEM 10 - equals는 일반 규약을 지켜 재정의하라\n* 일반 규약에 맞도록 재정의 하지 않을꺼면 재정의를 안하는 것이 최선. \n\n* 아래 항목이 해당하는 경우 재정의를 하는 것이 크게 의미가 없을 수 있음.\n  * 각 인스턴스는 본질적으로 고유\n  * 인스턴스의 `논리적 동치성`을 검사할 일이 없는 경우\n  * 상위 클래스에서 정의한 `equals`가 하위 클래스에 딱 들어맞는 경우\n  * 클래스가 `private`이거나 `package-private`일 경우, equals를 호출할 일이 없음\n\n* 그럼 언제 재정의 해야 할까?\n  * 객체 간 `논리적 동치성`을 확인해야 하는데 상위 클래스의 `equals`가 이를 비교하도록 정의되지 않았을 경우에 재정의 해야 함.\n  * 주로 값 클래스일 경우가 해당 함.\n\n* `equals`의 일반 규약은 아래와 같다.\n  * 반사성: 자기 자신과 같아야 함.\n  * 대칭성: x가 y와 같다면, y도 x와 같아야 한다.\n  * 추이성: x가 y와 같고, y가 z와 같다면, x는 z와 같아야 한다.\n  * 일관성: x와 y가 같다면, 영원히 같아야 함.\n  * null-아님: null과 비교하는 것은 의미가 없음.\n\n* 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족 시킬 방법은 존재하지 않음.\n  * Point 클래스를 상속한 ColorPoint클래스와 Point클래스의 인스턴스를 비교할 수 없음, Why?\n  * 객체의 동등성 비교 시, 한쪽만 true인 결과를 얻을 수 있기 때문. equals의 대칭성 규약을 지킬 수 없다.\n* 상속이 아닌 컴포지션을 사용하면 우회하여 값을 비교하는 equals를 재정의 하는 것이 가능하다.\n\n* `equals` 메서드를 구현하는 일반적인 방법은 아래와 같다.\n  1. `==` 연산자를 사용하여 자기 자신의 참조 확인\n  2. instanceof 연산자로 올바른 타입인지 체크\n  3. 2번 단계에서 확인한 타입으로 타입 캐스팅\n  4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 검사\n\n* 값 혹은 참조를 비교하는 방법은?\n  - float, double을 제외한 기본 타입의 필드는 `==` 연산자로 비교\n    - float, double은 `Float.compare(float, float)`, `Double.compare(double, double)`로 비교\n    - Float.equals 및 Double.equals는 오토박싱을 수반하므로 성능상 좋지 않음\n  - 참조 타입 필드는 해당 타입의 `equals`를 이용하여 비교\n  - 배열 전체를 비교 할 경우, `Arrays.equals`를 사용\n\n```java\npublic final class PhoneNumber {\n    private final short areaCode, prefix, lineNum;\n\n    public PhoneNumber(short areaCode, short prefix, short lineNum) {\n        this.areaCode = areaCode;\n        this.prefix = prefix;\n        this.lineNum = lineNum;\n    }\n\n    private static short rangeCheck(int val, int max, String arg) {\n        if (val < 0 || val > max) throw new IllegalArgumentException(arg + \": \" + val);\n        return (short) val;\n    }\n\n    @Override\n    // 인자의 타입은 `Object` 타입을 사용하도록 하자\n    public boolean equals(Object o) {\n        // 1. 자기 자신과 같은지 확인\n        if (o == this) return true;\n        // 2. 타입이 같은 체크\n        if (!(o instanceof PhoneNumber)) return false;\n        // 3. 타입 캐스팅\n        PhoneNumber pn = (PhoneNumber)o;\n        // 4. 주요 필드 값에 대해 비교 연산 수행\n        return pn.lineNum == lineNum && pn.areaCode == areaCode && pn.prefix == prefix;\n    }\n}\n```\n\n* `equals`를 구현하고 체크해야 할 세가지\n  - 대칭적인지?, 추이성을 만족하는지?, 일관적인지?\n  - equals를 재정의할 경우 반드시 hashCode도 재정의하자\n  - 인자의 타입은 `Object` 타입을 사용하도록 하자. 만약 구체 타입으로 인자를 받을 경우 아래 그림과 컴파일이 되지 않는다. `@Override` 어노테이션을 일관되게 사용하면 이런 일련의 실수를 예방할 수 있다.\n    ![인자의 타입은 `Object`](https://i.imgur.com/MVYfZTY.png)\n\n## ITEM 11 - equals를 재정의하려거든 hashCode도 재정의하라\n- equals를 재정의 할 경우 반드시 hashCode도 재정의 해야 한다. \n  - 그러지 않으면, HashSet 혹은 HashMap과 같은 콜랙션 구현체에서 사용 시 문제가 발생한다.\n- 아래는 Object 명세의 일부이다.\n  * equals 비교에 사용되는 필드 값이 변경되지 않았다면, 매번 같은 hashCode를 반환해야 한다.\n  * **[중요] equals에서 두 객체가 같다고 판단했다면, hashCode도 같은 값을 반환해야 한다.**\n  * equals에서 두 객체가 다르다고 판단했더라도, 두 객체가 다른 hashCode값을 반환할 필요는 없다. \n  * **[중요] 하지만, 다른 객체에 대해서는 다른 hashCode 값을 반환해야 해시테이블의 성능이 좋아진다.**\n- 해시코드 반환을 올바르게 하지 않을 경우, 수행 시간의 계산이 최대 O(n)까지 늘어날 수 있다.아래는 O(n)까지 늘어나는 사용 금지 해시 코드 구현이다.\n\t```java\n\t@Override\n\tpublic int hashCode() { return 42; }\n\t```\n\n- 좋은 해시 함수는 결국 서로 다른 객체 혹은 인스턴스에 대해 다른 해시코드를 반환해야 한다. 이상적인 해시 함수는 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.\n\n- `hashCode`를 작성하는 요령은?\n  1. 첫 번째 핵심 필드에 대해 hashCode를 생성. 이를 변수 `result`에 할당.\n  2. 나머지 필드에 대해 아래와 같이 해시코드를 구하도록 하자.\n    - 해시코드 c를 아래와 같은 원칙으로 구해보자.\n      - 기본 타입 필드일 경우, 해당 타입의 박싱 클래스 타입의 Type.hashCode(f)를 수행 \n      - 참조 타입 필드일 경우, 해당 클래스의 필드 값들에 대해 hashCode를 재귀적으로 호출하고 복잡해질꺼 같으면 필드의 표준형을 만들어 호출하자. 필드 값이 null이면 0을 사용한다.\n      - 필드가 배열일 경우, 핵심 원소에 대해 각각 필드와 같이 다뤄준다. 핵심 원소가 없을 경우 0으로 다뤄주자.\n    - 첫 번째 단계에서 구한 해시코드 값을 아래와 같이 갱신하도록 하자.\n    ```java\n    result = 31 * result + c\n    ```\n  3. hashCode의 반환 값으로 result를 반환.\n  4. 작성 후 동치 인스턴스에 대해 같은 해시코드 값을 반환하는지 테스트 코드를 작성하도록 하자.\n  ```java\n  @Override\n  public int hashCode() {\n  \tint result = Short.hashCode(areaCode);\n  \tresult = 31 * result + Short.hashCode(prefix);\n  \tresult = 31 * result + Short.hashCode(lineNum);\n  \treturn result;\n  }\n  ```\n  ```java\n  // with Junit\n  @Test\n  public void hashCodeTest() {\n      short areaCode = 10, prefix = 5, lineNum = 1;\n      PhoneNumber p1 = new PhoneNumber(areaCode, prefix, lineNum);\n      PhoneNumber p2 = new PhoneNumber(areaCode, prefix, lineNum);\n      assertEquals(p1.hashCode(), p2.hashCode());\n  }\n  ```\n\n- 해시 충돌이 더 적은 구현을 원한다면 `guava`의 `Hashing` 구현을 참고하자.\n- `Objects` 클래스의 hash 메서드를 이용하면 해쉬 값을 쉽게 구할 수 있으나, 안타깝게도 해당 메서드는 박싱과 언박싱의 과정이 길어서 속도가 더 느리다고 한다. \n- 만약 클래스가 불변인 상황에서 해시코드를 구하는 과정이 길거나 오래걸린다면 캐싱하는 방식을 고려해보면 좋다.\n- 성능 고려한다고 해시코드 계산 시 핵심 필드를 생략하면 안된다. 해당 필드를 생략할 경우 해시 품질이 나빠져 특정 영역으로 몰릴 수 있기 때문이다.\n- 해시코드 생성 규칙을 외부 사용자(API 사용하는)에게 알리지 않아야 추후에 변경이 발생했을 경우에 유연하게 변경이 가능하다.\n\n\n## ITEM 12 - toString을 항상 재정의하라\n별도로 `toString()`을 재정의하지 않으면 `클래스명@16진수의 해시코드`가 반환된다. toString의 일반 규약에서는 `간결하고 읽기 쉬운 형식의 정보를 반환해라`라고 명세되어 있다고 한다. 또한, 모든 하위 클래스에서 toString을 재정의 하라고 말하고 있다.\n쉽게 접할 수 있는 디버깅을 하는 상황이라고 생각해봐도 toString()을 재정의하여 유의미한 정보를 보면서 디버깅 하는 것과 그렇지 않은 경우는 많이 다르다. 결국 유의미한 정보를 반환하는 것이 관례이자 규약이라고 하면 이를 지키는 것이 좋을 것이다.\n\n* 객체가 가지고 있는 정보는 가급적 전부 반환하는 것이 좋다.\n* 반환하는 포맷에 대한 고민도 해봐야 한다.\n  - 포맷의 고정 유무와 상관 없이 `유의미한` 정보를 반환하고 의미를 분명하게 하는 것은 중요하다.\n\n책의 예제에서는 앞의 PhoneNumber 클래스에서 toString()을 재정의한 예시를 보여주고 있는데, 참고하기 좋은 주석과 내용을 담고 있는 듯 하다.\n```java\n    /**\n     * 이 전화번호의 문자열 표현을 반환한다.\n     * 이 문자열은 \"XXX-YYY-ZZZZ\" 형태의 12글자로 구성된다.\n     * XXX는 지역 코드, YYY는 Prefix, ZZZZ는 가입자 번호다.\n     * 각각의 대문자는 10진수 숫자 하나를 나타낸다.\n     *\n     * 전화번호의 각 부분의 값이 너무 작아서 자릿수를 채울 수 없다면,\n     * 앞에서부터 0으로 채워나간다. 예컨대 가입자 번호가 123이라면\n     * 전화번호의 마지막 네 문자는 \"0123\"이 된다.\n     * @return\n     */\n    @Override\n    public String toString() {\n        return String.format(\"%03d-%03d-%04d\", areaCode, prefix, lineNum);\n    }\n```\n\n`Google.AutoValue` 프레임워크에서는 toString을 생성해준다고 하는데, Lombok을 사용했을 때랑 어떻게 차이가 나는지는 직접 해보지 않아서 잘 모르겠다.\n\n## ITEM 13 - clone 재정의는 주의해서 진행하라\n* `Cloneable`는 `마커 인터페이스`로 **이를 구현한 객체는 복제가 가능한 객체**임을 명시하는 용도로 사용한다.\n* `Cloneable` 인터페이스를 구현한 클래스의 인스턴스에서 `clone`을 호출하면 필드 전체를 복사한 객체를 반환한다. 만약 인터페이스를 구현하지 않을 경우 CloneNotSupportedException을 반환한다.\n* **[중요] 메서드 하나 없는 `Cloneable`은 실상 `Object.clone`의 동작 방식을 결정하는데, 이례적인 사용으로 보이는 것이 인터페이스를 구현한 것만으로 상위 클래스 메서드 행위의 변경을 가하고 있기 때문이다.**\n* `Cloneable` 인터페이스를 구현함으로써, 해당 객체를 사용하는 사용자 측에서는 `clone()` 메서드가 public으로 제공되며 이를 통해 복제를 할 수 있으리라 판단할 수 있다.\n* 클래스의 계층 구조를 가지는 상황에서 하위 클래스가 만약 final 클래스라면 더 이상의 하위 클래스 상속은 발생하지 않기 때문에 관례는 무시해도 되겠지만, 만약 final 클래스의 clone 구현이 super.clone()을 호출하지 않는다면 Cloneable 인터페이스를 구현할 이유가 없다. 왜냐하면, 이는 위에서도 설명한대로 `Cloneable` 인터페이스가 Object.clone의 동작 방식을 결정하기 때문이고 이런 동작 방식 자체에 기댈 필요가 없기 때문이다.\n```java\n    @Override\n    public PhoneNumber clone() {\n        try {\n            return (PhoneNumber) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n        }\n    }\n```\n* 위 예제에서는 상위 타입에서 반환하는 `Object`타입이 아닌 `PhoneNumber`타입을 반환하고 있다. 이는 `공변 반환 타이핑(covariant return typing)`을 나타내고 있다. 다시 말해, 재정의한 메서드의 반환 타입은 상위 클래스의 메서드가 반환하는 타입의 하위 타입일 수 있다는 이야기이다.\n* `clone()` 메서드는 사실상 생성자와 같은 효과를 나타낸다. `clone()` 재정의 시 주의해야 하는 부분은 원본 객체에 변경이나 사이드 이펙트가 전달되지 않도록 복제된 객체의 불변성을 보장해야 한다.\n* clone() 재정의 시, 클래스에 배열 필드가 있다면 clone()을 호출해도 런타임 타입과 컴파일타임 타입 모두가 원본 배열과 똑같은 타입의 배열을 반환한다. 하지만, 깊은 복사가 진행되는 것이 아니기 때문에 주의해야 한다. \n```java\n    @Test\n    public void cloneTest() {\n        short areaCode = 10, prefix = 5, lineNum = 1;\n        PhoneNumber[] arr = new PhoneNumber[]{\n            new PhoneNumber(areaCode, prefix, lineNum),\n            new PhoneNumber(areaCode, prefix, lineNum)\n        };\n        PhoneNumber[] cloneArr = arr.clone();\n        // Reference Check\n        assertSame(arr[0], cloneArr[0]);\n    }\n```\n\n* 위의 예제와 같이, 깊은 복사가 필요할 경우 재귀호출을 통하거나 혹은 배열의 요소를 일일이 순회/반복하여 복제하는 작업이 필요하다. \n* 생성자에서는 일반적으로 하위 클래스에서 재정의 가능한 매서드를 호출하지 않는 것이 일반적인데, clone도 마찬가지이다. 재정의 시 변경되는 내용에 의해 원본 객체의 상태가 달라질 가능성이 크기 때문이다.\n* clone을 사용하는 것보다 복사 목적으로 사용하는 정잭 팩토리 메서드 혹은 복사 생성자를 사용하는 방법도 있다. 복사 생성자와 팩토리 메서드는 인터페이스 타입의 인자를 받을 수 있기 때문에, 객체 복사 시 유연한 타입 변경이 가능해진다.\n* **[결론] clone()의 객체 생성 메카니즘은 위험천만하다. 차라리 복사 정적 팩토리 메서드 혹은 복사 목적의 생성자를 사용하자.**\n## ITEM 14 - Comparable을 구현할지 고려하라\n- `Comparable.compareTo()`는 동치성 비교 및 순서까지 비교 가능하다.\n- `Object.equals()`와 마찬가지로 반사성, 대칭성, 추이성을 충족해야 한다. 또한, 해당 원칙을 제대로 지키지 않으면 equals와 마찬가지로 해당 구현을 이용하는 다른 클래스에서 예상하지 못한 결과를 반환할 수 있다.\n- `Comparable`을 구현하지 않은 필드나 표준이 아닌 순서로 비교하고 있는 상황이라면, `Comparator`를 대신 사용하자.\n- `compareTo()`에서 기본 타입을 비교 할때, 해당 기본 타입의 래퍼 타입의 `compare()`를 사용하여 비교하자. <, > 등의 연산자는 거추장스럽고 오류를 유발할 수 있다.\n- 필드가 여러개 있는 클래스의 경우, 핵심 필드부터 차례대로 비교하도록 하자\n```java\n    @Override\n    public int compareTo(PhoneNumber o) {\n        // 첫 번째 핵심 필드\n        int result = Short.compare(areaCode, o.areaCode);\n        if (result == 0) {\n            // 두 번째 핵심 필드\n            result = Short.compare(prefix, o.prefix);\n            if (result == 0) {\n                // 세 번째 핵심 필드\n                result = Short.compare(lineNum, o.lineNum);\n            }\n        }\n        return result;\n    }\n```\n- `Comparator`를 사용하는 방식은 FluentAPI 형식을 사용할 수 있어서 코드 자체가 우아하게 전개되지만, 성능 로스가 있다고 한다.\n- `Comparator`는 보조 메서드를 여러개 제공하고 있다. int보다 작은 타입의 경우 comparingInt를 사용하면 되고 float의 경우는 comparingDouble을 이용하면 된다.\n\n","slug":"Java/EffectiveJava3e_ch2","published":1,"updated":"2021-08-02T12:07:15.918Z","_id":"ckrsup508000wtjhv6erf3zhi","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Effective-Java-2장\"><a href=\"#Effective-Java-2장\" class=\"headerlink\" title=\"Effective Java - 2장\"></a>Effective Java - 2장</h1><h1 id=\"2장-모든-객체의-공통-메서드\"><a href=\"#2장-모든-객체의-공통-메서드\" class=\"headerlink\" title=\"[2장] 모든 객체의 공통 메서드\"></a>[2장] 모든 객체의 공통 메서드</h1><ul>\n<li>Objects는 객체를 만들 수 있는 구체 클래스면서 기본적으로 상속하여 사용이 가능</li>\n<li>equals, hashCode, toString, clone, finalize 모두 재정의를 염두로 두고 설계</li>\n<li>일반 규약에 맞도록 재정의(overriding)해야 하며, 잘못 구현하면 오작동을 발생 시킬 수 있음</li>\n</ul>\n<h2 id=\"ITEM-10-equals는-일반-규약을-지켜-재정의하라\"><a href=\"#ITEM-10-equals는-일반-규약을-지켜-재정의하라\" class=\"headerlink\" title=\"ITEM 10 - equals는 일반 규약을 지켜 재정의하라\"></a>ITEM 10 - equals는 일반 규약을 지켜 재정의하라</h2><ul>\n<li><p>일반 규약에 맞도록 재정의 하지 않을꺼면 재정의를 안하는 것이 최선. </p>\n</li>\n<li><p>아래 항목이 해당하는 경우 재정의를 하는 것이 크게 의미가 없을 수 있음.</p>\n<ul>\n<li>각 인스턴스는 본질적으로 고유</li>\n<li>인스턴스의 <code>논리적 동치성</code>을 검사할 일이 없는 경우</li>\n<li>상위 클래스에서 정의한 <code>equals</code>가 하위 클래스에 딱 들어맞는 경우</li>\n<li>클래스가 <code>private</code>이거나 <code>package-private</code>일 경우, equals를 호출할 일이 없음</li>\n</ul>\n</li>\n<li><p>그럼 언제 재정의 해야 할까?</p>\n<ul>\n<li>객체 간 <code>논리적 동치성</code>을 확인해야 하는데 상위 클래스의 <code>equals</code>가 이를 비교하도록 정의되지 않았을 경우에 재정의 해야 함.</li>\n<li>주로 값 클래스일 경우가 해당 함.</li>\n</ul>\n</li>\n<li><p><code>equals</code>의 일반 규약은 아래와 같다.</p>\n<ul>\n<li>반사성: 자기 자신과 같아야 함.</li>\n<li>대칭성: x가 y와 같다면, y도 x와 같아야 한다.</li>\n<li>추이성: x가 y와 같고, y가 z와 같다면, x는 z와 같아야 한다.</li>\n<li>일관성: x와 y가 같다면, 영원히 같아야 함.</li>\n<li>null-아님: null과 비교하는 것은 의미가 없음.</li>\n</ul>\n</li>\n<li><p>구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족 시킬 방법은 존재하지 않음.</p>\n<ul>\n<li>Point 클래스를 상속한 ColorPoint클래스와 Point클래스의 인스턴스를 비교할 수 없음, Why?</li>\n<li>객체의 동등성 비교 시, 한쪽만 true인 결과를 얻을 수 있기 때문. equals의 대칭성 규약을 지킬 수 없다.</li>\n</ul>\n</li>\n<li><p>상속이 아닌 컴포지션을 사용하면 우회하여 값을 비교하는 equals를 재정의 하는 것이 가능하다.</p>\n</li>\n<li><p><code>equals</code> 메서드를 구현하는 일반적인 방법은 아래와 같다.</p>\n<ol>\n<li><code>==</code> 연산자를 사용하여 자기 자신의 참조 확인</li>\n<li>instanceof 연산자로 올바른 타입인지 체크</li>\n<li>2번 단계에서 확인한 타입으로 타입 캐스팅</li>\n<li>입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 검사</li>\n</ol>\n</li>\n<li><p>값 혹은 참조를 비교하는 방법은?</p>\n<ul>\n<li>float, double을 제외한 기본 타입의 필드는 <code>==</code> 연산자로 비교<ul>\n<li>float, double은 <code>Float.compare(float, float)</code>, <code>Double.compare(double, double)</code>로 비교</li>\n<li>Float.equals 및 Double.equals는 오토박싱을 수반하므로 성능상 좋지 않음</li>\n</ul>\n</li>\n<li>참조 타입 필드는 해당 타입의 <code>equals</code>를 이용하여 비교</li>\n<li>배열 전체를 비교 할 경우, <code>Arrays.equals</code>를 사용</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneNumber</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">short</span> areaCode, prefix, lineNum;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhoneNumber</span><span class=\"params\">(<span class=\"keyword\">short</span> areaCode, <span class=\"keyword\">short</span> prefix, <span class=\"keyword\">short</span> lineNum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.areaCode = areaCode;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.prefix = prefix;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.lineNum = lineNum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">short</span> <span class=\"title\">rangeCheck</span><span class=\"params\">(<span class=\"keyword\">int</span> val, <span class=\"keyword\">int</span> max, String arg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val &lt; <span class=\"number\">0</span> || val &gt; max) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(arg + <span class=\"string\">&quot;: &quot;</span> + val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">short</span>) val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"comment\">// 인자의 타입은 `Object` 타입을 사용하도록 하자</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 자기 자신과 같은지 확인</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 2. 타입이 같은 체크</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> PhoneNumber)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 3. 타입 캐스팅</span></span><br><span class=\"line\">        PhoneNumber pn = (PhoneNumber)o;</span><br><span class=\"line\">        <span class=\"comment\">// 4. 주요 필드 값에 대해 비교 연산 수행</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> pn.lineNum == lineNum &amp;&amp; pn.areaCode == areaCode &amp;&amp; pn.prefix == prefix;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>equals</code>를 구현하고 체크해야 할 세가지<ul>\n<li>대칭적인지?, 추이성을 만족하는지?, 일관적인지?</li>\n<li>equals를 재정의할 경우 반드시 hashCode도 재정의하자</li>\n<li>인자의 타입은 <code>Object</code> 타입을 사용하도록 하자. 만약 구체 타입으로 인자를 받을 경우 아래 그림과 컴파일이 되지 않는다. <code>@Override</code> 어노테이션을 일관되게 사용하면 이런 일련의 실수를 예방할 수 있다.<br><img src=\"https://i.imgur.com/MVYfZTY.png\" alt=\"인자의 타입은 `Object`\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"ITEM-11-equals를-재정의하려거든-hashCode도-재정의하라\"><a href=\"#ITEM-11-equals를-재정의하려거든-hashCode도-재정의하라\" class=\"headerlink\" title=\"ITEM 11 - equals를 재정의하려거든 hashCode도 재정의하라\"></a>ITEM 11 - equals를 재정의하려거든 hashCode도 재정의하라</h2><ul>\n<li><p>equals를 재정의 할 경우 반드시 hashCode도 재정의 해야 한다. </p>\n<ul>\n<li>그러지 않으면, HashSet 혹은 HashMap과 같은 콜랙션 구현체에서 사용 시 문제가 발생한다.</li>\n</ul>\n</li>\n<li><p>아래는 Object 명세의 일부이다.</p>\n<ul>\n<li>equals 비교에 사용되는 필드 값이 변경되지 않았다면, 매번 같은 hashCode를 반환해야 한다.</li>\n<li><strong>[중요] equals에서 두 객체가 같다고 판단했다면, hashCode도 같은 값을 반환해야 한다.</strong></li>\n<li>equals에서 두 객체가 다르다고 판단했더라도, 두 객체가 다른 hashCode값을 반환할 필요는 없다. </li>\n<li><strong>[중요] 하지만, 다른 객체에 대해서는 다른 hashCode 값을 반환해야 해시테이블의 성능이 좋아진다.</strong></li>\n</ul>\n</li>\n<li><p>해시코드 반환을 올바르게 하지 않을 경우, 수행 시간의 계산이 최대 O(n)까지 늘어날 수 있다.아래는 O(n)까지 늘어나는 사용 금지 해시 코드 구현이다.</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">42</span>; &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>좋은 해시 함수는 결국 서로 다른 객체 혹은 인스턴스에 대해 다른 해시코드를 반환해야 한다. 이상적인 해시 함수는 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.</p>\n</li>\n<li><p><code>hashCode</code>를 작성하는 요령은?</p>\n<ol>\n<li>첫 번째 핵심 필드에 대해 hashCode를 생성. 이를 변수 <code>result</code>에 할당.</li>\n<li>나머지 필드에 대해 아래와 같이 해시코드를 구하도록 하자.</li>\n</ol>\n<ul>\n<li>해시코드 c를 아래와 같은 원칙으로 구해보자.<ul>\n<li>기본 타입 필드일 경우, 해당 타입의 박싱 클래스 타입의 Type.hashCode(f)를 수행 </li>\n<li>참조 타입 필드일 경우, 해당 클래스의 필드 값들에 대해 hashCode를 재귀적으로 호출하고 복잡해질꺼 같으면 필드의 표준형을 만들어 호출하자. 필드 값이 null이면 0을 사용한다.</li>\n<li>필드가 배열일 경우, 핵심 원소에 대해 각각 필드와 같이 다뤄준다. 핵심 원소가 없을 경우 0으로 다뤄주자.</li>\n</ul>\n</li>\n<li>첫 번째 단계에서 구한 해시코드 값을 아래와 같이 갱신하도록 하자.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = <span class=\"number\">31</span> * result + c</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"3\">\n<li>hashCode의 반환 값으로 result를 반환.</li>\n<li>작성 후 동치 인스턴스에 대해 같은 해시코드 값을 반환하는지 테스트 코드를 작성하도록 하자.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> result = Short.hashCode(areaCode);</span><br><span class=\"line\">\tresult = <span class=\"number\">31</span> * result + Short.hashCode(prefix);</span><br><span class=\"line\">\tresult = <span class=\"number\">31</span> * result + Short.hashCode(lineNum);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// with Junit</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hashCodeTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">short</span> areaCode = <span class=\"number\">10</span>, prefix = <span class=\"number\">5</span>, lineNum = <span class=\"number\">1</span>;</span><br><span class=\"line\">    PhoneNumber p1 = <span class=\"keyword\">new</span> PhoneNumber(areaCode, prefix, lineNum);</span><br><span class=\"line\">    PhoneNumber p2 = <span class=\"keyword\">new</span> PhoneNumber(areaCode, prefix, lineNum);</span><br><span class=\"line\">    assertEquals(p1.hashCode(), p2.hashCode());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>해시 충돌이 더 적은 구현을 원한다면 <code>guava</code>의 <code>Hashing</code> 구현을 참고하자.</p>\n</li>\n<li><p><code>Objects</code> 클래스의 hash 메서드를 이용하면 해쉬 값을 쉽게 구할 수 있으나, 안타깝게도 해당 메서드는 박싱과 언박싱의 과정이 길어서 속도가 더 느리다고 한다. </p>\n</li>\n<li><p>만약 클래스가 불변인 상황에서 해시코드를 구하는 과정이 길거나 오래걸린다면 캐싱하는 방식을 고려해보면 좋다.</p>\n</li>\n<li><p>성능 고려한다고 해시코드 계산 시 핵심 필드를 생략하면 안된다. 해당 필드를 생략할 경우 해시 품질이 나빠져 특정 영역으로 몰릴 수 있기 때문이다.</p>\n</li>\n<li><p>해시코드 생성 규칙을 외부 사용자(API 사용하는)에게 알리지 않아야 추후에 변경이 발생했을 경우에 유연하게 변경이 가능하다.</p>\n</li>\n</ul>\n<h2 id=\"ITEM-12-toString을-항상-재정의하라\"><a href=\"#ITEM-12-toString을-항상-재정의하라\" class=\"headerlink\" title=\"ITEM 12 - toString을 항상 재정의하라\"></a>ITEM 12 - toString을 항상 재정의하라</h2><p>별도로 <code>toString()</code>을 재정의하지 않으면 <code>클래스명@16진수의 해시코드</code>가 반환된다. toString의 일반 규약에서는 <code>간결하고 읽기 쉬운 형식의 정보를 반환해라</code>라고 명세되어 있다고 한다. 또한, 모든 하위 클래스에서 toString을 재정의 하라고 말하고 있다.<br>쉽게 접할 수 있는 디버깅을 하는 상황이라고 생각해봐도 toString()을 재정의하여 유의미한 정보를 보면서 디버깅 하는 것과 그렇지 않은 경우는 많이 다르다. 결국 유의미한 정보를 반환하는 것이 관례이자 규약이라고 하면 이를 지키는 것이 좋을 것이다.</p>\n<ul>\n<li>객체가 가지고 있는 정보는 가급적 전부 반환하는 것이 좋다.</li>\n<li>반환하는 포맷에 대한 고민도 해봐야 한다.<ul>\n<li>포맷의 고정 유무와 상관 없이 <code>유의미한</code> 정보를 반환하고 의미를 분명하게 하는 것은 중요하다.</li>\n</ul>\n</li>\n</ul>\n<p>책의 예제에서는 앞의 PhoneNumber 클래스에서 toString()을 재정의한 예시를 보여주고 있는데, 참고하기 좋은 주석과 내용을 담고 있는 듯 하다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 이 전화번호의 문자열 표현을 반환한다.</span></span><br><span class=\"line\"><span class=\"comment\"> * 이 문자열은 &quot;XXX-YYY-ZZZZ&quot; 형태의 12글자로 구성된다.</span></span><br><span class=\"line\"><span class=\"comment\"> * XXX는 지역 코드, YYY는 Prefix, ZZZZ는 가입자 번호다.</span></span><br><span class=\"line\"><span class=\"comment\"> * 각각의 대문자는 10진수 숫자 하나를 나타낸다.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 전화번호의 각 부분의 값이 너무 작아서 자릿수를 채울 수 없다면,</span></span><br><span class=\"line\"><span class=\"comment\"> * 앞에서부터 0으로 채워나간다. 예컨대 가입자 번호가 123이라면</span></span><br><span class=\"line\"><span class=\"comment\"> * 전화번호의 마지막 네 문자는 &quot;0123&quot;이 된다.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> String.format(<span class=\"string\">&quot;%03d-%03d-%04d&quot;</span>, areaCode, prefix, lineNum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Google.AutoValue</code> 프레임워크에서는 toString을 생성해준다고 하는데, Lombok을 사용했을 때랑 어떻게 차이가 나는지는 직접 해보지 않아서 잘 모르겠다.</p>\n<h2 id=\"ITEM-13-clone-재정의는-주의해서-진행하라\"><a href=\"#ITEM-13-clone-재정의는-주의해서-진행하라\" class=\"headerlink\" title=\"ITEM 13 - clone 재정의는 주의해서 진행하라\"></a>ITEM 13 - clone 재정의는 주의해서 진행하라</h2><ul>\n<li><p><code>Cloneable</code>는 <code>마커 인터페이스</code>로 <strong>이를 구현한 객체는 복제가 가능한 객체</strong>임을 명시하는 용도로 사용한다.</p>\n</li>\n<li><p><code>Cloneable</code> 인터페이스를 구현한 클래스의 인스턴스에서 <code>clone</code>을 호출하면 필드 전체를 복사한 객체를 반환한다. 만약 인터페이스를 구현하지 않을 경우 CloneNotSupportedException을 반환한다.</p>\n</li>\n<li><p><strong>[중요] 메서드 하나 없는 <code>Cloneable</code>은 실상 <code>Object.clone</code>의 동작 방식을 결정하는데, 이례적인 사용으로 보이는 것이 인터페이스를 구현한 것만으로 상위 클래스 메서드 행위의 변경을 가하고 있기 때문이다.</strong></p>\n</li>\n<li><p><code>Cloneable</code> 인터페이스를 구현함으로써, 해당 객체를 사용하는 사용자 측에서는 <code>clone()</code> 메서드가 public으로 제공되며 이를 통해 복제를 할 수 있으리라 판단할 수 있다.</p>\n</li>\n<li><p>클래스의 계층 구조를 가지는 상황에서 하위 클래스가 만약 final 클래스라면 더 이상의 하위 클래스 상속은 발생하지 않기 때문에 관례는 무시해도 되겠지만, 만약 final 클래스의 clone 구현이 super.clone()을 호출하지 않는다면 Cloneable 인터페이스를 구현할 이유가 없다. 왜냐하면, 이는 위에서도 설명한대로 <code>Cloneable</code> 인터페이스가 Object.clone의 동작 방식을 결정하기 때문이고 이런 동작 방식 자체에 기댈 필요가 없기 때문이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PhoneNumber <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (PhoneNumber) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>위 예제에서는 상위 타입에서 반환하는 <code>Object</code>타입이 아닌 <code>PhoneNumber</code>타입을 반환하고 있다. 이는 <code>공변 반환 타이핑(covariant return typing)</code>을 나타내고 있다. 다시 말해, 재정의한 메서드의 반환 타입은 상위 클래스의 메서드가 반환하는 타입의 하위 타입일 수 있다는 이야기이다.</p>\n</li>\n<li><p><code>clone()</code> 메서드는 사실상 생성자와 같은 효과를 나타낸다. <code>clone()</code> 재정의 시 주의해야 하는 부분은 원본 객체에 변경이나 사이드 이펙트가 전달되지 않도록 복제된 객체의 불변성을 보장해야 한다.</p>\n</li>\n<li><p>clone() 재정의 시, 클래스에 배열 필드가 있다면 clone()을 호출해도 런타임 타입과 컴파일타임 타입 모두가 원본 배열과 똑같은 타입의 배열을 반환한다. 하지만, 깊은 복사가 진행되는 것이 아니기 때문에 주의해야 한다. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cloneTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">short</span> areaCode = <span class=\"number\">10</span>, prefix = <span class=\"number\">5</span>, lineNum = <span class=\"number\">1</span>;</span><br><span class=\"line\">    PhoneNumber[] arr = <span class=\"keyword\">new</span> PhoneNumber[]&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> PhoneNumber(areaCode, prefix, lineNum),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> PhoneNumber(areaCode, prefix, lineNum)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    PhoneNumber[] cloneArr = arr.clone();</span><br><span class=\"line\">    <span class=\"comment\">// Reference Check</span></span><br><span class=\"line\">    assertSame(arr[<span class=\"number\">0</span>], cloneArr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>위의 예제와 같이, 깊은 복사가 필요할 경우 재귀호출을 통하거나 혹은 배열의 요소를 일일이 순회/반복하여 복제하는 작업이 필요하다. </p>\n</li>\n<li><p>생성자에서는 일반적으로 하위 클래스에서 재정의 가능한 매서드를 호출하지 않는 것이 일반적인데, clone도 마찬가지이다. 재정의 시 변경되는 내용에 의해 원본 객체의 상태가 달라질 가능성이 크기 때문이다.</p>\n</li>\n<li><p>clone을 사용하는 것보다 복사 목적으로 사용하는 정잭 팩토리 메서드 혹은 복사 생성자를 사용하는 방법도 있다. 복사 생성자와 팩토리 메서드는 인터페이스 타입의 인자를 받을 수 있기 때문에, 객체 복사 시 유연한 타입 변경이 가능해진다.</p>\n</li>\n<li><p><strong>[결론] clone()의 객체 생성 메카니즘은 위험천만하다. 차라리 복사 정적 팩토리 메서드 혹은 복사 목적의 생성자를 사용하자.</strong></p>\n<h2 id=\"ITEM-14-Comparable을-구현할지-고려하라\"><a href=\"#ITEM-14-Comparable을-구현할지-고려하라\" class=\"headerlink\" title=\"ITEM 14 - Comparable을 구현할지 고려하라\"></a>ITEM 14 - Comparable을 구현할지 고려하라</h2></li>\n</ul>\n<ul>\n<li><code>Comparable.compareTo()</code>는 동치성 비교 및 순서까지 비교 가능하다.</li>\n<li><code>Object.equals()</code>와 마찬가지로 반사성, 대칭성, 추이성을 충족해야 한다. 또한, 해당 원칙을 제대로 지키지 않으면 equals와 마찬가지로 해당 구현을 이용하는 다른 클래스에서 예상하지 못한 결과를 반환할 수 있다.</li>\n<li><code>Comparable</code>을 구현하지 않은 필드나 표준이 아닌 순서로 비교하고 있는 상황이라면, <code>Comparator</code>를 대신 사용하자.</li>\n<li><code>compareTo()</code>에서 기본 타입을 비교 할때, 해당 기본 타입의 래퍼 타입의 <code>compare()</code>를 사용하여 비교하자. &lt;, &gt; 등의 연산자는 거추장스럽고 오류를 유발할 수 있다.</li>\n<li>필드가 여러개 있는 클래스의 경우, 핵심 필드부터 차례대로 비교하도록 하자<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(PhoneNumber o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 첫 번째 핵심 필드</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = Short.compare(areaCode, o.areaCode);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 두 번째 핵심 필드</span></span><br><span class=\"line\">        result = Short.compare(prefix, o.prefix);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 세 번째 핵심 필드</span></span><br><span class=\"line\">            result = Short.compare(lineNum, o.lineNum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>Comparator</code>를 사용하는 방식은 FluentAPI 형식을 사용할 수 있어서 코드 자체가 우아하게 전개되지만, 성능 로스가 있다고 한다.</li>\n<li><code>Comparator</code>는 보조 메서드를 여러개 제공하고 있다. int보다 작은 타입의 경우 comparingInt를 사용하면 되고 float의 경우는 comparingDouble을 이용하면 된다.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Effective-Java-2장\"><a href=\"#Effective-Java-2장\" class=\"headerlink\" title=\"Effective Java - 2장\"></a>Effective Java - 2장</h1><h1 id=\"2장-모든-객체의-공통-메서드\"><a href=\"#2장-모든-객체의-공통-메서드\" class=\"headerlink\" title=\"[2장] 모든 객체의 공통 메서드\"></a>[2장] 모든 객체의 공통 메서드</h1><ul>\n<li>Objects는 객체를 만들 수 있는 구체 클래스면서 기본적으로 상속하여 사용이 가능</li>\n<li>equals, hashCode, toString, clone, finalize 모두 재정의를 염두로 두고 설계</li>\n<li>일반 규약에 맞도록 재정의(overriding)해야 하며, 잘못 구현하면 오작동을 발생 시킬 수 있음</li>\n</ul>\n<h2 id=\"ITEM-10-equals는-일반-규약을-지켜-재정의하라\"><a href=\"#ITEM-10-equals는-일반-규약을-지켜-재정의하라\" class=\"headerlink\" title=\"ITEM 10 - equals는 일반 규약을 지켜 재정의하라\"></a>ITEM 10 - equals는 일반 규약을 지켜 재정의하라</h2><ul>\n<li><p>일반 규약에 맞도록 재정의 하지 않을꺼면 재정의를 안하는 것이 최선. </p>\n</li>\n<li><p>아래 항목이 해당하는 경우 재정의를 하는 것이 크게 의미가 없을 수 있음.</p>\n<ul>\n<li>각 인스턴스는 본질적으로 고유</li>\n<li>인스턴스의 <code>논리적 동치성</code>을 검사할 일이 없는 경우</li>\n<li>상위 클래스에서 정의한 <code>equals</code>가 하위 클래스에 딱 들어맞는 경우</li>\n<li>클래스가 <code>private</code>이거나 <code>package-private</code>일 경우, equals를 호출할 일이 없음</li>\n</ul>\n</li>\n<li><p>그럼 언제 재정의 해야 할까?</p>\n<ul>\n<li>객체 간 <code>논리적 동치성</code>을 확인해야 하는데 상위 클래스의 <code>equals</code>가 이를 비교하도록 정의되지 않았을 경우에 재정의 해야 함.</li>\n<li>주로 값 클래스일 경우가 해당 함.</li>\n</ul>\n</li>\n<li><p><code>equals</code>의 일반 규약은 아래와 같다.</p>\n<ul>\n<li>반사성: 자기 자신과 같아야 함.</li>\n<li>대칭성: x가 y와 같다면, y도 x와 같아야 한다.</li>\n<li>추이성: x가 y와 같고, y가 z와 같다면, x는 z와 같아야 한다.</li>\n<li>일관성: x와 y가 같다면, 영원히 같아야 함.</li>\n<li>null-아님: null과 비교하는 것은 의미가 없음.</li>\n</ul>\n</li>\n<li><p>구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족 시킬 방법은 존재하지 않음.</p>\n<ul>\n<li>Point 클래스를 상속한 ColorPoint클래스와 Point클래스의 인스턴스를 비교할 수 없음, Why?</li>\n<li>객체의 동등성 비교 시, 한쪽만 true인 결과를 얻을 수 있기 때문. equals의 대칭성 규약을 지킬 수 없다.</li>\n</ul>\n</li>\n<li><p>상속이 아닌 컴포지션을 사용하면 우회하여 값을 비교하는 equals를 재정의 하는 것이 가능하다.</p>\n</li>\n<li><p><code>equals</code> 메서드를 구현하는 일반적인 방법은 아래와 같다.</p>\n<ol>\n<li><code>==</code> 연산자를 사용하여 자기 자신의 참조 확인</li>\n<li>instanceof 연산자로 올바른 타입인지 체크</li>\n<li>2번 단계에서 확인한 타입으로 타입 캐스팅</li>\n<li>입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 검사</li>\n</ol>\n</li>\n<li><p>값 혹은 참조를 비교하는 방법은?</p>\n<ul>\n<li>float, double을 제외한 기본 타입의 필드는 <code>==</code> 연산자로 비교<ul>\n<li>float, double은 <code>Float.compare(float, float)</code>, <code>Double.compare(double, double)</code>로 비교</li>\n<li>Float.equals 및 Double.equals는 오토박싱을 수반하므로 성능상 좋지 않음</li>\n</ul>\n</li>\n<li>참조 타입 필드는 해당 타입의 <code>equals</code>를 이용하여 비교</li>\n<li>배열 전체를 비교 할 경우, <code>Arrays.equals</code>를 사용</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneNumber</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">short</span> areaCode, prefix, lineNum;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhoneNumber</span><span class=\"params\">(<span class=\"keyword\">short</span> areaCode, <span class=\"keyword\">short</span> prefix, <span class=\"keyword\">short</span> lineNum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.areaCode = areaCode;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.prefix = prefix;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.lineNum = lineNum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">short</span> <span class=\"title\">rangeCheck</span><span class=\"params\">(<span class=\"keyword\">int</span> val, <span class=\"keyword\">int</span> max, String arg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val &lt; <span class=\"number\">0</span> || val &gt; max) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(arg + <span class=\"string\">&quot;: &quot;</span> + val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">short</span>) val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"comment\">// 인자의 타입은 `Object` 타입을 사용하도록 하자</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 자기 자신과 같은지 확인</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 2. 타입이 같은 체크</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> PhoneNumber)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 3. 타입 캐스팅</span></span><br><span class=\"line\">        PhoneNumber pn = (PhoneNumber)o;</span><br><span class=\"line\">        <span class=\"comment\">// 4. 주요 필드 값에 대해 비교 연산 수행</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> pn.lineNum == lineNum &amp;&amp; pn.areaCode == areaCode &amp;&amp; pn.prefix == prefix;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>equals</code>를 구현하고 체크해야 할 세가지<ul>\n<li>대칭적인지?, 추이성을 만족하는지?, 일관적인지?</li>\n<li>equals를 재정의할 경우 반드시 hashCode도 재정의하자</li>\n<li>인자의 타입은 <code>Object</code> 타입을 사용하도록 하자. 만약 구체 타입으로 인자를 받을 경우 아래 그림과 컴파일이 되지 않는다. <code>@Override</code> 어노테이션을 일관되게 사용하면 이런 일련의 실수를 예방할 수 있다.<br><img src=\"https://i.imgur.com/MVYfZTY.png\" alt=\"인자의 타입은 `Object`\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"ITEM-11-equals를-재정의하려거든-hashCode도-재정의하라\"><a href=\"#ITEM-11-equals를-재정의하려거든-hashCode도-재정의하라\" class=\"headerlink\" title=\"ITEM 11 - equals를 재정의하려거든 hashCode도 재정의하라\"></a>ITEM 11 - equals를 재정의하려거든 hashCode도 재정의하라</h2><ul>\n<li><p>equals를 재정의 할 경우 반드시 hashCode도 재정의 해야 한다. </p>\n<ul>\n<li>그러지 않으면, HashSet 혹은 HashMap과 같은 콜랙션 구현체에서 사용 시 문제가 발생한다.</li>\n</ul>\n</li>\n<li><p>아래는 Object 명세의 일부이다.</p>\n<ul>\n<li>equals 비교에 사용되는 필드 값이 변경되지 않았다면, 매번 같은 hashCode를 반환해야 한다.</li>\n<li><strong>[중요] equals에서 두 객체가 같다고 판단했다면, hashCode도 같은 값을 반환해야 한다.</strong></li>\n<li>equals에서 두 객체가 다르다고 판단했더라도, 두 객체가 다른 hashCode값을 반환할 필요는 없다. </li>\n<li><strong>[중요] 하지만, 다른 객체에 대해서는 다른 hashCode 값을 반환해야 해시테이블의 성능이 좋아진다.</strong></li>\n</ul>\n</li>\n<li><p>해시코드 반환을 올바르게 하지 않을 경우, 수행 시간의 계산이 최대 O(n)까지 늘어날 수 있다.아래는 O(n)까지 늘어나는 사용 금지 해시 코드 구현이다.</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">42</span>; &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>좋은 해시 함수는 결국 서로 다른 객체 혹은 인스턴스에 대해 다른 해시코드를 반환해야 한다. 이상적인 해시 함수는 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.</p>\n</li>\n<li><p><code>hashCode</code>를 작성하는 요령은?</p>\n<ol>\n<li>첫 번째 핵심 필드에 대해 hashCode를 생성. 이를 변수 <code>result</code>에 할당.</li>\n<li>나머지 필드에 대해 아래와 같이 해시코드를 구하도록 하자.</li>\n</ol>\n<ul>\n<li>해시코드 c를 아래와 같은 원칙으로 구해보자.<ul>\n<li>기본 타입 필드일 경우, 해당 타입의 박싱 클래스 타입의 Type.hashCode(f)를 수행 </li>\n<li>참조 타입 필드일 경우, 해당 클래스의 필드 값들에 대해 hashCode를 재귀적으로 호출하고 복잡해질꺼 같으면 필드의 표준형을 만들어 호출하자. 필드 값이 null이면 0을 사용한다.</li>\n<li>필드가 배열일 경우, 핵심 원소에 대해 각각 필드와 같이 다뤄준다. 핵심 원소가 없을 경우 0으로 다뤄주자.</li>\n</ul>\n</li>\n<li>첫 번째 단계에서 구한 해시코드 값을 아래와 같이 갱신하도록 하자.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = <span class=\"number\">31</span> * result + c</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"3\">\n<li>hashCode의 반환 값으로 result를 반환.</li>\n<li>작성 후 동치 인스턴스에 대해 같은 해시코드 값을 반환하는지 테스트 코드를 작성하도록 하자.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> result = Short.hashCode(areaCode);</span><br><span class=\"line\">\tresult = <span class=\"number\">31</span> * result + Short.hashCode(prefix);</span><br><span class=\"line\">\tresult = <span class=\"number\">31</span> * result + Short.hashCode(lineNum);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// with Junit</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hashCodeTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">short</span> areaCode = <span class=\"number\">10</span>, prefix = <span class=\"number\">5</span>, lineNum = <span class=\"number\">1</span>;</span><br><span class=\"line\">    PhoneNumber p1 = <span class=\"keyword\">new</span> PhoneNumber(areaCode, prefix, lineNum);</span><br><span class=\"line\">    PhoneNumber p2 = <span class=\"keyword\">new</span> PhoneNumber(areaCode, prefix, lineNum);</span><br><span class=\"line\">    assertEquals(p1.hashCode(), p2.hashCode());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>해시 충돌이 더 적은 구현을 원한다면 <code>guava</code>의 <code>Hashing</code> 구현을 참고하자.</p>\n</li>\n<li><p><code>Objects</code> 클래스의 hash 메서드를 이용하면 해쉬 값을 쉽게 구할 수 있으나, 안타깝게도 해당 메서드는 박싱과 언박싱의 과정이 길어서 속도가 더 느리다고 한다. </p>\n</li>\n<li><p>만약 클래스가 불변인 상황에서 해시코드를 구하는 과정이 길거나 오래걸린다면 캐싱하는 방식을 고려해보면 좋다.</p>\n</li>\n<li><p>성능 고려한다고 해시코드 계산 시 핵심 필드를 생략하면 안된다. 해당 필드를 생략할 경우 해시 품질이 나빠져 특정 영역으로 몰릴 수 있기 때문이다.</p>\n</li>\n<li><p>해시코드 생성 규칙을 외부 사용자(API 사용하는)에게 알리지 않아야 추후에 변경이 발생했을 경우에 유연하게 변경이 가능하다.</p>\n</li>\n</ul>\n<h2 id=\"ITEM-12-toString을-항상-재정의하라\"><a href=\"#ITEM-12-toString을-항상-재정의하라\" class=\"headerlink\" title=\"ITEM 12 - toString을 항상 재정의하라\"></a>ITEM 12 - toString을 항상 재정의하라</h2><p>별도로 <code>toString()</code>을 재정의하지 않으면 <code>클래스명@16진수의 해시코드</code>가 반환된다. toString의 일반 규약에서는 <code>간결하고 읽기 쉬운 형식의 정보를 반환해라</code>라고 명세되어 있다고 한다. 또한, 모든 하위 클래스에서 toString을 재정의 하라고 말하고 있다.<br>쉽게 접할 수 있는 디버깅을 하는 상황이라고 생각해봐도 toString()을 재정의하여 유의미한 정보를 보면서 디버깅 하는 것과 그렇지 않은 경우는 많이 다르다. 결국 유의미한 정보를 반환하는 것이 관례이자 규약이라고 하면 이를 지키는 것이 좋을 것이다.</p>\n<ul>\n<li>객체가 가지고 있는 정보는 가급적 전부 반환하는 것이 좋다.</li>\n<li>반환하는 포맷에 대한 고민도 해봐야 한다.<ul>\n<li>포맷의 고정 유무와 상관 없이 <code>유의미한</code> 정보를 반환하고 의미를 분명하게 하는 것은 중요하다.</li>\n</ul>\n</li>\n</ul>\n<p>책의 예제에서는 앞의 PhoneNumber 클래스에서 toString()을 재정의한 예시를 보여주고 있는데, 참고하기 좋은 주석과 내용을 담고 있는 듯 하다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 이 전화번호의 문자열 표현을 반환한다.</span></span><br><span class=\"line\"><span class=\"comment\"> * 이 문자열은 &quot;XXX-YYY-ZZZZ&quot; 형태의 12글자로 구성된다.</span></span><br><span class=\"line\"><span class=\"comment\"> * XXX는 지역 코드, YYY는 Prefix, ZZZZ는 가입자 번호다.</span></span><br><span class=\"line\"><span class=\"comment\"> * 각각의 대문자는 10진수 숫자 하나를 나타낸다.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 전화번호의 각 부분의 값이 너무 작아서 자릿수를 채울 수 없다면,</span></span><br><span class=\"line\"><span class=\"comment\"> * 앞에서부터 0으로 채워나간다. 예컨대 가입자 번호가 123이라면</span></span><br><span class=\"line\"><span class=\"comment\"> * 전화번호의 마지막 네 문자는 &quot;0123&quot;이 된다.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> String.format(<span class=\"string\">&quot;%03d-%03d-%04d&quot;</span>, areaCode, prefix, lineNum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Google.AutoValue</code> 프레임워크에서는 toString을 생성해준다고 하는데, Lombok을 사용했을 때랑 어떻게 차이가 나는지는 직접 해보지 않아서 잘 모르겠다.</p>\n<h2 id=\"ITEM-13-clone-재정의는-주의해서-진행하라\"><a href=\"#ITEM-13-clone-재정의는-주의해서-진행하라\" class=\"headerlink\" title=\"ITEM 13 - clone 재정의는 주의해서 진행하라\"></a>ITEM 13 - clone 재정의는 주의해서 진행하라</h2><ul>\n<li><p><code>Cloneable</code>는 <code>마커 인터페이스</code>로 <strong>이를 구현한 객체는 복제가 가능한 객체</strong>임을 명시하는 용도로 사용한다.</p>\n</li>\n<li><p><code>Cloneable</code> 인터페이스를 구현한 클래스의 인스턴스에서 <code>clone</code>을 호출하면 필드 전체를 복사한 객체를 반환한다. 만약 인터페이스를 구현하지 않을 경우 CloneNotSupportedException을 반환한다.</p>\n</li>\n<li><p><strong>[중요] 메서드 하나 없는 <code>Cloneable</code>은 실상 <code>Object.clone</code>의 동작 방식을 결정하는데, 이례적인 사용으로 보이는 것이 인터페이스를 구현한 것만으로 상위 클래스 메서드 행위의 변경을 가하고 있기 때문이다.</strong></p>\n</li>\n<li><p><code>Cloneable</code> 인터페이스를 구현함으로써, 해당 객체를 사용하는 사용자 측에서는 <code>clone()</code> 메서드가 public으로 제공되며 이를 통해 복제를 할 수 있으리라 판단할 수 있다.</p>\n</li>\n<li><p>클래스의 계층 구조를 가지는 상황에서 하위 클래스가 만약 final 클래스라면 더 이상의 하위 클래스 상속은 발생하지 않기 때문에 관례는 무시해도 되겠지만, 만약 final 클래스의 clone 구현이 super.clone()을 호출하지 않는다면 Cloneable 인터페이스를 구현할 이유가 없다. 왜냐하면, 이는 위에서도 설명한대로 <code>Cloneable</code> 인터페이스가 Object.clone의 동작 방식을 결정하기 때문이고 이런 동작 방식 자체에 기댈 필요가 없기 때문이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> PhoneNumber <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (PhoneNumber) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>위 예제에서는 상위 타입에서 반환하는 <code>Object</code>타입이 아닌 <code>PhoneNumber</code>타입을 반환하고 있다. 이는 <code>공변 반환 타이핑(covariant return typing)</code>을 나타내고 있다. 다시 말해, 재정의한 메서드의 반환 타입은 상위 클래스의 메서드가 반환하는 타입의 하위 타입일 수 있다는 이야기이다.</p>\n</li>\n<li><p><code>clone()</code> 메서드는 사실상 생성자와 같은 효과를 나타낸다. <code>clone()</code> 재정의 시 주의해야 하는 부분은 원본 객체에 변경이나 사이드 이펙트가 전달되지 않도록 복제된 객체의 불변성을 보장해야 한다.</p>\n</li>\n<li><p>clone() 재정의 시, 클래스에 배열 필드가 있다면 clone()을 호출해도 런타임 타입과 컴파일타임 타입 모두가 원본 배열과 똑같은 타입의 배열을 반환한다. 하지만, 깊은 복사가 진행되는 것이 아니기 때문에 주의해야 한다. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cloneTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">short</span> areaCode = <span class=\"number\">10</span>, prefix = <span class=\"number\">5</span>, lineNum = <span class=\"number\">1</span>;</span><br><span class=\"line\">    PhoneNumber[] arr = <span class=\"keyword\">new</span> PhoneNumber[]&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> PhoneNumber(areaCode, prefix, lineNum),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> PhoneNumber(areaCode, prefix, lineNum)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    PhoneNumber[] cloneArr = arr.clone();</span><br><span class=\"line\">    <span class=\"comment\">// Reference Check</span></span><br><span class=\"line\">    assertSame(arr[<span class=\"number\">0</span>], cloneArr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>위의 예제와 같이, 깊은 복사가 필요할 경우 재귀호출을 통하거나 혹은 배열의 요소를 일일이 순회/반복하여 복제하는 작업이 필요하다. </p>\n</li>\n<li><p>생성자에서는 일반적으로 하위 클래스에서 재정의 가능한 매서드를 호출하지 않는 것이 일반적인데, clone도 마찬가지이다. 재정의 시 변경되는 내용에 의해 원본 객체의 상태가 달라질 가능성이 크기 때문이다.</p>\n</li>\n<li><p>clone을 사용하는 것보다 복사 목적으로 사용하는 정잭 팩토리 메서드 혹은 복사 생성자를 사용하는 방법도 있다. 복사 생성자와 팩토리 메서드는 인터페이스 타입의 인자를 받을 수 있기 때문에, 객체 복사 시 유연한 타입 변경이 가능해진다.</p>\n</li>\n<li><p><strong>[결론] clone()의 객체 생성 메카니즘은 위험천만하다. 차라리 복사 정적 팩토리 메서드 혹은 복사 목적의 생성자를 사용하자.</strong></p>\n<h2 id=\"ITEM-14-Comparable을-구현할지-고려하라\"><a href=\"#ITEM-14-Comparable을-구현할지-고려하라\" class=\"headerlink\" title=\"ITEM 14 - Comparable을 구현할지 고려하라\"></a>ITEM 14 - Comparable을 구현할지 고려하라</h2></li>\n</ul>\n<ul>\n<li><code>Comparable.compareTo()</code>는 동치성 비교 및 순서까지 비교 가능하다.</li>\n<li><code>Object.equals()</code>와 마찬가지로 반사성, 대칭성, 추이성을 충족해야 한다. 또한, 해당 원칙을 제대로 지키지 않으면 equals와 마찬가지로 해당 구현을 이용하는 다른 클래스에서 예상하지 못한 결과를 반환할 수 있다.</li>\n<li><code>Comparable</code>을 구현하지 않은 필드나 표준이 아닌 순서로 비교하고 있는 상황이라면, <code>Comparator</code>를 대신 사용하자.</li>\n<li><code>compareTo()</code>에서 기본 타입을 비교 할때, 해당 기본 타입의 래퍼 타입의 <code>compare()</code>를 사용하여 비교하자. &lt;, &gt; 등의 연산자는 거추장스럽고 오류를 유발할 수 있다.</li>\n<li>필드가 여러개 있는 클래스의 경우, 핵심 필드부터 차례대로 비교하도록 하자<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(PhoneNumber o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 첫 번째 핵심 필드</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = Short.compare(areaCode, o.areaCode);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 두 번째 핵심 필드</span></span><br><span class=\"line\">        result = Short.compare(prefix, o.prefix);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 세 번째 핵심 필드</span></span><br><span class=\"line\">            result = Short.compare(lineNum, o.lineNum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>Comparator</code>를 사용하는 방식은 FluentAPI 형식을 사용할 수 있어서 코드 자체가 우아하게 전개되지만, 성능 로스가 있다고 한다.</li>\n<li><code>Comparator</code>는 보조 메서드를 여러개 제공하고 있다. int보다 작은 타입의 경우 comparingInt를 사용하면 되고 float의 경우는 comparingDouble을 이용하면 된다.</li>\n</ul>\n"},{"title":"Effective Java - 3장","date":"2019-02-19T14:00:00.000Z","_content":"\n# Effective Java - 3장\n## ITEM 15 - 클래스와 멤버의 접근 권한을 최소화하라\n\n> 접근성은 가능한 최소한으로 유지하자. 그리고 공개API로 필요한 최소한을 선정하여 공개하도록 하자. 의도하지 않은 공개가 발생하지 않도록 주의해야 하며, 상수용 필드를 노출 할때에도 기본 타입 혹은 불변 타입만을 공개하도록 해야 한다.\n\n* **잘 설계된 컴포넌트는 내부 구현과 데이터를 외부로부터 잘 숨겼는지 여부에 달려있다.** 다시 말해, 구현과 공개하는 API를 깔끔하게 분리한다는 이야기이다. API를 통해서만 외부의 컴포넌트 혹인 API와 소통하며 서로 내부 동작은 전혀 개의치 않게 되는 것이다.\n* 접근 제어 메커니즘을 잘 활용하면 위에서 설명한 내용 즉, **정보 은닉**에 해당하는 내용을 충실하게 구현 할 수 있다.\n* 기본 원칙은 **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다**\n  * 패키지 외부에서 사용 할 일이 없다면 `package-private`으로 선언하자.\n  * 한 클래스에서만 사용하는 클래스 혹은 인터페이스는 private static으로 중첩 시켜서 사용해보자.\n  * public일 필요 없으면 package-private으로 좁혀보자. 즉, public이 아닌 경우 내부 구현에 해당하므로 이에 대한 접근 범위를 좁히라는 이야기이다.\n* **다시 보는 접근 제어자**\n  * **private**: 클래스 내부에서만 접근 가능\n  * **package-private**: 같은 패키지에서는 접근 가능\n  * **protected**: 같은 패키지 접근 + 멤버가 만약 protected로 선언 되어 있을 경우 상속 시 접근 가능\n  * **public**: 외부 공개\n* **클래스를 디자인하거나 설계 할때, 공개 API를 설계한 후 그 외의 멤버에 대해서는 private으로 만들어놓고 시작해보자. 그리고 나서 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 package-private으로 풀어주도록 하자.** \n  * 만약 package-private으로 풀어주는 멤버가 많아진다면 컴포넌트/클래스를 더 분해해야 하는지 고민해봐야 한다.\n* **protected 멤버의 경우, 멤버에 접근 할 수 있는 대상 범위가 엄청 넓어진다.**\n  * 사실상 공개 멤버이므로, 영원히 지원이 되어야 하며. 이를 위한 충분한 문서화를 통하여 외부에 공개 할 수 있어야 한다.\n* 테스트를 위해서 클래스 혹은 인터페이스의 멤버를 공개API로 변경하는 일은 없어야 한다.\n* **public 클래스의 인스턴스 필드는 public으로 두지 말자**\n  * 가변 필드의 경우, 값을 제어 할 수 없을 뿐만 아니라 스레드 세이프 하지 않으므로 잠재적인 위험요소이다.\n  * 상수 개념으로 사용한다면 공개해도 괜찮지만, 기본 타입의 값 혹은 불변 객체를 대상으로 하자\n  * 길이가 0이 아닌 배열의 경우. 변경이 가능하니 주의하자.\n  \n  > 배열을 사용한다면 이를 수정 불가능한 리스트로 변경 후 공개하도록 하자\n  ```java\n  public class PublicConstant {\n        private static final Thing[] thingsArr = { new Thing() };\n        public static final List<Thing> thingsList = Collections.unmodifiableList(Arrays.asList(thingsArr));\n  }\n  ```\n  > 복사본을 만들어서 활용하는 방법도 있다.\n  ```java\n  public class PublicConstant {\n        private static final Thing[] thingsArr = { new Thing() };\n        public static final Thing[] getThings() {\n              return thingsArr.clone();\n        }\n  }\n  ```  \n\n\n## ITEM 16 - public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라\n> public 클래스에서 절대 가변 필드를 노출 시키지 말자. 불변 필드를 노출시키는 것은 나쁘진 않지만 완전히 안심할 수 없는 일이다.\n\n* public 클래스의 필드가 public이면 이를 사용하는 클라이언트가 생길것이며, 이는 곧 내부 표현을 쉽게 변경할 수 없음을 뜻한다.\n* 필드에 대한 직접 접근은 지양하고 **접근자**를 사용하자.\n  ```java\n  public class Point {\n      private double x;\n      private double y;\n  \n      public Point(double x, double y) {\n          this.x = x;\n          this.y = y;\n      }\n  \n      public double getX() {\n          return x;\n      }\n  \n      public void setX(double x) {\n          this.x = x;\n      }\n  \n      public double getY() {\n          return y;\n      }\n  \n      public void setY(double y) {\n          this.y = y;\n      }\n  }  \n  ```\n* public 클래스의 필드가 **불변**이면 노출 시 단점을 줄어들지만 여전히 좋은 생각은 아니다. API를 변경하지 않고는 표현 방식을 바꿀 수 없으며 필드를 읽을 때 부수 작업을 수행할 수 없다는 단점은 여전하다.\n\n## ITEM 16 - public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라\n### 불변 클래스란?\n  ```java\n  public class Point {\n      private final double x;\n      private final double y;\n  \n      public Point(double x, double y) {\n          this.x = x;\n          this.y = y;\n      }\n  \n      public double getX() {\n          return x;\n      }\n  \n      public double getY() {\n          return y;\n      }\n  }  \n  ```\n내부 값을 수정 할 수 없는 클래스. 간직된 데이터는 객체가 파괴되는 순간까지 달라지지 않는다. 가변 클래스보다 설계 및 구현이 쉬우며 오류 발생 여지가 확실히 적다.\n\n### 구현 규칙은?\n* 객체 상태를 변경하는 설정자 메서드를 제공하지 않음\n* 확장이 안되도록 한다.\n* 모든 필드는 private final로 선언한다.\n* 클래스 자신을 외에는 내부 구현에 접근하지 않도록 한다.\n\n","source":"_posts/Java/EffectiveJava3e_ch3.md","raw":"---\ntitle: Effective Java - 3장\ndate: 2019.2.19. 23:00\ncategories:\n- Java\n---\n\n# Effective Java - 3장\n## ITEM 15 - 클래스와 멤버의 접근 권한을 최소화하라\n\n> 접근성은 가능한 최소한으로 유지하자. 그리고 공개API로 필요한 최소한을 선정하여 공개하도록 하자. 의도하지 않은 공개가 발생하지 않도록 주의해야 하며, 상수용 필드를 노출 할때에도 기본 타입 혹은 불변 타입만을 공개하도록 해야 한다.\n\n* **잘 설계된 컴포넌트는 내부 구현과 데이터를 외부로부터 잘 숨겼는지 여부에 달려있다.** 다시 말해, 구현과 공개하는 API를 깔끔하게 분리한다는 이야기이다. API를 통해서만 외부의 컴포넌트 혹인 API와 소통하며 서로 내부 동작은 전혀 개의치 않게 되는 것이다.\n* 접근 제어 메커니즘을 잘 활용하면 위에서 설명한 내용 즉, **정보 은닉**에 해당하는 내용을 충실하게 구현 할 수 있다.\n* 기본 원칙은 **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다**\n  * 패키지 외부에서 사용 할 일이 없다면 `package-private`으로 선언하자.\n  * 한 클래스에서만 사용하는 클래스 혹은 인터페이스는 private static으로 중첩 시켜서 사용해보자.\n  * public일 필요 없으면 package-private으로 좁혀보자. 즉, public이 아닌 경우 내부 구현에 해당하므로 이에 대한 접근 범위를 좁히라는 이야기이다.\n* **다시 보는 접근 제어자**\n  * **private**: 클래스 내부에서만 접근 가능\n  * **package-private**: 같은 패키지에서는 접근 가능\n  * **protected**: 같은 패키지 접근 + 멤버가 만약 protected로 선언 되어 있을 경우 상속 시 접근 가능\n  * **public**: 외부 공개\n* **클래스를 디자인하거나 설계 할때, 공개 API를 설계한 후 그 외의 멤버에 대해서는 private으로 만들어놓고 시작해보자. 그리고 나서 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 package-private으로 풀어주도록 하자.** \n  * 만약 package-private으로 풀어주는 멤버가 많아진다면 컴포넌트/클래스를 더 분해해야 하는지 고민해봐야 한다.\n* **protected 멤버의 경우, 멤버에 접근 할 수 있는 대상 범위가 엄청 넓어진다.**\n  * 사실상 공개 멤버이므로, 영원히 지원이 되어야 하며. 이를 위한 충분한 문서화를 통하여 외부에 공개 할 수 있어야 한다.\n* 테스트를 위해서 클래스 혹은 인터페이스의 멤버를 공개API로 변경하는 일은 없어야 한다.\n* **public 클래스의 인스턴스 필드는 public으로 두지 말자**\n  * 가변 필드의 경우, 값을 제어 할 수 없을 뿐만 아니라 스레드 세이프 하지 않으므로 잠재적인 위험요소이다.\n  * 상수 개념으로 사용한다면 공개해도 괜찮지만, 기본 타입의 값 혹은 불변 객체를 대상으로 하자\n  * 길이가 0이 아닌 배열의 경우. 변경이 가능하니 주의하자.\n  \n  > 배열을 사용한다면 이를 수정 불가능한 리스트로 변경 후 공개하도록 하자\n  ```java\n  public class PublicConstant {\n        private static final Thing[] thingsArr = { new Thing() };\n        public static final List<Thing> thingsList = Collections.unmodifiableList(Arrays.asList(thingsArr));\n  }\n  ```\n  > 복사본을 만들어서 활용하는 방법도 있다.\n  ```java\n  public class PublicConstant {\n        private static final Thing[] thingsArr = { new Thing() };\n        public static final Thing[] getThings() {\n              return thingsArr.clone();\n        }\n  }\n  ```  \n\n\n## ITEM 16 - public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라\n> public 클래스에서 절대 가변 필드를 노출 시키지 말자. 불변 필드를 노출시키는 것은 나쁘진 않지만 완전히 안심할 수 없는 일이다.\n\n* public 클래스의 필드가 public이면 이를 사용하는 클라이언트가 생길것이며, 이는 곧 내부 표현을 쉽게 변경할 수 없음을 뜻한다.\n* 필드에 대한 직접 접근은 지양하고 **접근자**를 사용하자.\n  ```java\n  public class Point {\n      private double x;\n      private double y;\n  \n      public Point(double x, double y) {\n          this.x = x;\n          this.y = y;\n      }\n  \n      public double getX() {\n          return x;\n      }\n  \n      public void setX(double x) {\n          this.x = x;\n      }\n  \n      public double getY() {\n          return y;\n      }\n  \n      public void setY(double y) {\n          this.y = y;\n      }\n  }  \n  ```\n* public 클래스의 필드가 **불변**이면 노출 시 단점을 줄어들지만 여전히 좋은 생각은 아니다. API를 변경하지 않고는 표현 방식을 바꿀 수 없으며 필드를 읽을 때 부수 작업을 수행할 수 없다는 단점은 여전하다.\n\n## ITEM 16 - public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라\n### 불변 클래스란?\n  ```java\n  public class Point {\n      private final double x;\n      private final double y;\n  \n      public Point(double x, double y) {\n          this.x = x;\n          this.y = y;\n      }\n  \n      public double getX() {\n          return x;\n      }\n  \n      public double getY() {\n          return y;\n      }\n  }  \n  ```\n내부 값을 수정 할 수 없는 클래스. 간직된 데이터는 객체가 파괴되는 순간까지 달라지지 않는다. 가변 클래스보다 설계 및 구현이 쉬우며 오류 발생 여지가 확실히 적다.\n\n### 구현 규칙은?\n* 객체 상태를 변경하는 설정자 메서드를 제공하지 않음\n* 확장이 안되도록 한다.\n* 모든 필드는 private final로 선언한다.\n* 클래스 자신을 외에는 내부 구현에 접근하지 않도록 한다.\n\n","slug":"Java/EffectiveJava3e_ch3","published":1,"updated":"2021-08-02T12:07:22.606Z","_id":"ckrsup509000xtjhv4z1a48a0","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Effective-Java-3장\"><a href=\"#Effective-Java-3장\" class=\"headerlink\" title=\"Effective Java - 3장\"></a>Effective Java - 3장</h1><h2 id=\"ITEM-15-클래스와-멤버의-접근-권한을-최소화하라\"><a href=\"#ITEM-15-클래스와-멤버의-접근-권한을-최소화하라\" class=\"headerlink\" title=\"ITEM 15 - 클래스와 멤버의 접근 권한을 최소화하라\"></a>ITEM 15 - 클래스와 멤버의 접근 권한을 최소화하라</h2><blockquote>\n<p>접근성은 가능한 최소한으로 유지하자. 그리고 공개API로 필요한 최소한을 선정하여 공개하도록 하자. 의도하지 않은 공개가 발생하지 않도록 주의해야 하며, 상수용 필드를 노출 할때에도 기본 타입 혹은 불변 타입만을 공개하도록 해야 한다.</p>\n</blockquote>\n<ul>\n<li><strong>잘 설계된 컴포넌트는 내부 구현과 데이터를 외부로부터 잘 숨겼는지 여부에 달려있다.</strong> 다시 말해, 구현과 공개하는 API를 깔끔하게 분리한다는 이야기이다. API를 통해서만 외부의 컴포넌트 혹인 API와 소통하며 서로 내부 동작은 전혀 개의치 않게 되는 것이다.</li>\n<li>접근 제어 메커니즘을 잘 활용하면 위에서 설명한 내용 즉, <strong>정보 은닉</strong>에 해당하는 내용을 충실하게 구현 할 수 있다.</li>\n<li>기본 원칙은 <strong>모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다</strong><ul>\n<li>패키지 외부에서 사용 할 일이 없다면 <code>package-private</code>으로 선언하자.</li>\n<li>한 클래스에서만 사용하는 클래스 혹은 인터페이스는 private static으로 중첩 시켜서 사용해보자.</li>\n<li>public일 필요 없으면 package-private으로 좁혀보자. 즉, public이 아닌 경우 내부 구현에 해당하므로 이에 대한 접근 범위를 좁히라는 이야기이다.</li>\n</ul>\n</li>\n<li><strong>다시 보는 접근 제어자</strong><ul>\n<li><strong>private</strong>: 클래스 내부에서만 접근 가능</li>\n<li><strong>package-private</strong>: 같은 패키지에서는 접근 가능</li>\n<li><strong>protected</strong>: 같은 패키지 접근 + 멤버가 만약 protected로 선언 되어 있을 경우 상속 시 접근 가능</li>\n<li><strong>public</strong>: 외부 공개</li>\n</ul>\n</li>\n<li><strong>클래스를 디자인하거나 설계 할때, 공개 API를 설계한 후 그 외의 멤버에 대해서는 private으로 만들어놓고 시작해보자. 그리고 나서 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 package-private으로 풀어주도록 하자.</strong> <ul>\n<li>만약 package-private으로 풀어주는 멤버가 많아진다면 컴포넌트/클래스를 더 분해해야 하는지 고민해봐야 한다.</li>\n</ul>\n</li>\n<li><strong>protected 멤버의 경우, 멤버에 접근 할 수 있는 대상 범위가 엄청 넓어진다.</strong><ul>\n<li>사실상 공개 멤버이므로, 영원히 지원이 되어야 하며. 이를 위한 충분한 문서화를 통하여 외부에 공개 할 수 있어야 한다.</li>\n</ul>\n</li>\n<li>테스트를 위해서 클래스 혹은 인터페이스의 멤버를 공개API로 변경하는 일은 없어야 한다.</li>\n<li><strong>public 클래스의 인스턴스 필드는 public으로 두지 말자</strong><ul>\n<li>가변 필드의 경우, 값을 제어 할 수 없을 뿐만 아니라 스레드 세이프 하지 않으므로 잠재적인 위험요소이다.</li>\n<li>상수 개념으로 사용한다면 공개해도 괜찮지만, 기본 타입의 값 혹은 불변 객체를 대상으로 하자</li>\n<li>길이가 0이 아닌 배열의 경우. 변경이 가능하니 주의하자.</li>\n</ul>\n<blockquote>\n<p>배열을 사용한다면 이를 수정 불가능한 리스트로 변경 후 공개하도록 하자</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PublicConstant</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Thing[] thingsArr = &#123; <span class=\"keyword\">new</span> Thing() &#125;;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;Thing&gt; thingsList = Collections.unmodifiableList(Arrays.asList(thingsArr));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>복사본을 만들어서 활용하는 방법도 있다.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PublicConstant</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Thing[] thingsArr = &#123; <span class=\"keyword\">new</span> Thing() &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Thing[] getThings() &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> thingsArr.clone();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ```  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## ITEM <span class=\"number\">16</span> - <span class=\"keyword\">public</span> 클래스에서는 <span class=\"keyword\">public</span> 필드가 아닌 접근자 메서드를 사용하라</span><br><span class=\"line\">&gt; <span class=\"keyword\">public</span> 클래스에서 절대 가변 필드를 노출 시키지 말자. 불변 필드를 노출시키는 것은 나쁘진 않지만 완전히 안심할 수 없는 일이다.</span><br><span class=\"line\"></span><br><span class=\"line\">* <span class=\"keyword\">public</span> 클래스의 필드가 <span class=\"keyword\">public</span>이면 이를 사용하는 클라이언트가 생길것이며, 이는 곧 내부 표현을 쉽게 변경할 수 없음을 뜻한다.</span><br><span class=\"line\">* 필드에 대한 직접 접근은 지양하고 **접근자**를 사용하자.</span><br><span class=\"line\">  ```java</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> y;</span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">double</span> y)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getX</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setX</span><span class=\"params\">(<span class=\"keyword\">double</span> x)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getY</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setY</span><span class=\"params\">(<span class=\"keyword\">double</span> y)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;  </span><br></pre></td></tr></table></figure></li>\n<li>public 클래스의 필드가 <strong>불변</strong>이면 노출 시 단점을 줄어들지만 여전히 좋은 생각은 아니다. API를 변경하지 않고는 표현 방식을 바꿀 수 없으며 필드를 읽을 때 부수 작업을 수행할 수 없다는 단점은 여전하다.</li>\n</ul>\n<h2 id=\"ITEM-16-public-클래스에서는-public-필드가-아닌-접근자-메서드를-사용하라\"><a href=\"#ITEM-16-public-클래스에서는-public-필드가-아닌-접근자-메서드를-사용하라\" class=\"headerlink\" title=\"ITEM 16 - public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라\"></a>ITEM 16 - public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라</h2><h3 id=\"불변-클래스란\"><a href=\"#불변-클래스란\" class=\"headerlink\" title=\"불변 클래스란?\"></a>불변 클래스란?</h3>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">double</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">double</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getX</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getY</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>내부 값을 수정 할 수 없는 클래스. 간직된 데이터는 객체가 파괴되는 순간까지 달라지지 않는다. 가변 클래스보다 설계 및 구현이 쉬우며 오류 발생 여지가 확실히 적다.</p>\n<h3 id=\"구현-규칙은\"><a href=\"#구현-규칙은\" class=\"headerlink\" title=\"구현 규칙은?\"></a>구현 규칙은?</h3><ul>\n<li>객체 상태를 변경하는 설정자 메서드를 제공하지 않음</li>\n<li>확장이 안되도록 한다.</li>\n<li>모든 필드는 private final로 선언한다.</li>\n<li>클래스 자신을 외에는 내부 구현에 접근하지 않도록 한다.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Effective-Java-3장\"><a href=\"#Effective-Java-3장\" class=\"headerlink\" title=\"Effective Java - 3장\"></a>Effective Java - 3장</h1><h2 id=\"ITEM-15-클래스와-멤버의-접근-권한을-최소화하라\"><a href=\"#ITEM-15-클래스와-멤버의-접근-권한을-최소화하라\" class=\"headerlink\" title=\"ITEM 15 - 클래스와 멤버의 접근 권한을 최소화하라\"></a>ITEM 15 - 클래스와 멤버의 접근 권한을 최소화하라</h2><blockquote>\n<p>접근성은 가능한 최소한으로 유지하자. 그리고 공개API로 필요한 최소한을 선정하여 공개하도록 하자. 의도하지 않은 공개가 발생하지 않도록 주의해야 하며, 상수용 필드를 노출 할때에도 기본 타입 혹은 불변 타입만을 공개하도록 해야 한다.</p>\n</blockquote>\n<ul>\n<li><strong>잘 설계된 컴포넌트는 내부 구현과 데이터를 외부로부터 잘 숨겼는지 여부에 달려있다.</strong> 다시 말해, 구현과 공개하는 API를 깔끔하게 분리한다는 이야기이다. API를 통해서만 외부의 컴포넌트 혹인 API와 소통하며 서로 내부 동작은 전혀 개의치 않게 되는 것이다.</li>\n<li>접근 제어 메커니즘을 잘 활용하면 위에서 설명한 내용 즉, <strong>정보 은닉</strong>에 해당하는 내용을 충실하게 구현 할 수 있다.</li>\n<li>기본 원칙은 <strong>모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다</strong><ul>\n<li>패키지 외부에서 사용 할 일이 없다면 <code>package-private</code>으로 선언하자.</li>\n<li>한 클래스에서만 사용하는 클래스 혹은 인터페이스는 private static으로 중첩 시켜서 사용해보자.</li>\n<li>public일 필요 없으면 package-private으로 좁혀보자. 즉, public이 아닌 경우 내부 구현에 해당하므로 이에 대한 접근 범위를 좁히라는 이야기이다.</li>\n</ul>\n</li>\n<li><strong>다시 보는 접근 제어자</strong><ul>\n<li><strong>private</strong>: 클래스 내부에서만 접근 가능</li>\n<li><strong>package-private</strong>: 같은 패키지에서는 접근 가능</li>\n<li><strong>protected</strong>: 같은 패키지 접근 + 멤버가 만약 protected로 선언 되어 있을 경우 상속 시 접근 가능</li>\n<li><strong>public</strong>: 외부 공개</li>\n</ul>\n</li>\n<li><strong>클래스를 디자인하거나 설계 할때, 공개 API를 설계한 후 그 외의 멤버에 대해서는 private으로 만들어놓고 시작해보자. 그리고 나서 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 package-private으로 풀어주도록 하자.</strong> <ul>\n<li>만약 package-private으로 풀어주는 멤버가 많아진다면 컴포넌트/클래스를 더 분해해야 하는지 고민해봐야 한다.</li>\n</ul>\n</li>\n<li><strong>protected 멤버의 경우, 멤버에 접근 할 수 있는 대상 범위가 엄청 넓어진다.</strong><ul>\n<li>사실상 공개 멤버이므로, 영원히 지원이 되어야 하며. 이를 위한 충분한 문서화를 통하여 외부에 공개 할 수 있어야 한다.</li>\n</ul>\n</li>\n<li>테스트를 위해서 클래스 혹은 인터페이스의 멤버를 공개API로 변경하는 일은 없어야 한다.</li>\n<li><strong>public 클래스의 인스턴스 필드는 public으로 두지 말자</strong><ul>\n<li>가변 필드의 경우, 값을 제어 할 수 없을 뿐만 아니라 스레드 세이프 하지 않으므로 잠재적인 위험요소이다.</li>\n<li>상수 개념으로 사용한다면 공개해도 괜찮지만, 기본 타입의 값 혹은 불변 객체를 대상으로 하자</li>\n<li>길이가 0이 아닌 배열의 경우. 변경이 가능하니 주의하자.</li>\n</ul>\n<blockquote>\n<p>배열을 사용한다면 이를 수정 불가능한 리스트로 변경 후 공개하도록 하자</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PublicConstant</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Thing[] thingsArr = &#123; <span class=\"keyword\">new</span> Thing() &#125;;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;Thing&gt; thingsList = Collections.unmodifiableList(Arrays.asList(thingsArr));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>복사본을 만들어서 활용하는 방법도 있다.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PublicConstant</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Thing[] thingsArr = &#123; <span class=\"keyword\">new</span> Thing() &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Thing[] getThings() &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> thingsArr.clone();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ```  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## ITEM <span class=\"number\">16</span> - <span class=\"keyword\">public</span> 클래스에서는 <span class=\"keyword\">public</span> 필드가 아닌 접근자 메서드를 사용하라</span><br><span class=\"line\">&gt; <span class=\"keyword\">public</span> 클래스에서 절대 가변 필드를 노출 시키지 말자. 불변 필드를 노출시키는 것은 나쁘진 않지만 완전히 안심할 수 없는 일이다.</span><br><span class=\"line\"></span><br><span class=\"line\">* <span class=\"keyword\">public</span> 클래스의 필드가 <span class=\"keyword\">public</span>이면 이를 사용하는 클라이언트가 생길것이며, 이는 곧 내부 표현을 쉽게 변경할 수 없음을 뜻한다.</span><br><span class=\"line\">* 필드에 대한 직접 접근은 지양하고 **접근자**를 사용하자.</span><br><span class=\"line\">  ```java</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> y;</span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">double</span> y)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getX</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setX</span><span class=\"params\">(<span class=\"keyword\">double</span> x)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getY</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setY</span><span class=\"params\">(<span class=\"keyword\">double</span> y)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;  </span><br></pre></td></tr></table></figure></li>\n<li>public 클래스의 필드가 <strong>불변</strong>이면 노출 시 단점을 줄어들지만 여전히 좋은 생각은 아니다. API를 변경하지 않고는 표현 방식을 바꿀 수 없으며 필드를 읽을 때 부수 작업을 수행할 수 없다는 단점은 여전하다.</li>\n</ul>\n<h2 id=\"ITEM-16-public-클래스에서는-public-필드가-아닌-접근자-메서드를-사용하라\"><a href=\"#ITEM-16-public-클래스에서는-public-필드가-아닌-접근자-메서드를-사용하라\" class=\"headerlink\" title=\"ITEM 16 - public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라\"></a>ITEM 16 - public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라</h2><h3 id=\"불변-클래스란\"><a href=\"#불변-클래스란\" class=\"headerlink\" title=\"불변 클래스란?\"></a>불변 클래스란?</h3>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">double</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">double</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getX</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getY</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>내부 값을 수정 할 수 없는 클래스. 간직된 데이터는 객체가 파괴되는 순간까지 달라지지 않는다. 가변 클래스보다 설계 및 구현이 쉬우며 오류 발생 여지가 확실히 적다.</p>\n<h3 id=\"구현-규칙은\"><a href=\"#구현-규칙은\" class=\"headerlink\" title=\"구현 규칙은?\"></a>구현 규칙은?</h3><ul>\n<li>객체 상태를 변경하는 설정자 메서드를 제공하지 않음</li>\n<li>확장이 안되도록 한다.</li>\n<li>모든 필드는 private final로 선언한다.</li>\n<li>클래스 자신을 외에는 내부 구현에 접근하지 않도록 한다.</li>\n</ul>\n"},{"title":"Thread 관련 링크 정리","date":"2021-06-08T15:00:00.000Z","_content":"\n# Thread 관련 링크 정리\n\n- [An Introduction to JVM Threading Implementation](https://www.developer.com/design/an-introduction-to-jvm-threading-implementation/)\n- [유저 레벨 스레드 / 커널 레벨 스레드](https://genesis8.tistory.com/242)\n- [Green Thread vs Native Thread](https://perfectacle.github.io/2019/03/10/green-thread-vs-native-thread/)\n- [JVM Specification](https://docs.oracle.com/javase/specs/index.html)","source":"_posts/Java/THREAD.md","raw":"---\ntitle: Thread 관련 링크 정리\ndate: 2021/6/9 00:00:00\ncategories:\n- Java\n---\n\n# Thread 관련 링크 정리\n\n- [An Introduction to JVM Threading Implementation](https://www.developer.com/design/an-introduction-to-jvm-threading-implementation/)\n- [유저 레벨 스레드 / 커널 레벨 스레드](https://genesis8.tistory.com/242)\n- [Green Thread vs Native Thread](https://perfectacle.github.io/2019/03/10/green-thread-vs-native-thread/)\n- [JVM Specification](https://docs.oracle.com/javase/specs/index.html)","slug":"Java/THREAD","published":1,"updated":"2021-08-02T12:24:40.958Z","_id":"ckrsup509000ytjhv8lzwhbj7","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Thread-관련-링크-정리\"><a href=\"#Thread-관련-링크-정리\" class=\"headerlink\" title=\"Thread 관련 링크 정리\"></a>Thread 관련 링크 정리</h1><ul>\n<li><a href=\"https://www.developer.com/design/an-introduction-to-jvm-threading-implementation/\">An Introduction to JVM Threading Implementation</a></li>\n<li><a href=\"https://genesis8.tistory.com/242\">유저 레벨 스레드 / 커널 레벨 스레드</a></li>\n<li><a href=\"https://perfectacle.github.io/2019/03/10/green-thread-vs-native-thread/\">Green Thread vs Native Thread</a></li>\n<li><a href=\"https://docs.oracle.com/javase/specs/index.html\">JVM Specification</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Thread-관련-링크-정리\"><a href=\"#Thread-관련-링크-정리\" class=\"headerlink\" title=\"Thread 관련 링크 정리\"></a>Thread 관련 링크 정리</h1><ul>\n<li><a href=\"https://www.developer.com/design/an-introduction-to-jvm-threading-implementation/\">An Introduction to JVM Threading Implementation</a></li>\n<li><a href=\"https://genesis8.tistory.com/242\">유저 레벨 스레드 / 커널 레벨 스레드</a></li>\n<li><a href=\"https://perfectacle.github.io/2019/03/10/green-thread-vs-native-thread/\">Green Thread vs Native Thread</a></li>\n<li><a href=\"https://docs.oracle.com/javase/specs/index.html\">JVM Specification</a></li>\n</ul>\n"},{"title":"mapStruct","date":"2019-05-26T11:58:00.000Z","_content":"\n# mapStruct\n## Summary & Why?\n- 타입 세이프하게 bean 매핑을 도와주는 어노테이션 프로세서\n- 보통 JPA 기반의 어플리케이션을 개발하게 되면 만나게 되는 DTO 변환 작업은 대부분이 반복적인 작업이 대부분\n- ModelMapper와 같은 매핑 구현체가 존재하지만, ModelMapper의 경우 리플렉션 기반으로 동작하기도 하고 퍼포먼스에 대한 이슈가 많은편\n- 도메인 객체를 풍부하게 사용하면서, 반환 데이터가 달라지게 될 경우 이를 적절하고 큰 힘을 들이지 않고 매핑할 수 있도록 도와주는 것이 바로 mapStruct\n- *mapStruct 역시 메뉴얼에서 확인할 수 있듯이, 편하게 사용하려면 어느정도의 학습 기간을 거쳐야 편하게 사용할 수 있는듯하다.*\n\n## Simple Usage\n### 개발 환경\n- Kotlin 1.3.31\n- Spring BOOT 2.1.5 RELEASE(WEB, DATA-JPA)\n- H2\n\n\n```kotlin\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\nplugins {\n    val kotlinVersion = \"1.3.31\"\n    id(\"org.springframework.boot\") version \"2.1.5.RELEASE\"\n    id(\"io.spring.dependency-management\") version \"1.0.7.RELEASE\"\n    id(\"org.jetbrains.kotlin.jvm\") version kotlinVersion\n    id(\"org.jetbrains.kotlin.plugin.spring\") version kotlinVersion\n    id(\"org.jetbrains.kotlin.plugin.jpa\") version kotlinVersion\n    id(\"org.jetbrains.kotlin.kapt\") version kotlinVersion\n}\n\ngroup = \"me.daniel\"\nversion = \"0.0.1-SNAPSHOT\"\njava.sourceCompatibility = JavaVersion.VERSION_1_8\n\nrepositories {\n    mavenCentral()\n}\n\nnoArg {\n    annotation(\"javax.persistence.Entity\")\n    annotation(\"javax.persistence.MappedSuperclass\")\n    annotation(\"javax.persistence.Embeddable\")\n}\nallOpen {\n    annotation(\"javax.persistence.Entity\")\n    annotation(\"javax.persistence.MappedSuperclass\")\n    annotation(\"javax.persistence.Embeddable\")\n}\n\ndependencies {\n    implementation(\"org.springframework.boot:spring-boot-starter-data-jpa\")\n    implementation(\"org.springframework.boot:spring-boot-starter-web\")\n    implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin\")\n    implementation(\"org.jetbrains.kotlin:kotlin-reflect\")\n    implementation(\"org.jetbrains.kotlin:kotlin-stdlib-jdk8\")\n    runtimeOnly(\"com.h2database:h2\")\n    testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\n    // map-struct\n    // map-struct Annotation Processor\n    implementation(\"org.mapstruct:mapstruct:1.3.0.Final\")\n    kapt(\"org.mapstruct:mapstruct-processor:1.3.0.Final\")\n    kaptTest(\"org.mapstruct:mapstruct-processor:1.3.0.Final\")\n\n}\n\ntasks.withType<KotlinCompile> {\n    kotlinOptions {\n        freeCompilerArgs = listOf(\"-Xjsr305=strict\")\n        jvmTarget = \"1.8\"\n    }\n}\n```\n\n```kotlin\n@Mapper\ninterface UserMapper {\n    fun toUser(req: CreateDTO): User\n    fun fromUser(user: User): ResponseDTO\n}\n```\n- kapt를 활용하여 매퍼 클래스에 대응하는 Java 구현체를 생성해주는데, 도메인 객체와 DTO 객체간의 1:1 매핑을 지원하며, 1:1 매핑이 원활하게 되기 위해서는 Source 쪽의 타입 선언와 Target쪽의 타입 선언이 똑같아야 자연스럽게 매핑을 처리할 수 있다.\n\n\n```kotlin\n@Mapper\npublic interface AddressMapper {\n\n    @Mapping(source = \"person.description\", target = \"description\")\n    @Mapping(source = \"address.houseNo\", target = \"houseNumber\")\n    DeliveryAddressDto personAndAddressToDeliveryAddressDto(Person person, Address address);\n}\n```\n\n- 1:1 매핑이 아니라고 추가적인 매핑을 진행해야 하는 경우, 위와 같이 매핑에 대한 룰을 지정해주면 된다.\n\n```kotlin\n@Mapper(componentModel = \"spring\")\ninterface UserMapper {\n    @Mapping(source = \"roles\", target = \"_roles\", qualifiedByName = [\"toUserRole\"])\n    fun toUser(req: CreateDTO): User\n    fun fromUser(user: User): ResponseDTO\n\n    @Named(\"toUserRole\")\n    fun toUserRole(roles: List<UserRole.Role>) = roles.map {\n        UserRole().apply {\n            this.role = it\n        }\n    }\n}\n```\n- 추가적인 매핑말고도 조금 복잡한 매핑 룰이 필요한 경우 인터페이스의 `default` 메서드를 선언하여 이를 활용할 수 있다.(코틀린에서는 바로 method를 선언해두면 이게 default 메서드 역할을 수행해준다.) 이 때 사용하는 어노테이션이 바로 `@Named` 어노테이션으로 선언해놓은 값을 `qualifiedByName`에 매핑해주면 된다.\n\n- 생성한 매퍼에 대해 컴포넌트 모델을 지정 할 수 있다.\n  - default: 컴포넌트 모델을 생성하지 않으며, `Mappers#getMapper(Class)`로 선언해두었던 매퍼 인터페이스의 타입으로 객체를 가져올 수 있다.\n  - spring, jsr330: 컴포넌트 모델을 스프링 어플리케이션 컨텍스트에서 컴포넌트 스캔을 통하여 DI 받을 수 있다. 실제 선언해둔 코드 일부를 살펴보면 아래와 같다.\n  ![mapstruct-img](https://i.imgur.com/PrFkBbM.png)\n  - cdi\n\n## Tip & 사용 시 주의점\n- `source`측과 `target`측의 클래스 선언에서 기본 생성자가 반드시 선언되어 있어야 한다.\n- Kotlin, SpringBoot, Data-JPA와 함께 사용하게 될 경우, `kotlin-jpa` 플러그인을 활용하여 no-argument-consturctor에 대해 코드를 생성해주는 방식으로 기본 셋팅을 해놓고 진행하는데, 기본 생성자에 대해 바이트코드 레벨에서 Generation을 해주기 때문에 **결국 기본 생성자를 명시적으로 선언해줘야 하는 불편함이 존재하는거 같다.**\n```kotlin\n@Entity(name = \"T_USER\")\nclass User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    var id: Long = 0L\n\n    @Column(name = \"name\", length = 20)\n    var name: String = \"\"\n\n    @Column(name = \"email\", length = 100)\n    var email: String = \"\"\n\n    @Column(name = \"gender\", length = 10)\n    var gender: UserGender = UserGender.MALE\n\n    @OneToMany(mappedBy = \"user\", cascade = [CascadeType.ALL], fetch = FetchType.LAZY)\n    @BatchSize(size = 30)\n    var _roles: MutableList<UserRole> = mutableListOf()\n\n    @Column(name = \"foreigner\", length = 10)\n    var foreigner: Boolean = false\n\n    @CreatedDate\n    @Column(name = \"createdAt\", columnDefinition = \"DATETIME\")\n    var _createdAt: LocalDateTime = LocalDateTime.now()\n\n    @LastModifiedDate\n    @Column(name = \"updatedAt\", columnDefinition = \"DATETIME\")\n    var _updatedAt: LocalDateTime = LocalDateTime.now()\n\n    enum class UserGender {\n        MALE, FEMALE\n    }\n\n    constructor(name: String = \"\", email: String = \"\") {\n        this.name = name\n        this.email = email\n    }\n\n}\n```\n> 간단한 엔티티 코드 예제인데, 위 코드와 같이 별도의 생성자 선언을 안해두고 사용했을 경우 기본 생성자만 포함이 된다. 만약 별도의 생성자 선언이 필요한 경우 코드 가장 하단과 같이 필요한 선언을 해두면 되며 Kotlin의 Argument Default Value를 적극적으로 활용하여 필수 인자값과 그렇지 않은 값을 분리하는 전략을 취하는 것이 좋을거 같다.\n\n- 컬럼과 매핑되는 프로퍼티가 아닌 값을 매핑하게 될 경우가 생길 수 있는데, 이럴 때 사용하면 좋은 것이 Lazy Delegate이다. 관계 매핑에 사용되는 것이 아닌 해당 도메인 객체의 상태를 유연하게  유연하게 표현할 수 있으며 바인딩한 프로퍼티를 바로 mapStruct 바인딩으로 넘길 수 있어서 실제 예제 코드를 작성해보니 편리함을 느낄 수 있었다.\n```kotlin\nclass User {\n    ...생략...\n\n    @get:Transient\n    @delegate:Transient\n    val roles: MutableList<String> by lazy {\n        this._roles.map { it.role.name }.toMutableList()\n    }\n\n    @get:Transient\n    @delegate:Transient\n    val createdAt: LocalDateTime by lazy {\n        this._createdAt\n    }\n\n    @get:Transient\n    @delegate:Transient\n    val updatedAt: LocalDateTime by lazy {\n        this._updatedAt\n    }\n}\n\n```\n\n- Generation 해주는 코드는 기본적으로 세터 기반의 데이터 바인딩을 해주고 있는 것을 확인 할수 있는데,이를 빌더 기반으로 변경하는 것도 가능하다고 한다. 빌더 구현체로는 유명한 Lombok, AutoValue 등이 사용 가능하다고 메뉴얼에 명시되어 있다.\n  - [참고 링크](http://mapstruct.org/documentation/stable/reference/html/#mapping-with-builders)\n  - 하지만, 코틀린 기반으로 사용하게 될 경우 보통 lombok과 같은 빌더 구현을 대체 해주는 구현이 없어서 당분간은 세터 기반의 주입을 사용해야 될듯\n\n> 예제 코드는 [링크](https://github.com/thefeeling/spring-code/tree/develop/kotlin-spring-boot-mapstruct)를 통하여 확인 할 수 있습니다.","source":"_posts/Java/mapStruct.md","raw":"---\ntitle: mapStruct\ndate: 2019.5.26. 20:58:00\ncategories:\n- Java\n---\n\n# mapStruct\n## Summary & Why?\n- 타입 세이프하게 bean 매핑을 도와주는 어노테이션 프로세서\n- 보통 JPA 기반의 어플리케이션을 개발하게 되면 만나게 되는 DTO 변환 작업은 대부분이 반복적인 작업이 대부분\n- ModelMapper와 같은 매핑 구현체가 존재하지만, ModelMapper의 경우 리플렉션 기반으로 동작하기도 하고 퍼포먼스에 대한 이슈가 많은편\n- 도메인 객체를 풍부하게 사용하면서, 반환 데이터가 달라지게 될 경우 이를 적절하고 큰 힘을 들이지 않고 매핑할 수 있도록 도와주는 것이 바로 mapStruct\n- *mapStruct 역시 메뉴얼에서 확인할 수 있듯이, 편하게 사용하려면 어느정도의 학습 기간을 거쳐야 편하게 사용할 수 있는듯하다.*\n\n## Simple Usage\n### 개발 환경\n- Kotlin 1.3.31\n- Spring BOOT 2.1.5 RELEASE(WEB, DATA-JPA)\n- H2\n\n\n```kotlin\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\nplugins {\n    val kotlinVersion = \"1.3.31\"\n    id(\"org.springframework.boot\") version \"2.1.5.RELEASE\"\n    id(\"io.spring.dependency-management\") version \"1.0.7.RELEASE\"\n    id(\"org.jetbrains.kotlin.jvm\") version kotlinVersion\n    id(\"org.jetbrains.kotlin.plugin.spring\") version kotlinVersion\n    id(\"org.jetbrains.kotlin.plugin.jpa\") version kotlinVersion\n    id(\"org.jetbrains.kotlin.kapt\") version kotlinVersion\n}\n\ngroup = \"me.daniel\"\nversion = \"0.0.1-SNAPSHOT\"\njava.sourceCompatibility = JavaVersion.VERSION_1_8\n\nrepositories {\n    mavenCentral()\n}\n\nnoArg {\n    annotation(\"javax.persistence.Entity\")\n    annotation(\"javax.persistence.MappedSuperclass\")\n    annotation(\"javax.persistence.Embeddable\")\n}\nallOpen {\n    annotation(\"javax.persistence.Entity\")\n    annotation(\"javax.persistence.MappedSuperclass\")\n    annotation(\"javax.persistence.Embeddable\")\n}\n\ndependencies {\n    implementation(\"org.springframework.boot:spring-boot-starter-data-jpa\")\n    implementation(\"org.springframework.boot:spring-boot-starter-web\")\n    implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin\")\n    implementation(\"org.jetbrains.kotlin:kotlin-reflect\")\n    implementation(\"org.jetbrains.kotlin:kotlin-stdlib-jdk8\")\n    runtimeOnly(\"com.h2database:h2\")\n    testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\n    // map-struct\n    // map-struct Annotation Processor\n    implementation(\"org.mapstruct:mapstruct:1.3.0.Final\")\n    kapt(\"org.mapstruct:mapstruct-processor:1.3.0.Final\")\n    kaptTest(\"org.mapstruct:mapstruct-processor:1.3.0.Final\")\n\n}\n\ntasks.withType<KotlinCompile> {\n    kotlinOptions {\n        freeCompilerArgs = listOf(\"-Xjsr305=strict\")\n        jvmTarget = \"1.8\"\n    }\n}\n```\n\n```kotlin\n@Mapper\ninterface UserMapper {\n    fun toUser(req: CreateDTO): User\n    fun fromUser(user: User): ResponseDTO\n}\n```\n- kapt를 활용하여 매퍼 클래스에 대응하는 Java 구현체를 생성해주는데, 도메인 객체와 DTO 객체간의 1:1 매핑을 지원하며, 1:1 매핑이 원활하게 되기 위해서는 Source 쪽의 타입 선언와 Target쪽의 타입 선언이 똑같아야 자연스럽게 매핑을 처리할 수 있다.\n\n\n```kotlin\n@Mapper\npublic interface AddressMapper {\n\n    @Mapping(source = \"person.description\", target = \"description\")\n    @Mapping(source = \"address.houseNo\", target = \"houseNumber\")\n    DeliveryAddressDto personAndAddressToDeliveryAddressDto(Person person, Address address);\n}\n```\n\n- 1:1 매핑이 아니라고 추가적인 매핑을 진행해야 하는 경우, 위와 같이 매핑에 대한 룰을 지정해주면 된다.\n\n```kotlin\n@Mapper(componentModel = \"spring\")\ninterface UserMapper {\n    @Mapping(source = \"roles\", target = \"_roles\", qualifiedByName = [\"toUserRole\"])\n    fun toUser(req: CreateDTO): User\n    fun fromUser(user: User): ResponseDTO\n\n    @Named(\"toUserRole\")\n    fun toUserRole(roles: List<UserRole.Role>) = roles.map {\n        UserRole().apply {\n            this.role = it\n        }\n    }\n}\n```\n- 추가적인 매핑말고도 조금 복잡한 매핑 룰이 필요한 경우 인터페이스의 `default` 메서드를 선언하여 이를 활용할 수 있다.(코틀린에서는 바로 method를 선언해두면 이게 default 메서드 역할을 수행해준다.) 이 때 사용하는 어노테이션이 바로 `@Named` 어노테이션으로 선언해놓은 값을 `qualifiedByName`에 매핑해주면 된다.\n\n- 생성한 매퍼에 대해 컴포넌트 모델을 지정 할 수 있다.\n  - default: 컴포넌트 모델을 생성하지 않으며, `Mappers#getMapper(Class)`로 선언해두었던 매퍼 인터페이스의 타입으로 객체를 가져올 수 있다.\n  - spring, jsr330: 컴포넌트 모델을 스프링 어플리케이션 컨텍스트에서 컴포넌트 스캔을 통하여 DI 받을 수 있다. 실제 선언해둔 코드 일부를 살펴보면 아래와 같다.\n  ![mapstruct-img](https://i.imgur.com/PrFkBbM.png)\n  - cdi\n\n## Tip & 사용 시 주의점\n- `source`측과 `target`측의 클래스 선언에서 기본 생성자가 반드시 선언되어 있어야 한다.\n- Kotlin, SpringBoot, Data-JPA와 함께 사용하게 될 경우, `kotlin-jpa` 플러그인을 활용하여 no-argument-consturctor에 대해 코드를 생성해주는 방식으로 기본 셋팅을 해놓고 진행하는데, 기본 생성자에 대해 바이트코드 레벨에서 Generation을 해주기 때문에 **결국 기본 생성자를 명시적으로 선언해줘야 하는 불편함이 존재하는거 같다.**\n```kotlin\n@Entity(name = \"T_USER\")\nclass User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    var id: Long = 0L\n\n    @Column(name = \"name\", length = 20)\n    var name: String = \"\"\n\n    @Column(name = \"email\", length = 100)\n    var email: String = \"\"\n\n    @Column(name = \"gender\", length = 10)\n    var gender: UserGender = UserGender.MALE\n\n    @OneToMany(mappedBy = \"user\", cascade = [CascadeType.ALL], fetch = FetchType.LAZY)\n    @BatchSize(size = 30)\n    var _roles: MutableList<UserRole> = mutableListOf()\n\n    @Column(name = \"foreigner\", length = 10)\n    var foreigner: Boolean = false\n\n    @CreatedDate\n    @Column(name = \"createdAt\", columnDefinition = \"DATETIME\")\n    var _createdAt: LocalDateTime = LocalDateTime.now()\n\n    @LastModifiedDate\n    @Column(name = \"updatedAt\", columnDefinition = \"DATETIME\")\n    var _updatedAt: LocalDateTime = LocalDateTime.now()\n\n    enum class UserGender {\n        MALE, FEMALE\n    }\n\n    constructor(name: String = \"\", email: String = \"\") {\n        this.name = name\n        this.email = email\n    }\n\n}\n```\n> 간단한 엔티티 코드 예제인데, 위 코드와 같이 별도의 생성자 선언을 안해두고 사용했을 경우 기본 생성자만 포함이 된다. 만약 별도의 생성자 선언이 필요한 경우 코드 가장 하단과 같이 필요한 선언을 해두면 되며 Kotlin의 Argument Default Value를 적극적으로 활용하여 필수 인자값과 그렇지 않은 값을 분리하는 전략을 취하는 것이 좋을거 같다.\n\n- 컬럼과 매핑되는 프로퍼티가 아닌 값을 매핑하게 될 경우가 생길 수 있는데, 이럴 때 사용하면 좋은 것이 Lazy Delegate이다. 관계 매핑에 사용되는 것이 아닌 해당 도메인 객체의 상태를 유연하게  유연하게 표현할 수 있으며 바인딩한 프로퍼티를 바로 mapStruct 바인딩으로 넘길 수 있어서 실제 예제 코드를 작성해보니 편리함을 느낄 수 있었다.\n```kotlin\nclass User {\n    ...생략...\n\n    @get:Transient\n    @delegate:Transient\n    val roles: MutableList<String> by lazy {\n        this._roles.map { it.role.name }.toMutableList()\n    }\n\n    @get:Transient\n    @delegate:Transient\n    val createdAt: LocalDateTime by lazy {\n        this._createdAt\n    }\n\n    @get:Transient\n    @delegate:Transient\n    val updatedAt: LocalDateTime by lazy {\n        this._updatedAt\n    }\n}\n\n```\n\n- Generation 해주는 코드는 기본적으로 세터 기반의 데이터 바인딩을 해주고 있는 것을 확인 할수 있는데,이를 빌더 기반으로 변경하는 것도 가능하다고 한다. 빌더 구현체로는 유명한 Lombok, AutoValue 등이 사용 가능하다고 메뉴얼에 명시되어 있다.\n  - [참고 링크](http://mapstruct.org/documentation/stable/reference/html/#mapping-with-builders)\n  - 하지만, 코틀린 기반으로 사용하게 될 경우 보통 lombok과 같은 빌더 구현을 대체 해주는 구현이 없어서 당분간은 세터 기반의 주입을 사용해야 될듯\n\n> 예제 코드는 [링크](https://github.com/thefeeling/spring-code/tree/develop/kotlin-spring-boot-mapstruct)를 통하여 확인 할 수 있습니다.","slug":"Java/mapStruct","published":1,"updated":"2021-08-02T12:05:21.916Z","_id":"ckrsup50a000ztjhv4r4ph1q7","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"mapStruct\"><a href=\"#mapStruct\" class=\"headerlink\" title=\"mapStruct\"></a>mapStruct</h1><h2 id=\"Summary-amp-Why\"><a href=\"#Summary-amp-Why\" class=\"headerlink\" title=\"Summary &amp; Why?\"></a>Summary &amp; Why?</h2><ul>\n<li>타입 세이프하게 bean 매핑을 도와주는 어노테이션 프로세서</li>\n<li>보통 JPA 기반의 어플리케이션을 개발하게 되면 만나게 되는 DTO 변환 작업은 대부분이 반복적인 작업이 대부분</li>\n<li>ModelMapper와 같은 매핑 구현체가 존재하지만, ModelMapper의 경우 리플렉션 기반으로 동작하기도 하고 퍼포먼스에 대한 이슈가 많은편</li>\n<li>도메인 객체를 풍부하게 사용하면서, 반환 데이터가 달라지게 될 경우 이를 적절하고 큰 힘을 들이지 않고 매핑할 수 있도록 도와주는 것이 바로 mapStruct</li>\n<li><em>mapStruct 역시 메뉴얼에서 확인할 수 있듯이, 편하게 사용하려면 어느정도의 학습 기간을 거쳐야 편하게 사용할 수 있는듯하다.</em></li>\n</ul>\n<h2 id=\"Simple-Usage\"><a href=\"#Simple-Usage\" class=\"headerlink\" title=\"Simple Usage\"></a>Simple Usage</h2><h3 id=\"개발-환경\"><a href=\"#개발-환경\" class=\"headerlink\" title=\"개발 환경\"></a>개발 환경</h3><ul>\n<li>Kotlin 1.3.31</li>\n<li>Spring BOOT 2.1.5 RELEASE(WEB, DATA-JPA)</li>\n<li>H2</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.jetbrains.kotlin.gradle.tasks.KotlinCompile</span><br><span class=\"line\"></span><br><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> kotlinVersion = <span class=\"string\">&quot;1.3.31&quot;</span></span><br><span class=\"line\">    id(<span class=\"string\">&quot;org.springframework.boot&quot;</span>) version <span class=\"string\">&quot;2.1.5.RELEASE&quot;</span></span><br><span class=\"line\">    id(<span class=\"string\">&quot;io.spring.dependency-management&quot;</span>) version <span class=\"string\">&quot;1.0.7.RELEASE&quot;</span></span><br><span class=\"line\">    id(<span class=\"string\">&quot;org.jetbrains.kotlin.jvm&quot;</span>) version kotlinVersion</span><br><span class=\"line\">    id(<span class=\"string\">&quot;org.jetbrains.kotlin.plugin.spring&quot;</span>) version kotlinVersion</span><br><span class=\"line\">    id(<span class=\"string\">&quot;org.jetbrains.kotlin.plugin.jpa&quot;</span>) version kotlinVersion</span><br><span class=\"line\">    id(<span class=\"string\">&quot;org.jetbrains.kotlin.kapt&quot;</span>) version kotlinVersion</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">group = <span class=\"string\">&quot;me.daniel&quot;</span></span><br><span class=\"line\">version = <span class=\"string\">&quot;0.0.1-SNAPSHOT&quot;</span></span><br><span class=\"line\">java.sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class=\"line\"></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">noArg &#123;</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.Entity&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.MappedSuperclass&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.Embeddable&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">allOpen &#123;</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.Entity&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.MappedSuperclass&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.Embeddable&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation(<span class=\"string\">&quot;org.springframework.boot:spring-boot-starter-data-jpa&quot;</span>)</span><br><span class=\"line\">    implementation(<span class=\"string\">&quot;org.springframework.boot:spring-boot-starter-web&quot;</span>)</span><br><span class=\"line\">    implementation(<span class=\"string\">&quot;com.fasterxml.jackson.module:jackson-module-kotlin&quot;</span>)</span><br><span class=\"line\">    implementation(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-reflect&quot;</span>)</span><br><span class=\"line\">    implementation(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot;</span>)</span><br><span class=\"line\">    runtimeOnly(<span class=\"string\">&quot;com.h2database:h2&quot;</span>)</span><br><span class=\"line\">    testImplementation(<span class=\"string\">&quot;org.springframework.boot:spring-boot-starter-test&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// map-struct</span></span><br><span class=\"line\">    <span class=\"comment\">// map-struct Annotation Processor</span></span><br><span class=\"line\">    implementation(<span class=\"string\">&quot;org.mapstruct:mapstruct:1.3.0.Final&quot;</span>)</span><br><span class=\"line\">    kapt(<span class=\"string\">&quot;org.mapstruct:mapstruct-processor:1.3.0.Final&quot;</span>)</span><br><span class=\"line\">    kaptTest(<span class=\"string\">&quot;org.mapstruct:mapstruct-processor:1.3.0.Final&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">tasks.withType&lt;KotlinCompile&gt; &#123;</span><br><span class=\"line\">    kotlinOptions &#123;</span><br><span class=\"line\">        freeCompilerArgs = listOf(<span class=\"string\">&quot;-Xjsr305=strict&quot;</span>)</span><br><span class=\"line\">        jvmTarget = <span class=\"string\">&quot;1.8&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserMapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">toUser</span><span class=\"params\">(req: <span class=\"type\">CreateDTO</span>)</span></span>: User</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fromUser</span><span class=\"params\">(user: <span class=\"type\">User</span>)</span></span>: ResponseDTO</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>kapt를 활용하여 매퍼 클래스에 대응하는 Java 구현체를 생성해주는데, 도메인 객체와 DTO 객체간의 1:1 매핑을 지원하며, 1:1 매핑이 원활하게 되기 위해서는 Source 쪽의 타입 선언와 Target쪽의 타입 선언이 똑같아야 자연스럽게 매핑을 처리할 수 있다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AddressMapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Mapping(source = <span class=\"meta-string\">&quot;person.description&quot;</span>, target = <span class=\"meta-string\">&quot;description&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"meta\">@Mapping(source = <span class=\"meta-string\">&quot;address.houseNo&quot;</span>, target = <span class=\"meta-string\">&quot;houseNumber&quot;</span>)</span></span><br><span class=\"line\">    DeliveryAddressDto personAndAddressToDeliveryAddressDto(Person person, Address address);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1:1 매핑이 아니라고 추가적인 매핑을 진행해야 하는 경우, 위와 같이 매핑에 대한 룰을 지정해주면 된다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper(componentModel = <span class=\"meta-string\">&quot;spring&quot;</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserMapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Mapping(source = <span class=\"meta-string\">&quot;roles&quot;</span>, target = <span class=\"meta-string\">&quot;_roles&quot;</span>, qualifiedByName = [<span class=\"meta-string\">&quot;toUserRole&quot;</span>])</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">toUser</span><span class=\"params\">(req: <span class=\"type\">CreateDTO</span>)</span></span>: User</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fromUser</span><span class=\"params\">(user: <span class=\"type\">User</span>)</span></span>: ResponseDTO</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Named(<span class=\"meta-string\">&quot;toUserRole&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">toUserRole</span><span class=\"params\">(roles: <span class=\"type\">List</span>&lt;<span class=\"type\">UserRole</span>.<span class=\"type\">Role</span>&gt;)</span></span> = roles.map &#123;</span><br><span class=\"line\">        UserRole().apply &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.role = it</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>추가적인 매핑말고도 조금 복잡한 매핑 룰이 필요한 경우 인터페이스의 <code>default</code> 메서드를 선언하여 이를 활용할 수 있다.(코틀린에서는 바로 method를 선언해두면 이게 default 메서드 역할을 수행해준다.) 이 때 사용하는 어노테이션이 바로 <code>@Named</code> 어노테이션으로 선언해놓은 값을 <code>qualifiedByName</code>에 매핑해주면 된다.</p>\n</li>\n<li><p>생성한 매퍼에 대해 컴포넌트 모델을 지정 할 수 있다.</p>\n<ul>\n<li>default: 컴포넌트 모델을 생성하지 않으며, <code>Mappers#getMapper(Class)</code>로 선언해두었던 매퍼 인터페이스의 타입으로 객체를 가져올 수 있다.</li>\n<li>spring, jsr330: 컴포넌트 모델을 스프링 어플리케이션 컨텍스트에서 컴포넌트 스캔을 통하여 DI 받을 수 있다. 실제 선언해둔 코드 일부를 살펴보면 아래와 같다.<br><img src=\"https://i.imgur.com/PrFkBbM.png\" alt=\"mapstruct-img\"></li>\n<li>cdi</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Tip-amp-사용-시-주의점\"><a href=\"#Tip-amp-사용-시-주의점\" class=\"headerlink\" title=\"Tip &amp; 사용 시 주의점\"></a>Tip &amp; 사용 시 주의점</h2><ul>\n<li><p><code>source</code>측과 <code>target</code>측의 클래스 선언에서 기본 생성자가 반드시 선언되어 있어야 한다.</p>\n</li>\n<li><p>Kotlin, SpringBoot, Data-JPA와 함께 사용하게 될 경우, <code>kotlin-jpa</code> 플러그인을 활용하여 no-argument-consturctor에 대해 코드를 생성해주는 방식으로 기본 셋팅을 해놓고 진행하는데, 기본 생성자에 대해 바이트코드 레벨에서 Generation을 해주기 때문에 <strong>결국 기본 생성자를 명시적으로 선언해줘야 하는 불편함이 존재하는거 같다.</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity(name = <span class=\"meta-string\">&quot;T_USER&quot;</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> id: <span class=\"built_in\">Long</span> = <span class=\"number\">0L</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Column(name = <span class=\"meta-string\">&quot;name&quot;</span>, length = 20)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: String = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Column(name = <span class=\"meta-string\">&quot;email&quot;</span>, length = 100)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> email: String = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Column(name = <span class=\"meta-string\">&quot;gender&quot;</span>, length = 10)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> gender: UserGender = UserGender.MALE</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OneToMany(mappedBy = <span class=\"meta-string\">&quot;user&quot;</span>, cascade = [CascadeType.ALL], fetch = FetchType.LAZY)</span></span><br><span class=\"line\">    <span class=\"meta\">@BatchSize(size = 30)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> _roles: MutableList&lt;UserRole&gt; = mutableListOf()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Column(name = <span class=\"meta-string\">&quot;foreigner&quot;</span>, length = 10)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> foreigner: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@CreatedDate</span></span><br><span class=\"line\">    <span class=\"meta\">@Column(name = <span class=\"meta-string\">&quot;createdAt&quot;</span>, columnDefinition = <span class=\"meta-string\">&quot;DATETIME&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> _createdAt: LocalDateTime = LocalDateTime.now()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@LastModifiedDate</span></span><br><span class=\"line\">    <span class=\"meta\">@Column(name = <span class=\"meta-string\">&quot;updatedAt&quot;</span>, columnDefinition = <span class=\"meta-string\">&quot;DATETIME&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> _updatedAt: LocalDateTime = LocalDateTime.now()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserGender</span> </span>&#123;</span><br><span class=\"line\">        MALE, FEMALE</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name: String = <span class=\"string\">&quot;&quot;</span>, email: String = <span class=\"string\">&quot;&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.email = email</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>간단한 엔티티 코드 예제인데, 위 코드와 같이 별도의 생성자 선언을 안해두고 사용했을 경우 기본 생성자만 포함이 된다. 만약 별도의 생성자 선언이 필요한 경우 코드 가장 하단과 같이 필요한 선언을 해두면 되며 Kotlin의 Argument Default Value를 적극적으로 활용하여 필수 인자값과 그렇지 않은 값을 분리하는 전략을 취하는 것이 좋을거 같다.</p>\n</blockquote>\n</li>\n<li><p>컬럼과 매핑되는 프로퍼티가 아닌 값을 매핑하게 될 경우가 생길 수 있는데, 이럴 때 사용하면 좋은 것이 Lazy Delegate이다. 관계 매핑에 사용되는 것이 아닌 해당 도메인 객체의 상태를 유연하게  유연하게 표현할 수 있으며 바인딩한 프로퍼티를 바로 mapStruct 바인딩으로 넘길 수 있어서 실제 예제 코드를 작성해보니 편리함을 느낄 수 있었다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    ...생략...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@get:Transient</span></span><br><span class=\"line\">    <span class=\"meta\">@delegate:Transient</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> roles: MutableList&lt;String&gt; <span class=\"keyword\">by</span> lazy &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._roles.map &#123; it.role.name &#125;.toMutableList()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@get:Transient</span></span><br><span class=\"line\">    <span class=\"meta\">@delegate:Transient</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> createdAt: LocalDateTime <span class=\"keyword\">by</span> lazy &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._createdAt</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@get:Transient</span></span><br><span class=\"line\">    <span class=\"meta\">@delegate:Transient</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> updatedAt: LocalDateTime <span class=\"keyword\">by</span> lazy &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._updatedAt</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>Generation 해주는 코드는 기본적으로 세터 기반의 데이터 바인딩을 해주고 있는 것을 확인 할수 있는데,이를 빌더 기반으로 변경하는 것도 가능하다고 한다. 빌더 구현체로는 유명한 Lombok, AutoValue 등이 사용 가능하다고 메뉴얼에 명시되어 있다.</p>\n<ul>\n<li><a href=\"http://mapstruct.org/documentation/stable/reference/html/#mapping-with-builders\">참고 링크</a></li>\n<li>하지만, 코틀린 기반으로 사용하게 될 경우 보통 lombok과 같은 빌더 구현을 대체 해주는 구현이 없어서 당분간은 세터 기반의 주입을 사용해야 될듯</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>예제 코드는 <a href=\"https://github.com/thefeeling/spring-code/tree/develop/kotlin-spring-boot-mapstruct\">링크</a>를 통하여 확인 할 수 있습니다.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"mapStruct\"><a href=\"#mapStruct\" class=\"headerlink\" title=\"mapStruct\"></a>mapStruct</h1><h2 id=\"Summary-amp-Why\"><a href=\"#Summary-amp-Why\" class=\"headerlink\" title=\"Summary &amp; Why?\"></a>Summary &amp; Why?</h2><ul>\n<li>타입 세이프하게 bean 매핑을 도와주는 어노테이션 프로세서</li>\n<li>보통 JPA 기반의 어플리케이션을 개발하게 되면 만나게 되는 DTO 변환 작업은 대부분이 반복적인 작업이 대부분</li>\n<li>ModelMapper와 같은 매핑 구현체가 존재하지만, ModelMapper의 경우 리플렉션 기반으로 동작하기도 하고 퍼포먼스에 대한 이슈가 많은편</li>\n<li>도메인 객체를 풍부하게 사용하면서, 반환 데이터가 달라지게 될 경우 이를 적절하고 큰 힘을 들이지 않고 매핑할 수 있도록 도와주는 것이 바로 mapStruct</li>\n<li><em>mapStruct 역시 메뉴얼에서 확인할 수 있듯이, 편하게 사용하려면 어느정도의 학습 기간을 거쳐야 편하게 사용할 수 있는듯하다.</em></li>\n</ul>\n<h2 id=\"Simple-Usage\"><a href=\"#Simple-Usage\" class=\"headerlink\" title=\"Simple Usage\"></a>Simple Usage</h2><h3 id=\"개발-환경\"><a href=\"#개발-환경\" class=\"headerlink\" title=\"개발 환경\"></a>개발 환경</h3><ul>\n<li>Kotlin 1.3.31</li>\n<li>Spring BOOT 2.1.5 RELEASE(WEB, DATA-JPA)</li>\n<li>H2</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.jetbrains.kotlin.gradle.tasks.KotlinCompile</span><br><span class=\"line\"></span><br><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> kotlinVersion = <span class=\"string\">&quot;1.3.31&quot;</span></span><br><span class=\"line\">    id(<span class=\"string\">&quot;org.springframework.boot&quot;</span>) version <span class=\"string\">&quot;2.1.5.RELEASE&quot;</span></span><br><span class=\"line\">    id(<span class=\"string\">&quot;io.spring.dependency-management&quot;</span>) version <span class=\"string\">&quot;1.0.7.RELEASE&quot;</span></span><br><span class=\"line\">    id(<span class=\"string\">&quot;org.jetbrains.kotlin.jvm&quot;</span>) version kotlinVersion</span><br><span class=\"line\">    id(<span class=\"string\">&quot;org.jetbrains.kotlin.plugin.spring&quot;</span>) version kotlinVersion</span><br><span class=\"line\">    id(<span class=\"string\">&quot;org.jetbrains.kotlin.plugin.jpa&quot;</span>) version kotlinVersion</span><br><span class=\"line\">    id(<span class=\"string\">&quot;org.jetbrains.kotlin.kapt&quot;</span>) version kotlinVersion</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">group = <span class=\"string\">&quot;me.daniel&quot;</span></span><br><span class=\"line\">version = <span class=\"string\">&quot;0.0.1-SNAPSHOT&quot;</span></span><br><span class=\"line\">java.sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class=\"line\"></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">noArg &#123;</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.Entity&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.MappedSuperclass&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.Embeddable&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">allOpen &#123;</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.Entity&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.MappedSuperclass&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.Embeddable&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation(<span class=\"string\">&quot;org.springframework.boot:spring-boot-starter-data-jpa&quot;</span>)</span><br><span class=\"line\">    implementation(<span class=\"string\">&quot;org.springframework.boot:spring-boot-starter-web&quot;</span>)</span><br><span class=\"line\">    implementation(<span class=\"string\">&quot;com.fasterxml.jackson.module:jackson-module-kotlin&quot;</span>)</span><br><span class=\"line\">    implementation(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-reflect&quot;</span>)</span><br><span class=\"line\">    implementation(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot;</span>)</span><br><span class=\"line\">    runtimeOnly(<span class=\"string\">&quot;com.h2database:h2&quot;</span>)</span><br><span class=\"line\">    testImplementation(<span class=\"string\">&quot;org.springframework.boot:spring-boot-starter-test&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// map-struct</span></span><br><span class=\"line\">    <span class=\"comment\">// map-struct Annotation Processor</span></span><br><span class=\"line\">    implementation(<span class=\"string\">&quot;org.mapstruct:mapstruct:1.3.0.Final&quot;</span>)</span><br><span class=\"line\">    kapt(<span class=\"string\">&quot;org.mapstruct:mapstruct-processor:1.3.0.Final&quot;</span>)</span><br><span class=\"line\">    kaptTest(<span class=\"string\">&quot;org.mapstruct:mapstruct-processor:1.3.0.Final&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">tasks.withType&lt;KotlinCompile&gt; &#123;</span><br><span class=\"line\">    kotlinOptions &#123;</span><br><span class=\"line\">        freeCompilerArgs = listOf(<span class=\"string\">&quot;-Xjsr305=strict&quot;</span>)</span><br><span class=\"line\">        jvmTarget = <span class=\"string\">&quot;1.8&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserMapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">toUser</span><span class=\"params\">(req: <span class=\"type\">CreateDTO</span>)</span></span>: User</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fromUser</span><span class=\"params\">(user: <span class=\"type\">User</span>)</span></span>: ResponseDTO</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>kapt를 활용하여 매퍼 클래스에 대응하는 Java 구현체를 생성해주는데, 도메인 객체와 DTO 객체간의 1:1 매핑을 지원하며, 1:1 매핑이 원활하게 되기 위해서는 Source 쪽의 타입 선언와 Target쪽의 타입 선언이 똑같아야 자연스럽게 매핑을 처리할 수 있다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AddressMapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Mapping(source = <span class=\"meta-string\">&quot;person.description&quot;</span>, target = <span class=\"meta-string\">&quot;description&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"meta\">@Mapping(source = <span class=\"meta-string\">&quot;address.houseNo&quot;</span>, target = <span class=\"meta-string\">&quot;houseNumber&quot;</span>)</span></span><br><span class=\"line\">    DeliveryAddressDto personAndAddressToDeliveryAddressDto(Person person, Address address);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1:1 매핑이 아니라고 추가적인 매핑을 진행해야 하는 경우, 위와 같이 매핑에 대한 룰을 지정해주면 된다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper(componentModel = <span class=\"meta-string\">&quot;spring&quot;</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserMapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Mapping(source = <span class=\"meta-string\">&quot;roles&quot;</span>, target = <span class=\"meta-string\">&quot;_roles&quot;</span>, qualifiedByName = [<span class=\"meta-string\">&quot;toUserRole&quot;</span>])</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">toUser</span><span class=\"params\">(req: <span class=\"type\">CreateDTO</span>)</span></span>: User</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fromUser</span><span class=\"params\">(user: <span class=\"type\">User</span>)</span></span>: ResponseDTO</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Named(<span class=\"meta-string\">&quot;toUserRole&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">toUserRole</span><span class=\"params\">(roles: <span class=\"type\">List</span>&lt;<span class=\"type\">UserRole</span>.<span class=\"type\">Role</span>&gt;)</span></span> = roles.map &#123;</span><br><span class=\"line\">        UserRole().apply &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.role = it</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>추가적인 매핑말고도 조금 복잡한 매핑 룰이 필요한 경우 인터페이스의 <code>default</code> 메서드를 선언하여 이를 활용할 수 있다.(코틀린에서는 바로 method를 선언해두면 이게 default 메서드 역할을 수행해준다.) 이 때 사용하는 어노테이션이 바로 <code>@Named</code> 어노테이션으로 선언해놓은 값을 <code>qualifiedByName</code>에 매핑해주면 된다.</p>\n</li>\n<li><p>생성한 매퍼에 대해 컴포넌트 모델을 지정 할 수 있다.</p>\n<ul>\n<li>default: 컴포넌트 모델을 생성하지 않으며, <code>Mappers#getMapper(Class)</code>로 선언해두었던 매퍼 인터페이스의 타입으로 객체를 가져올 수 있다.</li>\n<li>spring, jsr330: 컴포넌트 모델을 스프링 어플리케이션 컨텍스트에서 컴포넌트 스캔을 통하여 DI 받을 수 있다. 실제 선언해둔 코드 일부를 살펴보면 아래와 같다.<br><img src=\"https://i.imgur.com/PrFkBbM.png\" alt=\"mapstruct-img\"></li>\n<li>cdi</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Tip-amp-사용-시-주의점\"><a href=\"#Tip-amp-사용-시-주의점\" class=\"headerlink\" title=\"Tip &amp; 사용 시 주의점\"></a>Tip &amp; 사용 시 주의점</h2><ul>\n<li><p><code>source</code>측과 <code>target</code>측의 클래스 선언에서 기본 생성자가 반드시 선언되어 있어야 한다.</p>\n</li>\n<li><p>Kotlin, SpringBoot, Data-JPA와 함께 사용하게 될 경우, <code>kotlin-jpa</code> 플러그인을 활용하여 no-argument-consturctor에 대해 코드를 생성해주는 방식으로 기본 셋팅을 해놓고 진행하는데, 기본 생성자에 대해 바이트코드 레벨에서 Generation을 해주기 때문에 <strong>결국 기본 생성자를 명시적으로 선언해줘야 하는 불편함이 존재하는거 같다.</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity(name = <span class=\"meta-string\">&quot;T_USER&quot;</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> id: <span class=\"built_in\">Long</span> = <span class=\"number\">0L</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Column(name = <span class=\"meta-string\">&quot;name&quot;</span>, length = 20)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: String = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Column(name = <span class=\"meta-string\">&quot;email&quot;</span>, length = 100)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> email: String = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Column(name = <span class=\"meta-string\">&quot;gender&quot;</span>, length = 10)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> gender: UserGender = UserGender.MALE</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OneToMany(mappedBy = <span class=\"meta-string\">&quot;user&quot;</span>, cascade = [CascadeType.ALL], fetch = FetchType.LAZY)</span></span><br><span class=\"line\">    <span class=\"meta\">@BatchSize(size = 30)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> _roles: MutableList&lt;UserRole&gt; = mutableListOf()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Column(name = <span class=\"meta-string\">&quot;foreigner&quot;</span>, length = 10)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> foreigner: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@CreatedDate</span></span><br><span class=\"line\">    <span class=\"meta\">@Column(name = <span class=\"meta-string\">&quot;createdAt&quot;</span>, columnDefinition = <span class=\"meta-string\">&quot;DATETIME&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> _createdAt: LocalDateTime = LocalDateTime.now()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@LastModifiedDate</span></span><br><span class=\"line\">    <span class=\"meta\">@Column(name = <span class=\"meta-string\">&quot;updatedAt&quot;</span>, columnDefinition = <span class=\"meta-string\">&quot;DATETIME&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> _updatedAt: LocalDateTime = LocalDateTime.now()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserGender</span> </span>&#123;</span><br><span class=\"line\">        MALE, FEMALE</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name: String = <span class=\"string\">&quot;&quot;</span>, email: String = <span class=\"string\">&quot;&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.email = email</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>간단한 엔티티 코드 예제인데, 위 코드와 같이 별도의 생성자 선언을 안해두고 사용했을 경우 기본 생성자만 포함이 된다. 만약 별도의 생성자 선언이 필요한 경우 코드 가장 하단과 같이 필요한 선언을 해두면 되며 Kotlin의 Argument Default Value를 적극적으로 활용하여 필수 인자값과 그렇지 않은 값을 분리하는 전략을 취하는 것이 좋을거 같다.</p>\n</blockquote>\n</li>\n<li><p>컬럼과 매핑되는 프로퍼티가 아닌 값을 매핑하게 될 경우가 생길 수 있는데, 이럴 때 사용하면 좋은 것이 Lazy Delegate이다. 관계 매핑에 사용되는 것이 아닌 해당 도메인 객체의 상태를 유연하게  유연하게 표현할 수 있으며 바인딩한 프로퍼티를 바로 mapStruct 바인딩으로 넘길 수 있어서 실제 예제 코드를 작성해보니 편리함을 느낄 수 있었다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    ...생략...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@get:Transient</span></span><br><span class=\"line\">    <span class=\"meta\">@delegate:Transient</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> roles: MutableList&lt;String&gt; <span class=\"keyword\">by</span> lazy &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._roles.map &#123; it.role.name &#125;.toMutableList()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@get:Transient</span></span><br><span class=\"line\">    <span class=\"meta\">@delegate:Transient</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> createdAt: LocalDateTime <span class=\"keyword\">by</span> lazy &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._createdAt</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@get:Transient</span></span><br><span class=\"line\">    <span class=\"meta\">@delegate:Transient</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> updatedAt: LocalDateTime <span class=\"keyword\">by</span> lazy &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._updatedAt</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>Generation 해주는 코드는 기본적으로 세터 기반의 데이터 바인딩을 해주고 있는 것을 확인 할수 있는데,이를 빌더 기반으로 변경하는 것도 가능하다고 한다. 빌더 구현체로는 유명한 Lombok, AutoValue 등이 사용 가능하다고 메뉴얼에 명시되어 있다.</p>\n<ul>\n<li><a href=\"http://mapstruct.org/documentation/stable/reference/html/#mapping-with-builders\">참고 링크</a></li>\n<li>하지만, 코틀린 기반으로 사용하게 될 경우 보통 lombok과 같은 빌더 구현을 대체 해주는 구현이 없어서 당분간은 세터 기반의 주입을 사용해야 될듯</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>예제 코드는 <a href=\"https://github.com/thefeeling/spring-code/tree/develop/kotlin-spring-boot-mapstruct\">링크</a>를 통하여 확인 할 수 있습니다.</p>\n</blockquote>\n"},{"title":"Best Practices for Spies, Stubs and Mocks in Sinon.js","date":"2016-07-11T15:00:00.000Z","_content":"\n# Best Practices for Spies, Stubs and Mocks in Sinon.js\n\n### Introduction\nAjax 호출, 네트워킹, 데이터베이스 혹은 다른 의존성(함수,모듈)와 관련된 코드를 테스트하는 것은 매우 어렵다. 만약 Ajax 호출이나 네트워킹 호출이 필요한 코드를 테스트한다면, 기본적으로 당신의 코드의 요청에 응답할 수 있는 서버가 필요하다. 마찬가지로 데이터베이스 관련 코드를 테스트할때도 테스트에 필요한 데이터를 셋팅하는 등 사전 작업이 필요하다.\n\n위에서 언급한 모든 것이 바로 테스트를 어렵게 하는 것들인데, 왜냐하면 테스트에 필요한 환경을 셋팅하는 등의 부수적인 작업이 필요하기 떄문이다.\n\n고맙게도 <code>Sinon.js</code>를 이용하면 이런 일련의 복잡한 작업을 피할 수 있으며, 우리는 단순히 이것의 좋은 특징을 사용하여 여러가지 번거로운 작업을 단순화할 수 있다.\n\n<code>Sinon.js</code>를 시작하는 것은 어렵지만, <code>Sinon.js</code>가 제공하고 호출하는 Spies, Stubs, Mocks 등을 이용하면 테스트에 필요한 상당한 기능성을 얻을 수 있다. 하지만, 이 세가지를 구분하고 선택하여 사용하는 것은 어려움이 존재한다. 아래 글을 통하여 SPY, STUB, MOCK의 차이점을 파악하고 최적의 사용 방법을 파악해보자.\n\n\n\n### 예제 코드\n```javascript\nfunction setupNewUser(info, callback) {\n  var user = {\n    name: info.name,\n    nameLowercase: info.name.toLowerCase()\n  };\n\n  try {\n    Database.save(user, callback);\n  }\n  catch(err) {\n    callback(err);\n  }\n}\n```\n\n위 함수는 두개의 인자를 받을 수 있다. 첫 번째 인자의 경우, 저장하고자 하는 데이터를 담은 객체이며 두 번째 인자의 경우 콜백 함수이다. 우리는 첫 번째 인자의 데이터를 <code>info</code> 객체에서 <code>user</code> 객체 변수로 할당할 것이며, 이를 저장하는 연산을 수행할 것이다.\n> <code>Database.save()</code>는 웹 환경이라면 ajax호출을 통한 통신이 될 수도 있으며, Node 관련 환경이라면 파일이나 데이터베이스에 직접 저장하는 코드가 될 수 있다. 예제 코드는 이런 상황을 가정하여 작성한 것이다.</code>\n\n\n### Spies, Stubs and Mocks\n**SPY, STUB** 그리고 **MOCK** 을 가리켜서 **테스트 더블(TEST DOUBLES)** 이라고 하며, 영화에서 스턴트 더블이 위험한 일을 하듯이, 우리는 **테스트 더블** 을 활용하여 문제가 되는 코드를 대체하여 테스트를 쉽게할 수 있다.\n\n\n### When Do You Need ***Test Doubles***?\n- Functions **without side effects**\n- Functions **with side effects**\n\n우리는 함수가 부정적인 영향이나 부작용을 가지고 있을 때, 테스트 더블을 이용한 테스트가 필요하다. 부작용을 가지고 있는 함수 뿐만 아니라, 경우에 따라서 외부 통신이나 연산이 필요한 함수(잠재적으로 테스트를 느려지게 할 수 있는 연산 모두를 포함한다.)에서도 테스트 더블을 이용한 테스트를 진행할 수 있다.\n\n다시 말해, 외부 환경과 관련이 있는 코드 혹은 함수 호출이 주된 테스트 더블의 대상이 되며 이를 가리켜 ***Functions with side effects*** 라고 표현한다.\n\n### When to Use SPY\n**SPY** 는 함수 호출과 관련된 정보를 얻는데에 사용된다.\n- **함수가 얼마나 많이 호출되었는지**\n- **어떤 인자가 함수로 전달되었는지**\n- **어떤 값이 리턴 되는지**\n- **어떤 예외가 발생하는지**\n\n가장 일반적인 시나리오는 바로 **함수 호출 횟수 및 어떤 인자를 함수에 넘겼는지에 관련된 부분이다.**\n\n\n**함수 호출 횟수** 는 <code>sinon.assert.callCount</code>, <code>sinon.assert.calledOnce</code>, <code>sinon.assert.notCalled</code> 등의 메소드를 활용하면 확인할 수 있다.\n```javascript\nit('should call save once', function() {\n  var save = sinon.spy(Database, 'save');\n\n  setupNewUser({ name: 'test' }, function() { });\n\n  save.restore();\n\n  // save 함수가 정확하게 한 번만 호출되었는지 확인.\n  // if spy was called once and only once.\n  sinon.assert.calledOnce(save);\n});\n```\n\n\n**함수에 어떤 인자를 넘겼는지 확인할 수 있다.** 확인은 <code>sinon.assert.calledWith</code> 매소드를 호출하거나, or <code>spy.lastCall</code> or <code>spy.getCall</code> 매소드 등을 통하여 직접 접근하여 확인할 수 있다.\n\n아래 예제는 <code>setupNewUser</code>에서 호출하는 <code>Database.save()</code>가 <code>expectedUser</code> 객체의 내용과 동일하게 인자를 넘기지는지 유무를 확인한다.\n```javascript\nit('should pass object with correct values to save', function() {\n  var save = sinon.spy(Database, 'save');\n  var info = { name: 'test' };\n  var expectedUser = {\n    name: info.name,\n    nameLowercase: info.name.toLowerCase()\n  };\n\n  setupNewUser(info, function() { });\n\n  save.restore();\n  sinon.assert.calledWith(save, expectedUser);\n});\n```\n\n\n### When to Use Stubs\nSPY 객체와 하는 일은 비슷하지만, STUB 객체는 함수(모듈/매소드)의 자체를 대체할 수 있다. 즉, 커스텀 행위를 수행할 수 있다는 뜻이다.(값을 리턴하거나 예외를 발생시키는 등) 또한, 주어진 인자를 통하여 콜백 함수를 호출할 수 있다. 즉, 테스트에 어려움이 많은 외부 종속적인 코드(네트워크, 데이터베이스 등)를 쉽게 테스트할 수 있는 것이다.\n\n- 문제가 될 수 있는 코드 블록을 대체할 수 있다.\n- 특정 코드 경로를 호출하는 경우(예외 발생 등).\n- 비동기 코드를 쉽게 테스트할 수 있다.\n\n**문제가 될 수 있는 코드 블록을 대체할 수 있다.**,\n테스트하기 어려운 코드(외부 환경에 종속적인 혹은 DB 혹은 네트워킹이 필요한)에 대하여 코드 블럭 대체를 통하여 테스트를 좀 더 쉽게 할 수 있도록 할 수 있다.\n```javascript\nit('should pass object with correct values to save', function() {\n  var save = sinon.stub(Database, 'save');\n  var info = { name: 'test' };\n  var expectedUser = {\n    name: info.name,\n    nameLowercase: info.name.toLowerCase()\n  };\n\n  setupNewUser(info, function() { });\n\n  save.restore();\n  sinon.assert.calledWith(save, expectedUser);\n});\n```\n\n**특정 코드 경로를 호출하는 경우(예외 발생 등).**\n우리가 테스트하고 있는 코드에서 만약 특정 함수를 호출하고 이 특정 함수가 만약 예외를 발생시킬 수도 있다. 이럴 경우 STUB 객체를 활용하여 예외를 발생시키는 코드를 쉽게 테스트할 수 있다.\n\n```javascript\nit('should pass the error into the callback if save fails', function() {\n  var expectedError = new Error('oops');\n  var save = sinon.stub(Database, 'save');\n  save.throws(expectedError);\n  var callback = sinon.spy();\n\n  setupNewUser({ name: 'foo' }, callback);\n\n  save.restore();\n  sinon.assert.calledWith(callback, expectedError);\n});\n```\n\n**비동기 코드를 쉽게 테스트할 수 있다.**\n만약 비동기 함수를 STUB 객체로 대체한다면, 이에 대한 호출과 동시에 바로 콜백을 실행시킬수도 있으며 또한 테스트 하기 어려운 비동기 코드를 동기 코드처럼 다룰 수 있게 한다.\n\n```javascript\nit('should pass the database result into the callback', function() {\n  var expectedResult = { success: true };\n  var save = sinon.stub(Database, 'save');\n  save.yields(null, expectedResult);\n  var callback = sinon.spy();\n\n  setupNewUser({ name: 'foo' }, callback);\n\n  save.restore();\n  sinon.assert.calledWith(callback, null, expectedResult);\n});\n```\n\n\n### When to Use Mocks\nMOCK 객체 사용 시 세심한 주의가 필요하다. **주의! MOCK 객체는 SPY 및 STUB 객체하는 하는 모든 일을 대체할 수 있는데, 이는 곧 테스트 자체를 복잡하게 만들거나 자칫하면 부서지기 쉬운(불안정한) 테스트 케이스를 만들어 낼 수 있다.**\n\nMOCK 객체는 STUB 객체를 사용할 때, 연쇄적인 액션이 필요한 경우 STUB 객체를 대신하여 사용할 떄 주요하다.\n\n```javascript\nit('should pass object with correct values to save only once', function() {\n  var info = { name: 'test' };\n  var expectedUser = {\n    name: info.name,\n    nameLowercase: info.name.toLowerCase()\n  };\n  var database = sinon.mock(Database);\n  database.expects('save').once().withArgs(expectedUser);\n\n  setupNewUser(info, function() { });\n\n  database.verify();\n  database.restore();\n});\n```\n\n\n### 참고\n- [Sinon.JS](http://sinonjs.org/docs/)\n","source":"_posts/JavaScript/BestPracticesforSpiesStubsAndMocksinSinon.js.md","raw":"---\ntitle: Best Practices for Spies, Stubs and Mocks in Sinon.js\ndate: 2016/7/12 00:00:00\ncategories:\n- JavaScript\n---\n\n# Best Practices for Spies, Stubs and Mocks in Sinon.js\n\n### Introduction\nAjax 호출, 네트워킹, 데이터베이스 혹은 다른 의존성(함수,모듈)와 관련된 코드를 테스트하는 것은 매우 어렵다. 만약 Ajax 호출이나 네트워킹 호출이 필요한 코드를 테스트한다면, 기본적으로 당신의 코드의 요청에 응답할 수 있는 서버가 필요하다. 마찬가지로 데이터베이스 관련 코드를 테스트할때도 테스트에 필요한 데이터를 셋팅하는 등 사전 작업이 필요하다.\n\n위에서 언급한 모든 것이 바로 테스트를 어렵게 하는 것들인데, 왜냐하면 테스트에 필요한 환경을 셋팅하는 등의 부수적인 작업이 필요하기 떄문이다.\n\n고맙게도 <code>Sinon.js</code>를 이용하면 이런 일련의 복잡한 작업을 피할 수 있으며, 우리는 단순히 이것의 좋은 특징을 사용하여 여러가지 번거로운 작업을 단순화할 수 있다.\n\n<code>Sinon.js</code>를 시작하는 것은 어렵지만, <code>Sinon.js</code>가 제공하고 호출하는 Spies, Stubs, Mocks 등을 이용하면 테스트에 필요한 상당한 기능성을 얻을 수 있다. 하지만, 이 세가지를 구분하고 선택하여 사용하는 것은 어려움이 존재한다. 아래 글을 통하여 SPY, STUB, MOCK의 차이점을 파악하고 최적의 사용 방법을 파악해보자.\n\n\n\n### 예제 코드\n```javascript\nfunction setupNewUser(info, callback) {\n  var user = {\n    name: info.name,\n    nameLowercase: info.name.toLowerCase()\n  };\n\n  try {\n    Database.save(user, callback);\n  }\n  catch(err) {\n    callback(err);\n  }\n}\n```\n\n위 함수는 두개의 인자를 받을 수 있다. 첫 번째 인자의 경우, 저장하고자 하는 데이터를 담은 객체이며 두 번째 인자의 경우 콜백 함수이다. 우리는 첫 번째 인자의 데이터를 <code>info</code> 객체에서 <code>user</code> 객체 변수로 할당할 것이며, 이를 저장하는 연산을 수행할 것이다.\n> <code>Database.save()</code>는 웹 환경이라면 ajax호출을 통한 통신이 될 수도 있으며, Node 관련 환경이라면 파일이나 데이터베이스에 직접 저장하는 코드가 될 수 있다. 예제 코드는 이런 상황을 가정하여 작성한 것이다.</code>\n\n\n### Spies, Stubs and Mocks\n**SPY, STUB** 그리고 **MOCK** 을 가리켜서 **테스트 더블(TEST DOUBLES)** 이라고 하며, 영화에서 스턴트 더블이 위험한 일을 하듯이, 우리는 **테스트 더블** 을 활용하여 문제가 되는 코드를 대체하여 테스트를 쉽게할 수 있다.\n\n\n### When Do You Need ***Test Doubles***?\n- Functions **without side effects**\n- Functions **with side effects**\n\n우리는 함수가 부정적인 영향이나 부작용을 가지고 있을 때, 테스트 더블을 이용한 테스트가 필요하다. 부작용을 가지고 있는 함수 뿐만 아니라, 경우에 따라서 외부 통신이나 연산이 필요한 함수(잠재적으로 테스트를 느려지게 할 수 있는 연산 모두를 포함한다.)에서도 테스트 더블을 이용한 테스트를 진행할 수 있다.\n\n다시 말해, 외부 환경과 관련이 있는 코드 혹은 함수 호출이 주된 테스트 더블의 대상이 되며 이를 가리켜 ***Functions with side effects*** 라고 표현한다.\n\n### When to Use SPY\n**SPY** 는 함수 호출과 관련된 정보를 얻는데에 사용된다.\n- **함수가 얼마나 많이 호출되었는지**\n- **어떤 인자가 함수로 전달되었는지**\n- **어떤 값이 리턴 되는지**\n- **어떤 예외가 발생하는지**\n\n가장 일반적인 시나리오는 바로 **함수 호출 횟수 및 어떤 인자를 함수에 넘겼는지에 관련된 부분이다.**\n\n\n**함수 호출 횟수** 는 <code>sinon.assert.callCount</code>, <code>sinon.assert.calledOnce</code>, <code>sinon.assert.notCalled</code> 등의 메소드를 활용하면 확인할 수 있다.\n```javascript\nit('should call save once', function() {\n  var save = sinon.spy(Database, 'save');\n\n  setupNewUser({ name: 'test' }, function() { });\n\n  save.restore();\n\n  // save 함수가 정확하게 한 번만 호출되었는지 확인.\n  // if spy was called once and only once.\n  sinon.assert.calledOnce(save);\n});\n```\n\n\n**함수에 어떤 인자를 넘겼는지 확인할 수 있다.** 확인은 <code>sinon.assert.calledWith</code> 매소드를 호출하거나, or <code>spy.lastCall</code> or <code>spy.getCall</code> 매소드 등을 통하여 직접 접근하여 확인할 수 있다.\n\n아래 예제는 <code>setupNewUser</code>에서 호출하는 <code>Database.save()</code>가 <code>expectedUser</code> 객체의 내용과 동일하게 인자를 넘기지는지 유무를 확인한다.\n```javascript\nit('should pass object with correct values to save', function() {\n  var save = sinon.spy(Database, 'save');\n  var info = { name: 'test' };\n  var expectedUser = {\n    name: info.name,\n    nameLowercase: info.name.toLowerCase()\n  };\n\n  setupNewUser(info, function() { });\n\n  save.restore();\n  sinon.assert.calledWith(save, expectedUser);\n});\n```\n\n\n### When to Use Stubs\nSPY 객체와 하는 일은 비슷하지만, STUB 객체는 함수(모듈/매소드)의 자체를 대체할 수 있다. 즉, 커스텀 행위를 수행할 수 있다는 뜻이다.(값을 리턴하거나 예외를 발생시키는 등) 또한, 주어진 인자를 통하여 콜백 함수를 호출할 수 있다. 즉, 테스트에 어려움이 많은 외부 종속적인 코드(네트워크, 데이터베이스 등)를 쉽게 테스트할 수 있는 것이다.\n\n- 문제가 될 수 있는 코드 블록을 대체할 수 있다.\n- 특정 코드 경로를 호출하는 경우(예외 발생 등).\n- 비동기 코드를 쉽게 테스트할 수 있다.\n\n**문제가 될 수 있는 코드 블록을 대체할 수 있다.**,\n테스트하기 어려운 코드(외부 환경에 종속적인 혹은 DB 혹은 네트워킹이 필요한)에 대하여 코드 블럭 대체를 통하여 테스트를 좀 더 쉽게 할 수 있도록 할 수 있다.\n```javascript\nit('should pass object with correct values to save', function() {\n  var save = sinon.stub(Database, 'save');\n  var info = { name: 'test' };\n  var expectedUser = {\n    name: info.name,\n    nameLowercase: info.name.toLowerCase()\n  };\n\n  setupNewUser(info, function() { });\n\n  save.restore();\n  sinon.assert.calledWith(save, expectedUser);\n});\n```\n\n**특정 코드 경로를 호출하는 경우(예외 발생 등).**\n우리가 테스트하고 있는 코드에서 만약 특정 함수를 호출하고 이 특정 함수가 만약 예외를 발생시킬 수도 있다. 이럴 경우 STUB 객체를 활용하여 예외를 발생시키는 코드를 쉽게 테스트할 수 있다.\n\n```javascript\nit('should pass the error into the callback if save fails', function() {\n  var expectedError = new Error('oops');\n  var save = sinon.stub(Database, 'save');\n  save.throws(expectedError);\n  var callback = sinon.spy();\n\n  setupNewUser({ name: 'foo' }, callback);\n\n  save.restore();\n  sinon.assert.calledWith(callback, expectedError);\n});\n```\n\n**비동기 코드를 쉽게 테스트할 수 있다.**\n만약 비동기 함수를 STUB 객체로 대체한다면, 이에 대한 호출과 동시에 바로 콜백을 실행시킬수도 있으며 또한 테스트 하기 어려운 비동기 코드를 동기 코드처럼 다룰 수 있게 한다.\n\n```javascript\nit('should pass the database result into the callback', function() {\n  var expectedResult = { success: true };\n  var save = sinon.stub(Database, 'save');\n  save.yields(null, expectedResult);\n  var callback = sinon.spy();\n\n  setupNewUser({ name: 'foo' }, callback);\n\n  save.restore();\n  sinon.assert.calledWith(callback, null, expectedResult);\n});\n```\n\n\n### When to Use Mocks\nMOCK 객체 사용 시 세심한 주의가 필요하다. **주의! MOCK 객체는 SPY 및 STUB 객체하는 하는 모든 일을 대체할 수 있는데, 이는 곧 테스트 자체를 복잡하게 만들거나 자칫하면 부서지기 쉬운(불안정한) 테스트 케이스를 만들어 낼 수 있다.**\n\nMOCK 객체는 STUB 객체를 사용할 때, 연쇄적인 액션이 필요한 경우 STUB 객체를 대신하여 사용할 떄 주요하다.\n\n```javascript\nit('should pass object with correct values to save only once', function() {\n  var info = { name: 'test' };\n  var expectedUser = {\n    name: info.name,\n    nameLowercase: info.name.toLowerCase()\n  };\n  var database = sinon.mock(Database);\n  database.expects('save').once().withArgs(expectedUser);\n\n  setupNewUser(info, function() { });\n\n  database.verify();\n  database.restore();\n});\n```\n\n\n### 참고\n- [Sinon.JS](http://sinonjs.org/docs/)\n","slug":"JavaScript/BestPracticesforSpiesStubsAndMocksinSinon.js","published":1,"updated":"2021-08-02T12:28:07.137Z","_id":"ckrsup50a0010tjhvgj4lcf06","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Best-Practices-for-Spies-Stubs-and-Mocks-in-Sinon-js\"><a href=\"#Best-Practices-for-Spies-Stubs-and-Mocks-in-Sinon-js\" class=\"headerlink\" title=\"Best Practices for Spies, Stubs and Mocks in Sinon.js\"></a>Best Practices for Spies, Stubs and Mocks in Sinon.js</h1><h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>Ajax 호출, 네트워킹, 데이터베이스 혹은 다른 의존성(함수,모듈)와 관련된 코드를 테스트하는 것은 매우 어렵다. 만약 Ajax 호출이나 네트워킹 호출이 필요한 코드를 테스트한다면, 기본적으로 당신의 코드의 요청에 응답할 수 있는 서버가 필요하다. 마찬가지로 데이터베이스 관련 코드를 테스트할때도 테스트에 필요한 데이터를 셋팅하는 등 사전 작업이 필요하다.</p>\n<p>위에서 언급한 모든 것이 바로 테스트를 어렵게 하는 것들인데, 왜냐하면 테스트에 필요한 환경을 셋팅하는 등의 부수적인 작업이 필요하기 떄문이다.</p>\n<p>고맙게도 <code>Sinon.js</code>를 이용하면 이런 일련의 복잡한 작업을 피할 수 있으며, 우리는 단순히 이것의 좋은 특징을 사용하여 여러가지 번거로운 작업을 단순화할 수 있다.</p>\n<p><code>Sinon.js</code>를 시작하는 것은 어렵지만, <code>Sinon.js</code>가 제공하고 호출하는 Spies, Stubs, Mocks 등을 이용하면 테스트에 필요한 상당한 기능성을 얻을 수 있다. 하지만, 이 세가지를 구분하고 선택하여 사용하는 것은 어려움이 존재한다. 아래 글을 통하여 SPY, STUB, MOCK의 차이점을 파악하고 최적의 사용 방법을 파악해보자.</p>\n<h3 id=\"예제-코드\"><a href=\"#예제-코드\" class=\"headerlink\" title=\"예제 코드\"></a>예제 코드</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setupNewUser</span>(<span class=\"params\">info, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> user = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: info.name,</span><br><span class=\"line\">    <span class=\"attr\">nameLowercase</span>: info.name.toLowerCase()</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Database.save(user, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">catch</span>(err) &#123;</span><br><span class=\"line\">    callback(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위 함수는 두개의 인자를 받을 수 있다. 첫 번째 인자의 경우, 저장하고자 하는 데이터를 담은 객체이며 두 번째 인자의 경우 콜백 함수이다. 우리는 첫 번째 인자의 데이터를 <code>info</code> 객체에서 <code>user</code> 객체 변수로 할당할 것이며, 이를 저장하는 연산을 수행할 것이다.</p>\n<blockquote>\n<p><code>Database.save()</code>는 웹 환경이라면 ajax호출을 통한 통신이 될 수도 있으며, Node 관련 환경이라면 파일이나 데이터베이스에 직접 저장하는 코드가 될 수 있다. 예제 코드는 이런 상황을 가정하여 작성한 것이다.</code></p>\n</blockquote>\n<h3 id=\"Spies-Stubs-and-Mocks\"><a href=\"#Spies-Stubs-and-Mocks\" class=\"headerlink\" title=\"Spies, Stubs and Mocks\"></a>Spies, Stubs and Mocks</h3><p><strong>SPY, STUB</strong> 그리고 <strong>MOCK</strong> 을 가리켜서 <strong>테스트 더블(TEST DOUBLES)</strong> 이라고 하며, 영화에서 스턴트 더블이 위험한 일을 하듯이, 우리는 <strong>테스트 더블</strong> 을 활용하여 문제가 되는 코드를 대체하여 테스트를 쉽게할 수 있다.</p>\n<h3 id=\"When-Do-You-Need-Test-Doubles\"><a href=\"#When-Do-You-Need-Test-Doubles\" class=\"headerlink\" title=\"When Do You Need Test Doubles?\"></a>When Do You Need <em><strong>Test Doubles</strong></em>?</h3><ul>\n<li>Functions <strong>without side effects</strong></li>\n<li>Functions <strong>with side effects</strong></li>\n</ul>\n<p>우리는 함수가 부정적인 영향이나 부작용을 가지고 있을 때, 테스트 더블을 이용한 테스트가 필요하다. 부작용을 가지고 있는 함수 뿐만 아니라, 경우에 따라서 외부 통신이나 연산이 필요한 함수(잠재적으로 테스트를 느려지게 할 수 있는 연산 모두를 포함한다.)에서도 테스트 더블을 이용한 테스트를 진행할 수 있다.</p>\n<p>다시 말해, 외부 환경과 관련이 있는 코드 혹은 함수 호출이 주된 테스트 더블의 대상이 되며 이를 가리켜 <em><strong>Functions with side effects</strong></em> 라고 표현한다.</p>\n<h3 id=\"When-to-Use-SPY\"><a href=\"#When-to-Use-SPY\" class=\"headerlink\" title=\"When to Use SPY\"></a>When to Use SPY</h3><p><strong>SPY</strong> 는 함수 호출과 관련된 정보를 얻는데에 사용된다.</p>\n<ul>\n<li><strong>함수가 얼마나 많이 호출되었는지</strong></li>\n<li><strong>어떤 인자가 함수로 전달되었는지</strong></li>\n<li><strong>어떤 값이 리턴 되는지</strong></li>\n<li><strong>어떤 예외가 발생하는지</strong></li>\n</ul>\n<p>가장 일반적인 시나리오는 바로 <strong>함수 호출 횟수 및 어떤 인자를 함수에 넘겼는지에 관련된 부분이다.</strong></p>\n<p><strong>함수 호출 횟수</strong> 는 <code>sinon.assert.callCount</code>, <code>sinon.assert.calledOnce</code>, <code>sinon.assert.notCalled</code> 등의 메소드를 활용하면 확인할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">&#x27;should call save once&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> save = sinon.spy(Database, <span class=\"string\">&#x27;save&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  setupNewUser(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;test&#x27;</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  save.restore();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// save 함수가 정확하게 한 번만 호출되었는지 확인.</span></span><br><span class=\"line\">  <span class=\"comment\">// if spy was called once and only once.</span></span><br><span class=\"line\">  sinon.assert.calledOnce(save);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>함수에 어떤 인자를 넘겼는지 확인할 수 있다.</strong> 확인은 <code>sinon.assert.calledWith</code> 매소드를 호출하거나, or <code>spy.lastCall</code> or <code>spy.getCall</code> 매소드 등을 통하여 직접 접근하여 확인할 수 있다.</p>\n<p>아래 예제는 <code>setupNewUser</code>에서 호출하는 <code>Database.save()</code>가 <code>expectedUser</code> 객체의 내용과 동일하게 인자를 넘기지는지 유무를 확인한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">&#x27;should pass object with correct values to save&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> save = sinon.spy(Database, <span class=\"string\">&#x27;save&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> info = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;test&#x27;</span> &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> expectedUser = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: info.name,</span><br><span class=\"line\">    <span class=\"attr\">nameLowercase</span>: info.name.toLowerCase()</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  setupNewUser(info, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  save.restore();</span><br><span class=\"line\">  sinon.assert.calledWith(save, expectedUser);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"When-to-Use-Stubs\"><a href=\"#When-to-Use-Stubs\" class=\"headerlink\" title=\"When to Use Stubs\"></a>When to Use Stubs</h3><p>SPY 객체와 하는 일은 비슷하지만, STUB 객체는 함수(모듈/매소드)의 자체를 대체할 수 있다. 즉, 커스텀 행위를 수행할 수 있다는 뜻이다.(값을 리턴하거나 예외를 발생시키는 등) 또한, 주어진 인자를 통하여 콜백 함수를 호출할 수 있다. 즉, 테스트에 어려움이 많은 외부 종속적인 코드(네트워크, 데이터베이스 등)를 쉽게 테스트할 수 있는 것이다.</p>\n<ul>\n<li>문제가 될 수 있는 코드 블록을 대체할 수 있다.</li>\n<li>특정 코드 경로를 호출하는 경우(예외 발생 등).</li>\n<li>비동기 코드를 쉽게 테스트할 수 있다.</li>\n</ul>\n<p><strong>문제가 될 수 있는 코드 블록을 대체할 수 있다.</strong>,<br>테스트하기 어려운 코드(외부 환경에 종속적인 혹은 DB 혹은 네트워킹이 필요한)에 대하여 코드 블럭 대체를 통하여 테스트를 좀 더 쉽게 할 수 있도록 할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">&#x27;should pass object with correct values to save&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> save = sinon.stub(Database, <span class=\"string\">&#x27;save&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> info = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;test&#x27;</span> &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> expectedUser = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: info.name,</span><br><span class=\"line\">    <span class=\"attr\">nameLowercase</span>: info.name.toLowerCase()</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  setupNewUser(info, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  save.restore();</span><br><span class=\"line\">  sinon.assert.calledWith(save, expectedUser);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>특정 코드 경로를 호출하는 경우(예외 발생 등).</strong><br>우리가 테스트하고 있는 코드에서 만약 특정 함수를 호출하고 이 특정 함수가 만약 예외를 발생시킬 수도 있다. 이럴 경우 STUB 객체를 활용하여 예외를 발생시키는 코드를 쉽게 테스트할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">&#x27;should pass the error into the callback if save fails&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> expectedError = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;oops&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> save = sinon.stub(Database, <span class=\"string\">&#x27;save&#x27;</span>);</span><br><span class=\"line\">  save.throws(expectedError);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> callback = sinon.spy();</span><br><span class=\"line\"></span><br><span class=\"line\">  setupNewUser(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;foo&#x27;</span> &#125;, callback);</span><br><span class=\"line\"></span><br><span class=\"line\">  save.restore();</span><br><span class=\"line\">  sinon.assert.calledWith(callback, expectedError);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>비동기 코드를 쉽게 테스트할 수 있다.</strong><br>만약 비동기 함수를 STUB 객체로 대체한다면, 이에 대한 호출과 동시에 바로 콜백을 실행시킬수도 있으며 또한 테스트 하기 어려운 비동기 코드를 동기 코드처럼 다룰 수 있게 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">&#x27;should pass the database result into the callback&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> expectedResult = &#123; <span class=\"attr\">success</span>: <span class=\"literal\">true</span> &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> save = sinon.stub(Database, <span class=\"string\">&#x27;save&#x27;</span>);</span><br><span class=\"line\">  save.yields(<span class=\"literal\">null</span>, expectedResult);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> callback = sinon.spy();</span><br><span class=\"line\"></span><br><span class=\"line\">  setupNewUser(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;foo&#x27;</span> &#125;, callback);</span><br><span class=\"line\"></span><br><span class=\"line\">  save.restore();</span><br><span class=\"line\">  sinon.assert.calledWith(callback, <span class=\"literal\">null</span>, expectedResult);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"When-to-Use-Mocks\"><a href=\"#When-to-Use-Mocks\" class=\"headerlink\" title=\"When to Use Mocks\"></a>When to Use Mocks</h3><p>MOCK 객체 사용 시 세심한 주의가 필요하다. <strong>주의! MOCK 객체는 SPY 및 STUB 객체하는 하는 모든 일을 대체할 수 있는데, 이는 곧 테스트 자체를 복잡하게 만들거나 자칫하면 부서지기 쉬운(불안정한) 테스트 케이스를 만들어 낼 수 있다.</strong></p>\n<p>MOCK 객체는 STUB 객체를 사용할 때, 연쇄적인 액션이 필요한 경우 STUB 객체를 대신하여 사용할 떄 주요하다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">&#x27;should pass object with correct values to save only once&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> info = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;test&#x27;</span> &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> expectedUser = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: info.name,</span><br><span class=\"line\">    <span class=\"attr\">nameLowercase</span>: info.name.toLowerCase()</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> database = sinon.mock(Database);</span><br><span class=\"line\">  database.expects(<span class=\"string\">&#x27;save&#x27;</span>).once().withArgs(expectedUser);</span><br><span class=\"line\"></span><br><span class=\"line\">  setupNewUser(info, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  database.verify();</span><br><span class=\"line\">  database.restore();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h3><ul>\n<li><a href=\"http://sinonjs.org/docs/\">Sinon.JS</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Best-Practices-for-Spies-Stubs-and-Mocks-in-Sinon-js\"><a href=\"#Best-Practices-for-Spies-Stubs-and-Mocks-in-Sinon-js\" class=\"headerlink\" title=\"Best Practices for Spies, Stubs and Mocks in Sinon.js\"></a>Best Practices for Spies, Stubs and Mocks in Sinon.js</h1><h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>Ajax 호출, 네트워킹, 데이터베이스 혹은 다른 의존성(함수,모듈)와 관련된 코드를 테스트하는 것은 매우 어렵다. 만약 Ajax 호출이나 네트워킹 호출이 필요한 코드를 테스트한다면, 기본적으로 당신의 코드의 요청에 응답할 수 있는 서버가 필요하다. 마찬가지로 데이터베이스 관련 코드를 테스트할때도 테스트에 필요한 데이터를 셋팅하는 등 사전 작업이 필요하다.</p>\n<p>위에서 언급한 모든 것이 바로 테스트를 어렵게 하는 것들인데, 왜냐하면 테스트에 필요한 환경을 셋팅하는 등의 부수적인 작업이 필요하기 떄문이다.</p>\n<p>고맙게도 <code>Sinon.js</code>를 이용하면 이런 일련의 복잡한 작업을 피할 수 있으며, 우리는 단순히 이것의 좋은 특징을 사용하여 여러가지 번거로운 작업을 단순화할 수 있다.</p>\n<p><code>Sinon.js</code>를 시작하는 것은 어렵지만, <code>Sinon.js</code>가 제공하고 호출하는 Spies, Stubs, Mocks 등을 이용하면 테스트에 필요한 상당한 기능성을 얻을 수 있다. 하지만, 이 세가지를 구분하고 선택하여 사용하는 것은 어려움이 존재한다. 아래 글을 통하여 SPY, STUB, MOCK의 차이점을 파악하고 최적의 사용 방법을 파악해보자.</p>\n<h3 id=\"예제-코드\"><a href=\"#예제-코드\" class=\"headerlink\" title=\"예제 코드\"></a>예제 코드</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setupNewUser</span>(<span class=\"params\">info, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> user = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: info.name,</span><br><span class=\"line\">    <span class=\"attr\">nameLowercase</span>: info.name.toLowerCase()</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Database.save(user, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">catch</span>(err) &#123;</span><br><span class=\"line\">    callback(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위 함수는 두개의 인자를 받을 수 있다. 첫 번째 인자의 경우, 저장하고자 하는 데이터를 담은 객체이며 두 번째 인자의 경우 콜백 함수이다. 우리는 첫 번째 인자의 데이터를 <code>info</code> 객체에서 <code>user</code> 객체 변수로 할당할 것이며, 이를 저장하는 연산을 수행할 것이다.</p>\n<blockquote>\n<p><code>Database.save()</code>는 웹 환경이라면 ajax호출을 통한 통신이 될 수도 있으며, Node 관련 환경이라면 파일이나 데이터베이스에 직접 저장하는 코드가 될 수 있다. 예제 코드는 이런 상황을 가정하여 작성한 것이다.</code></p>\n</blockquote>\n<h3 id=\"Spies-Stubs-and-Mocks\"><a href=\"#Spies-Stubs-and-Mocks\" class=\"headerlink\" title=\"Spies, Stubs and Mocks\"></a>Spies, Stubs and Mocks</h3><p><strong>SPY, STUB</strong> 그리고 <strong>MOCK</strong> 을 가리켜서 <strong>테스트 더블(TEST DOUBLES)</strong> 이라고 하며, 영화에서 스턴트 더블이 위험한 일을 하듯이, 우리는 <strong>테스트 더블</strong> 을 활용하여 문제가 되는 코드를 대체하여 테스트를 쉽게할 수 있다.</p>\n<h3 id=\"When-Do-You-Need-Test-Doubles\"><a href=\"#When-Do-You-Need-Test-Doubles\" class=\"headerlink\" title=\"When Do You Need Test Doubles?\"></a>When Do You Need <em><strong>Test Doubles</strong></em>?</h3><ul>\n<li>Functions <strong>without side effects</strong></li>\n<li>Functions <strong>with side effects</strong></li>\n</ul>\n<p>우리는 함수가 부정적인 영향이나 부작용을 가지고 있을 때, 테스트 더블을 이용한 테스트가 필요하다. 부작용을 가지고 있는 함수 뿐만 아니라, 경우에 따라서 외부 통신이나 연산이 필요한 함수(잠재적으로 테스트를 느려지게 할 수 있는 연산 모두를 포함한다.)에서도 테스트 더블을 이용한 테스트를 진행할 수 있다.</p>\n<p>다시 말해, 외부 환경과 관련이 있는 코드 혹은 함수 호출이 주된 테스트 더블의 대상이 되며 이를 가리켜 <em><strong>Functions with side effects</strong></em> 라고 표현한다.</p>\n<h3 id=\"When-to-Use-SPY\"><a href=\"#When-to-Use-SPY\" class=\"headerlink\" title=\"When to Use SPY\"></a>When to Use SPY</h3><p><strong>SPY</strong> 는 함수 호출과 관련된 정보를 얻는데에 사용된다.</p>\n<ul>\n<li><strong>함수가 얼마나 많이 호출되었는지</strong></li>\n<li><strong>어떤 인자가 함수로 전달되었는지</strong></li>\n<li><strong>어떤 값이 리턴 되는지</strong></li>\n<li><strong>어떤 예외가 발생하는지</strong></li>\n</ul>\n<p>가장 일반적인 시나리오는 바로 <strong>함수 호출 횟수 및 어떤 인자를 함수에 넘겼는지에 관련된 부분이다.</strong></p>\n<p><strong>함수 호출 횟수</strong> 는 <code>sinon.assert.callCount</code>, <code>sinon.assert.calledOnce</code>, <code>sinon.assert.notCalled</code> 등의 메소드를 활용하면 확인할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">&#x27;should call save once&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> save = sinon.spy(Database, <span class=\"string\">&#x27;save&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  setupNewUser(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;test&#x27;</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  save.restore();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// save 함수가 정확하게 한 번만 호출되었는지 확인.</span></span><br><span class=\"line\">  <span class=\"comment\">// if spy was called once and only once.</span></span><br><span class=\"line\">  sinon.assert.calledOnce(save);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>함수에 어떤 인자를 넘겼는지 확인할 수 있다.</strong> 확인은 <code>sinon.assert.calledWith</code> 매소드를 호출하거나, or <code>spy.lastCall</code> or <code>spy.getCall</code> 매소드 등을 통하여 직접 접근하여 확인할 수 있다.</p>\n<p>아래 예제는 <code>setupNewUser</code>에서 호출하는 <code>Database.save()</code>가 <code>expectedUser</code> 객체의 내용과 동일하게 인자를 넘기지는지 유무를 확인한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">&#x27;should pass object with correct values to save&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> save = sinon.spy(Database, <span class=\"string\">&#x27;save&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> info = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;test&#x27;</span> &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> expectedUser = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: info.name,</span><br><span class=\"line\">    <span class=\"attr\">nameLowercase</span>: info.name.toLowerCase()</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  setupNewUser(info, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  save.restore();</span><br><span class=\"line\">  sinon.assert.calledWith(save, expectedUser);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"When-to-Use-Stubs\"><a href=\"#When-to-Use-Stubs\" class=\"headerlink\" title=\"When to Use Stubs\"></a>When to Use Stubs</h3><p>SPY 객체와 하는 일은 비슷하지만, STUB 객체는 함수(모듈/매소드)의 자체를 대체할 수 있다. 즉, 커스텀 행위를 수행할 수 있다는 뜻이다.(값을 리턴하거나 예외를 발생시키는 등) 또한, 주어진 인자를 통하여 콜백 함수를 호출할 수 있다. 즉, 테스트에 어려움이 많은 외부 종속적인 코드(네트워크, 데이터베이스 등)를 쉽게 테스트할 수 있는 것이다.</p>\n<ul>\n<li>문제가 될 수 있는 코드 블록을 대체할 수 있다.</li>\n<li>특정 코드 경로를 호출하는 경우(예외 발생 등).</li>\n<li>비동기 코드를 쉽게 테스트할 수 있다.</li>\n</ul>\n<p><strong>문제가 될 수 있는 코드 블록을 대체할 수 있다.</strong>,<br>테스트하기 어려운 코드(외부 환경에 종속적인 혹은 DB 혹은 네트워킹이 필요한)에 대하여 코드 블럭 대체를 통하여 테스트를 좀 더 쉽게 할 수 있도록 할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">&#x27;should pass object with correct values to save&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> save = sinon.stub(Database, <span class=\"string\">&#x27;save&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> info = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;test&#x27;</span> &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> expectedUser = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: info.name,</span><br><span class=\"line\">    <span class=\"attr\">nameLowercase</span>: info.name.toLowerCase()</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  setupNewUser(info, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  save.restore();</span><br><span class=\"line\">  sinon.assert.calledWith(save, expectedUser);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>특정 코드 경로를 호출하는 경우(예외 발생 등).</strong><br>우리가 테스트하고 있는 코드에서 만약 특정 함수를 호출하고 이 특정 함수가 만약 예외를 발생시킬 수도 있다. 이럴 경우 STUB 객체를 활용하여 예외를 발생시키는 코드를 쉽게 테스트할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">&#x27;should pass the error into the callback if save fails&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> expectedError = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;oops&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> save = sinon.stub(Database, <span class=\"string\">&#x27;save&#x27;</span>);</span><br><span class=\"line\">  save.throws(expectedError);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> callback = sinon.spy();</span><br><span class=\"line\"></span><br><span class=\"line\">  setupNewUser(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;foo&#x27;</span> &#125;, callback);</span><br><span class=\"line\"></span><br><span class=\"line\">  save.restore();</span><br><span class=\"line\">  sinon.assert.calledWith(callback, expectedError);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>비동기 코드를 쉽게 테스트할 수 있다.</strong><br>만약 비동기 함수를 STUB 객체로 대체한다면, 이에 대한 호출과 동시에 바로 콜백을 실행시킬수도 있으며 또한 테스트 하기 어려운 비동기 코드를 동기 코드처럼 다룰 수 있게 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">&#x27;should pass the database result into the callback&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> expectedResult = &#123; <span class=\"attr\">success</span>: <span class=\"literal\">true</span> &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> save = sinon.stub(Database, <span class=\"string\">&#x27;save&#x27;</span>);</span><br><span class=\"line\">  save.yields(<span class=\"literal\">null</span>, expectedResult);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> callback = sinon.spy();</span><br><span class=\"line\"></span><br><span class=\"line\">  setupNewUser(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;foo&#x27;</span> &#125;, callback);</span><br><span class=\"line\"></span><br><span class=\"line\">  save.restore();</span><br><span class=\"line\">  sinon.assert.calledWith(callback, <span class=\"literal\">null</span>, expectedResult);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"When-to-Use-Mocks\"><a href=\"#When-to-Use-Mocks\" class=\"headerlink\" title=\"When to Use Mocks\"></a>When to Use Mocks</h3><p>MOCK 객체 사용 시 세심한 주의가 필요하다. <strong>주의! MOCK 객체는 SPY 및 STUB 객체하는 하는 모든 일을 대체할 수 있는데, 이는 곧 테스트 자체를 복잡하게 만들거나 자칫하면 부서지기 쉬운(불안정한) 테스트 케이스를 만들어 낼 수 있다.</strong></p>\n<p>MOCK 객체는 STUB 객체를 사용할 때, 연쇄적인 액션이 필요한 경우 STUB 객체를 대신하여 사용할 떄 주요하다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">&#x27;should pass object with correct values to save only once&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> info = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;test&#x27;</span> &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> expectedUser = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: info.name,</span><br><span class=\"line\">    <span class=\"attr\">nameLowercase</span>: info.name.toLowerCase()</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> database = sinon.mock(Database);</span><br><span class=\"line\">  database.expects(<span class=\"string\">&#x27;save&#x27;</span>).once().withArgs(expectedUser);</span><br><span class=\"line\"></span><br><span class=\"line\">  setupNewUser(info, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  database.verify();</span><br><span class=\"line\">  database.restore();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h3><ul>\n<li><a href=\"http://sinonjs.org/docs/\">Sinon.JS</a></li>\n</ul>\n"},{"title":"[ES6] default parameter / spread operator / rest parameter","date":"2016-07-11T15:00:00.000Z","_content":"\n# [ES6] - default parameter / spread operator / rest parameter\n\n## default parameter(디폴트 파라미터)\n거창하게 디폴트 파라메터라고 하는데, 별건 없고 함수에서 파라미터/인자 값에 대하여 기본값을 지정하는 ES6 구현 내용이다.\n\n```javascript\nfunction printFriendsName(a,b){\n\tconsole.log(\"친구 1 : \" + a);\n\tconsole.log(\"친구 2 : \" + b); \n}\n```\n\n친구 이름을 출력하는 함수를 가지고 설명을 간단하게 할 수 있을꺼 같다. 이런 함수가 있다면 일반적으로 인자 값에 대하여 기본 값을 지정하기 위해서는 이런 코딩을 주로 해왔을꺼 같다.\n\n```javascript\nfunction printFriendsName(a,b){\n\ta = (a === undefined) ? \"내가 친구가 없다니!!!!\" : a;\n\tb = (b === undefined) ? \"내가 진짜 없는거야?????\" : b;\n\tconsole.log(\"출력을 해보자! :  \" + a + \" \" + b);\n}\nprintFriendsName();\n```\n\n```\n[출력 결과]\n출력을 해보자! :  내가 친구가 없다니!!!! 내가 진짜 없는거야?????\n```\n\n문자열을 넘기기 때문에 간단하게 보이지만, 만약 인자에서 객체나 다른 복잡한 프로퍼티를 받는 상황이라면 상황은 좀 더 복잡할 수 있을 것이다. \n\nES6에서는 이런 코드를 간단하게 줄이고자 엔진 자체에서 파라미터/인자에 기본 값을 할당할 수 있도록 구현할 수 있는 문법을 추가했다. 그것이 바로 **디폴트 파라미터**라 불리는 녀석이다. 그렇다면 위 코드에 디폴트 파라미터를 지정하여 바꿔보도록 하자.\n\n```javascript\nfunction printFriendsName(\n\ta = \"내가 친구가 없다니!!!!\",\n\tb = \"내가 진짜 없는거야?????\"){\n\tconsole.log(\"출력을 해보자! :  \" + a + \" \" + b);\n}\nprintFriendsName();\n```\n\n```\n[출력 결과]\n출력을 해보자! :  내가 친구가 없다니!!!! 내가 진짜 없는거야?????\n```\n\n출력 결과도 동일하고 코드가 한결 간단해졌다. 결정적으로 인자 정합성에 대한 코드가 빠졌기 때문에 로직도 한결 간단해보인다.\n\n기본 타입의 값뿐만 아니라, 참조 타입의 디폴트 파라미터 지정도 가능하다.\n\n```javascript\nfunction referencesTypeDefaultParameterTest(\n\ta = {},\n\tb = [],\n\tc = function(){}){\n\tconsole.log(\"참조 타입도 사용이 가능해요\")\n\tconsole.log(\"인자 타입 체크 : \" + typeof a);\n\tconsole.log(\"인자 타입 체크 : \" + typeof b);\n\tconsole.log(\"인자 타입 체크 : \" + typeof c);\t\n}\n\nreferencesTypeDefaultParameterTest();\n\nfunction expressionDefaultParameterTest(\n\ta = 1+2+3){\n\tconsole.log(\"표현식 사용이 가능해요.\")\n\tconsole.log(a);\n}\n\nexpressionDefaultParameterTest();\n```\n\n```\n[출력 결과]\n객체 타입도 사용이 가능해요\n인자 타입 체크 : object\n인자 타입 체크 : object\n인자 타입 체크 : function\n표현식도 사용이 가능해요.\n6\n```\n\n## spread operator(펼침 연산자)\n**...** 으로 포기되며 객체 순회가 가능한 객체를 개별 인자나 값으로 나누는 구문 요소가 추가되었다. \n펼침 연산자는 함수의 파라미터 혹은 인자가 여러개 필요한 곳에서 사용이 가능하다.(배열이 대표적임)\n\n```javascript\nfunction spreadArrTestFunc(a,b){\n\treturn a+b;\n}\nconsole.log(spreadArrTestFunc(...[1,2]));\n```\n\n```\n[출력 결과]\n3\n```\n\n엔진 내부적으로는 ...[1,2]를 ... 연산자가 붙으면 1,2로 치환하고 이를 함수 호출 시 인자로 넘기는 것이다. 이는 이터러블 규약으로 ES6에 정해진 일종의 PROTOCOL이라고 한다.\n\n값이 여러개 사용되는 배열같은 곳에서도 활용이 될 수 있는데, 사용할 수 있는 경우를 여러개로 나눠서 간단하게 샘플 코드를 짜봤다.\n\n\n```javascript\nlet arr1 = [1,2];\nlet arr2 = [3,4,5];\nlet arr3 = [...arr1, ...arr2];\n\nconsole.log(arr3);\n\nlet arr4 = [1,2];\nlet arr5 = [3,4,5];\n\narr4.push(...arr5);\nconsole.log(arr4);\n```\n\n```\n[출력 결과]\n[ 1, 2, 3, 4, 5 ]\n[ 1, 2, 3, 4, 5 ]\n```\n\n여러 개의 값을 가지고 있는 배열을 펼치기 연산을 통하여 통합하거나 배열의 끝자리에 붙이는게 상당히 간편한 것을 확인할 수 있다.\n\n\n## rest parameter(나머지 파라미터)\n말 그대로 나머지 파라미터로 함수에서 사용되며 함수 인자/파라미터 마지막에 \"...\"을 붙여서 가변적으로 넘어올 수 있는 함수 인자/파라미터를 배열로 바인딩할 수 있다. \n물론 argument를 활용하면 비슷한 기능을 흉내낼 수 있겠지만 argument 같은 경우에는 정확하게 배열이 아닌 유사배열이기 때문에 어느 정도 차이가 존재한다.\n\n\n```javascript\nfunction printNumbers(a,b,...nums){\n\tconsole.log(Array.isArray(nums));\n\tconsole.log(a,b,nums);\n}\nprintNumbers(1,2,3,4,5,6,7,8,9);\n```\n\n```\n[출력 결과]\ntrue\n1 2 [ 3, 4, 5, 6, 7, 8, 9 ]\n```\n\n넘어온 나머지 파라미터의 타입이 배열임을 확인하고 값을 출력하는 간단한 함수를 만든 결과이다.","source":"_posts/JavaScript/ES6_defaultparameter_spreadoperator.md","raw":"---\ntitle: '[ES6] default parameter / spread operator / rest parameter'\ndate: 2016/7/12 00:00:00\ncategories:\n- JavaScript\n---\n\n# [ES6] - default parameter / spread operator / rest parameter\n\n## default parameter(디폴트 파라미터)\n거창하게 디폴트 파라메터라고 하는데, 별건 없고 함수에서 파라미터/인자 값에 대하여 기본값을 지정하는 ES6 구현 내용이다.\n\n```javascript\nfunction printFriendsName(a,b){\n\tconsole.log(\"친구 1 : \" + a);\n\tconsole.log(\"친구 2 : \" + b); \n}\n```\n\n친구 이름을 출력하는 함수를 가지고 설명을 간단하게 할 수 있을꺼 같다. 이런 함수가 있다면 일반적으로 인자 값에 대하여 기본 값을 지정하기 위해서는 이런 코딩을 주로 해왔을꺼 같다.\n\n```javascript\nfunction printFriendsName(a,b){\n\ta = (a === undefined) ? \"내가 친구가 없다니!!!!\" : a;\n\tb = (b === undefined) ? \"내가 진짜 없는거야?????\" : b;\n\tconsole.log(\"출력을 해보자! :  \" + a + \" \" + b);\n}\nprintFriendsName();\n```\n\n```\n[출력 결과]\n출력을 해보자! :  내가 친구가 없다니!!!! 내가 진짜 없는거야?????\n```\n\n문자열을 넘기기 때문에 간단하게 보이지만, 만약 인자에서 객체나 다른 복잡한 프로퍼티를 받는 상황이라면 상황은 좀 더 복잡할 수 있을 것이다. \n\nES6에서는 이런 코드를 간단하게 줄이고자 엔진 자체에서 파라미터/인자에 기본 값을 할당할 수 있도록 구현할 수 있는 문법을 추가했다. 그것이 바로 **디폴트 파라미터**라 불리는 녀석이다. 그렇다면 위 코드에 디폴트 파라미터를 지정하여 바꿔보도록 하자.\n\n```javascript\nfunction printFriendsName(\n\ta = \"내가 친구가 없다니!!!!\",\n\tb = \"내가 진짜 없는거야?????\"){\n\tconsole.log(\"출력을 해보자! :  \" + a + \" \" + b);\n}\nprintFriendsName();\n```\n\n```\n[출력 결과]\n출력을 해보자! :  내가 친구가 없다니!!!! 내가 진짜 없는거야?????\n```\n\n출력 결과도 동일하고 코드가 한결 간단해졌다. 결정적으로 인자 정합성에 대한 코드가 빠졌기 때문에 로직도 한결 간단해보인다.\n\n기본 타입의 값뿐만 아니라, 참조 타입의 디폴트 파라미터 지정도 가능하다.\n\n```javascript\nfunction referencesTypeDefaultParameterTest(\n\ta = {},\n\tb = [],\n\tc = function(){}){\n\tconsole.log(\"참조 타입도 사용이 가능해요\")\n\tconsole.log(\"인자 타입 체크 : \" + typeof a);\n\tconsole.log(\"인자 타입 체크 : \" + typeof b);\n\tconsole.log(\"인자 타입 체크 : \" + typeof c);\t\n}\n\nreferencesTypeDefaultParameterTest();\n\nfunction expressionDefaultParameterTest(\n\ta = 1+2+3){\n\tconsole.log(\"표현식 사용이 가능해요.\")\n\tconsole.log(a);\n}\n\nexpressionDefaultParameterTest();\n```\n\n```\n[출력 결과]\n객체 타입도 사용이 가능해요\n인자 타입 체크 : object\n인자 타입 체크 : object\n인자 타입 체크 : function\n표현식도 사용이 가능해요.\n6\n```\n\n## spread operator(펼침 연산자)\n**...** 으로 포기되며 객체 순회가 가능한 객체를 개별 인자나 값으로 나누는 구문 요소가 추가되었다. \n펼침 연산자는 함수의 파라미터 혹은 인자가 여러개 필요한 곳에서 사용이 가능하다.(배열이 대표적임)\n\n```javascript\nfunction spreadArrTestFunc(a,b){\n\treturn a+b;\n}\nconsole.log(spreadArrTestFunc(...[1,2]));\n```\n\n```\n[출력 결과]\n3\n```\n\n엔진 내부적으로는 ...[1,2]를 ... 연산자가 붙으면 1,2로 치환하고 이를 함수 호출 시 인자로 넘기는 것이다. 이는 이터러블 규약으로 ES6에 정해진 일종의 PROTOCOL이라고 한다.\n\n값이 여러개 사용되는 배열같은 곳에서도 활용이 될 수 있는데, 사용할 수 있는 경우를 여러개로 나눠서 간단하게 샘플 코드를 짜봤다.\n\n\n```javascript\nlet arr1 = [1,2];\nlet arr2 = [3,4,5];\nlet arr3 = [...arr1, ...arr2];\n\nconsole.log(arr3);\n\nlet arr4 = [1,2];\nlet arr5 = [3,4,5];\n\narr4.push(...arr5);\nconsole.log(arr4);\n```\n\n```\n[출력 결과]\n[ 1, 2, 3, 4, 5 ]\n[ 1, 2, 3, 4, 5 ]\n```\n\n여러 개의 값을 가지고 있는 배열을 펼치기 연산을 통하여 통합하거나 배열의 끝자리에 붙이는게 상당히 간편한 것을 확인할 수 있다.\n\n\n## rest parameter(나머지 파라미터)\n말 그대로 나머지 파라미터로 함수에서 사용되며 함수 인자/파라미터 마지막에 \"...\"을 붙여서 가변적으로 넘어올 수 있는 함수 인자/파라미터를 배열로 바인딩할 수 있다. \n물론 argument를 활용하면 비슷한 기능을 흉내낼 수 있겠지만 argument 같은 경우에는 정확하게 배열이 아닌 유사배열이기 때문에 어느 정도 차이가 존재한다.\n\n\n```javascript\nfunction printNumbers(a,b,...nums){\n\tconsole.log(Array.isArray(nums));\n\tconsole.log(a,b,nums);\n}\nprintNumbers(1,2,3,4,5,6,7,8,9);\n```\n\n```\n[출력 결과]\ntrue\n1 2 [ 3, 4, 5, 6, 7, 8, 9 ]\n```\n\n넘어온 나머지 파라미터의 타입이 배열임을 확인하고 값을 출력하는 간단한 함수를 만든 결과이다.","slug":"JavaScript/ES6_defaultparameter_spreadoperator","published":1,"updated":"2021-08-02T12:28:10.375Z","_id":"ckrsup50b0011tjhv0ihhgezc","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"ES6-default-parameter-spread-operator-rest-parameter\"><a href=\"#ES6-default-parameter-spread-operator-rest-parameter\" class=\"headerlink\" title=\"[ES6] - default parameter / spread operator / rest parameter\"></a>[ES6] - default parameter / spread operator / rest parameter</h1><h2 id=\"default-parameter-디폴트-파라미터\"><a href=\"#default-parameter-디폴트-파라미터\" class=\"headerlink\" title=\"default parameter(디폴트 파라미터)\"></a>default parameter(디폴트 파라미터)</h2><p>거창하게 디폴트 파라메터라고 하는데, 별건 없고 함수에서 파라미터/인자 값에 대하여 기본값을 지정하는 ES6 구현 내용이다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printFriendsName</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;친구 1 : &quot;</span> + a);</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;친구 2 : &quot;</span> + b); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>친구 이름을 출력하는 함수를 가지고 설명을 간단하게 할 수 있을꺼 같다. 이런 함수가 있다면 일반적으로 인자 값에 대하여 기본 값을 지정하기 위해서는 이런 코딩을 주로 해왔을꺼 같다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printFriendsName</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\ta = (a === <span class=\"literal\">undefined</span>) ? <span class=\"string\">&quot;내가 친구가 없다니!!!!&quot;</span> : a;</span><br><span class=\"line\">\tb = (b === <span class=\"literal\">undefined</span>) ? <span class=\"string\">&quot;내가 진짜 없는거야?????&quot;</span> : b;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;출력을 해보자! :  &quot;</span> + a + <span class=\"string\">&quot; &quot;</span> + b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printFriendsName();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력 결과]</span><br><span class=\"line\">출력을 해보자! :  내가 친구가 없다니!!!! 내가 진짜 없는거야?????</span><br></pre></td></tr></table></figure>\n\n<p>문자열을 넘기기 때문에 간단하게 보이지만, 만약 인자에서 객체나 다른 복잡한 프로퍼티를 받는 상황이라면 상황은 좀 더 복잡할 수 있을 것이다. </p>\n<p>ES6에서는 이런 코드를 간단하게 줄이고자 엔진 자체에서 파라미터/인자에 기본 값을 할당할 수 있도록 구현할 수 있는 문법을 추가했다. 그것이 바로 <strong>디폴트 파라미터</strong>라 불리는 녀석이다. 그렇다면 위 코드에 디폴트 파라미터를 지정하여 바꿔보도록 하자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printFriendsName</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\ta = <span class=\"string\">&quot;내가 친구가 없다니!!!!&quot;</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tb = <span class=\"string\">&quot;내가 진짜 없는거야?????&quot;</span></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;출력을 해보자! :  &quot;</span> + a + <span class=\"string\">&quot; &quot;</span> + b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printFriendsName();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력 결과]</span><br><span class=\"line\">출력을 해보자! :  내가 친구가 없다니!!!! 내가 진짜 없는거야?????</span><br></pre></td></tr></table></figure>\n\n<p>출력 결과도 동일하고 코드가 한결 간단해졌다. 결정적으로 인자 정합성에 대한 코드가 빠졌기 때문에 로직도 한결 간단해보인다.</p>\n<p>기본 타입의 값뿐만 아니라, 참조 타입의 디폴트 파라미터 지정도 가능하다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">referencesTypeDefaultParameterTest</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\ta = &#123;&#125;,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tb = [],</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tc = <span class=\"keyword\">function</span>()&#123;&#125;</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;참조 타입도 사용이 가능해요&quot;</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;인자 타입 체크 : &quot;</span> + <span class=\"keyword\">typeof</span> a);</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;인자 타입 체크 : &quot;</span> + <span class=\"keyword\">typeof</span> b);</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;인자 타입 체크 : &quot;</span> + <span class=\"keyword\">typeof</span> c);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">referencesTypeDefaultParameterTest();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">expressionDefaultParameterTest</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\ta = <span class=\"number\">1</span>+<span class=\"number\">2</span>+<span class=\"number\">3</span></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;표현식 사용이 가능해요.&quot;</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">expressionDefaultParameterTest();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력 결과]</span><br><span class=\"line\">객체 타입도 사용이 가능해요</span><br><span class=\"line\">인자 타입 체크 : object</span><br><span class=\"line\">인자 타입 체크 : object</span><br><span class=\"line\">인자 타입 체크 : function</span><br><span class=\"line\">표현식도 사용이 가능해요.</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"spread-operator-펼침-연산자\"><a href=\"#spread-operator-펼침-연산자\" class=\"headerlink\" title=\"spread operator(펼침 연산자)\"></a>spread operator(펼침 연산자)</h2><p><strong>…</strong> 으로 포기되며 객체 순회가 가능한 객체를 개별 인자나 값으로 나누는 구문 요소가 추가되었다.<br>펼침 연산자는 함수의 파라미터 혹은 인자가 여러개 필요한 곳에서 사용이 가능하다.(배열이 대표적임)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">spreadArrTestFunc</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(spreadArrTestFunc(...[<span class=\"number\">1</span>,<span class=\"number\">2</span>]));</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력 결과]</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<p>엔진 내부적으로는 …[1,2]를 … 연산자가 붙으면 1,2로 치환하고 이를 함수 호출 시 인자로 넘기는 것이다. 이는 이터러블 규약으로 ES6에 정해진 일종의 PROTOCOL이라고 한다.</p>\n<p>값이 여러개 사용되는 배열같은 곳에서도 활용이 될 수 있는데, 사용할 수 있는 경우를 여러개로 나눠서 간단하게 샘플 코드를 짜봤다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = [<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3 = [...arr1, ...arr2];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr3);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr4 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr5 = [<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">arr4.push(...arr5);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr4);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력 결과]</span><br><span class=\"line\">[ 1, 2, 3, 4, 5 ]</span><br><span class=\"line\">[ 1, 2, 3, 4, 5 ]</span><br></pre></td></tr></table></figure>\n\n<p>여러 개의 값을 가지고 있는 배열을 펼치기 연산을 통하여 통합하거나 배열의 끝자리에 붙이는게 상당히 간편한 것을 확인할 수 있다.</p>\n<h2 id=\"rest-parameter-나머지-파라미터\"><a href=\"#rest-parameter-나머지-파라미터\" class=\"headerlink\" title=\"rest parameter(나머지 파라미터)\"></a>rest parameter(나머지 파라미터)</h2><p>말 그대로 나머지 파라미터로 함수에서 사용되며 함수 인자/파라미터 마지막에 “…”을 붙여서 가변적으로 넘어올 수 있는 함수 인자/파라미터를 배열로 바인딩할 수 있다.<br>물론 argument를 활용하면 비슷한 기능을 흉내낼 수 있겠지만 argument 같은 경우에는 정확하게 배열이 아닌 유사배열이기 때문에 어느 정도 차이가 존재한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printNumbers</span>(<span class=\"params\">a,b,...nums</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.isArray(nums));</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a,b,nums);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printNumbers(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력 결과]</span><br><span class=\"line\">true</span><br><span class=\"line\">1 2 [ 3, 4, 5, 6, 7, 8, 9 ]</span><br></pre></td></tr></table></figure>\n\n<p>넘어온 나머지 파라미터의 타입이 배열임을 확인하고 값을 출력하는 간단한 함수를 만든 결과이다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ES6-default-parameter-spread-operator-rest-parameter\"><a href=\"#ES6-default-parameter-spread-operator-rest-parameter\" class=\"headerlink\" title=\"[ES6] - default parameter / spread operator / rest parameter\"></a>[ES6] - default parameter / spread operator / rest parameter</h1><h2 id=\"default-parameter-디폴트-파라미터\"><a href=\"#default-parameter-디폴트-파라미터\" class=\"headerlink\" title=\"default parameter(디폴트 파라미터)\"></a>default parameter(디폴트 파라미터)</h2><p>거창하게 디폴트 파라메터라고 하는데, 별건 없고 함수에서 파라미터/인자 값에 대하여 기본값을 지정하는 ES6 구현 내용이다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printFriendsName</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;친구 1 : &quot;</span> + a);</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;친구 2 : &quot;</span> + b); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>친구 이름을 출력하는 함수를 가지고 설명을 간단하게 할 수 있을꺼 같다. 이런 함수가 있다면 일반적으로 인자 값에 대하여 기본 값을 지정하기 위해서는 이런 코딩을 주로 해왔을꺼 같다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printFriendsName</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\ta = (a === <span class=\"literal\">undefined</span>) ? <span class=\"string\">&quot;내가 친구가 없다니!!!!&quot;</span> : a;</span><br><span class=\"line\">\tb = (b === <span class=\"literal\">undefined</span>) ? <span class=\"string\">&quot;내가 진짜 없는거야?????&quot;</span> : b;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;출력을 해보자! :  &quot;</span> + a + <span class=\"string\">&quot; &quot;</span> + b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printFriendsName();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력 결과]</span><br><span class=\"line\">출력을 해보자! :  내가 친구가 없다니!!!! 내가 진짜 없는거야?????</span><br></pre></td></tr></table></figure>\n\n<p>문자열을 넘기기 때문에 간단하게 보이지만, 만약 인자에서 객체나 다른 복잡한 프로퍼티를 받는 상황이라면 상황은 좀 더 복잡할 수 있을 것이다. </p>\n<p>ES6에서는 이런 코드를 간단하게 줄이고자 엔진 자체에서 파라미터/인자에 기본 값을 할당할 수 있도록 구현할 수 있는 문법을 추가했다. 그것이 바로 <strong>디폴트 파라미터</strong>라 불리는 녀석이다. 그렇다면 위 코드에 디폴트 파라미터를 지정하여 바꿔보도록 하자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printFriendsName</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\ta = <span class=\"string\">&quot;내가 친구가 없다니!!!!&quot;</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tb = <span class=\"string\">&quot;내가 진짜 없는거야?????&quot;</span></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;출력을 해보자! :  &quot;</span> + a + <span class=\"string\">&quot; &quot;</span> + b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printFriendsName();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력 결과]</span><br><span class=\"line\">출력을 해보자! :  내가 친구가 없다니!!!! 내가 진짜 없는거야?????</span><br></pre></td></tr></table></figure>\n\n<p>출력 결과도 동일하고 코드가 한결 간단해졌다. 결정적으로 인자 정합성에 대한 코드가 빠졌기 때문에 로직도 한결 간단해보인다.</p>\n<p>기본 타입의 값뿐만 아니라, 참조 타입의 디폴트 파라미터 지정도 가능하다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">referencesTypeDefaultParameterTest</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\ta = &#123;&#125;,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tb = [],</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tc = <span class=\"keyword\">function</span>()&#123;&#125;</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;참조 타입도 사용이 가능해요&quot;</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;인자 타입 체크 : &quot;</span> + <span class=\"keyword\">typeof</span> a);</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;인자 타입 체크 : &quot;</span> + <span class=\"keyword\">typeof</span> b);</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;인자 타입 체크 : &quot;</span> + <span class=\"keyword\">typeof</span> c);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">referencesTypeDefaultParameterTest();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">expressionDefaultParameterTest</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\ta = <span class=\"number\">1</span>+<span class=\"number\">2</span>+<span class=\"number\">3</span></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;표현식 사용이 가능해요.&quot;</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">expressionDefaultParameterTest();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력 결과]</span><br><span class=\"line\">객체 타입도 사용이 가능해요</span><br><span class=\"line\">인자 타입 체크 : object</span><br><span class=\"line\">인자 타입 체크 : object</span><br><span class=\"line\">인자 타입 체크 : function</span><br><span class=\"line\">표현식도 사용이 가능해요.</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"spread-operator-펼침-연산자\"><a href=\"#spread-operator-펼침-연산자\" class=\"headerlink\" title=\"spread operator(펼침 연산자)\"></a>spread operator(펼침 연산자)</h2><p><strong>…</strong> 으로 포기되며 객체 순회가 가능한 객체를 개별 인자나 값으로 나누는 구문 요소가 추가되었다.<br>펼침 연산자는 함수의 파라미터 혹은 인자가 여러개 필요한 곳에서 사용이 가능하다.(배열이 대표적임)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">spreadArrTestFunc</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(spreadArrTestFunc(...[<span class=\"number\">1</span>,<span class=\"number\">2</span>]));</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력 결과]</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<p>엔진 내부적으로는 …[1,2]를 … 연산자가 붙으면 1,2로 치환하고 이를 함수 호출 시 인자로 넘기는 것이다. 이는 이터러블 규약으로 ES6에 정해진 일종의 PROTOCOL이라고 한다.</p>\n<p>값이 여러개 사용되는 배열같은 곳에서도 활용이 될 수 있는데, 사용할 수 있는 경우를 여러개로 나눠서 간단하게 샘플 코드를 짜봤다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = [<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3 = [...arr1, ...arr2];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr3);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr4 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr5 = [<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">arr4.push(...arr5);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr4);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력 결과]</span><br><span class=\"line\">[ 1, 2, 3, 4, 5 ]</span><br><span class=\"line\">[ 1, 2, 3, 4, 5 ]</span><br></pre></td></tr></table></figure>\n\n<p>여러 개의 값을 가지고 있는 배열을 펼치기 연산을 통하여 통합하거나 배열의 끝자리에 붙이는게 상당히 간편한 것을 확인할 수 있다.</p>\n<h2 id=\"rest-parameter-나머지-파라미터\"><a href=\"#rest-parameter-나머지-파라미터\" class=\"headerlink\" title=\"rest parameter(나머지 파라미터)\"></a>rest parameter(나머지 파라미터)</h2><p>말 그대로 나머지 파라미터로 함수에서 사용되며 함수 인자/파라미터 마지막에 “…”을 붙여서 가변적으로 넘어올 수 있는 함수 인자/파라미터를 배열로 바인딩할 수 있다.<br>물론 argument를 활용하면 비슷한 기능을 흉내낼 수 있겠지만 argument 같은 경우에는 정확하게 배열이 아닌 유사배열이기 때문에 어느 정도 차이가 존재한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printNumbers</span>(<span class=\"params\">a,b,...nums</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.isArray(nums));</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a,b,nums);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printNumbers(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력 결과]</span><br><span class=\"line\">true</span><br><span class=\"line\">1 2 [ 3, 4, 5, 6, 7, 8, 9 ]</span><br></pre></td></tr></table></figure>\n\n<p>넘어온 나머지 파라미터의 타입이 배열임을 확인하고 값을 출력하는 간단한 함수를 만든 결과이다.</p>\n"},{"title":"JavaScript_this 바인딩(함수/객체)","date":"2016-07-11T15:00:00.000Z","_content":"\n# JavaScript_this 바인딩(함수/객체)\n자바스크립트에서 this는 함수/객체 실행에 따라서 바라보는(참조)하는 객체가 달라지게 된다.\n\n\n## 객체\n객체 프로퍼티가 함수인 경우, 함수 내부에서 this는 객체를 가리키게 된다.\n\n다시 말해서, this는 그 매서드를 호출한 객체를 바라보게 된다.\n```javascript\nvar myObject = {\n  value : 100,\n  getValue : function(){\n    console.log(this.value) // 100;\n  }\n}\n```\n프로퍼티가 함수인 경우, 간단하게 this가 가리키는 것이 객체가 된다고 생각할 수 있다. 하지만 함수 내부에서 다시 내부 함수를 사용할 경우, 그 내부함수에서 가리키게 되는 this는 일반 함수에서의 this가 가리키는 것과 동일하게 전역객체를 가리키게 된다. 그렇기 때문에 코드상에서 객체를 가리킬 수 있도록 임의로 객체를 참조하는 변수를 만들어서 사용하기도 한다.\n```javascript\nvar myObject = {\n  value : 100,\n  getValue : function(){\n    var that = this; // 일반적으로 that으로 참조 변수명을 정하는게 관례\n    console.log(this.value) // 100;\n    var func1 = function(){\n      console.log(that.value) // 100;\n    }\n\n  }\n}\n```\n\n## 함수\n기본적으로, 함수를 실행하게되면 this는 전역객체인 window(브라우저) / global(Node)를 가리키게 된다. 결과적으로 함수를 그냥 실행하느냐와 생성자 함수로 실행하느냐의 차이는 엄청나게 다르다.\n```javascript\nfunction A(){\n  this.value = 100; // window.value = 100;\n  this.name = \"kschoi\"; // window.name = \"kschoi\"\n}\n```\n## 생성자 함수\n생성자 함수의 경우, 아래의 순서대로 인스턴스를 생성하게 된다.\n- 빈 객체를 생성하여, 빈 객체에 this를 바인딩하게 된다.\n- 빈 객체에 this를 바인딩하기 앞서, 객체의 __proto__ 프로퍼티를 생성하여 함수 객체의 prototype 영역을 참조하게 한다\n- 이후 함수 내부 코드에서 this를 사용하여 객체에 속성 혹은 매소드를 생성하게 된다.\n```javascript\nfunction Test(){\n    this.name = \"kschoi\"\n    this.age = 20;\n}\nvar obj = {};\nobj.__proto__ = Test.prototype;\nTest.call(obj);\nconsole.log(obj);\n```\n\n하나 눈여겨 볼 부분은 함수의 리턴값에 관련된 부분이다. 만약 함수에 리턴값이 없으면 'undefined'가 리턴되지만, 생성자 함수의 경우 생성된 객체를 리턴하게 된다. 하지만, 만약 생성자 함수에서 임의적으로 리턴하는 객체가 존재하게 되면 this를 사용하여 속성값 혹은 매소드를 생성한 객체를 리턴하는 것이 아닌 임의로 지정한 리턴 객체를 반환하게 된다.\n","source":"_posts/JavaScript/Function.md","raw":"---\ntitle: 'JavaScript_this 바인딩(함수/객체)'\ndate: 2016/7/12 00:00:00\ncategories:\n- JavaScript\n---\n\n# JavaScript_this 바인딩(함수/객체)\n자바스크립트에서 this는 함수/객체 실행에 따라서 바라보는(참조)하는 객체가 달라지게 된다.\n\n\n## 객체\n객체 프로퍼티가 함수인 경우, 함수 내부에서 this는 객체를 가리키게 된다.\n\n다시 말해서, this는 그 매서드를 호출한 객체를 바라보게 된다.\n```javascript\nvar myObject = {\n  value : 100,\n  getValue : function(){\n    console.log(this.value) // 100;\n  }\n}\n```\n프로퍼티가 함수인 경우, 간단하게 this가 가리키는 것이 객체가 된다고 생각할 수 있다. 하지만 함수 내부에서 다시 내부 함수를 사용할 경우, 그 내부함수에서 가리키게 되는 this는 일반 함수에서의 this가 가리키는 것과 동일하게 전역객체를 가리키게 된다. 그렇기 때문에 코드상에서 객체를 가리킬 수 있도록 임의로 객체를 참조하는 변수를 만들어서 사용하기도 한다.\n```javascript\nvar myObject = {\n  value : 100,\n  getValue : function(){\n    var that = this; // 일반적으로 that으로 참조 변수명을 정하는게 관례\n    console.log(this.value) // 100;\n    var func1 = function(){\n      console.log(that.value) // 100;\n    }\n\n  }\n}\n```\n\n## 함수\n기본적으로, 함수를 실행하게되면 this는 전역객체인 window(브라우저) / global(Node)를 가리키게 된다. 결과적으로 함수를 그냥 실행하느냐와 생성자 함수로 실행하느냐의 차이는 엄청나게 다르다.\n```javascript\nfunction A(){\n  this.value = 100; // window.value = 100;\n  this.name = \"kschoi\"; // window.name = \"kschoi\"\n}\n```\n## 생성자 함수\n생성자 함수의 경우, 아래의 순서대로 인스턴스를 생성하게 된다.\n- 빈 객체를 생성하여, 빈 객체에 this를 바인딩하게 된다.\n- 빈 객체에 this를 바인딩하기 앞서, 객체의 __proto__ 프로퍼티를 생성하여 함수 객체의 prototype 영역을 참조하게 한다\n- 이후 함수 내부 코드에서 this를 사용하여 객체에 속성 혹은 매소드를 생성하게 된다.\n```javascript\nfunction Test(){\n    this.name = \"kschoi\"\n    this.age = 20;\n}\nvar obj = {};\nobj.__proto__ = Test.prototype;\nTest.call(obj);\nconsole.log(obj);\n```\n\n하나 눈여겨 볼 부분은 함수의 리턴값에 관련된 부분이다. 만약 함수에 리턴값이 없으면 'undefined'가 리턴되지만, 생성자 함수의 경우 생성된 객체를 리턴하게 된다. 하지만, 만약 생성자 함수에서 임의적으로 리턴하는 객체가 존재하게 되면 this를 사용하여 속성값 혹은 매소드를 생성한 객체를 리턴하는 것이 아닌 임의로 지정한 리턴 객체를 반환하게 된다.\n","slug":"JavaScript/Function","published":1,"updated":"2021-08-02T12:28:17.973Z","_id":"ckrsup50c0012tjhv4dg7hnqm","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"JavaScript-this-바인딩-함수-객체\"><a href=\"#JavaScript-this-바인딩-함수-객체\" class=\"headerlink\" title=\"JavaScript_this 바인딩(함수/객체)\"></a>JavaScript_this 바인딩(함수/객체)</h1><p>자바스크립트에서 this는 함수/객체 실행에 따라서 바라보는(참조)하는 객체가 달라지게 된다.</p>\n<h2 id=\"객체\"><a href=\"#객체\" class=\"headerlink\" title=\"객체\"></a>객체</h2><p>객체 프로퍼티가 함수인 경우, 함수 내부에서 this는 객체를 가리키게 된다.</p>\n<p>다시 말해서, this는 그 매서드를 호출한 객체를 바라보게 된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span> : <span class=\"number\">100</span>,</span><br><span class=\"line\">  <span class=\"attr\">getValue</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.value) <span class=\"comment\">// 100;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>프로퍼티가 함수인 경우, 간단하게 this가 가리키는 것이 객체가 된다고 생각할 수 있다. 하지만 함수 내부에서 다시 내부 함수를 사용할 경우, 그 내부함수에서 가리키게 되는 this는 일반 함수에서의 this가 가리키는 것과 동일하게 전역객체를 가리키게 된다. 그렇기 때문에 코드상에서 객체를 가리킬 수 있도록 임의로 객체를 참조하는 변수를 만들어서 사용하기도 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span> : <span class=\"number\">100</span>,</span><br><span class=\"line\">  <span class=\"attr\">getValue</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"built_in\">this</span>; <span class=\"comment\">// 일반적으로 that으로 참조 변수명을 정하는게 관례</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.value) <span class=\"comment\">// 100;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> func1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(that.value) <span class=\"comment\">// 100;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"함수\"><a href=\"#함수\" class=\"headerlink\" title=\"함수\"></a>함수</h2><p>기본적으로, 함수를 실행하게되면 this는 전역객체인 window(브라우저) / global(Node)를 가리키게 된다. 결과적으로 함수를 그냥 실행하느냐와 생성자 함수로 실행하느냐의 차이는 엄청나게 다르다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.value = <span class=\"number\">100</span>; <span class=\"comment\">// window.value = 100;</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = <span class=\"string\">&quot;kschoi&quot;</span>; <span class=\"comment\">// window.name = &quot;kschoi&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"생성자-함수\"><a href=\"#생성자-함수\" class=\"headerlink\" title=\"생성자 함수\"></a>생성자 함수</h2><p>생성자 함수의 경우, 아래의 순서대로 인스턴스를 생성하게 된다.</p>\n<ul>\n<li>빈 객체를 생성하여, 빈 객체에 this를 바인딩하게 된다.</li>\n<li>빈 객체에 this를 바인딩하기 앞서, 객체의 <strong>proto</strong> 프로퍼티를 생성하여 함수 객체의 prototype 영역을 참조하게 한다</li>\n<li>이후 함수 내부 코드에서 this를 사용하여 객체에 속성 혹은 매소드를 생성하게 된다.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = <span class=\"string\">&quot;kschoi&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = <span class=\"number\">20</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.__proto__ = Test.prototype;</span><br><span class=\"line\">Test.call(obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>하나 눈여겨 볼 부분은 함수의 리턴값에 관련된 부분이다. 만약 함수에 리턴값이 없으면 ‘undefined’가 리턴되지만, 생성자 함수의 경우 생성된 객체를 리턴하게 된다. 하지만, 만약 생성자 함수에서 임의적으로 리턴하는 객체가 존재하게 되면 this를 사용하여 속성값 혹은 매소드를 생성한 객체를 리턴하는 것이 아닌 임의로 지정한 리턴 객체를 반환하게 된다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript-this-바인딩-함수-객체\"><a href=\"#JavaScript-this-바인딩-함수-객체\" class=\"headerlink\" title=\"JavaScript_this 바인딩(함수/객체)\"></a>JavaScript_this 바인딩(함수/객체)</h1><p>자바스크립트에서 this는 함수/객체 실행에 따라서 바라보는(참조)하는 객체가 달라지게 된다.</p>\n<h2 id=\"객체\"><a href=\"#객체\" class=\"headerlink\" title=\"객체\"></a>객체</h2><p>객체 프로퍼티가 함수인 경우, 함수 내부에서 this는 객체를 가리키게 된다.</p>\n<p>다시 말해서, this는 그 매서드를 호출한 객체를 바라보게 된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span> : <span class=\"number\">100</span>,</span><br><span class=\"line\">  <span class=\"attr\">getValue</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.value) <span class=\"comment\">// 100;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>프로퍼티가 함수인 경우, 간단하게 this가 가리키는 것이 객체가 된다고 생각할 수 있다. 하지만 함수 내부에서 다시 내부 함수를 사용할 경우, 그 내부함수에서 가리키게 되는 this는 일반 함수에서의 this가 가리키는 것과 동일하게 전역객체를 가리키게 된다. 그렇기 때문에 코드상에서 객체를 가리킬 수 있도록 임의로 객체를 참조하는 변수를 만들어서 사용하기도 한다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span> : <span class=\"number\">100</span>,</span><br><span class=\"line\">  <span class=\"attr\">getValue</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"built_in\">this</span>; <span class=\"comment\">// 일반적으로 that으로 참조 변수명을 정하는게 관례</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.value) <span class=\"comment\">// 100;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> func1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(that.value) <span class=\"comment\">// 100;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"함수\"><a href=\"#함수\" class=\"headerlink\" title=\"함수\"></a>함수</h2><p>기본적으로, 함수를 실행하게되면 this는 전역객체인 window(브라우저) / global(Node)를 가리키게 된다. 결과적으로 함수를 그냥 실행하느냐와 생성자 함수로 실행하느냐의 차이는 엄청나게 다르다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.value = <span class=\"number\">100</span>; <span class=\"comment\">// window.value = 100;</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = <span class=\"string\">&quot;kschoi&quot;</span>; <span class=\"comment\">// window.name = &quot;kschoi&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"생성자-함수\"><a href=\"#생성자-함수\" class=\"headerlink\" title=\"생성자 함수\"></a>생성자 함수</h2><p>생성자 함수의 경우, 아래의 순서대로 인스턴스를 생성하게 된다.</p>\n<ul>\n<li>빈 객체를 생성하여, 빈 객체에 this를 바인딩하게 된다.</li>\n<li>빈 객체에 this를 바인딩하기 앞서, 객체의 <strong>proto</strong> 프로퍼티를 생성하여 함수 객체의 prototype 영역을 참조하게 한다</li>\n<li>이후 함수 내부 코드에서 this를 사용하여 객체에 속성 혹은 매소드를 생성하게 된다.<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = <span class=\"string\">&quot;kschoi&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = <span class=\"number\">20</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.__proto__ = Test.prototype;</span><br><span class=\"line\">Test.call(obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>하나 눈여겨 볼 부분은 함수의 리턴값에 관련된 부분이다. 만약 함수에 리턴값이 없으면 ‘undefined’가 리턴되지만, 생성자 함수의 경우 생성된 객체를 리턴하게 된다. 하지만, 만약 생성자 함수에서 임의적으로 리턴하는 객체가 존재하게 되면 this를 사용하여 속성값 혹은 매소드를 생성한 객체를 리턴하는 것이 아닌 임의로 지정한 리턴 객체를 반환하게 된다.</p>\n"},{"title":"자바스크립트의 메모리 관리","date":"2016-07-11T15:00:00.000Z","_content":"\n# [자바스크립트의 메모리 관리](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management)\n\n### 개요\n\nC 언어같은 저급 언어는 메모리 관리를 위해 `malloc()` 과 `free()`를 사용한다. 반면, 자바스크립트는 무언가가 생성되었을 때(오브젝트나 문자열 등) 메모리를 할당하고 쓸모 없어졌을 때 '자동으로' free 한다. '자동으로' 라는 말에는 혼란의 여지가 있다. 이는 자바스크립트를 포함한 여러 고급 언어 개발자들에게 메모리 관리가 불가능하다는 인상을 준다. 하지만 실상은 그렇지 않다.  \n\n### 메모리 생존주기\n\n메모리 생존주기는 프로그래밍 언어와 관계없이 비슷하다.\n\n1. 필요할때 할당한다.\n2. 사용한다. (읽기, 쓰기)\n3. 필요없어지면 해제한다. \n\n첫 번째 부분과 두 번째 부분은 모든 언어에서 분명하게 기술되지만 마지막 부분은 조금 다르다. 저급 언어에서는 분명히 기술되지만 자바스크립트 같은 고급 언어에서는 분명하게 기술되지 않는다(역자: 명시적으로 free를 하지 않는다는 의미). \n\n#### 자바스크립트에서 메모리 할당\n\n##### 값 초기화\n\n자바스크립트에서는 프로그래머들이 일일히 메모리 할당을 하는 수고를 덜어주기위해 값을 선언할 때 메모리를 할당한다. \n\n```javascript\nvar n = 123; // 정수를 담기 위한 메모리 할당\nvar s = \"azerty\"; // 문자열을 담기 위한 메모리 할당\n\nvar o = {\n  a: 1,\n  b: null\n}; // 오브젝트와 그 오브젝트에 포함된 값들을 담기 위한 메모리 할당\n\nvar a = [1, null, \"abra\"]; // (오브젝트 처럼) 배열과 배열에 담긴 값들을 위한 메모리 할당\n\nfunction f(a){\n  return a + 2;\n} // 함수를 위한 할당(함수는 '호출가능한' 오브젝트이다)\n\n// 함수식 또한 오브젝트를 담기위한 메모리를 할당한다. \nsomeElement.addEventListener('click', function(){\n  someElement.style.backgroundColor = 'blue';\n}, false);\n```\n\n##### 함수 호출을 통한 할당\n\n몇 가지 함수에서도 메모리 할당이 일어난다. \n\n```javascript\nvar d = new Date(); // Date 개체를 위해 메모리를 할당\nvar e = document.createElement('div'); // DOM 엘리먼트를 위해 메모리를 할당한다.\n```\n\n#### 값 사용\n\n값 사용이란 기본적으로는 할당된 메모리를 읽고 쓰는 것을 의미한다. 변수나 오브젝트 속성 값을 읽고 쓸때 값 사용이 일어난다. 또 함수 호출시 함수에 인수를 넘길때도 일어난다. \n\n#### 할당된 메모리가 더 이상 필요없을 때 해제하기\n\n이 단계에서 대부분의 문제가 발생한다. \"할당된 메모리가 더 이상 필요없을 때\"를 알아내기가 힘들기 때문이다. 이제까지는 개발자들이 메모리가 필요없어질 때를 정하고 free하곤 했다. \n\n고급 언어 인터프리터는 \"가비지 콜렉터\"라는 소프트웨어를 가지고 있다. 가비지 콜렉터란 메모리 할당을 추적하고 할당된 메모리가 더 이상 필요 없어졌을 때 해제하는 작업을 한다. 이 작업은 근사적인 작업이다. 왜냐하면 일반적인 경우에 어떤 메모리가 필요없는지 알아내는 것은 알고리즘으로 풀 수 없는 [비결정적](http://en.wikipedia.org/wiki/Decidability_%28logic%29)인 문제이기 때문이다. \n\n```\n세상에 존재하는 모든 가비지 콜렉터는 안전하지만 완전하지 않다. \n가비지 콜렉터는 항상 필요없어진 메모리만을 해제하지만 모든 필요없어진 메모리를 해제하는건 아니다\n```\n\n### 가비지 콜렉션\n\n위에서 언급한 것처럼 \"더 이상 필요없는\" 모든 메모리를 찾는건 비결정적이다. 따라서 몇 가지 제한을 두어 \"더 이상 필요없는 모든 메모리\"가 아니라 \"더 이상 필요없는 몇몇 메모리\"를 찾아보자. 몇 개의 가비지 콜렉션 알고리즘을 소개하고 한계점을 알아볼 것이다.\n\n#### 참조\n\n가비지 콜렉션 알고리즘의 핵심 개념은 *참조*이다. A라는 메모리를 통해 (명시적이든 암시적이든) B라는 메모리에 접근할 수 있다면 \"B는 A에 참조된다\" 라고 한다. 예를 들어 모든 자바스크립트 오브젝트는 [prototype](https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_and_the_prototype_chain) 을 암시적으로 참조하고 그 오브젝트의 속성을 명시적으로 참조한다.\n\n앞으로 \"오브젝트\"라는 어휘의 의미를 넓혀서 기존의 자바스크립트 오브젝트뿐만 아니라 함수 스코프도 포괄하자.\n\n\n\n#### 참조-세기(Reference-counting) 가비지 콜렉션\n\n참조-세기 알고리즘은 가장 무난한 알고리즘이다. 이 알고리즘은 \"더 이상 필요없는 오브젝트\"를 \"어떤 다른 오브젝트도 참조하지 않는 오브젝트\"라고 정의한다. 어떤 오브젝트를 참조하는 다른 오브젝트가 하나도 없다면 그 오브젝트에 대해 가비지 콜렉션을 수행한다.\n\n##### 예제\n\n```javascript\nvar o = { \n  a: {\n    b:2\n  }\n}; // 2개의 오브젝트가 생성되었다. 하나의 오브젝트는 다른 오브젝트의 속성으로 참조된다.\n// 나머지 하나는 'o' 변수에 할당되었다.\n// 명백하게 가비지 콜렉션 수행될 메모리는 하나도 없다.\n\n\nvar o2 = o; // 'o2' 변수는 위의 오브젝트를 참조하는 두 번째 변수이다.\no = 1; // 이제 'o2' 변수가 위의 오브젝트를 참조하는 유일한 변수가 되었다.\n\nvar oa = o2.a; // 위의 오브젝트의 'a' 속성을 참조했다.\n// 이제 'o2.a'는 두 개의 참조를 가진다. 'o2'가 속성으로 참조하고 'oa'라는 변수가 참조한다.\n\no2 = \"yo\"; // 이제 맨 처음 'o' 변수가 참조했던 오브젝트를 참조하는 오브젝트는 없다(역자: 참조하는 유일한 변수였던 o2에 다른 값을 대입했다)\n// 이제 오브젝트에 가비지 콜렉션이 수행될 수 있을까?\n// 아니다. 오브젝트의 'a' 속성이 여전히 'oa' 변수에 의해 참조되므로 메모리를 해제할 수 없다.\n\noa = null; // 'oa' 변수에 다른 값을 할당했다. 이제 맨 처음 'o' 변수가 참조했던 오브젝트를 참조하는 다른 변수는 없으므로 가비지 콜렉션이 수행된다.\n```\n\n##### 한계: 순환\n\n이 알고리즘은 두 오브젝트가 서로를 참조하면 문제가 발생한다. 두 오브젝트 모두 필요 없어졌더라도 가비지 콜렉션을 수행할 수 없다.\n\n```javascript\nfunction f(){\n  var o = {};\n  var o2 = {};\n  o.a = o2; // o는 o2를 참조한다.\n  o2.a = o; // o2는 o를 참조한다.\n\n  return \"azerty\";\n}\n\nf();\n// 두 오브젝트가 만들어지고 서로를 참조해서 순환이 일어났다.\n// 함수가 종료되고 나면 사실상 두 오브젝트는 의미가 없어지므로 가비지 콜렉션이 수행되어야 한다.\n// 그러나 위의 참조-세기 알고리즘에서는 두 오브젝트 모두 참조를 가지고 있기 때문에 둘 다 가비지 콜렉션이 일어나지 않는다.\n```\n\n##### 실제 예제\n\n인터넷 익스플로러 6, 7 은 DOM 오브젝트에 대해 참조-세기 알고리즘으로 가비지 콜렉션을 수행한다. 흔히, 이 두 브라우저에서는 다음과 같은 패턴의 메모리 누수가 발생한다. \n\n```javascript\nvar div = document.createElement(\"div\");\ndiv.onclick = function(){\n  doSomething();\n}; // div 오브젝트는 이벤트 핸들러를 'onclick' 속성을 통해 참조한다.\n// 이벤트 핸들러의 스코프에도 div 오브젝트가 있으므로 div 오브젝트에 접근할 수 있다. 따라서 이벤트 핸들러도 div 오브젝트를 참조한다.\n// 순환이 발생했고 메모리 누수가 일어난다.\n```\n\n#### 표시하고-쓸기(Mark-and-sweep) 알고리즘\n\n이 알고리즘은 \"더 이상 필요없는 오브젝트\"를 \"닿을 수 없는 오브젝트\"로 정의한다.\n\n이 알고리즘은 *roots* 라는 오브젝트의 집합을 가지고 있다(자바스크립트에서는 전역 변수들을 의미한다). 주기적으로 가비지 콜렉터는 roots로 부터 시작하여 roots가 참조하는 오브젝트들, roots가 참조하는 오브젝트가 참조하는 오브젝트들... 을 *닿을 수 있는 오브젝트*라고 표시한다. 그리고 닿을 수 있는 오브젝트가 아닌 닿을 수 없는 오브젝트에 대해 가비지 콜렉션을 수행한다.\n\n이 알고리즘은 위에서 설명한 참조-세기 알고리즘보다 효율적이다. 왜냐하면 \"참조되지 않는 오브젝트\"는 모두 \"닿을 수 없는 오브젝트\" 이지만 역은 성립하지 않기 때문이다. 위에서 반례인 순환 참조하는 오브젝트들을 설명했다.\n\n2012년 기준으로 모든 최신 브라우저들은 가비지 콜렉션에서 표시하고-쓸기 알고리즘을 사용한다. 지난 몇 년간 연구된 자바스크립트 가비지 콜렉션 알고리즘의 개선들은 모두 이 알고리즘에 대한 것이다. 개선된 알고리즘도 여전히 \"더 이상 필요없는 오브젝트\"를 \"닿을 수 없는 오브젝트\"로 정의하고 있다.\n\n\n\n##### 순환 참조는 이제 문제가 되지 않는다.\n\n첫 번째 예제에서 함수가 리턴되고 나서 두 오브젝트는 닿을 수 없다. 따라서 가비지 콜렉션이 일어난다.\n\n두 번째 예제에서도 마찬가지다. div 변수와 이벤트 핸들러가 roots로 부터 닿을 수 없어지면 순환 참조가 일어났음에도 불구하고 가비지 콜렉션이 일어난다. (역자2: div 선언을 블럭안에다 넣어야 된다.(테스트는 못 해봤다.))\n\n##### 한계: 오브젝트들은 명시적으로 닿을 수 없어져야 한다.\n이 한계가 지적되었지만 실제로는 사람들은 이 문제를 비롯한 가비지 콜렉션에 별 관심이 없다.\n\n\n\n## 더 보기\n\n- [IBM article on \"Memory leak patterns in JavaScript\" (2007)](http://www.ibm.com/developerworks/web/library/wa-memleak/)\n- [Kangax article on how to register event handler and avoid memory leaks (2010)](http://msdn.microsoft.com/en-us/magazine/ff728624.aspx)","source":"_posts/JavaScript/MemoryManagement.md","raw":"---\ntitle: '자바스크립트의 메모리 관리'\ndate: 2016/7/12 00:00:00\ncategories:\n- JavaScript\n---\n\n# [자바스크립트의 메모리 관리](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management)\n\n### 개요\n\nC 언어같은 저급 언어는 메모리 관리를 위해 `malloc()` 과 `free()`를 사용한다. 반면, 자바스크립트는 무언가가 생성되었을 때(오브젝트나 문자열 등) 메모리를 할당하고 쓸모 없어졌을 때 '자동으로' free 한다. '자동으로' 라는 말에는 혼란의 여지가 있다. 이는 자바스크립트를 포함한 여러 고급 언어 개발자들에게 메모리 관리가 불가능하다는 인상을 준다. 하지만 실상은 그렇지 않다.  \n\n### 메모리 생존주기\n\n메모리 생존주기는 프로그래밍 언어와 관계없이 비슷하다.\n\n1. 필요할때 할당한다.\n2. 사용한다. (읽기, 쓰기)\n3. 필요없어지면 해제한다. \n\n첫 번째 부분과 두 번째 부분은 모든 언어에서 분명하게 기술되지만 마지막 부분은 조금 다르다. 저급 언어에서는 분명히 기술되지만 자바스크립트 같은 고급 언어에서는 분명하게 기술되지 않는다(역자: 명시적으로 free를 하지 않는다는 의미). \n\n#### 자바스크립트에서 메모리 할당\n\n##### 값 초기화\n\n자바스크립트에서는 프로그래머들이 일일히 메모리 할당을 하는 수고를 덜어주기위해 값을 선언할 때 메모리를 할당한다. \n\n```javascript\nvar n = 123; // 정수를 담기 위한 메모리 할당\nvar s = \"azerty\"; // 문자열을 담기 위한 메모리 할당\n\nvar o = {\n  a: 1,\n  b: null\n}; // 오브젝트와 그 오브젝트에 포함된 값들을 담기 위한 메모리 할당\n\nvar a = [1, null, \"abra\"]; // (오브젝트 처럼) 배열과 배열에 담긴 값들을 위한 메모리 할당\n\nfunction f(a){\n  return a + 2;\n} // 함수를 위한 할당(함수는 '호출가능한' 오브젝트이다)\n\n// 함수식 또한 오브젝트를 담기위한 메모리를 할당한다. \nsomeElement.addEventListener('click', function(){\n  someElement.style.backgroundColor = 'blue';\n}, false);\n```\n\n##### 함수 호출을 통한 할당\n\n몇 가지 함수에서도 메모리 할당이 일어난다. \n\n```javascript\nvar d = new Date(); // Date 개체를 위해 메모리를 할당\nvar e = document.createElement('div'); // DOM 엘리먼트를 위해 메모리를 할당한다.\n```\n\n#### 값 사용\n\n값 사용이란 기본적으로는 할당된 메모리를 읽고 쓰는 것을 의미한다. 변수나 오브젝트 속성 값을 읽고 쓸때 값 사용이 일어난다. 또 함수 호출시 함수에 인수를 넘길때도 일어난다. \n\n#### 할당된 메모리가 더 이상 필요없을 때 해제하기\n\n이 단계에서 대부분의 문제가 발생한다. \"할당된 메모리가 더 이상 필요없을 때\"를 알아내기가 힘들기 때문이다. 이제까지는 개발자들이 메모리가 필요없어질 때를 정하고 free하곤 했다. \n\n고급 언어 인터프리터는 \"가비지 콜렉터\"라는 소프트웨어를 가지고 있다. 가비지 콜렉터란 메모리 할당을 추적하고 할당된 메모리가 더 이상 필요 없어졌을 때 해제하는 작업을 한다. 이 작업은 근사적인 작업이다. 왜냐하면 일반적인 경우에 어떤 메모리가 필요없는지 알아내는 것은 알고리즘으로 풀 수 없는 [비결정적](http://en.wikipedia.org/wiki/Decidability_%28logic%29)인 문제이기 때문이다. \n\n```\n세상에 존재하는 모든 가비지 콜렉터는 안전하지만 완전하지 않다. \n가비지 콜렉터는 항상 필요없어진 메모리만을 해제하지만 모든 필요없어진 메모리를 해제하는건 아니다\n```\n\n### 가비지 콜렉션\n\n위에서 언급한 것처럼 \"더 이상 필요없는\" 모든 메모리를 찾는건 비결정적이다. 따라서 몇 가지 제한을 두어 \"더 이상 필요없는 모든 메모리\"가 아니라 \"더 이상 필요없는 몇몇 메모리\"를 찾아보자. 몇 개의 가비지 콜렉션 알고리즘을 소개하고 한계점을 알아볼 것이다.\n\n#### 참조\n\n가비지 콜렉션 알고리즘의 핵심 개념은 *참조*이다. A라는 메모리를 통해 (명시적이든 암시적이든) B라는 메모리에 접근할 수 있다면 \"B는 A에 참조된다\" 라고 한다. 예를 들어 모든 자바스크립트 오브젝트는 [prototype](https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_and_the_prototype_chain) 을 암시적으로 참조하고 그 오브젝트의 속성을 명시적으로 참조한다.\n\n앞으로 \"오브젝트\"라는 어휘의 의미를 넓혀서 기존의 자바스크립트 오브젝트뿐만 아니라 함수 스코프도 포괄하자.\n\n\n\n#### 참조-세기(Reference-counting) 가비지 콜렉션\n\n참조-세기 알고리즘은 가장 무난한 알고리즘이다. 이 알고리즘은 \"더 이상 필요없는 오브젝트\"를 \"어떤 다른 오브젝트도 참조하지 않는 오브젝트\"라고 정의한다. 어떤 오브젝트를 참조하는 다른 오브젝트가 하나도 없다면 그 오브젝트에 대해 가비지 콜렉션을 수행한다.\n\n##### 예제\n\n```javascript\nvar o = { \n  a: {\n    b:2\n  }\n}; // 2개의 오브젝트가 생성되었다. 하나의 오브젝트는 다른 오브젝트의 속성으로 참조된다.\n// 나머지 하나는 'o' 변수에 할당되었다.\n// 명백하게 가비지 콜렉션 수행될 메모리는 하나도 없다.\n\n\nvar o2 = o; // 'o2' 변수는 위의 오브젝트를 참조하는 두 번째 변수이다.\no = 1; // 이제 'o2' 변수가 위의 오브젝트를 참조하는 유일한 변수가 되었다.\n\nvar oa = o2.a; // 위의 오브젝트의 'a' 속성을 참조했다.\n// 이제 'o2.a'는 두 개의 참조를 가진다. 'o2'가 속성으로 참조하고 'oa'라는 변수가 참조한다.\n\no2 = \"yo\"; // 이제 맨 처음 'o' 변수가 참조했던 오브젝트를 참조하는 오브젝트는 없다(역자: 참조하는 유일한 변수였던 o2에 다른 값을 대입했다)\n// 이제 오브젝트에 가비지 콜렉션이 수행될 수 있을까?\n// 아니다. 오브젝트의 'a' 속성이 여전히 'oa' 변수에 의해 참조되므로 메모리를 해제할 수 없다.\n\noa = null; // 'oa' 변수에 다른 값을 할당했다. 이제 맨 처음 'o' 변수가 참조했던 오브젝트를 참조하는 다른 변수는 없으므로 가비지 콜렉션이 수행된다.\n```\n\n##### 한계: 순환\n\n이 알고리즘은 두 오브젝트가 서로를 참조하면 문제가 발생한다. 두 오브젝트 모두 필요 없어졌더라도 가비지 콜렉션을 수행할 수 없다.\n\n```javascript\nfunction f(){\n  var o = {};\n  var o2 = {};\n  o.a = o2; // o는 o2를 참조한다.\n  o2.a = o; // o2는 o를 참조한다.\n\n  return \"azerty\";\n}\n\nf();\n// 두 오브젝트가 만들어지고 서로를 참조해서 순환이 일어났다.\n// 함수가 종료되고 나면 사실상 두 오브젝트는 의미가 없어지므로 가비지 콜렉션이 수행되어야 한다.\n// 그러나 위의 참조-세기 알고리즘에서는 두 오브젝트 모두 참조를 가지고 있기 때문에 둘 다 가비지 콜렉션이 일어나지 않는다.\n```\n\n##### 실제 예제\n\n인터넷 익스플로러 6, 7 은 DOM 오브젝트에 대해 참조-세기 알고리즘으로 가비지 콜렉션을 수행한다. 흔히, 이 두 브라우저에서는 다음과 같은 패턴의 메모리 누수가 발생한다. \n\n```javascript\nvar div = document.createElement(\"div\");\ndiv.onclick = function(){\n  doSomething();\n}; // div 오브젝트는 이벤트 핸들러를 'onclick' 속성을 통해 참조한다.\n// 이벤트 핸들러의 스코프에도 div 오브젝트가 있으므로 div 오브젝트에 접근할 수 있다. 따라서 이벤트 핸들러도 div 오브젝트를 참조한다.\n// 순환이 발생했고 메모리 누수가 일어난다.\n```\n\n#### 표시하고-쓸기(Mark-and-sweep) 알고리즘\n\n이 알고리즘은 \"더 이상 필요없는 오브젝트\"를 \"닿을 수 없는 오브젝트\"로 정의한다.\n\n이 알고리즘은 *roots* 라는 오브젝트의 집합을 가지고 있다(자바스크립트에서는 전역 변수들을 의미한다). 주기적으로 가비지 콜렉터는 roots로 부터 시작하여 roots가 참조하는 오브젝트들, roots가 참조하는 오브젝트가 참조하는 오브젝트들... 을 *닿을 수 있는 오브젝트*라고 표시한다. 그리고 닿을 수 있는 오브젝트가 아닌 닿을 수 없는 오브젝트에 대해 가비지 콜렉션을 수행한다.\n\n이 알고리즘은 위에서 설명한 참조-세기 알고리즘보다 효율적이다. 왜냐하면 \"참조되지 않는 오브젝트\"는 모두 \"닿을 수 없는 오브젝트\" 이지만 역은 성립하지 않기 때문이다. 위에서 반례인 순환 참조하는 오브젝트들을 설명했다.\n\n2012년 기준으로 모든 최신 브라우저들은 가비지 콜렉션에서 표시하고-쓸기 알고리즘을 사용한다. 지난 몇 년간 연구된 자바스크립트 가비지 콜렉션 알고리즘의 개선들은 모두 이 알고리즘에 대한 것이다. 개선된 알고리즘도 여전히 \"더 이상 필요없는 오브젝트\"를 \"닿을 수 없는 오브젝트\"로 정의하고 있다.\n\n\n\n##### 순환 참조는 이제 문제가 되지 않는다.\n\n첫 번째 예제에서 함수가 리턴되고 나서 두 오브젝트는 닿을 수 없다. 따라서 가비지 콜렉션이 일어난다.\n\n두 번째 예제에서도 마찬가지다. div 변수와 이벤트 핸들러가 roots로 부터 닿을 수 없어지면 순환 참조가 일어났음에도 불구하고 가비지 콜렉션이 일어난다. (역자2: div 선언을 블럭안에다 넣어야 된다.(테스트는 못 해봤다.))\n\n##### 한계: 오브젝트들은 명시적으로 닿을 수 없어져야 한다.\n이 한계가 지적되었지만 실제로는 사람들은 이 문제를 비롯한 가비지 콜렉션에 별 관심이 없다.\n\n\n\n## 더 보기\n\n- [IBM article on \"Memory leak patterns in JavaScript\" (2007)](http://www.ibm.com/developerworks/web/library/wa-memleak/)\n- [Kangax article on how to register event handler and avoid memory leaks (2010)](http://msdn.microsoft.com/en-us/magazine/ff728624.aspx)","slug":"JavaScript/MemoryManagement","published":1,"updated":"2021-08-02T12:28:20.977Z","_id":"ckrsup50d0013tjhvg3694i6h","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"자바스크립트의-메모리-관리\"><a href=\"#자바스크립트의-메모리-관리\" class=\"headerlink\" title=\"자바스크립트의 메모리 관리\"></a><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management\">자바스크립트의 메모리 관리</a></h1><h3 id=\"개요\"><a href=\"#개요\" class=\"headerlink\" title=\"개요\"></a>개요</h3><p>C 언어같은 저급 언어는 메모리 관리를 위해 <code>malloc()</code> 과 <code>free()</code>를 사용한다. 반면, 자바스크립트는 무언가가 생성되었을 때(오브젝트나 문자열 등) 메모리를 할당하고 쓸모 없어졌을 때 ‘자동으로’ free 한다. ‘자동으로’ 라는 말에는 혼란의 여지가 있다. 이는 자바스크립트를 포함한 여러 고급 언어 개발자들에게 메모리 관리가 불가능하다는 인상을 준다. 하지만 실상은 그렇지 않다.  </p>\n<h3 id=\"메모리-생존주기\"><a href=\"#메모리-생존주기\" class=\"headerlink\" title=\"메모리 생존주기\"></a>메모리 생존주기</h3><p>메모리 생존주기는 프로그래밍 언어와 관계없이 비슷하다.</p>\n<ol>\n<li>필요할때 할당한다.</li>\n<li>사용한다. (읽기, 쓰기)</li>\n<li>필요없어지면 해제한다. </li>\n</ol>\n<p>첫 번째 부분과 두 번째 부분은 모든 언어에서 분명하게 기술되지만 마지막 부분은 조금 다르다. 저급 언어에서는 분명히 기술되지만 자바스크립트 같은 고급 언어에서는 분명하게 기술되지 않는다(역자: 명시적으로 free를 하지 않는다는 의미). </p>\n<h4 id=\"자바스크립트에서-메모리-할당\"><a href=\"#자바스크립트에서-메모리-할당\" class=\"headerlink\" title=\"자바스크립트에서 메모리 할당\"></a>자바스크립트에서 메모리 할당</h4><h5 id=\"값-초기화\"><a href=\"#값-초기화\" class=\"headerlink\" title=\"값 초기화\"></a>값 초기화</h5><p>자바스크립트에서는 프로그래머들이 일일히 메모리 할당을 하는 수고를 덜어주기위해 값을 선언할 때 메모리를 할당한다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">123</span>; <span class=\"comment\">// 정수를 담기 위한 메모리 할당</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">&quot;azerty&quot;</span>; <span class=\"comment\">// 문자열을 담기 위한 메모리 할당</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;; <span class=\"comment\">// 오브젝트와 그 오브젝트에 포함된 값들을 담기 위한 메모리 할당</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"literal\">null</span>, <span class=\"string\">&quot;abra&quot;</span>]; <span class=\"comment\">// (오브젝트 처럼) 배열과 배열에 담긴 값들을 위한 메모리 할당</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 함수를 위한 할당(함수는 &#x27;호출가능한&#x27; 오브젝트이다)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 함수식 또한 오브젝트를 담기위한 메모리를 할당한다. </span></span><br><span class=\"line\">someElement.addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  someElement.style.backgroundColor = <span class=\"string\">&#x27;blue&#x27;</span>;</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"함수-호출을-통한-할당\"><a href=\"#함수-호출을-통한-할당\" class=\"headerlink\" title=\"함수 호출을 통한 할당\"></a>함수 호출을 통한 할당</h5><p>몇 가지 함수에서도 메모리 할당이 일어난다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); <span class=\"comment\">// Date 개체를 위해 메모리를 할당</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> e = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;div&#x27;</span>); <span class=\"comment\">// DOM 엘리먼트를 위해 메모리를 할당한다.</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"값-사용\"><a href=\"#값-사용\" class=\"headerlink\" title=\"값 사용\"></a>값 사용</h4><p>값 사용이란 기본적으로는 할당된 메모리를 읽고 쓰는 것을 의미한다. 변수나 오브젝트 속성 값을 읽고 쓸때 값 사용이 일어난다. 또 함수 호출시 함수에 인수를 넘길때도 일어난다. </p>\n<h4 id=\"할당된-메모리가-더-이상-필요없을-때-해제하기\"><a href=\"#할당된-메모리가-더-이상-필요없을-때-해제하기\" class=\"headerlink\" title=\"할당된 메모리가 더 이상 필요없을 때 해제하기\"></a>할당된 메모리가 더 이상 필요없을 때 해제하기</h4><p>이 단계에서 대부분의 문제가 발생한다. “할당된 메모리가 더 이상 필요없을 때”를 알아내기가 힘들기 때문이다. 이제까지는 개발자들이 메모리가 필요없어질 때를 정하고 free하곤 했다. </p>\n<p>고급 언어 인터프리터는 “가비지 콜렉터”라는 소프트웨어를 가지고 있다. 가비지 콜렉터란 메모리 할당을 추적하고 할당된 메모리가 더 이상 필요 없어졌을 때 해제하는 작업을 한다. 이 작업은 근사적인 작업이다. 왜냐하면 일반적인 경우에 어떤 메모리가 필요없는지 알아내는 것은 알고리즘으로 풀 수 없는 <a href=\"http://en.wikipedia.org/wiki/Decidability_%28logic%29\">비결정적</a>인 문제이기 때문이다. </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">세상에 존재하는 모든 가비지 콜렉터는 안전하지만 완전하지 않다. </span><br><span class=\"line\">가비지 콜렉터는 항상 필요없어진 메모리만을 해제하지만 모든 필요없어진 메모리를 해제하는건 아니다</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"가비지-콜렉션\"><a href=\"#가비지-콜렉션\" class=\"headerlink\" title=\"가비지 콜렉션\"></a>가비지 콜렉션</h3><p>위에서 언급한 것처럼 “더 이상 필요없는” 모든 메모리를 찾는건 비결정적이다. 따라서 몇 가지 제한을 두어 “더 이상 필요없는 모든 메모리”가 아니라 “더 이상 필요없는 몇몇 메모리”를 찾아보자. 몇 개의 가비지 콜렉션 알고리즘을 소개하고 한계점을 알아볼 것이다.</p>\n<h4 id=\"참조\"><a href=\"#참조\" class=\"headerlink\" title=\"참조\"></a>참조</h4><p>가비지 콜렉션 알고리즘의 핵심 개념은 <em>참조</em>이다. A라는 메모리를 통해 (명시적이든 암시적이든) B라는 메모리에 접근할 수 있다면 “B는 A에 참조된다” 라고 한다. 예를 들어 모든 자바스크립트 오브젝트는 <a href=\"https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_and_the_prototype_chain\">prototype</a> 을 암시적으로 참조하고 그 오브젝트의 속성을 명시적으로 참조한다.</p>\n<p>앞으로 “오브젝트”라는 어휘의 의미를 넓혀서 기존의 자바스크립트 오브젝트뿐만 아니라 함수 스코프도 포괄하자.</p>\n<h4 id=\"참조-세기-Reference-counting-가비지-콜렉션\"><a href=\"#참조-세기-Reference-counting-가비지-콜렉션\" class=\"headerlink\" title=\"참조-세기(Reference-counting) 가비지 콜렉션\"></a>참조-세기(Reference-counting) 가비지 콜렉션</h4><p>참조-세기 알고리즘은 가장 무난한 알고리즘이다. 이 알고리즘은 “더 이상 필요없는 오브젝트”를 “어떤 다른 오브젝트도 참조하지 않는 오브젝트”라고 정의한다. 어떤 오브젝트를 참조하는 다른 오브젝트가 하나도 없다면 그 오브젝트에 대해 가비지 콜렉션을 수행한다.</p>\n<h5 id=\"예제\"><a href=\"#예제\" class=\"headerlink\" title=\"예제\"></a>예제</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; </span><br><span class=\"line\">  <span class=\"attr\">a</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>:<span class=\"number\">2</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;; <span class=\"comment\">// 2개의 오브젝트가 생성되었다. 하나의 오브젝트는 다른 오브젝트의 속성으로 참조된다.</span></span><br><span class=\"line\"><span class=\"comment\">// 나머지 하나는 &#x27;o&#x27; 변수에 할당되었다.</span></span><br><span class=\"line\"><span class=\"comment\">// 명백하게 가비지 콜렉션 수행될 메모리는 하나도 없다.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o2 = o; <span class=\"comment\">// &#x27;o2&#x27; 변수는 위의 오브젝트를 참조하는 두 번째 변수이다.</span></span><br><span class=\"line\">o = <span class=\"number\">1</span>; <span class=\"comment\">// 이제 &#x27;o2&#x27; 변수가 위의 오브젝트를 참조하는 유일한 변수가 되었다.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> oa = o2.a; <span class=\"comment\">// 위의 오브젝트의 &#x27;a&#x27; 속성을 참조했다.</span></span><br><span class=\"line\"><span class=\"comment\">// 이제 &#x27;o2.a&#x27;는 두 개의 참조를 가진다. &#x27;o2&#x27;가 속성으로 참조하고 &#x27;oa&#x27;라는 변수가 참조한다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">o2 = <span class=\"string\">&quot;yo&quot;</span>; <span class=\"comment\">// 이제 맨 처음 &#x27;o&#x27; 변수가 참조했던 오브젝트를 참조하는 오브젝트는 없다(역자: 참조하는 유일한 변수였던 o2에 다른 값을 대입했다)</span></span><br><span class=\"line\"><span class=\"comment\">// 이제 오브젝트에 가비지 콜렉션이 수행될 수 있을까?</span></span><br><span class=\"line\"><span class=\"comment\">// 아니다. 오브젝트의 &#x27;a&#x27; 속성이 여전히 &#x27;oa&#x27; 변수에 의해 참조되므로 메모리를 해제할 수 없다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">oa = <span class=\"literal\">null</span>; <span class=\"comment\">// &#x27;oa&#x27; 변수에 다른 값을 할당했다. 이제 맨 처음 &#x27;o&#x27; 변수가 참조했던 오브젝트를 참조하는 다른 변수는 없으므로 가비지 콜렉션이 수행된다.</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"한계-순환\"><a href=\"#한계-순환\" class=\"headerlink\" title=\"한계: 순환\"></a>한계: 순환</h5><p>이 알고리즘은 두 오브젝트가 서로를 참조하면 문제가 발생한다. 두 오브젝트 모두 필요 없어졌더라도 가비지 콜렉션을 수행할 수 없다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o2 = &#123;&#125;;</span><br><span class=\"line\">  o.a = o2; <span class=\"comment\">// o는 o2를 참조한다.</span></span><br><span class=\"line\">  o2.a = o; <span class=\"comment\">// o2는 o를 참조한다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;azerty&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f();</span><br><span class=\"line\"><span class=\"comment\">// 두 오브젝트가 만들어지고 서로를 참조해서 순환이 일어났다.</span></span><br><span class=\"line\"><span class=\"comment\">// 함수가 종료되고 나면 사실상 두 오브젝트는 의미가 없어지므로 가비지 콜렉션이 수행되어야 한다.</span></span><br><span class=\"line\"><span class=\"comment\">// 그러나 위의 참조-세기 알고리즘에서는 두 오브젝트 모두 참조를 가지고 있기 때문에 둘 다 가비지 콜렉션이 일어나지 않는다.</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"실제-예제\"><a href=\"#실제-예제\" class=\"headerlink\" title=\"실제 예제\"></a>실제 예제</h5><p>인터넷 익스플로러 6, 7 은 DOM 오브젝트에 대해 참조-세기 알고리즘으로 가비지 콜렉션을 수행한다. 흔히, 이 두 브라우저에서는 다음과 같은 패턴의 메모리 누수가 발생한다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;div&quot;</span>);</span><br><span class=\"line\">div.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  doSomething();</span><br><span class=\"line\">&#125;; <span class=\"comment\">// div 오브젝트는 이벤트 핸들러를 &#x27;onclick&#x27; 속성을 통해 참조한다.</span></span><br><span class=\"line\"><span class=\"comment\">// 이벤트 핸들러의 스코프에도 div 오브젝트가 있으므로 div 오브젝트에 접근할 수 있다. 따라서 이벤트 핸들러도 div 오브젝트를 참조한다.</span></span><br><span class=\"line\"><span class=\"comment\">// 순환이 발생했고 메모리 누수가 일어난다.</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"표시하고-쓸기-Mark-and-sweep-알고리즘\"><a href=\"#표시하고-쓸기-Mark-and-sweep-알고리즘\" class=\"headerlink\" title=\"표시하고-쓸기(Mark-and-sweep) 알고리즘\"></a>표시하고-쓸기(Mark-and-sweep) 알고리즘</h4><p>이 알고리즘은 “더 이상 필요없는 오브젝트”를 “닿을 수 없는 오브젝트”로 정의한다.</p>\n<p>이 알고리즘은 <em>roots</em> 라는 오브젝트의 집합을 가지고 있다(자바스크립트에서는 전역 변수들을 의미한다). 주기적으로 가비지 콜렉터는 roots로 부터 시작하여 roots가 참조하는 오브젝트들, roots가 참조하는 오브젝트가 참조하는 오브젝트들… 을 <em>닿을 수 있는 오브젝트</em>라고 표시한다. 그리고 닿을 수 있는 오브젝트가 아닌 닿을 수 없는 오브젝트에 대해 가비지 콜렉션을 수행한다.</p>\n<p>이 알고리즘은 위에서 설명한 참조-세기 알고리즘보다 효율적이다. 왜냐하면 “참조되지 않는 오브젝트”는 모두 “닿을 수 없는 오브젝트” 이지만 역은 성립하지 않기 때문이다. 위에서 반례인 순환 참조하는 오브젝트들을 설명했다.</p>\n<p>2012년 기준으로 모든 최신 브라우저들은 가비지 콜렉션에서 표시하고-쓸기 알고리즘을 사용한다. 지난 몇 년간 연구된 자바스크립트 가비지 콜렉션 알고리즘의 개선들은 모두 이 알고리즘에 대한 것이다. 개선된 알고리즘도 여전히 “더 이상 필요없는 오브젝트”를 “닿을 수 없는 오브젝트”로 정의하고 있다.</p>\n<h5 id=\"순환-참조는-이제-문제가-되지-않는다\"><a href=\"#순환-참조는-이제-문제가-되지-않는다\" class=\"headerlink\" title=\"순환 참조는 이제 문제가 되지 않는다.\"></a>순환 참조는 이제 문제가 되지 않는다.</h5><p>첫 번째 예제에서 함수가 리턴되고 나서 두 오브젝트는 닿을 수 없다. 따라서 가비지 콜렉션이 일어난다.</p>\n<p>두 번째 예제에서도 마찬가지다. div 변수와 이벤트 핸들러가 roots로 부터 닿을 수 없어지면 순환 참조가 일어났음에도 불구하고 가비지 콜렉션이 일어난다. (역자2: div 선언을 블럭안에다 넣어야 된다.(테스트는 못 해봤다.))</p>\n<h5 id=\"한계-오브젝트들은-명시적으로-닿을-수-없어져야-한다\"><a href=\"#한계-오브젝트들은-명시적으로-닿을-수-없어져야-한다\" class=\"headerlink\" title=\"한계: 오브젝트들은 명시적으로 닿을 수 없어져야 한다.\"></a>한계: 오브젝트들은 명시적으로 닿을 수 없어져야 한다.</h5><p>이 한계가 지적되었지만 실제로는 사람들은 이 문제를 비롯한 가비지 콜렉션에 별 관심이 없다.</p>\n<h2 id=\"더-보기\"><a href=\"#더-보기\" class=\"headerlink\" title=\"더 보기\"></a>더 보기</h2><ul>\n<li><a href=\"http://www.ibm.com/developerworks/web/library/wa-memleak/\">IBM article on “Memory leak patterns in JavaScript” (2007)</a></li>\n<li><a href=\"http://msdn.microsoft.com/en-us/magazine/ff728624.aspx\">Kangax article on how to register event handler and avoid memory leaks (2010)</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"자바스크립트의-메모리-관리\"><a href=\"#자바스크립트의-메모리-관리\" class=\"headerlink\" title=\"자바스크립트의 메모리 관리\"></a><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management\">자바스크립트의 메모리 관리</a></h1><h3 id=\"개요\"><a href=\"#개요\" class=\"headerlink\" title=\"개요\"></a>개요</h3><p>C 언어같은 저급 언어는 메모리 관리를 위해 <code>malloc()</code> 과 <code>free()</code>를 사용한다. 반면, 자바스크립트는 무언가가 생성되었을 때(오브젝트나 문자열 등) 메모리를 할당하고 쓸모 없어졌을 때 ‘자동으로’ free 한다. ‘자동으로’ 라는 말에는 혼란의 여지가 있다. 이는 자바스크립트를 포함한 여러 고급 언어 개발자들에게 메모리 관리가 불가능하다는 인상을 준다. 하지만 실상은 그렇지 않다.  </p>\n<h3 id=\"메모리-생존주기\"><a href=\"#메모리-생존주기\" class=\"headerlink\" title=\"메모리 생존주기\"></a>메모리 생존주기</h3><p>메모리 생존주기는 프로그래밍 언어와 관계없이 비슷하다.</p>\n<ol>\n<li>필요할때 할당한다.</li>\n<li>사용한다. (읽기, 쓰기)</li>\n<li>필요없어지면 해제한다. </li>\n</ol>\n<p>첫 번째 부분과 두 번째 부분은 모든 언어에서 분명하게 기술되지만 마지막 부분은 조금 다르다. 저급 언어에서는 분명히 기술되지만 자바스크립트 같은 고급 언어에서는 분명하게 기술되지 않는다(역자: 명시적으로 free를 하지 않는다는 의미). </p>\n<h4 id=\"자바스크립트에서-메모리-할당\"><a href=\"#자바스크립트에서-메모리-할당\" class=\"headerlink\" title=\"자바스크립트에서 메모리 할당\"></a>자바스크립트에서 메모리 할당</h4><h5 id=\"값-초기화\"><a href=\"#값-초기화\" class=\"headerlink\" title=\"값 초기화\"></a>값 초기화</h5><p>자바스크립트에서는 프로그래머들이 일일히 메모리 할당을 하는 수고를 덜어주기위해 값을 선언할 때 메모리를 할당한다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">123</span>; <span class=\"comment\">// 정수를 담기 위한 메모리 할당</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">&quot;azerty&quot;</span>; <span class=\"comment\">// 문자열을 담기 위한 메모리 할당</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;; <span class=\"comment\">// 오브젝트와 그 오브젝트에 포함된 값들을 담기 위한 메모리 할당</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"literal\">null</span>, <span class=\"string\">&quot;abra&quot;</span>]; <span class=\"comment\">// (오브젝트 처럼) 배열과 배열에 담긴 값들을 위한 메모리 할당</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 함수를 위한 할당(함수는 &#x27;호출가능한&#x27; 오브젝트이다)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 함수식 또한 오브젝트를 담기위한 메모리를 할당한다. </span></span><br><span class=\"line\">someElement.addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  someElement.style.backgroundColor = <span class=\"string\">&#x27;blue&#x27;</span>;</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"함수-호출을-통한-할당\"><a href=\"#함수-호출을-통한-할당\" class=\"headerlink\" title=\"함수 호출을 통한 할당\"></a>함수 호출을 통한 할당</h5><p>몇 가지 함수에서도 메모리 할당이 일어난다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); <span class=\"comment\">// Date 개체를 위해 메모리를 할당</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> e = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;div&#x27;</span>); <span class=\"comment\">// DOM 엘리먼트를 위해 메모리를 할당한다.</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"값-사용\"><a href=\"#값-사용\" class=\"headerlink\" title=\"값 사용\"></a>값 사용</h4><p>값 사용이란 기본적으로는 할당된 메모리를 읽고 쓰는 것을 의미한다. 변수나 오브젝트 속성 값을 읽고 쓸때 값 사용이 일어난다. 또 함수 호출시 함수에 인수를 넘길때도 일어난다. </p>\n<h4 id=\"할당된-메모리가-더-이상-필요없을-때-해제하기\"><a href=\"#할당된-메모리가-더-이상-필요없을-때-해제하기\" class=\"headerlink\" title=\"할당된 메모리가 더 이상 필요없을 때 해제하기\"></a>할당된 메모리가 더 이상 필요없을 때 해제하기</h4><p>이 단계에서 대부분의 문제가 발생한다. “할당된 메모리가 더 이상 필요없을 때”를 알아내기가 힘들기 때문이다. 이제까지는 개발자들이 메모리가 필요없어질 때를 정하고 free하곤 했다. </p>\n<p>고급 언어 인터프리터는 “가비지 콜렉터”라는 소프트웨어를 가지고 있다. 가비지 콜렉터란 메모리 할당을 추적하고 할당된 메모리가 더 이상 필요 없어졌을 때 해제하는 작업을 한다. 이 작업은 근사적인 작업이다. 왜냐하면 일반적인 경우에 어떤 메모리가 필요없는지 알아내는 것은 알고리즘으로 풀 수 없는 <a href=\"http://en.wikipedia.org/wiki/Decidability_%28logic%29\">비결정적</a>인 문제이기 때문이다. </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">세상에 존재하는 모든 가비지 콜렉터는 안전하지만 완전하지 않다. </span><br><span class=\"line\">가비지 콜렉터는 항상 필요없어진 메모리만을 해제하지만 모든 필요없어진 메모리를 해제하는건 아니다</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"가비지-콜렉션\"><a href=\"#가비지-콜렉션\" class=\"headerlink\" title=\"가비지 콜렉션\"></a>가비지 콜렉션</h3><p>위에서 언급한 것처럼 “더 이상 필요없는” 모든 메모리를 찾는건 비결정적이다. 따라서 몇 가지 제한을 두어 “더 이상 필요없는 모든 메모리”가 아니라 “더 이상 필요없는 몇몇 메모리”를 찾아보자. 몇 개의 가비지 콜렉션 알고리즘을 소개하고 한계점을 알아볼 것이다.</p>\n<h4 id=\"참조\"><a href=\"#참조\" class=\"headerlink\" title=\"참조\"></a>참조</h4><p>가비지 콜렉션 알고리즘의 핵심 개념은 <em>참조</em>이다. A라는 메모리를 통해 (명시적이든 암시적이든) B라는 메모리에 접근할 수 있다면 “B는 A에 참조된다” 라고 한다. 예를 들어 모든 자바스크립트 오브젝트는 <a href=\"https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_and_the_prototype_chain\">prototype</a> 을 암시적으로 참조하고 그 오브젝트의 속성을 명시적으로 참조한다.</p>\n<p>앞으로 “오브젝트”라는 어휘의 의미를 넓혀서 기존의 자바스크립트 오브젝트뿐만 아니라 함수 스코프도 포괄하자.</p>\n<h4 id=\"참조-세기-Reference-counting-가비지-콜렉션\"><a href=\"#참조-세기-Reference-counting-가비지-콜렉션\" class=\"headerlink\" title=\"참조-세기(Reference-counting) 가비지 콜렉션\"></a>참조-세기(Reference-counting) 가비지 콜렉션</h4><p>참조-세기 알고리즘은 가장 무난한 알고리즘이다. 이 알고리즘은 “더 이상 필요없는 오브젝트”를 “어떤 다른 오브젝트도 참조하지 않는 오브젝트”라고 정의한다. 어떤 오브젝트를 참조하는 다른 오브젝트가 하나도 없다면 그 오브젝트에 대해 가비지 콜렉션을 수행한다.</p>\n<h5 id=\"예제\"><a href=\"#예제\" class=\"headerlink\" title=\"예제\"></a>예제</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; </span><br><span class=\"line\">  <span class=\"attr\">a</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>:<span class=\"number\">2</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;; <span class=\"comment\">// 2개의 오브젝트가 생성되었다. 하나의 오브젝트는 다른 오브젝트의 속성으로 참조된다.</span></span><br><span class=\"line\"><span class=\"comment\">// 나머지 하나는 &#x27;o&#x27; 변수에 할당되었다.</span></span><br><span class=\"line\"><span class=\"comment\">// 명백하게 가비지 콜렉션 수행될 메모리는 하나도 없다.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o2 = o; <span class=\"comment\">// &#x27;o2&#x27; 변수는 위의 오브젝트를 참조하는 두 번째 변수이다.</span></span><br><span class=\"line\">o = <span class=\"number\">1</span>; <span class=\"comment\">// 이제 &#x27;o2&#x27; 변수가 위의 오브젝트를 참조하는 유일한 변수가 되었다.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> oa = o2.a; <span class=\"comment\">// 위의 오브젝트의 &#x27;a&#x27; 속성을 참조했다.</span></span><br><span class=\"line\"><span class=\"comment\">// 이제 &#x27;o2.a&#x27;는 두 개의 참조를 가진다. &#x27;o2&#x27;가 속성으로 참조하고 &#x27;oa&#x27;라는 변수가 참조한다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">o2 = <span class=\"string\">&quot;yo&quot;</span>; <span class=\"comment\">// 이제 맨 처음 &#x27;o&#x27; 변수가 참조했던 오브젝트를 참조하는 오브젝트는 없다(역자: 참조하는 유일한 변수였던 o2에 다른 값을 대입했다)</span></span><br><span class=\"line\"><span class=\"comment\">// 이제 오브젝트에 가비지 콜렉션이 수행될 수 있을까?</span></span><br><span class=\"line\"><span class=\"comment\">// 아니다. 오브젝트의 &#x27;a&#x27; 속성이 여전히 &#x27;oa&#x27; 변수에 의해 참조되므로 메모리를 해제할 수 없다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">oa = <span class=\"literal\">null</span>; <span class=\"comment\">// &#x27;oa&#x27; 변수에 다른 값을 할당했다. 이제 맨 처음 &#x27;o&#x27; 변수가 참조했던 오브젝트를 참조하는 다른 변수는 없으므로 가비지 콜렉션이 수행된다.</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"한계-순환\"><a href=\"#한계-순환\" class=\"headerlink\" title=\"한계: 순환\"></a>한계: 순환</h5><p>이 알고리즘은 두 오브젝트가 서로를 참조하면 문제가 발생한다. 두 오브젝트 모두 필요 없어졌더라도 가비지 콜렉션을 수행할 수 없다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o2 = &#123;&#125;;</span><br><span class=\"line\">  o.a = o2; <span class=\"comment\">// o는 o2를 참조한다.</span></span><br><span class=\"line\">  o2.a = o; <span class=\"comment\">// o2는 o를 참조한다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;azerty&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f();</span><br><span class=\"line\"><span class=\"comment\">// 두 오브젝트가 만들어지고 서로를 참조해서 순환이 일어났다.</span></span><br><span class=\"line\"><span class=\"comment\">// 함수가 종료되고 나면 사실상 두 오브젝트는 의미가 없어지므로 가비지 콜렉션이 수행되어야 한다.</span></span><br><span class=\"line\"><span class=\"comment\">// 그러나 위의 참조-세기 알고리즘에서는 두 오브젝트 모두 참조를 가지고 있기 때문에 둘 다 가비지 콜렉션이 일어나지 않는다.</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"실제-예제\"><a href=\"#실제-예제\" class=\"headerlink\" title=\"실제 예제\"></a>실제 예제</h5><p>인터넷 익스플로러 6, 7 은 DOM 오브젝트에 대해 참조-세기 알고리즘으로 가비지 콜렉션을 수행한다. 흔히, 이 두 브라우저에서는 다음과 같은 패턴의 메모리 누수가 발생한다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;div&quot;</span>);</span><br><span class=\"line\">div.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  doSomething();</span><br><span class=\"line\">&#125;; <span class=\"comment\">// div 오브젝트는 이벤트 핸들러를 &#x27;onclick&#x27; 속성을 통해 참조한다.</span></span><br><span class=\"line\"><span class=\"comment\">// 이벤트 핸들러의 스코프에도 div 오브젝트가 있으므로 div 오브젝트에 접근할 수 있다. 따라서 이벤트 핸들러도 div 오브젝트를 참조한다.</span></span><br><span class=\"line\"><span class=\"comment\">// 순환이 발생했고 메모리 누수가 일어난다.</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"표시하고-쓸기-Mark-and-sweep-알고리즘\"><a href=\"#표시하고-쓸기-Mark-and-sweep-알고리즘\" class=\"headerlink\" title=\"표시하고-쓸기(Mark-and-sweep) 알고리즘\"></a>표시하고-쓸기(Mark-and-sweep) 알고리즘</h4><p>이 알고리즘은 “더 이상 필요없는 오브젝트”를 “닿을 수 없는 오브젝트”로 정의한다.</p>\n<p>이 알고리즘은 <em>roots</em> 라는 오브젝트의 집합을 가지고 있다(자바스크립트에서는 전역 변수들을 의미한다). 주기적으로 가비지 콜렉터는 roots로 부터 시작하여 roots가 참조하는 오브젝트들, roots가 참조하는 오브젝트가 참조하는 오브젝트들… 을 <em>닿을 수 있는 오브젝트</em>라고 표시한다. 그리고 닿을 수 있는 오브젝트가 아닌 닿을 수 없는 오브젝트에 대해 가비지 콜렉션을 수행한다.</p>\n<p>이 알고리즘은 위에서 설명한 참조-세기 알고리즘보다 효율적이다. 왜냐하면 “참조되지 않는 오브젝트”는 모두 “닿을 수 없는 오브젝트” 이지만 역은 성립하지 않기 때문이다. 위에서 반례인 순환 참조하는 오브젝트들을 설명했다.</p>\n<p>2012년 기준으로 모든 최신 브라우저들은 가비지 콜렉션에서 표시하고-쓸기 알고리즘을 사용한다. 지난 몇 년간 연구된 자바스크립트 가비지 콜렉션 알고리즘의 개선들은 모두 이 알고리즘에 대한 것이다. 개선된 알고리즘도 여전히 “더 이상 필요없는 오브젝트”를 “닿을 수 없는 오브젝트”로 정의하고 있다.</p>\n<h5 id=\"순환-참조는-이제-문제가-되지-않는다\"><a href=\"#순환-참조는-이제-문제가-되지-않는다\" class=\"headerlink\" title=\"순환 참조는 이제 문제가 되지 않는다.\"></a>순환 참조는 이제 문제가 되지 않는다.</h5><p>첫 번째 예제에서 함수가 리턴되고 나서 두 오브젝트는 닿을 수 없다. 따라서 가비지 콜렉션이 일어난다.</p>\n<p>두 번째 예제에서도 마찬가지다. div 변수와 이벤트 핸들러가 roots로 부터 닿을 수 없어지면 순환 참조가 일어났음에도 불구하고 가비지 콜렉션이 일어난다. (역자2: div 선언을 블럭안에다 넣어야 된다.(테스트는 못 해봤다.))</p>\n<h5 id=\"한계-오브젝트들은-명시적으로-닿을-수-없어져야-한다\"><a href=\"#한계-오브젝트들은-명시적으로-닿을-수-없어져야-한다\" class=\"headerlink\" title=\"한계: 오브젝트들은 명시적으로 닿을 수 없어져야 한다.\"></a>한계: 오브젝트들은 명시적으로 닿을 수 없어져야 한다.</h5><p>이 한계가 지적되었지만 실제로는 사람들은 이 문제를 비롯한 가비지 콜렉션에 별 관심이 없다.</p>\n<h2 id=\"더-보기\"><a href=\"#더-보기\" class=\"headerlink\" title=\"더 보기\"></a>더 보기</h2><ul>\n<li><a href=\"http://www.ibm.com/developerworks/web/library/wa-memleak/\">IBM article on “Memory leak patterns in JavaScript” (2007)</a></li>\n<li><a href=\"http://msdn.microsoft.com/en-us/magazine/ff728624.aspx\">Kangax article on how to register event handler and avoid memory leaks (2010)</a></li>\n</ul>\n"},{"title":"[ES6] - let/const","date":"2016-07-11T15:00:00.000Z","_content":"\n# [ES6] - let/const\n## let 키워드 사용 : 블록 스코프 변수 생성\n자바스크립트 기본적으로 함수 단위의 스코프를 제공하고 있는데, 다른 언어들과는 다른 부분이기 때문에 이러한 특징을 잘 알고 있지 않으면 코드 작성에 어려움을 겪거나 메모리 누수를 낳는 코드를 만들 가능성이 높다.\nES6에서는 이러한 다른 언어들의 특성을 받아들여 블록 단위의 변수 선언을 할 수 있는 let 키워드가 추가가 되었다.\n기존 컴파일 언어나 다른 언어를 쓰던 개발자들도 이제 쉽게 블록 단위의 변수 선언을 통하여 햇갈리지 않는 개발이 가능하다.\n\n> var 키워드가 표준에서 빠지는 건 아니기 때문에, 새로 추가된 let 키워드의 스코프 특성에 대해 잘 알고 있어야 한다.\n\n```javascript\nvar a = 1;\nconsole.log(a);\nfunction printNumberZ(){\n\tconsole.log(a);\n\tvar a = 2;\n}\nprintNumber();\n```\n\n\n```\n[출력결과]\n1\n2\n```\n위와 같은 코드가 있다고 할때, 출력 결과를 생각해보면 자바스크립트 변수 특징에 대해 원래 잘 알고 있는 개발자라면 쉽게 대답할 수 있는 결과가 출력이 될 것이다.\n기본 var 변수로 선언하면 함수 단위의 스코프로 생성되기 때문에, 자신의 스코프에 있는 함수를 먼저 참조하게 된다. 그래서 출력 결과가 같은 스코프에 있는 변수를 바라보게 되는 것이다.\n\nlet 키워드를 사용한 샘플 코드를 작성해봤는데 간단하게 결과를 예측해봐도 재밌을꺼 같다.\n\n```javascript\nlet a = 10;\nconsole.log(a);\nfunction printLetVariable(){\n\tlet a = 20;\n\tconsole.log(a);\n}\nprintLetVariable();\nconsole.log(a);\n```\n\n```\n[출력결과]\n10\n20\n10\n```\n출력 결과를 살펴보니, let도 역시 같은 스코프에 있는 변수를 참고 하는 것을 기본으로 하고 있다. \n그렇다면 코드를 살짝 틀어서 중복으로 선언했을 경우를 생각해보자. 먼저 var 변수 선언의 경우를 보고 그 다음에 let 변수 선언에 대해 테스트 코드를 작성해보자.\n\n```javascript\nvar a = 10;\nvar a = 20;\nconsole.log(a);\n```\n\n```\n[출력결과]\n20\n```\n\n```javascript\nlet a = 10;\nlet a = 20;\nconsole.log(a);\n```\n\n```\n[출력결과]\nSyntaxError: Identifier 'a' has already been declared\n```\nNode.js 6.x 버젼에서 테스트를 해봤는데 위와 같은 결과가 리턴되었다. 변수 특성에 대한 결과를 정리해보자.\n\n- let 변수는 같은 스코프에 있을 경우 중복으로 선언하면 TypeError 예외를 발생시킨다.\n- var 변수의 경우 중복 선언 허용\n- 만약, 스코프가 다르다면 같은 변수명을 선언해도 문제가 없으며 참조 시 같은 스코프에 있는 변수를 참조하게 된다.\n- var/let 을 조합한다고 해도, 같은 스코프에 저장되는 변수기 때문에 중복 선언이 안된다.\n\n> 흠 하위 호환성을 생각하면 var 변수를 써야 할꺼 같은데, 만약 개발하는 환경이 ES6 코드가 정상적으로 굴러갈 수 있는 환경이라면 적극적으로 let 키워드를 통하여 변수를 선언하는 것이 유리할꺼 같다.\n\n\n## const 상수 생성\nC,C++,Java 같은 언어에는 상수를 저장할 수 있는 문법적인 요소를 지원하고 있는데 자바스크립트를 그런 부분에 대한 지원이 전혀 없었다. 그래서 대부분 코드 컨벤션을 대문자로 잡거나 하는 방법으로 나름대로 상수를 식별하는 경우를 많이 봤었다. \n\nvar 변수의 경우 스코프의 변수 변경이 가능하다는 점 때문에 기존 코드에서는 상수 운영 시 변경에 대한 위험이 있었다고 할 수 있겠다.\nES6에서는 이런 상수에 대한 문법적인 지원을 포함하였는데, 그것이 바로 const 키워드이다.\n\n쉽게 생각하여 읽기 전용 변수라고 보면 좋을꺼 같은데, 앞서 let 변수 선언의 특징을 설명했었는데 const는 이런 let 변수의 성격에 변경이 불가능한 '읽기전용'이라는 성격이 들어간다.\n\n```javascript\nconst ABS = 10;\nABS = 20;\n```\n\n```javascript\n[출력 결과]\nTypeError: Assignment to constant variable.\n```\n\n```javascript\nconst ABS = 10;\nconsole.log(ABS);\nfunction printAbs(){\n\tconst ABS = 20;\n\tconsole.log(ABS);\n}\nprintAbs();\n```\n\n```javascript\n[출력 결과]\n10\n20\n```\n\n읽기 전용 변수의 성격이라서 값을 다시 할당하는 것은 불가능하다. \n그리고 let 변수의 성격처럼 블록 단위의 스코프를 지원하기 때문에 같은 변수명을 사용하더라도 스코프가 다르면 사용이 가능하다.\n\n\n앞에서 let/const 의 간단한 성격을 설명했는데, 값을 직접 할당하는 방식으로 사용했기 때문에 실제로 코드를 작성할때 참조 타입의 데이터(객체,함수,배열)이 들어갔을 경우에 어떻게 되는지 궁금할 수 있다.\n기본적으로 참조 타입은 데이터의 주소 값을 저장하는 점을 잘 기억하면 좋을꺼 같다.\n> 다른 언어들도 거의 비슷하기 때문에, 경험 많은 분들이면 쉽게 이해할 수 있을꺼 같아요.\n\n```javascript\nconst arr = [10,20,30,40];\narr[0] = 100;\nconsole.log(arr);\n```\n\n```\n[출력결과]\n[ 100, 20, 30, 40 ]\n```\n\nconst는 읽기 전용이라고 했는데, 왜 변경이 되는지 잘 생각해보면 쉽게 답이 나온다. 실제로 arr의 참조 값을 바꾸는 것이 아니기 때문에 해당 참조 타입의 데이터의 인덱스/프로퍼티를 수정하더라도 기존 참조 타입의 데이터를 사용하듯이 추가/변경이 가능 한 것이다.\n\n> 쫌 어려운 말로 const 변수가 객체 타입이더라도, 객체 자체는 가변(mutable) 상태인 것이다. 다른 언어들에서는 Mutable / Immutable 상태에 따른 변수를 선언하는 방식도 사용하고 있고 변경이 가능하냐 불가능하냐고 중요한 부분이기 때문에 해당 키워드를 검색해보는 것도 좋은 공부가 될꺼 같다.\n\n예제는 물론 배열로 선언했지만 객체 역시도 동일하게 적용된다. 사용해야 할 목적과 이유는 분명한거 같다. \n객체 자체의 변경이 없어야 할 경우 const 변수와 참조 타입을 적절하게 조합하여 사용하면 기존 var 변수로 선언했던 방식보다 좀 더 수월하게 개발이 가능한 것이다.\n\n\n","source":"_posts/JavaScript/ES6_let_const.md","raw":"---\ntitle: '[ES6] - let/const'\ndate: 2016/7/12 00:00:00\ncategories:\n- JavaScript\n---\n\n# [ES6] - let/const\n## let 키워드 사용 : 블록 스코프 변수 생성\n자바스크립트 기본적으로 함수 단위의 스코프를 제공하고 있는데, 다른 언어들과는 다른 부분이기 때문에 이러한 특징을 잘 알고 있지 않으면 코드 작성에 어려움을 겪거나 메모리 누수를 낳는 코드를 만들 가능성이 높다.\nES6에서는 이러한 다른 언어들의 특성을 받아들여 블록 단위의 변수 선언을 할 수 있는 let 키워드가 추가가 되었다.\n기존 컴파일 언어나 다른 언어를 쓰던 개발자들도 이제 쉽게 블록 단위의 변수 선언을 통하여 햇갈리지 않는 개발이 가능하다.\n\n> var 키워드가 표준에서 빠지는 건 아니기 때문에, 새로 추가된 let 키워드의 스코프 특성에 대해 잘 알고 있어야 한다.\n\n```javascript\nvar a = 1;\nconsole.log(a);\nfunction printNumberZ(){\n\tconsole.log(a);\n\tvar a = 2;\n}\nprintNumber();\n```\n\n\n```\n[출력결과]\n1\n2\n```\n위와 같은 코드가 있다고 할때, 출력 결과를 생각해보면 자바스크립트 변수 특징에 대해 원래 잘 알고 있는 개발자라면 쉽게 대답할 수 있는 결과가 출력이 될 것이다.\n기본 var 변수로 선언하면 함수 단위의 스코프로 생성되기 때문에, 자신의 스코프에 있는 함수를 먼저 참조하게 된다. 그래서 출력 결과가 같은 스코프에 있는 변수를 바라보게 되는 것이다.\n\nlet 키워드를 사용한 샘플 코드를 작성해봤는데 간단하게 결과를 예측해봐도 재밌을꺼 같다.\n\n```javascript\nlet a = 10;\nconsole.log(a);\nfunction printLetVariable(){\n\tlet a = 20;\n\tconsole.log(a);\n}\nprintLetVariable();\nconsole.log(a);\n```\n\n```\n[출력결과]\n10\n20\n10\n```\n출력 결과를 살펴보니, let도 역시 같은 스코프에 있는 변수를 참고 하는 것을 기본으로 하고 있다. \n그렇다면 코드를 살짝 틀어서 중복으로 선언했을 경우를 생각해보자. 먼저 var 변수 선언의 경우를 보고 그 다음에 let 변수 선언에 대해 테스트 코드를 작성해보자.\n\n```javascript\nvar a = 10;\nvar a = 20;\nconsole.log(a);\n```\n\n```\n[출력결과]\n20\n```\n\n```javascript\nlet a = 10;\nlet a = 20;\nconsole.log(a);\n```\n\n```\n[출력결과]\nSyntaxError: Identifier 'a' has already been declared\n```\nNode.js 6.x 버젼에서 테스트를 해봤는데 위와 같은 결과가 리턴되었다. 변수 특성에 대한 결과를 정리해보자.\n\n- let 변수는 같은 스코프에 있을 경우 중복으로 선언하면 TypeError 예외를 발생시킨다.\n- var 변수의 경우 중복 선언 허용\n- 만약, 스코프가 다르다면 같은 변수명을 선언해도 문제가 없으며 참조 시 같은 스코프에 있는 변수를 참조하게 된다.\n- var/let 을 조합한다고 해도, 같은 스코프에 저장되는 변수기 때문에 중복 선언이 안된다.\n\n> 흠 하위 호환성을 생각하면 var 변수를 써야 할꺼 같은데, 만약 개발하는 환경이 ES6 코드가 정상적으로 굴러갈 수 있는 환경이라면 적극적으로 let 키워드를 통하여 변수를 선언하는 것이 유리할꺼 같다.\n\n\n## const 상수 생성\nC,C++,Java 같은 언어에는 상수를 저장할 수 있는 문법적인 요소를 지원하고 있는데 자바스크립트를 그런 부분에 대한 지원이 전혀 없었다. 그래서 대부분 코드 컨벤션을 대문자로 잡거나 하는 방법으로 나름대로 상수를 식별하는 경우를 많이 봤었다. \n\nvar 변수의 경우 스코프의 변수 변경이 가능하다는 점 때문에 기존 코드에서는 상수 운영 시 변경에 대한 위험이 있었다고 할 수 있겠다.\nES6에서는 이런 상수에 대한 문법적인 지원을 포함하였는데, 그것이 바로 const 키워드이다.\n\n쉽게 생각하여 읽기 전용 변수라고 보면 좋을꺼 같은데, 앞서 let 변수 선언의 특징을 설명했었는데 const는 이런 let 변수의 성격에 변경이 불가능한 '읽기전용'이라는 성격이 들어간다.\n\n```javascript\nconst ABS = 10;\nABS = 20;\n```\n\n```javascript\n[출력 결과]\nTypeError: Assignment to constant variable.\n```\n\n```javascript\nconst ABS = 10;\nconsole.log(ABS);\nfunction printAbs(){\n\tconst ABS = 20;\n\tconsole.log(ABS);\n}\nprintAbs();\n```\n\n```javascript\n[출력 결과]\n10\n20\n```\n\n읽기 전용 변수의 성격이라서 값을 다시 할당하는 것은 불가능하다. \n그리고 let 변수의 성격처럼 블록 단위의 스코프를 지원하기 때문에 같은 변수명을 사용하더라도 스코프가 다르면 사용이 가능하다.\n\n\n앞에서 let/const 의 간단한 성격을 설명했는데, 값을 직접 할당하는 방식으로 사용했기 때문에 실제로 코드를 작성할때 참조 타입의 데이터(객체,함수,배열)이 들어갔을 경우에 어떻게 되는지 궁금할 수 있다.\n기본적으로 참조 타입은 데이터의 주소 값을 저장하는 점을 잘 기억하면 좋을꺼 같다.\n> 다른 언어들도 거의 비슷하기 때문에, 경험 많은 분들이면 쉽게 이해할 수 있을꺼 같아요.\n\n```javascript\nconst arr = [10,20,30,40];\narr[0] = 100;\nconsole.log(arr);\n```\n\n```\n[출력결과]\n[ 100, 20, 30, 40 ]\n```\n\nconst는 읽기 전용이라고 했는데, 왜 변경이 되는지 잘 생각해보면 쉽게 답이 나온다. 실제로 arr의 참조 값을 바꾸는 것이 아니기 때문에 해당 참조 타입의 데이터의 인덱스/프로퍼티를 수정하더라도 기존 참조 타입의 데이터를 사용하듯이 추가/변경이 가능 한 것이다.\n\n> 쫌 어려운 말로 const 변수가 객체 타입이더라도, 객체 자체는 가변(mutable) 상태인 것이다. 다른 언어들에서는 Mutable / Immutable 상태에 따른 변수를 선언하는 방식도 사용하고 있고 변경이 가능하냐 불가능하냐고 중요한 부분이기 때문에 해당 키워드를 검색해보는 것도 좋은 공부가 될꺼 같다.\n\n예제는 물론 배열로 선언했지만 객체 역시도 동일하게 적용된다. 사용해야 할 목적과 이유는 분명한거 같다. \n객체 자체의 변경이 없어야 할 경우 const 변수와 참조 타입을 적절하게 조합하여 사용하면 기존 var 변수로 선언했던 방식보다 좀 더 수월하게 개발이 가능한 것이다.\n\n\n","slug":"JavaScript/ES6_let_const","published":1,"updated":"2021-08-02T12:28:13.249Z","_id":"ckrsup50e0014tjhvafcy9x2o","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"ES6-let-const\"><a href=\"#ES6-let-const\" class=\"headerlink\" title=\"[ES6] - let/const\"></a>[ES6] - let/const</h1><h2 id=\"let-키워드-사용-블록-스코프-변수-생성\"><a href=\"#let-키워드-사용-블록-스코프-변수-생성\" class=\"headerlink\" title=\"let 키워드 사용 : 블록 스코프 변수 생성\"></a>let 키워드 사용 : 블록 스코프 변수 생성</h2><p>자바스크립트 기본적으로 함수 단위의 스코프를 제공하고 있는데, 다른 언어들과는 다른 부분이기 때문에 이러한 특징을 잘 알고 있지 않으면 코드 작성에 어려움을 겪거나 메모리 누수를 낳는 코드를 만들 가능성이 높다.<br>ES6에서는 이러한 다른 언어들의 특성을 받아들여 블록 단위의 변수 선언을 할 수 있는 let 키워드가 추가가 되었다.<br>기존 컴파일 언어나 다른 언어를 쓰던 개발자들도 이제 쉽게 블록 단위의 변수 선언을 통하여 햇갈리지 않는 개발이 가능하다.</p>\n<blockquote>\n<p>var 키워드가 표준에서 빠지는 건 아니기 때문에, 새로 추가된 let 키워드의 스코프 특성에 대해 잘 알고 있어야 한다.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printNumberZ</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printNumber();</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력결과]</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<p>위와 같은 코드가 있다고 할때, 출력 결과를 생각해보면 자바스크립트 변수 특징에 대해 원래 잘 알고 있는 개발자라면 쉽게 대답할 수 있는 결과가 출력이 될 것이다.<br>기본 var 변수로 선언하면 함수 단위의 스코프로 생성되기 때문에, 자신의 스코프에 있는 함수를 먼저 참조하게 된다. 그래서 출력 결과가 같은 스코프에 있는 변수를 바라보게 되는 것이다.</p>\n<p>let 키워드를 사용한 샘플 코드를 작성해봤는데 간단하게 결과를 예측해봐도 재밌을꺼 같다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLetVariable</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printLetVariable();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력결과]</span><br><span class=\"line\">10</span><br><span class=\"line\">20</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>출력 결과를 살펴보니, let도 역시 같은 스코프에 있는 변수를 참고 하는 것을 기본으로 하고 있다.<br>그렇다면 코드를 살짝 틀어서 중복으로 선언했을 경우를 생각해보자. 먼저 var 변수 선언의 경우를 보고 그 다음에 let 변수 선언에 대해 테스트 코드를 작성해보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력결과]</span><br><span class=\"line\">20</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력결과]</span><br><span class=\"line\">SyntaxError: Identifier &#x27;a&#x27; has already been declared</span><br></pre></td></tr></table></figure>\n<p>Node.js 6.x 버젼에서 테스트를 해봤는데 위와 같은 결과가 리턴되었다. 변수 특성에 대한 결과를 정리해보자.</p>\n<ul>\n<li>let 변수는 같은 스코프에 있을 경우 중복으로 선언하면 TypeError 예외를 발생시킨다.</li>\n<li>var 변수의 경우 중복 선언 허용</li>\n<li>만약, 스코프가 다르다면 같은 변수명을 선언해도 문제가 없으며 참조 시 같은 스코프에 있는 변수를 참조하게 된다.</li>\n<li>var/let 을 조합한다고 해도, 같은 스코프에 저장되는 변수기 때문에 중복 선언이 안된다.</li>\n</ul>\n<blockquote>\n<p>흠 하위 호환성을 생각하면 var 변수를 써야 할꺼 같은데, 만약 개발하는 환경이 ES6 코드가 정상적으로 굴러갈 수 있는 환경이라면 적극적으로 let 키워드를 통하여 변수를 선언하는 것이 유리할꺼 같다.</p>\n</blockquote>\n<h2 id=\"const-상수-생성\"><a href=\"#const-상수-생성\" class=\"headerlink\" title=\"const 상수 생성\"></a>const 상수 생성</h2><p>C,C++,Java 같은 언어에는 상수를 저장할 수 있는 문법적인 요소를 지원하고 있는데 자바스크립트를 그런 부분에 대한 지원이 전혀 없었다. 그래서 대부분 코드 컨벤션을 대문자로 잡거나 하는 방법으로 나름대로 상수를 식별하는 경우를 많이 봤었다. </p>\n<p>var 변수의 경우 스코프의 변수 변경이 가능하다는 점 때문에 기존 코드에서는 상수 운영 시 변경에 대한 위험이 있었다고 할 수 있겠다.<br>ES6에서는 이런 상수에 대한 문법적인 지원을 포함하였는데, 그것이 바로 const 키워드이다.</p>\n<p>쉽게 생각하여 읽기 전용 변수라고 보면 좋을꺼 같은데, 앞서 let 변수 선언의 특징을 설명했었는데 const는 이런 let 변수의 성격에 변경이 불가능한 ‘읽기전용’이라는 성격이 들어간다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ABS = <span class=\"number\">10</span>;</span><br><span class=\"line\">ABS = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력 결과]</span><br><span class=\"line\"><span class=\"attr\">TypeError</span>: Assignment to constant variable.</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ABS = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ABS);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printAbs</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> ABS = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(ABS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printAbs();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력 결과]</span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n\n<p>읽기 전용 변수의 성격이라서 값을 다시 할당하는 것은 불가능하다.<br>그리고 let 변수의 성격처럼 블록 단위의 스코프를 지원하기 때문에 같은 변수명을 사용하더라도 스코프가 다르면 사용이 가능하다.</p>\n<p>앞에서 let/const 의 간단한 성격을 설명했는데, 값을 직접 할당하는 방식으로 사용했기 때문에 실제로 코드를 작성할때 참조 타입의 데이터(객체,함수,배열)이 들어갔을 경우에 어떻게 되는지 궁금할 수 있다.<br>기본적으로 참조 타입은 데이터의 주소 값을 저장하는 점을 잘 기억하면 좋을꺼 같다.</p>\n<blockquote>\n<p>다른 언어들도 거의 비슷하기 때문에, 경험 많은 분들이면 쉽게 이해할 수 있을꺼 같아요.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>,<span class=\"number\">40</span>];</span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력결과]</span><br><span class=\"line\">[ 100, 20, 30, 40 ]</span><br></pre></td></tr></table></figure>\n\n<p>const는 읽기 전용이라고 했는데, 왜 변경이 되는지 잘 생각해보면 쉽게 답이 나온다. 실제로 arr의 참조 값을 바꾸는 것이 아니기 때문에 해당 참조 타입의 데이터의 인덱스/프로퍼티를 수정하더라도 기존 참조 타입의 데이터를 사용하듯이 추가/변경이 가능 한 것이다.</p>\n<blockquote>\n<p>쫌 어려운 말로 const 변수가 객체 타입이더라도, 객체 자체는 가변(mutable) 상태인 것이다. 다른 언어들에서는 Mutable / Immutable 상태에 따른 변수를 선언하는 방식도 사용하고 있고 변경이 가능하냐 불가능하냐고 중요한 부분이기 때문에 해당 키워드를 검색해보는 것도 좋은 공부가 될꺼 같다.</p>\n</blockquote>\n<p>예제는 물론 배열로 선언했지만 객체 역시도 동일하게 적용된다. 사용해야 할 목적과 이유는 분명한거 같다.<br>객체 자체의 변경이 없어야 할 경우 const 변수와 참조 타입을 적절하게 조합하여 사용하면 기존 var 변수로 선언했던 방식보다 좀 더 수월하게 개발이 가능한 것이다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ES6-let-const\"><a href=\"#ES6-let-const\" class=\"headerlink\" title=\"[ES6] - let/const\"></a>[ES6] - let/const</h1><h2 id=\"let-키워드-사용-블록-스코프-변수-생성\"><a href=\"#let-키워드-사용-블록-스코프-변수-생성\" class=\"headerlink\" title=\"let 키워드 사용 : 블록 스코프 변수 생성\"></a>let 키워드 사용 : 블록 스코프 변수 생성</h2><p>자바스크립트 기본적으로 함수 단위의 스코프를 제공하고 있는데, 다른 언어들과는 다른 부분이기 때문에 이러한 특징을 잘 알고 있지 않으면 코드 작성에 어려움을 겪거나 메모리 누수를 낳는 코드를 만들 가능성이 높다.<br>ES6에서는 이러한 다른 언어들의 특성을 받아들여 블록 단위의 변수 선언을 할 수 있는 let 키워드가 추가가 되었다.<br>기존 컴파일 언어나 다른 언어를 쓰던 개발자들도 이제 쉽게 블록 단위의 변수 선언을 통하여 햇갈리지 않는 개발이 가능하다.</p>\n<blockquote>\n<p>var 키워드가 표준에서 빠지는 건 아니기 때문에, 새로 추가된 let 키워드의 스코프 특성에 대해 잘 알고 있어야 한다.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printNumberZ</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printNumber();</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력결과]</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<p>위와 같은 코드가 있다고 할때, 출력 결과를 생각해보면 자바스크립트 변수 특징에 대해 원래 잘 알고 있는 개발자라면 쉽게 대답할 수 있는 결과가 출력이 될 것이다.<br>기본 var 변수로 선언하면 함수 단위의 스코프로 생성되기 때문에, 자신의 스코프에 있는 함수를 먼저 참조하게 된다. 그래서 출력 결과가 같은 스코프에 있는 변수를 바라보게 되는 것이다.</p>\n<p>let 키워드를 사용한 샘플 코드를 작성해봤는데 간단하게 결과를 예측해봐도 재밌을꺼 같다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLetVariable</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printLetVariable();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력결과]</span><br><span class=\"line\">10</span><br><span class=\"line\">20</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>출력 결과를 살펴보니, let도 역시 같은 스코프에 있는 변수를 참고 하는 것을 기본으로 하고 있다.<br>그렇다면 코드를 살짝 틀어서 중복으로 선언했을 경우를 생각해보자. 먼저 var 변수 선언의 경우를 보고 그 다음에 let 변수 선언에 대해 테스트 코드를 작성해보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력결과]</span><br><span class=\"line\">20</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력결과]</span><br><span class=\"line\">SyntaxError: Identifier &#x27;a&#x27; has already been declared</span><br></pre></td></tr></table></figure>\n<p>Node.js 6.x 버젼에서 테스트를 해봤는데 위와 같은 결과가 리턴되었다. 변수 특성에 대한 결과를 정리해보자.</p>\n<ul>\n<li>let 변수는 같은 스코프에 있을 경우 중복으로 선언하면 TypeError 예외를 발생시킨다.</li>\n<li>var 변수의 경우 중복 선언 허용</li>\n<li>만약, 스코프가 다르다면 같은 변수명을 선언해도 문제가 없으며 참조 시 같은 스코프에 있는 변수를 참조하게 된다.</li>\n<li>var/let 을 조합한다고 해도, 같은 스코프에 저장되는 변수기 때문에 중복 선언이 안된다.</li>\n</ul>\n<blockquote>\n<p>흠 하위 호환성을 생각하면 var 변수를 써야 할꺼 같은데, 만약 개발하는 환경이 ES6 코드가 정상적으로 굴러갈 수 있는 환경이라면 적극적으로 let 키워드를 통하여 변수를 선언하는 것이 유리할꺼 같다.</p>\n</blockquote>\n<h2 id=\"const-상수-생성\"><a href=\"#const-상수-생성\" class=\"headerlink\" title=\"const 상수 생성\"></a>const 상수 생성</h2><p>C,C++,Java 같은 언어에는 상수를 저장할 수 있는 문법적인 요소를 지원하고 있는데 자바스크립트를 그런 부분에 대한 지원이 전혀 없었다. 그래서 대부분 코드 컨벤션을 대문자로 잡거나 하는 방법으로 나름대로 상수를 식별하는 경우를 많이 봤었다. </p>\n<p>var 변수의 경우 스코프의 변수 변경이 가능하다는 점 때문에 기존 코드에서는 상수 운영 시 변경에 대한 위험이 있었다고 할 수 있겠다.<br>ES6에서는 이런 상수에 대한 문법적인 지원을 포함하였는데, 그것이 바로 const 키워드이다.</p>\n<p>쉽게 생각하여 읽기 전용 변수라고 보면 좋을꺼 같은데, 앞서 let 변수 선언의 특징을 설명했었는데 const는 이런 let 변수의 성격에 변경이 불가능한 ‘읽기전용’이라는 성격이 들어간다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ABS = <span class=\"number\">10</span>;</span><br><span class=\"line\">ABS = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력 결과]</span><br><span class=\"line\"><span class=\"attr\">TypeError</span>: Assignment to constant variable.</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ABS = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ABS);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printAbs</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> ABS = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(ABS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printAbs();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력 결과]</span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n\n<p>읽기 전용 변수의 성격이라서 값을 다시 할당하는 것은 불가능하다.<br>그리고 let 변수의 성격처럼 블록 단위의 스코프를 지원하기 때문에 같은 변수명을 사용하더라도 스코프가 다르면 사용이 가능하다.</p>\n<p>앞에서 let/const 의 간단한 성격을 설명했는데, 값을 직접 할당하는 방식으로 사용했기 때문에 실제로 코드를 작성할때 참조 타입의 데이터(객체,함수,배열)이 들어갔을 경우에 어떻게 되는지 궁금할 수 있다.<br>기본적으로 참조 타입은 데이터의 주소 값을 저장하는 점을 잘 기억하면 좋을꺼 같다.</p>\n<blockquote>\n<p>다른 언어들도 거의 비슷하기 때문에, 경험 많은 분들이면 쉽게 이해할 수 있을꺼 같아요.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>,<span class=\"number\">40</span>];</span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[출력결과]</span><br><span class=\"line\">[ 100, 20, 30, 40 ]</span><br></pre></td></tr></table></figure>\n\n<p>const는 읽기 전용이라고 했는데, 왜 변경이 되는지 잘 생각해보면 쉽게 답이 나온다. 실제로 arr의 참조 값을 바꾸는 것이 아니기 때문에 해당 참조 타입의 데이터의 인덱스/프로퍼티를 수정하더라도 기존 참조 타입의 데이터를 사용하듯이 추가/변경이 가능 한 것이다.</p>\n<blockquote>\n<p>쫌 어려운 말로 const 변수가 객체 타입이더라도, 객체 자체는 가변(mutable) 상태인 것이다. 다른 언어들에서는 Mutable / Immutable 상태에 따른 변수를 선언하는 방식도 사용하고 있고 변경이 가능하냐 불가능하냐고 중요한 부분이기 때문에 해당 키워드를 검색해보는 것도 좋은 공부가 될꺼 같다.</p>\n</blockquote>\n<p>예제는 물론 배열로 선언했지만 객체 역시도 동일하게 적용된다. 사용해야 할 목적과 이유는 분명한거 같다.<br>객체 자체의 변경이 없어야 할 경우 const 변수와 참조 타입을 적절하게 조합하여 사용하면 기존 var 변수로 선언했던 방식보다 좀 더 수월하게 개발이 가능한 것이다.</p>\n"},{"title":"NVM 설치 및 기본 사용 방법","date":"2016-07-11T15:00:00.000Z","_content":"\n### NVM 설치 및 기본 사용 방법\n수시로 업데이트 되는 노드 버젼 관리를 위하여 설치.\n#### 설치 전 확인사항\n> The installer can use git, curl, or wget to download nvm, whatever is available.\n\n1. 인스톨러는 *git*과 *curl* 혹은 *wget*를 사용함.\n\n> First you'll need to make sure your system has a c++ compiler. For OS X, Xcode will work, for Ubuntu, the build-essential and libssl-dev packages work.\n\n2. 시스템에 C++ 컴파일러가 설치 되어 있어야 함. Mac OS의 경우 XCode가 설치 되어 있어야 하며, 우분투 환경에서는 *build-essential*과 *libssl-dev* 패키지가 설치 되어 있어야 함.\n\n\n>Note: nvm does not support Windows (see #284). Two alternatives exist, which are neither supported nor developed by us:\n\n3. *nvm*은 윈도우 환경에 대하여 지원을 하지 않으나, 공식적으로 지원되지 않거나 개발되지 않은 환경으로 대안이 존재함.(하단 링크 참조)\n\n - [nvm-windows](https://github.com/coreybutler/nvm-windows)\n - [nodist](https://github.com/marcelklehr/nodist)\n\n\n> Homebrew installation is not supported\n\n4. *HomeBrew*는 지원하지 않음.(homebrew로 설치한 경우 제거해야 함.)\n\n> Git versions before v1.7 may face a problem of cloning nvm source from GitHub via https protocol, and there is also different behavior of git before v1.6, so the minimum required git version is v1.7.0 and we recommend v1.7.9.5 as it's the default version of the wildly used Ubuntu 12.04 LTS\n\n5. v1.7 이하의 git에서는 nvm 소스를 복사하는 과정에서 https 프로토콜 관련 문제가 생길 수 있으며, v1.6 이하에서도 역시 다른 행동(예상이 안되는)을 보일 수 있음. 그래서, 최소한 v1.7 이상을 권하며, 그 중에서 v1.7.9.5 버젼 설치를 권고함.\n\n#### 설치\n\n```bash\n# Curl\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash\n# wget\nwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash\n```\n커맨드 라인을 활용하여 설치를 진행하며 *curl* 혹은 *wget*이 사용 가능한 환경이 준비 되어 있어야 한다.\n\n```bash\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && . \"$NVM_DIR/nvm.sh\" # This loads nvm\n```\n위 스크립트는 nvm repository에서 ~./nvm으로 복사되며, 해당 소스 라인은 프로파일(*~/.bash_profile*, *~/.zshrc*, *~/.profile*, or *~/.bashrc*)에 추가된다.\n\nOS X 사용자의 경우, 인스톨 스크립트 진행 후 *nvm: command not found*과 같은 메세지를 볼 수도 있는데, 이는 프로파일(<u>.bash_profile</u>)이 추가 되어 있지 않기 때문에 생기는 오류이다. 간단하게 아래와 같이 커맨드 라인을 입력하여 추가 후 인스톨 스크립트를 다시 실행시키면 된다.\n\n```bash\ntouch ~/.bash_profile\n```\n\n설치가 정상적으로 진행되었다면, 아래 커맨드를 입력하여 정상적으로 설치가 되었는지 확인하면 된다.\n```bash\ncommand -v nvm\n```\n\n#### 수동 설치\n[링크](https://github.com/creationix/nvm#manual-install)를 통하여 안내 가이드를 참고하자.\n\n\n\n#### 기본 사용 방법\n```bash\n# 최신 릴리즈 설치 후 해당 버젼 사용\nnvm install node\nnvm use node\nnvm run node --version\n\n# 버젼 지정 후 설치 진행\n# 아래 커맨드의 경우, 5.X 버젼대의 최신 버젼 설치를 진행함.\nnvm install v5\n\n# 원하는 버젼으로 실행\nnvm exec 4.2 node --version\n\n# 설치 되어 있는 노드 버젼 패스 확인\nnvm which 5.0\n\n# 사용 가능한(설치 되어 있는) 노드 버젼 리스트\nnvm ls\n\n# 설치 가능한 노드 버젼 리스트\nnvm ls-remote\n\n# alias 옵션 설정을 통하여\n# 전역 쉘 환경에서 사용할 기본 노드 버젼 지정\nnvm alias default node\n```\n#### 기타 참고\n- 전역 환경이 아닌 프로젝트별로 환경이 고정되어 있는 경우에는 *.nvmrc*을 루트 폴더 혹은 프로젝트 폴더 최상위에 정의하여 노드 버젼 환경을 관리할 수도 있다.\n\n- 쉘 환경(zsh 등)을 이용하여 nvm과 통합 환경을 구성할 수 있으나, 공식적으로 지원되는 항목이 아니라고 한다.(하지만 nvm 개발팀에서는 여러 유저들의 통합 환경 구성에 대하여 의견은 받고 있는거 같다.)\n","source":"_posts/JavaScript/NVM-NodeJs.md","raw":"---\ntitle: 'NVM 설치 및 기본 사용 방법'\ndate: 2016/7/12 00:00:00\ncategories:\n- JavaScript\n---\n\n### NVM 설치 및 기본 사용 방법\n수시로 업데이트 되는 노드 버젼 관리를 위하여 설치.\n#### 설치 전 확인사항\n> The installer can use git, curl, or wget to download nvm, whatever is available.\n\n1. 인스톨러는 *git*과 *curl* 혹은 *wget*를 사용함.\n\n> First you'll need to make sure your system has a c++ compiler. For OS X, Xcode will work, for Ubuntu, the build-essential and libssl-dev packages work.\n\n2. 시스템에 C++ 컴파일러가 설치 되어 있어야 함. Mac OS의 경우 XCode가 설치 되어 있어야 하며, 우분투 환경에서는 *build-essential*과 *libssl-dev* 패키지가 설치 되어 있어야 함.\n\n\n>Note: nvm does not support Windows (see #284). Two alternatives exist, which are neither supported nor developed by us:\n\n3. *nvm*은 윈도우 환경에 대하여 지원을 하지 않으나, 공식적으로 지원되지 않거나 개발되지 않은 환경으로 대안이 존재함.(하단 링크 참조)\n\n - [nvm-windows](https://github.com/coreybutler/nvm-windows)\n - [nodist](https://github.com/marcelklehr/nodist)\n\n\n> Homebrew installation is not supported\n\n4. *HomeBrew*는 지원하지 않음.(homebrew로 설치한 경우 제거해야 함.)\n\n> Git versions before v1.7 may face a problem of cloning nvm source from GitHub via https protocol, and there is also different behavior of git before v1.6, so the minimum required git version is v1.7.0 and we recommend v1.7.9.5 as it's the default version of the wildly used Ubuntu 12.04 LTS\n\n5. v1.7 이하의 git에서는 nvm 소스를 복사하는 과정에서 https 프로토콜 관련 문제가 생길 수 있으며, v1.6 이하에서도 역시 다른 행동(예상이 안되는)을 보일 수 있음. 그래서, 최소한 v1.7 이상을 권하며, 그 중에서 v1.7.9.5 버젼 설치를 권고함.\n\n#### 설치\n\n```bash\n# Curl\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash\n# wget\nwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash\n```\n커맨드 라인을 활용하여 설치를 진행하며 *curl* 혹은 *wget*이 사용 가능한 환경이 준비 되어 있어야 한다.\n\n```bash\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && . \"$NVM_DIR/nvm.sh\" # This loads nvm\n```\n위 스크립트는 nvm repository에서 ~./nvm으로 복사되며, 해당 소스 라인은 프로파일(*~/.bash_profile*, *~/.zshrc*, *~/.profile*, or *~/.bashrc*)에 추가된다.\n\nOS X 사용자의 경우, 인스톨 스크립트 진행 후 *nvm: command not found*과 같은 메세지를 볼 수도 있는데, 이는 프로파일(<u>.bash_profile</u>)이 추가 되어 있지 않기 때문에 생기는 오류이다. 간단하게 아래와 같이 커맨드 라인을 입력하여 추가 후 인스톨 스크립트를 다시 실행시키면 된다.\n\n```bash\ntouch ~/.bash_profile\n```\n\n설치가 정상적으로 진행되었다면, 아래 커맨드를 입력하여 정상적으로 설치가 되었는지 확인하면 된다.\n```bash\ncommand -v nvm\n```\n\n#### 수동 설치\n[링크](https://github.com/creationix/nvm#manual-install)를 통하여 안내 가이드를 참고하자.\n\n\n\n#### 기본 사용 방법\n```bash\n# 최신 릴리즈 설치 후 해당 버젼 사용\nnvm install node\nnvm use node\nnvm run node --version\n\n# 버젼 지정 후 설치 진행\n# 아래 커맨드의 경우, 5.X 버젼대의 최신 버젼 설치를 진행함.\nnvm install v5\n\n# 원하는 버젼으로 실행\nnvm exec 4.2 node --version\n\n# 설치 되어 있는 노드 버젼 패스 확인\nnvm which 5.0\n\n# 사용 가능한(설치 되어 있는) 노드 버젼 리스트\nnvm ls\n\n# 설치 가능한 노드 버젼 리스트\nnvm ls-remote\n\n# alias 옵션 설정을 통하여\n# 전역 쉘 환경에서 사용할 기본 노드 버젼 지정\nnvm alias default node\n```\n#### 기타 참고\n- 전역 환경이 아닌 프로젝트별로 환경이 고정되어 있는 경우에는 *.nvmrc*을 루트 폴더 혹은 프로젝트 폴더 최상위에 정의하여 노드 버젼 환경을 관리할 수도 있다.\n\n- 쉘 환경(zsh 등)을 이용하여 nvm과 통합 환경을 구성할 수 있으나, 공식적으로 지원되는 항목이 아니라고 한다.(하지만 nvm 개발팀에서는 여러 유저들의 통합 환경 구성에 대하여 의견은 받고 있는거 같다.)\n","slug":"JavaScript/NVM-NodeJs","published":1,"updated":"2021-08-02T12:28:23.955Z","_id":"ckrsup50g0015tjhv53dgfk57","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"NVM-설치-및-기본-사용-방법\"><a href=\"#NVM-설치-및-기본-사용-방법\" class=\"headerlink\" title=\"NVM 설치 및 기본 사용 방법\"></a>NVM 설치 및 기본 사용 방법</h3><p>수시로 업데이트 되는 노드 버젼 관리를 위하여 설치.</p>\n<h4 id=\"설치-전-확인사항\"><a href=\"#설치-전-확인사항\" class=\"headerlink\" title=\"설치 전 확인사항\"></a>설치 전 확인사항</h4><blockquote>\n<p>The installer can use git, curl, or wget to download nvm, whatever is available.</p>\n</blockquote>\n<ol>\n<li>인스톨러는 <em>git</em>과 <em>curl</em> 혹은 <em>wget</em>를 사용함.</li>\n</ol>\n<blockquote>\n<p>First you’ll need to make sure your system has a c++ compiler. For OS X, Xcode will work, for Ubuntu, the build-essential and libssl-dev packages work.</p>\n</blockquote>\n<ol start=\"2\">\n<li>시스템에 C++ 컴파일러가 설치 되어 있어야 함. Mac OS의 경우 XCode가 설치 되어 있어야 하며, 우분투 환경에서는 <em>build-essential</em>과 <em>libssl-dev</em> 패키지가 설치 되어 있어야 함.</li>\n</ol>\n<blockquote>\n<p>Note: nvm does not support Windows (see #284). Two alternatives exist, which are neither supported nor developed by us:</p>\n</blockquote>\n<ol start=\"3\">\n<li><em>nvm</em>은 윈도우 환경에 대하여 지원을 하지 않으나, 공식적으로 지원되지 않거나 개발되지 않은 환경으로 대안이 존재함.(하단 링크 참조)</li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/coreybutler/nvm-windows\">nvm-windows</a></li>\n<li><a href=\"https://github.com/marcelklehr/nodist\">nodist</a></li>\n</ul>\n<blockquote>\n<p>Homebrew installation is not supported</p>\n</blockquote>\n<ol start=\"4\">\n<li><em>HomeBrew</em>는 지원하지 않음.(homebrew로 설치한 경우 제거해야 함.)</li>\n</ol>\n<blockquote>\n<p>Git versions before v1.7 may face a problem of cloning nvm source from GitHub via https protocol, and there is also different behavior of git before v1.6, so the minimum required git version is v1.7.0 and we recommend v1.7.9.5 as it’s the default version of the wildly used Ubuntu 12.04 LTS</p>\n</blockquote>\n<ol start=\"5\">\n<li>v1.7 이하의 git에서는 nvm 소스를 복사하는 과정에서 https 프로토콜 관련 문제가 생길 수 있으며, v1.6 이하에서도 역시 다른 행동(예상이 안되는)을 보일 수 있음. 그래서, 최소한 v1.7 이상을 권하며, 그 중에서 v1.7.9.5 버젼 설치를 권고함.</li>\n</ol>\n<h4 id=\"설치\"><a href=\"#설치\" class=\"headerlink\" title=\"설치\"></a>설치</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Curl</span></span><br><span class=\"line\">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash</span><br><span class=\"line\"><span class=\"comment\"># wget</span></span><br><span class=\"line\">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash</span><br></pre></td></tr></table></figure>\n<p>커맨드 라인을 활용하여 설치를 진행하며 <em>curl</em> 혹은 <em>wget</em>이 사용 가능한 환경이 준비 되어 있어야 한다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> NVM_DIR=<span class=\"string\">&quot;<span class=\"variable\">$HOME</span>/.nvm&quot;</span></span><br><span class=\"line\">[ -s <span class=\"string\">&quot;<span class=\"variable\">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; . <span class=\"string\">&quot;<span class=\"variable\">$NVM_DIR</span>/nvm.sh&quot;</span> <span class=\"comment\"># This loads nvm</span></span><br></pre></td></tr></table></figure>\n<p>위 스크립트는 nvm repository에서 <del>./nvm으로 복사되며, 해당 소스 라인은 프로파일(*</del>/.bash_profile*, <em>~/.zshrc</em>, <em>~/.profile</em>, or <em>~/.bashrc</em>)에 추가된다.</p>\n<p>OS X 사용자의 경우, 인스톨 스크립트 진행 후 <em>nvm: command not found</em>과 같은 메세지를 볼 수도 있는데, 이는 프로파일(<u>.bash_profile</u>)이 추가 되어 있지 않기 때문에 생기는 오류이다. 간단하게 아래와 같이 커맨드 라인을 입력하여 추가 후 인스톨 스크립트를 다시 실행시키면 된다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch ~/.bash_profile</span><br></pre></td></tr></table></figure>\n\n<p>설치가 정상적으로 진행되었다면, 아래 커맨드를 입력하여 정상적으로 설치가 되었는지 확인하면 된다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">command</span> -v nvm</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"수동-설치\"><a href=\"#수동-설치\" class=\"headerlink\" title=\"수동 설치\"></a>수동 설치</h4><p><a href=\"https://github.com/creationix/nvm#manual-install\">링크</a>를 통하여 안내 가이드를 참고하자.</p>\n<h4 id=\"기본-사용-방법\"><a href=\"#기본-사용-방법\" class=\"headerlink\" title=\"기본 사용 방법\"></a>기본 사용 방법</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 최신 릴리즈 설치 후 해당 버젼 사용</span></span><br><span class=\"line\">nvm install node</span><br><span class=\"line\">nvm use node</span><br><span class=\"line\">nvm run node --version</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 버젼 지정 후 설치 진행</span></span><br><span class=\"line\"><span class=\"comment\"># 아래 커맨드의 경우, 5.X 버젼대의 최신 버젼 설치를 진행함.</span></span><br><span class=\"line\">nvm install v5</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 원하는 버젼으로 실행</span></span><br><span class=\"line\">nvm <span class=\"built_in\">exec</span> 4.2 node --version</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 설치 되어 있는 노드 버젼 패스 확인</span></span><br><span class=\"line\">nvm <span class=\"built_in\">which</span> 5.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 사용 가능한(설치 되어 있는) 노드 버젼 리스트</span></span><br><span class=\"line\">nvm ls</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 설치 가능한 노드 버젼 리스트</span></span><br><span class=\"line\">nvm ls-remote</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># alias 옵션 설정을 통하여</span></span><br><span class=\"line\"><span class=\"comment\"># 전역 쉘 환경에서 사용할 기본 노드 버젼 지정</span></span><br><span class=\"line\">nvm <span class=\"built_in\">alias</span> default node</span><br></pre></td></tr></table></figure>\n<h4 id=\"기타-참고\"><a href=\"#기타-참고\" class=\"headerlink\" title=\"기타 참고\"></a>기타 참고</h4><ul>\n<li><p>전역 환경이 아닌 프로젝트별로 환경이 고정되어 있는 경우에는 <em>.nvmrc</em>을 루트 폴더 혹은 프로젝트 폴더 최상위에 정의하여 노드 버젼 환경을 관리할 수도 있다.</p>\n</li>\n<li><p>쉘 환경(zsh 등)을 이용하여 nvm과 통합 환경을 구성할 수 있으나, 공식적으로 지원되는 항목이 아니라고 한다.(하지만 nvm 개발팀에서는 여러 유저들의 통합 환경 구성에 대하여 의견은 받고 있는거 같다.)</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"NVM-설치-및-기본-사용-방법\"><a href=\"#NVM-설치-및-기본-사용-방법\" class=\"headerlink\" title=\"NVM 설치 및 기본 사용 방법\"></a>NVM 설치 및 기본 사용 방법</h3><p>수시로 업데이트 되는 노드 버젼 관리를 위하여 설치.</p>\n<h4 id=\"설치-전-확인사항\"><a href=\"#설치-전-확인사항\" class=\"headerlink\" title=\"설치 전 확인사항\"></a>설치 전 확인사항</h4><blockquote>\n<p>The installer can use git, curl, or wget to download nvm, whatever is available.</p>\n</blockquote>\n<ol>\n<li>인스톨러는 <em>git</em>과 <em>curl</em> 혹은 <em>wget</em>를 사용함.</li>\n</ol>\n<blockquote>\n<p>First you’ll need to make sure your system has a c++ compiler. For OS X, Xcode will work, for Ubuntu, the build-essential and libssl-dev packages work.</p>\n</blockquote>\n<ol start=\"2\">\n<li>시스템에 C++ 컴파일러가 설치 되어 있어야 함. Mac OS의 경우 XCode가 설치 되어 있어야 하며, 우분투 환경에서는 <em>build-essential</em>과 <em>libssl-dev</em> 패키지가 설치 되어 있어야 함.</li>\n</ol>\n<blockquote>\n<p>Note: nvm does not support Windows (see #284). Two alternatives exist, which are neither supported nor developed by us:</p>\n</blockquote>\n<ol start=\"3\">\n<li><em>nvm</em>은 윈도우 환경에 대하여 지원을 하지 않으나, 공식적으로 지원되지 않거나 개발되지 않은 환경으로 대안이 존재함.(하단 링크 참조)</li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/coreybutler/nvm-windows\">nvm-windows</a></li>\n<li><a href=\"https://github.com/marcelklehr/nodist\">nodist</a></li>\n</ul>\n<blockquote>\n<p>Homebrew installation is not supported</p>\n</blockquote>\n<ol start=\"4\">\n<li><em>HomeBrew</em>는 지원하지 않음.(homebrew로 설치한 경우 제거해야 함.)</li>\n</ol>\n<blockquote>\n<p>Git versions before v1.7 may face a problem of cloning nvm source from GitHub via https protocol, and there is also different behavior of git before v1.6, so the minimum required git version is v1.7.0 and we recommend v1.7.9.5 as it’s the default version of the wildly used Ubuntu 12.04 LTS</p>\n</blockquote>\n<ol start=\"5\">\n<li>v1.7 이하의 git에서는 nvm 소스를 복사하는 과정에서 https 프로토콜 관련 문제가 생길 수 있으며, v1.6 이하에서도 역시 다른 행동(예상이 안되는)을 보일 수 있음. 그래서, 최소한 v1.7 이상을 권하며, 그 중에서 v1.7.9.5 버젼 설치를 권고함.</li>\n</ol>\n<h4 id=\"설치\"><a href=\"#설치\" class=\"headerlink\" title=\"설치\"></a>설치</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Curl</span></span><br><span class=\"line\">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash</span><br><span class=\"line\"><span class=\"comment\"># wget</span></span><br><span class=\"line\">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash</span><br></pre></td></tr></table></figure>\n<p>커맨드 라인을 활용하여 설치를 진행하며 <em>curl</em> 혹은 <em>wget</em>이 사용 가능한 환경이 준비 되어 있어야 한다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> NVM_DIR=<span class=\"string\">&quot;<span class=\"variable\">$HOME</span>/.nvm&quot;</span></span><br><span class=\"line\">[ -s <span class=\"string\">&quot;<span class=\"variable\">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; . <span class=\"string\">&quot;<span class=\"variable\">$NVM_DIR</span>/nvm.sh&quot;</span> <span class=\"comment\"># This loads nvm</span></span><br></pre></td></tr></table></figure>\n<p>위 스크립트는 nvm repository에서 <del>./nvm으로 복사되며, 해당 소스 라인은 프로파일(*</del>/.bash_profile*, <em>~/.zshrc</em>, <em>~/.profile</em>, or <em>~/.bashrc</em>)에 추가된다.</p>\n<p>OS X 사용자의 경우, 인스톨 스크립트 진행 후 <em>nvm: command not found</em>과 같은 메세지를 볼 수도 있는데, 이는 프로파일(<u>.bash_profile</u>)이 추가 되어 있지 않기 때문에 생기는 오류이다. 간단하게 아래와 같이 커맨드 라인을 입력하여 추가 후 인스톨 스크립트를 다시 실행시키면 된다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch ~/.bash_profile</span><br></pre></td></tr></table></figure>\n\n<p>설치가 정상적으로 진행되었다면, 아래 커맨드를 입력하여 정상적으로 설치가 되었는지 확인하면 된다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">command</span> -v nvm</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"수동-설치\"><a href=\"#수동-설치\" class=\"headerlink\" title=\"수동 설치\"></a>수동 설치</h4><p><a href=\"https://github.com/creationix/nvm#manual-install\">링크</a>를 통하여 안내 가이드를 참고하자.</p>\n<h4 id=\"기본-사용-방법\"><a href=\"#기본-사용-방법\" class=\"headerlink\" title=\"기본 사용 방법\"></a>기본 사용 방법</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 최신 릴리즈 설치 후 해당 버젼 사용</span></span><br><span class=\"line\">nvm install node</span><br><span class=\"line\">nvm use node</span><br><span class=\"line\">nvm run node --version</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 버젼 지정 후 설치 진행</span></span><br><span class=\"line\"><span class=\"comment\"># 아래 커맨드의 경우, 5.X 버젼대의 최신 버젼 설치를 진행함.</span></span><br><span class=\"line\">nvm install v5</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 원하는 버젼으로 실행</span></span><br><span class=\"line\">nvm <span class=\"built_in\">exec</span> 4.2 node --version</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 설치 되어 있는 노드 버젼 패스 확인</span></span><br><span class=\"line\">nvm <span class=\"built_in\">which</span> 5.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 사용 가능한(설치 되어 있는) 노드 버젼 리스트</span></span><br><span class=\"line\">nvm ls</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 설치 가능한 노드 버젼 리스트</span></span><br><span class=\"line\">nvm ls-remote</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># alias 옵션 설정을 통하여</span></span><br><span class=\"line\"><span class=\"comment\"># 전역 쉘 환경에서 사용할 기본 노드 버젼 지정</span></span><br><span class=\"line\">nvm <span class=\"built_in\">alias</span> default node</span><br></pre></td></tr></table></figure>\n<h4 id=\"기타-참고\"><a href=\"#기타-참고\" class=\"headerlink\" title=\"기타 참고\"></a>기타 참고</h4><ul>\n<li><p>전역 환경이 아닌 프로젝트별로 환경이 고정되어 있는 경우에는 <em>.nvmrc</em>을 루트 폴더 혹은 프로젝트 폴더 최상위에 정의하여 노드 버젼 환경을 관리할 수도 있다.</p>\n</li>\n<li><p>쉘 환경(zsh 등)을 이용하여 nvm과 통합 환경을 구성할 수 있으나, 공식적으로 지원되는 항목이 아니라고 한다.(하지만 nvm 개발팀에서는 여러 유저들의 통합 환경 구성에 대하여 의견은 받고 있는거 같다.)</p>\n</li>\n</ul>\n"},{"title":"JavaScript_Prototype & Prototype Chainning","date":"2016-07-17T13:50:00.000Z","_content":"\n# JavaScript_Prototype & Prototype Chainning\n자바스크립트는 **프로토타입** 기반의 객체지향 언어로 일반적인 객체 지향 언어와 다른 특성을 가지고 있다.\n\n특히, 자바스크립트는 기본적으로는 원시타입과 참조타입으로 데이터 타입을 나눌 수 있지만, 엔진 내부에서는 원시타입 역시 객체로 **오토박싱(AutoBoxing)** 을 시켜서 객체형으로 변환하여 변수를 관리한다.(즉, 원시타입도 어떤 생성자 함수의 인스턴스이다.)\n\n## 암묵적인 프로토타입 링크(implicit prototype link)\n자바스크립트의 모든 객체는 프로토타입 (링크)객체를 가지고 있다. 프로토타입 객체란, 자신을 생성한 생성자 함수의 프로토타입 객체를 가리키는 일종의 링크 객체로 자바스크립트에서 상속을 구현하는 핵심 메카니즘이라고 할 수 있다.\n- ECMA 표준에서는 이를 **암묵적인 프로토타입 링크** 라고 명칭한다.\n\n```javascript\nfunction Person(name){\n    this.name = name;\n}\nvar foo = new Person('Choi');\n\nfoo.__proto__ === Person.prototype\n```\n\n위 코드에서 foo 객체(인스턴스)의 프로토타입 링크는 foo 객체의 생성자인 Person 함수 객체의 **[프로토타입]** 영역을 가리키가 된다. 즉, 생성자 함수의 프로토타입 영역이 인스턴스의 프로토타입 링크가 가리키게 되는 객체가 되는 것이다.\n> Chrome에서는 _proto_ 라는 프로퍼티가 프로토타입 링크 역할을 하는 객체 프로퍼티가 된다.\n즉, 숨겨진 프로토타입 링크 역할을 수행하게 되는 것이다.\n\n생성자 함수로 생성된 객체뿐만 아니라, 객체 리터럴도 프로토타입 링크를 가지게 되는데 왜냐하면 객체 리터럴 역시 내부적으로는 Object() 생성자 함수의 객체(인스턴스)이기 때문에, Object.Prototype 영역을 가리키는 암묵적인 프로토타입 링크를 가지게 된다.\n\n```javascript\n// 객체 리터럴 생성\nvar obj = {};\n\n// 객체 리터럴도 Object 생성자 함수의 인스턴스이기 때문에 가리키는 프로토타입 링크와 프로토타입 영역은 동일한 객체를 바라보게 된다.\nobj.__proto__ === Object.prototype\n```\n\n> 결과적으로, 기억해야 할 부분은 바로 **객체리터럴 역시 Object() 생성자 함수의 인스턴스** 라는 점이다.\n\n\n## 프로토타입 체인(Prototype Chainning)\n자바스크립트에서 객체의 속성이나 매소드를 참조할 때, 객체에 해당 속성과 매소드가 없을 경우 **프로토타입 링크** 를 따라 프로토타입 객체의 프로퍼티를 차례대로 찾아가는 것을 **프로토타입 체인** 이라고 한다.\n\n> 객체의 속성을 읽거나 매소드를 호출(실행)할 때 프로토타입 체인이 작동한다\n\n```javascript\nvar myObj = {};\nmyObj.name = \"Choi\";\n\nmyObj.hasOwnProperty('name'); // true\nmyObj.hasOwnProperty('age'); // false\n```\n\n위 코드에서 hasOwnProperty() 매소드를 사용할 수 있는 근거도 위에서 말한대로 객체 리터럴 역시 Object() 생성자 함수의 인스턴스이기 때문에, 객체의 프로토타입 링크는 Object() 생성자 함수 객체의 프로토타입 영역을 참조하게 된다. 그래서 기존 Object() 생성자 함수의 프로토타입 영역에 정의되어 있는 매소드인 hasOwnProperty(Native 영역의 함수)를 사용할 수 있는 것이다.\n\n\n```javascript\nString.prototype.__proto__ === Object.prototype\nNumber.prototype.__proto__ === Object.prototype\n```\n\n\n이 밖에도, Number, String, Function 등의 생성자 함수들도 각자 프로토타입 영역을 가지고 있는데 **프로토타입 영역은 곧 객체** 이기 때문에 객체의 프로토타입 링크를 가지고 있게 된다. 이때 프로토타입 링크가 바라보게 되는 곳이 바로 Object()의 프로토타입 영역이기 때문에 실질적으로 모든 객체(인스턴스)에서 Object.prototype에 정의한 매서드들을 사용할 수 있는 것이 된다.\n\n\n## 프로토타입 && this\n프로토타입 객체의 속성(프로퍼티)가 매서드인 경우, 결과적으로 **this 키워드는 매서드를 호출한 객체를 바라보게 된다.** 말이 어려운데 아래 예제를 살펴보면 쉽게 이해할 수 있을 것이다.\n```javascript\nfunction Animal(name){\n    this.name = name;\n}\n\nAnimal.prototype.sayHello = function(msg){\n    return alert(this.name + \"이 말합니다. \" + msg);\n}\n\nvar tiger = new Animal('타이거');\ntiger.sayHello('난 호랭이야!'); // 타이거가 말합니다. 난 호랭이야!\n```\n\nsayHello를 호출한 객체는 바로 tiger 객체이기 때문에, sayHello 매서드 내부의 this 키워드가 가리키는 것은 바로 tiger 객체 자체를 참조하게 된다.(이것은 일종의 자바스크립트의 법칙과도 같다.) 즉, 호출한 객체의 자체를 바라보게 되는 것인데 살짝 예제를 틀어서보면 재밌는 부분을 발견할 수 있다.\n\n```javascript\nAnimal.prototype.name = \"강아지\";\n// 강아지가 말합니다. 난 강아지인데?!!!\nAnimal.prototype.sayHello('난 강아지인데?!!!');\n```\n\n첫 번쨰 예제와 두 번쨰 예제의 차이점은 sayHello() 매서도를 호출한 객체가 달라졌다는 부분이다. 다시 말해, 첫 번째 예제에서 sayHello()를 호출한 객체는 tiger 객체이기 때문에 this 키워드가 가리키는 객체는 tiger 객체가 되는 것이고, 두 번째 예제에서 sayHello()를 호출한 객체가 Animal.prototype 객체이기 때문에 this가 가리키는 녀석이 바로 Animal.prototype이 되는 것이다.\n> 정리해서, **객체의 속성(프로퍼티)가 매소드일 경우 이를 호출한 this는 호출한 객체에 바인딩된다** 가 결론이다.\n\n\n## 디플트 프로토타입 링크\n함수를 작성하면 기본적으로 디폴트 프로토타입 영역이 생성이 된다. 이 디폴트 프로토타입 영역은 constructor 라는 속성을 가지는데 constructor 단어 그 자체의 의미처럼 작성한 함수 객체를 참조하는 프로퍼티이다. 그런데 재밌는 부분은 이 디폴트 프로토타입 객체는 개발자에 의해서 변경이 가능하다는 점이다. 그렇기 때문에 프로토타입 객체의 참조 관계를 임의로 개발자가 변경하여 사용하는 것이 가능하다.\n\n```javascript\nfunction Weapon(name){\n    this.name = name;\n}\nvar machineGun = new Weapon('머신건');\n\n// 1번 문제\nmachineGun.__proto__.constructor === Weapon.prototype.constructor\n\nWeapon.prototype = {\n    sayWeaponName : function(){\n        return this.name;\n    }\n}\n\nvar newGun = new Weapon('뉴건');\n\n// 2번 문제\nmachineGun.__proto__ === newGun.__proto__\n```\n\n첫 번째 문제의 경우, Weapon 생성자 함수의 인스턴스인 machineGun의 프로토타입 링크는 Weapon 생성자 함수 객체의 프로토타입 영역을 가리키고 있기 때문에 두 객체의 constructor 는 동일한 녀석인 Weapon 생성자 함수를 가리키게 된다.\n\n\n두 번째 문제의 경우, machineGun의 프로토타입 링크가 끊어지지 않은 상태에서 Weapon 함수 객체의 프로토타입 영역을 다른 객체로 대체했다. 이렇게 되면 기존 machineGun의 프로토타입 링크는 그대로 유지되는 반면에 새롭게 생성되는 newGun 객체의 프로토타입 링크는 새롭게 정의된 프로토타입 객체를 바라보게 되면서 2번 문제의 경우 다른 객체를 바라보게 됨에 따라 \"false\"인 결과가 나오게 된다.\n\n## 참고\n- [인사이드 자바스크립트](http://book.naver.com/bookdb/book_detail.nhn?bid=7400243)\n- [자바스크립트 객체지향 프로그래밍](http://book.naver.com/bookdb/book_detail.nhn?bid=6960939)\n","source":"_posts/JavaScript/Prototype.md","raw":"---\ntitle: 'JavaScript_Prototype & Prototype Chainning'\ndate: 2016.7.17. 22:50\ncategories:\n- JavaScript\n---\n\n# JavaScript_Prototype & Prototype Chainning\n자바스크립트는 **프로토타입** 기반의 객체지향 언어로 일반적인 객체 지향 언어와 다른 특성을 가지고 있다.\n\n특히, 자바스크립트는 기본적으로는 원시타입과 참조타입으로 데이터 타입을 나눌 수 있지만, 엔진 내부에서는 원시타입 역시 객체로 **오토박싱(AutoBoxing)** 을 시켜서 객체형으로 변환하여 변수를 관리한다.(즉, 원시타입도 어떤 생성자 함수의 인스턴스이다.)\n\n## 암묵적인 프로토타입 링크(implicit prototype link)\n자바스크립트의 모든 객체는 프로토타입 (링크)객체를 가지고 있다. 프로토타입 객체란, 자신을 생성한 생성자 함수의 프로토타입 객체를 가리키는 일종의 링크 객체로 자바스크립트에서 상속을 구현하는 핵심 메카니즘이라고 할 수 있다.\n- ECMA 표준에서는 이를 **암묵적인 프로토타입 링크** 라고 명칭한다.\n\n```javascript\nfunction Person(name){\n    this.name = name;\n}\nvar foo = new Person('Choi');\n\nfoo.__proto__ === Person.prototype\n```\n\n위 코드에서 foo 객체(인스턴스)의 프로토타입 링크는 foo 객체의 생성자인 Person 함수 객체의 **[프로토타입]** 영역을 가리키가 된다. 즉, 생성자 함수의 프로토타입 영역이 인스턴스의 프로토타입 링크가 가리키게 되는 객체가 되는 것이다.\n> Chrome에서는 _proto_ 라는 프로퍼티가 프로토타입 링크 역할을 하는 객체 프로퍼티가 된다.\n즉, 숨겨진 프로토타입 링크 역할을 수행하게 되는 것이다.\n\n생성자 함수로 생성된 객체뿐만 아니라, 객체 리터럴도 프로토타입 링크를 가지게 되는데 왜냐하면 객체 리터럴 역시 내부적으로는 Object() 생성자 함수의 객체(인스턴스)이기 때문에, Object.Prototype 영역을 가리키는 암묵적인 프로토타입 링크를 가지게 된다.\n\n```javascript\n// 객체 리터럴 생성\nvar obj = {};\n\n// 객체 리터럴도 Object 생성자 함수의 인스턴스이기 때문에 가리키는 프로토타입 링크와 프로토타입 영역은 동일한 객체를 바라보게 된다.\nobj.__proto__ === Object.prototype\n```\n\n> 결과적으로, 기억해야 할 부분은 바로 **객체리터럴 역시 Object() 생성자 함수의 인스턴스** 라는 점이다.\n\n\n## 프로토타입 체인(Prototype Chainning)\n자바스크립트에서 객체의 속성이나 매소드를 참조할 때, 객체에 해당 속성과 매소드가 없을 경우 **프로토타입 링크** 를 따라 프로토타입 객체의 프로퍼티를 차례대로 찾아가는 것을 **프로토타입 체인** 이라고 한다.\n\n> 객체의 속성을 읽거나 매소드를 호출(실행)할 때 프로토타입 체인이 작동한다\n\n```javascript\nvar myObj = {};\nmyObj.name = \"Choi\";\n\nmyObj.hasOwnProperty('name'); // true\nmyObj.hasOwnProperty('age'); // false\n```\n\n위 코드에서 hasOwnProperty() 매소드를 사용할 수 있는 근거도 위에서 말한대로 객체 리터럴 역시 Object() 생성자 함수의 인스턴스이기 때문에, 객체의 프로토타입 링크는 Object() 생성자 함수 객체의 프로토타입 영역을 참조하게 된다. 그래서 기존 Object() 생성자 함수의 프로토타입 영역에 정의되어 있는 매소드인 hasOwnProperty(Native 영역의 함수)를 사용할 수 있는 것이다.\n\n\n```javascript\nString.prototype.__proto__ === Object.prototype\nNumber.prototype.__proto__ === Object.prototype\n```\n\n\n이 밖에도, Number, String, Function 등의 생성자 함수들도 각자 프로토타입 영역을 가지고 있는데 **프로토타입 영역은 곧 객체** 이기 때문에 객체의 프로토타입 링크를 가지고 있게 된다. 이때 프로토타입 링크가 바라보게 되는 곳이 바로 Object()의 프로토타입 영역이기 때문에 실질적으로 모든 객체(인스턴스)에서 Object.prototype에 정의한 매서드들을 사용할 수 있는 것이 된다.\n\n\n## 프로토타입 && this\n프로토타입 객체의 속성(프로퍼티)가 매서드인 경우, 결과적으로 **this 키워드는 매서드를 호출한 객체를 바라보게 된다.** 말이 어려운데 아래 예제를 살펴보면 쉽게 이해할 수 있을 것이다.\n```javascript\nfunction Animal(name){\n    this.name = name;\n}\n\nAnimal.prototype.sayHello = function(msg){\n    return alert(this.name + \"이 말합니다. \" + msg);\n}\n\nvar tiger = new Animal('타이거');\ntiger.sayHello('난 호랭이야!'); // 타이거가 말합니다. 난 호랭이야!\n```\n\nsayHello를 호출한 객체는 바로 tiger 객체이기 때문에, sayHello 매서드 내부의 this 키워드가 가리키는 것은 바로 tiger 객체 자체를 참조하게 된다.(이것은 일종의 자바스크립트의 법칙과도 같다.) 즉, 호출한 객체의 자체를 바라보게 되는 것인데 살짝 예제를 틀어서보면 재밌는 부분을 발견할 수 있다.\n\n```javascript\nAnimal.prototype.name = \"강아지\";\n// 강아지가 말합니다. 난 강아지인데?!!!\nAnimal.prototype.sayHello('난 강아지인데?!!!');\n```\n\n첫 번쨰 예제와 두 번쨰 예제의 차이점은 sayHello() 매서도를 호출한 객체가 달라졌다는 부분이다. 다시 말해, 첫 번째 예제에서 sayHello()를 호출한 객체는 tiger 객체이기 때문에 this 키워드가 가리키는 객체는 tiger 객체가 되는 것이고, 두 번째 예제에서 sayHello()를 호출한 객체가 Animal.prototype 객체이기 때문에 this가 가리키는 녀석이 바로 Animal.prototype이 되는 것이다.\n> 정리해서, **객체의 속성(프로퍼티)가 매소드일 경우 이를 호출한 this는 호출한 객체에 바인딩된다** 가 결론이다.\n\n\n## 디플트 프로토타입 링크\n함수를 작성하면 기본적으로 디폴트 프로토타입 영역이 생성이 된다. 이 디폴트 프로토타입 영역은 constructor 라는 속성을 가지는데 constructor 단어 그 자체의 의미처럼 작성한 함수 객체를 참조하는 프로퍼티이다. 그런데 재밌는 부분은 이 디폴트 프로토타입 객체는 개발자에 의해서 변경이 가능하다는 점이다. 그렇기 때문에 프로토타입 객체의 참조 관계를 임의로 개발자가 변경하여 사용하는 것이 가능하다.\n\n```javascript\nfunction Weapon(name){\n    this.name = name;\n}\nvar machineGun = new Weapon('머신건');\n\n// 1번 문제\nmachineGun.__proto__.constructor === Weapon.prototype.constructor\n\nWeapon.prototype = {\n    sayWeaponName : function(){\n        return this.name;\n    }\n}\n\nvar newGun = new Weapon('뉴건');\n\n// 2번 문제\nmachineGun.__proto__ === newGun.__proto__\n```\n\n첫 번째 문제의 경우, Weapon 생성자 함수의 인스턴스인 machineGun의 프로토타입 링크는 Weapon 생성자 함수 객체의 프로토타입 영역을 가리키고 있기 때문에 두 객체의 constructor 는 동일한 녀석인 Weapon 생성자 함수를 가리키게 된다.\n\n\n두 번째 문제의 경우, machineGun의 프로토타입 링크가 끊어지지 않은 상태에서 Weapon 함수 객체의 프로토타입 영역을 다른 객체로 대체했다. 이렇게 되면 기존 machineGun의 프로토타입 링크는 그대로 유지되는 반면에 새롭게 생성되는 newGun 객체의 프로토타입 링크는 새롭게 정의된 프로토타입 객체를 바라보게 되면서 2번 문제의 경우 다른 객체를 바라보게 됨에 따라 \"false\"인 결과가 나오게 된다.\n\n## 참고\n- [인사이드 자바스크립트](http://book.naver.com/bookdb/book_detail.nhn?bid=7400243)\n- [자바스크립트 객체지향 프로그래밍](http://book.naver.com/bookdb/book_detail.nhn?bid=6960939)\n","slug":"JavaScript/Prototype","published":1,"updated":"2021-08-02T12:08:32.907Z","_id":"ckrsup50h0016tjhvg6z1bp5r","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"JavaScript-Prototype-amp-Prototype-Chainning\"><a href=\"#JavaScript-Prototype-amp-Prototype-Chainning\" class=\"headerlink\" title=\"JavaScript_Prototype &amp; Prototype Chainning\"></a>JavaScript_Prototype &amp; Prototype Chainning</h1><p>자바스크립트는 <strong>프로토타입</strong> 기반의 객체지향 언어로 일반적인 객체 지향 언어와 다른 특성을 가지고 있다.</p>\n<p>특히, 자바스크립트는 기본적으로는 원시타입과 참조타입으로 데이터 타입을 나눌 수 있지만, 엔진 내부에서는 원시타입 역시 객체로 <strong>오토박싱(AutoBoxing)</strong> 을 시켜서 객체형으로 변환하여 변수를 관리한다.(즉, 원시타입도 어떤 생성자 함수의 인스턴스이다.)</p>\n<h2 id=\"암묵적인-프로토타입-링크-implicit-prototype-link\"><a href=\"#암묵적인-프로토타입-링크-implicit-prototype-link\" class=\"headerlink\" title=\"암묵적인 프로토타입 링크(implicit prototype link)\"></a>암묵적인 프로토타입 링크(implicit prototype link)</h2><p>자바스크립트의 모든 객체는 프로토타입 (링크)객체를 가지고 있다. 프로토타입 객체란, 자신을 생성한 생성자 함수의 프로토타입 객체를 가리키는 일종의 링크 객체로 자바스크립트에서 상속을 구현하는 핵심 메카니즘이라고 할 수 있다.</p>\n<ul>\n<li>ECMA 표준에서는 이를 <strong>암묵적인 프로토타입 링크</strong> 라고 명칭한다.</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Choi&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">foo.__proto__ === Person.prototype</span><br></pre></td></tr></table></figure>\n\n<p>위 코드에서 foo 객체(인스턴스)의 프로토타입 링크는 foo 객체의 생성자인 Person 함수 객체의 <strong>[프로토타입]</strong> 영역을 가리키가 된다. 즉, 생성자 함수의 프로토타입 영역이 인스턴스의 프로토타입 링크가 가리키게 되는 객체가 되는 것이다.</p>\n<blockquote>\n<p>Chrome에서는 <em>proto</em> 라는 프로퍼티가 프로토타입 링크 역할을 하는 객체 프로퍼티가 된다.<br>즉, 숨겨진 프로토타입 링크 역할을 수행하게 되는 것이다.</p>\n</blockquote>\n<p>생성자 함수로 생성된 객체뿐만 아니라, 객체 리터럴도 프로토타입 링크를 가지게 되는데 왜냐하면 객체 리터럴 역시 내부적으로는 Object() 생성자 함수의 객체(인스턴스)이기 때문에, Object.Prototype 영역을 가리키는 암묵적인 프로토타입 링크를 가지게 된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 객체 리터럴 생성</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 객체 리터럴도 Object 생성자 함수의 인스턴스이기 때문에 가리키는 프로토타입 링크와 프로토타입 영역은 동일한 객체를 바라보게 된다.</span></span><br><span class=\"line\">obj.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>결과적으로, 기억해야 할 부분은 바로 <strong>객체리터럴 역시 Object() 생성자 함수의 인스턴스</strong> 라는 점이다.</p>\n</blockquote>\n<h2 id=\"프로토타입-체인-Prototype-Chainning\"><a href=\"#프로토타입-체인-Prototype-Chainning\" class=\"headerlink\" title=\"프로토타입 체인(Prototype Chainning)\"></a>프로토타입 체인(Prototype Chainning)</h2><p>자바스크립트에서 객체의 속성이나 매소드를 참조할 때, 객체에 해당 속성과 매소드가 없을 경우 <strong>프로토타입 링크</strong> 를 따라 프로토타입 객체의 프로퍼티를 차례대로 찾아가는 것을 <strong>프로토타입 체인</strong> 이라고 한다.</p>\n<blockquote>\n<p>객체의 속성을 읽거나 매소드를 호출(실행)할 때 프로토타입 체인이 작동한다</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;&#125;;</span><br><span class=\"line\">myObj.name = <span class=\"string\">&quot;Choi&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">myObj.hasOwnProperty(<span class=\"string\">&#x27;name&#x27;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObj.hasOwnProperty(<span class=\"string\">&#x27;age&#x27;</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>위 코드에서 hasOwnProperty() 매소드를 사용할 수 있는 근거도 위에서 말한대로 객체 리터럴 역시 Object() 생성자 함수의 인스턴스이기 때문에, 객체의 프로토타입 링크는 Object() 생성자 함수 객체의 프로토타입 영역을 참조하게 된다. 그래서 기존 Object() 생성자 함수의 프로토타입 영역에 정의되어 있는 매소드인 hasOwnProperty(Native 영역의 함수)를 사용할 수 있는 것이다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br><span class=\"line\"><span class=\"built_in\">Number</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br></pre></td></tr></table></figure>\n\n\n<p>이 밖에도, Number, String, Function 등의 생성자 함수들도 각자 프로토타입 영역을 가지고 있는데 <strong>프로토타입 영역은 곧 객체</strong> 이기 때문에 객체의 프로토타입 링크를 가지고 있게 된다. 이때 프로토타입 링크가 바라보게 되는 곳이 바로 Object()의 프로토타입 영역이기 때문에 실질적으로 모든 객체(인스턴스)에서 Object.prototype에 정의한 매서드들을 사용할 수 있는 것이 된다.</p>\n<h2 id=\"프로토타입-amp-amp-this\"><a href=\"#프로토타입-amp-amp-this\" class=\"headerlink\" title=\"프로토타입 &amp;&amp; this\"></a>프로토타입 &amp;&amp; this</h2><p>프로토타입 객체의 속성(프로퍼티)가 매서드인 경우, 결과적으로 <strong>this 키워드는 매서드를 호출한 객체를 바라보게 된다.</strong> 말이 어려운데 아래 예제를 살펴보면 쉽게 이해할 수 있을 것이다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> alert(<span class=\"built_in\">this</span>.name + <span class=\"string\">&quot;이 말합니다. &quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tiger = <span class=\"keyword\">new</span> Animal(<span class=\"string\">&#x27;타이거&#x27;</span>);</span><br><span class=\"line\">tiger.sayHello(<span class=\"string\">&#x27;난 호랭이야!&#x27;</span>); <span class=\"comment\">// 타이거가 말합니다. 난 호랭이야!</span></span><br></pre></td></tr></table></figure>\n\n<p>sayHello를 호출한 객체는 바로 tiger 객체이기 때문에, sayHello 매서드 내부의 this 키워드가 가리키는 것은 바로 tiger 객체 자체를 참조하게 된다.(이것은 일종의 자바스크립트의 법칙과도 같다.) 즉, 호출한 객체의 자체를 바라보게 되는 것인데 살짝 예제를 틀어서보면 재밌는 부분을 발견할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal.prototype.name = <span class=\"string\">&quot;강아지&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 강아지가 말합니다. 난 강아지인데?!!!</span></span><br><span class=\"line\">Animal.prototype.sayHello(<span class=\"string\">&#x27;난 강아지인데?!!!&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>첫 번쨰 예제와 두 번쨰 예제의 차이점은 sayHello() 매서도를 호출한 객체가 달라졌다는 부분이다. 다시 말해, 첫 번째 예제에서 sayHello()를 호출한 객체는 tiger 객체이기 때문에 this 키워드가 가리키는 객체는 tiger 객체가 되는 것이고, 두 번째 예제에서 sayHello()를 호출한 객체가 Animal.prototype 객체이기 때문에 this가 가리키는 녀석이 바로 Animal.prototype이 되는 것이다.</p>\n<blockquote>\n<p>정리해서, <strong>객체의 속성(프로퍼티)가 매소드일 경우 이를 호출한 this는 호출한 객체에 바인딩된다</strong> 가 결론이다.</p>\n</blockquote>\n<h2 id=\"디플트-프로토타입-링크\"><a href=\"#디플트-프로토타입-링크\" class=\"headerlink\" title=\"디플트 프로토타입 링크\"></a>디플트 프로토타입 링크</h2><p>함수를 작성하면 기본적으로 디폴트 프로토타입 영역이 생성이 된다. 이 디폴트 프로토타입 영역은 constructor 라는 속성을 가지는데 constructor 단어 그 자체의 의미처럼 작성한 함수 객체를 참조하는 프로퍼티이다. 그런데 재밌는 부분은 이 디폴트 프로토타입 객체는 개발자에 의해서 변경이 가능하다는 점이다. 그렇기 때문에 프로토타입 객체의 참조 관계를 임의로 개발자가 변경하여 사용하는 것이 가능하다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Weapon</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> machineGun = <span class=\"keyword\">new</span> Weapon(<span class=\"string\">&#x27;머신건&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1번 문제</span></span><br><span class=\"line\">machineGun.__proto__.constructor === Weapon.prototype.constructor</span><br><span class=\"line\"></span><br><span class=\"line\">Weapon.prototype = &#123;</span><br><span class=\"line\">    <span class=\"attr\">sayWeaponName</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> newGun = <span class=\"keyword\">new</span> Weapon(<span class=\"string\">&#x27;뉴건&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2번 문제</span></span><br><span class=\"line\">machineGun.__proto__ === newGun.__proto__</span><br></pre></td></tr></table></figure>\n\n<p>첫 번째 문제의 경우, Weapon 생성자 함수의 인스턴스인 machineGun의 프로토타입 링크는 Weapon 생성자 함수 객체의 프로토타입 영역을 가리키고 있기 때문에 두 객체의 constructor 는 동일한 녀석인 Weapon 생성자 함수를 가리키게 된다.</p>\n<p>두 번째 문제의 경우, machineGun의 프로토타입 링크가 끊어지지 않은 상태에서 Weapon 함수 객체의 프로토타입 영역을 다른 객체로 대체했다. 이렇게 되면 기존 machineGun의 프로토타입 링크는 그대로 유지되는 반면에 새롭게 생성되는 newGun 객체의 프로토타입 링크는 새롭게 정의된 프로토타입 객체를 바라보게 되면서 2번 문제의 경우 다른 객체를 바라보게 됨에 따라 “false”인 결과가 나오게 된다.</p>\n<h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><ul>\n<li><a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=7400243\">인사이드 자바스크립트</a></li>\n<li><a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=6960939\">자바스크립트 객체지향 프로그래밍</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript-Prototype-amp-Prototype-Chainning\"><a href=\"#JavaScript-Prototype-amp-Prototype-Chainning\" class=\"headerlink\" title=\"JavaScript_Prototype &amp; Prototype Chainning\"></a>JavaScript_Prototype &amp; Prototype Chainning</h1><p>자바스크립트는 <strong>프로토타입</strong> 기반의 객체지향 언어로 일반적인 객체 지향 언어와 다른 특성을 가지고 있다.</p>\n<p>특히, 자바스크립트는 기본적으로는 원시타입과 참조타입으로 데이터 타입을 나눌 수 있지만, 엔진 내부에서는 원시타입 역시 객체로 <strong>오토박싱(AutoBoxing)</strong> 을 시켜서 객체형으로 변환하여 변수를 관리한다.(즉, 원시타입도 어떤 생성자 함수의 인스턴스이다.)</p>\n<h2 id=\"암묵적인-프로토타입-링크-implicit-prototype-link\"><a href=\"#암묵적인-프로토타입-링크-implicit-prototype-link\" class=\"headerlink\" title=\"암묵적인 프로토타입 링크(implicit prototype link)\"></a>암묵적인 프로토타입 링크(implicit prototype link)</h2><p>자바스크립트의 모든 객체는 프로토타입 (링크)객체를 가지고 있다. 프로토타입 객체란, 자신을 생성한 생성자 함수의 프로토타입 객체를 가리키는 일종의 링크 객체로 자바스크립트에서 상속을 구현하는 핵심 메카니즘이라고 할 수 있다.</p>\n<ul>\n<li>ECMA 표준에서는 이를 <strong>암묵적인 프로토타입 링크</strong> 라고 명칭한다.</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Choi&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">foo.__proto__ === Person.prototype</span><br></pre></td></tr></table></figure>\n\n<p>위 코드에서 foo 객체(인스턴스)의 프로토타입 링크는 foo 객체의 생성자인 Person 함수 객체의 <strong>[프로토타입]</strong> 영역을 가리키가 된다. 즉, 생성자 함수의 프로토타입 영역이 인스턴스의 프로토타입 링크가 가리키게 되는 객체가 되는 것이다.</p>\n<blockquote>\n<p>Chrome에서는 <em>proto</em> 라는 프로퍼티가 프로토타입 링크 역할을 하는 객체 프로퍼티가 된다.<br>즉, 숨겨진 프로토타입 링크 역할을 수행하게 되는 것이다.</p>\n</blockquote>\n<p>생성자 함수로 생성된 객체뿐만 아니라, 객체 리터럴도 프로토타입 링크를 가지게 되는데 왜냐하면 객체 리터럴 역시 내부적으로는 Object() 생성자 함수의 객체(인스턴스)이기 때문에, Object.Prototype 영역을 가리키는 암묵적인 프로토타입 링크를 가지게 된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 객체 리터럴 생성</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 객체 리터럴도 Object 생성자 함수의 인스턴스이기 때문에 가리키는 프로토타입 링크와 프로토타입 영역은 동일한 객체를 바라보게 된다.</span></span><br><span class=\"line\">obj.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>결과적으로, 기억해야 할 부분은 바로 <strong>객체리터럴 역시 Object() 생성자 함수의 인스턴스</strong> 라는 점이다.</p>\n</blockquote>\n<h2 id=\"프로토타입-체인-Prototype-Chainning\"><a href=\"#프로토타입-체인-Prototype-Chainning\" class=\"headerlink\" title=\"프로토타입 체인(Prototype Chainning)\"></a>프로토타입 체인(Prototype Chainning)</h2><p>자바스크립트에서 객체의 속성이나 매소드를 참조할 때, 객체에 해당 속성과 매소드가 없을 경우 <strong>프로토타입 링크</strong> 를 따라 프로토타입 객체의 프로퍼티를 차례대로 찾아가는 것을 <strong>프로토타입 체인</strong> 이라고 한다.</p>\n<blockquote>\n<p>객체의 속성을 읽거나 매소드를 호출(실행)할 때 프로토타입 체인이 작동한다</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;&#125;;</span><br><span class=\"line\">myObj.name = <span class=\"string\">&quot;Choi&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">myObj.hasOwnProperty(<span class=\"string\">&#x27;name&#x27;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObj.hasOwnProperty(<span class=\"string\">&#x27;age&#x27;</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>위 코드에서 hasOwnProperty() 매소드를 사용할 수 있는 근거도 위에서 말한대로 객체 리터럴 역시 Object() 생성자 함수의 인스턴스이기 때문에, 객체의 프로토타입 링크는 Object() 생성자 함수 객체의 프로토타입 영역을 참조하게 된다. 그래서 기존 Object() 생성자 함수의 프로토타입 영역에 정의되어 있는 매소드인 hasOwnProperty(Native 영역의 함수)를 사용할 수 있는 것이다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br><span class=\"line\"><span class=\"built_in\">Number</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br></pre></td></tr></table></figure>\n\n\n<p>이 밖에도, Number, String, Function 등의 생성자 함수들도 각자 프로토타입 영역을 가지고 있는데 <strong>프로토타입 영역은 곧 객체</strong> 이기 때문에 객체의 프로토타입 링크를 가지고 있게 된다. 이때 프로토타입 링크가 바라보게 되는 곳이 바로 Object()의 프로토타입 영역이기 때문에 실질적으로 모든 객체(인스턴스)에서 Object.prototype에 정의한 매서드들을 사용할 수 있는 것이 된다.</p>\n<h2 id=\"프로토타입-amp-amp-this\"><a href=\"#프로토타입-amp-amp-this\" class=\"headerlink\" title=\"프로토타입 &amp;&amp; this\"></a>프로토타입 &amp;&amp; this</h2><p>프로토타입 객체의 속성(프로퍼티)가 매서드인 경우, 결과적으로 <strong>this 키워드는 매서드를 호출한 객체를 바라보게 된다.</strong> 말이 어려운데 아래 예제를 살펴보면 쉽게 이해할 수 있을 것이다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> alert(<span class=\"built_in\">this</span>.name + <span class=\"string\">&quot;이 말합니다. &quot;</span> + msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tiger = <span class=\"keyword\">new</span> Animal(<span class=\"string\">&#x27;타이거&#x27;</span>);</span><br><span class=\"line\">tiger.sayHello(<span class=\"string\">&#x27;난 호랭이야!&#x27;</span>); <span class=\"comment\">// 타이거가 말합니다. 난 호랭이야!</span></span><br></pre></td></tr></table></figure>\n\n<p>sayHello를 호출한 객체는 바로 tiger 객체이기 때문에, sayHello 매서드 내부의 this 키워드가 가리키는 것은 바로 tiger 객체 자체를 참조하게 된다.(이것은 일종의 자바스크립트의 법칙과도 같다.) 즉, 호출한 객체의 자체를 바라보게 되는 것인데 살짝 예제를 틀어서보면 재밌는 부분을 발견할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal.prototype.name = <span class=\"string\">&quot;강아지&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 강아지가 말합니다. 난 강아지인데?!!!</span></span><br><span class=\"line\">Animal.prototype.sayHello(<span class=\"string\">&#x27;난 강아지인데?!!!&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>첫 번쨰 예제와 두 번쨰 예제의 차이점은 sayHello() 매서도를 호출한 객체가 달라졌다는 부분이다. 다시 말해, 첫 번째 예제에서 sayHello()를 호출한 객체는 tiger 객체이기 때문에 this 키워드가 가리키는 객체는 tiger 객체가 되는 것이고, 두 번째 예제에서 sayHello()를 호출한 객체가 Animal.prototype 객체이기 때문에 this가 가리키는 녀석이 바로 Animal.prototype이 되는 것이다.</p>\n<blockquote>\n<p>정리해서, <strong>객체의 속성(프로퍼티)가 매소드일 경우 이를 호출한 this는 호출한 객체에 바인딩된다</strong> 가 결론이다.</p>\n</blockquote>\n<h2 id=\"디플트-프로토타입-링크\"><a href=\"#디플트-프로토타입-링크\" class=\"headerlink\" title=\"디플트 프로토타입 링크\"></a>디플트 프로토타입 링크</h2><p>함수를 작성하면 기본적으로 디폴트 프로토타입 영역이 생성이 된다. 이 디폴트 프로토타입 영역은 constructor 라는 속성을 가지는데 constructor 단어 그 자체의 의미처럼 작성한 함수 객체를 참조하는 프로퍼티이다. 그런데 재밌는 부분은 이 디폴트 프로토타입 객체는 개발자에 의해서 변경이 가능하다는 점이다. 그렇기 때문에 프로토타입 객체의 참조 관계를 임의로 개발자가 변경하여 사용하는 것이 가능하다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Weapon</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> machineGun = <span class=\"keyword\">new</span> Weapon(<span class=\"string\">&#x27;머신건&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1번 문제</span></span><br><span class=\"line\">machineGun.__proto__.constructor === Weapon.prototype.constructor</span><br><span class=\"line\"></span><br><span class=\"line\">Weapon.prototype = &#123;</span><br><span class=\"line\">    <span class=\"attr\">sayWeaponName</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> newGun = <span class=\"keyword\">new</span> Weapon(<span class=\"string\">&#x27;뉴건&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2번 문제</span></span><br><span class=\"line\">machineGun.__proto__ === newGun.__proto__</span><br></pre></td></tr></table></figure>\n\n<p>첫 번째 문제의 경우, Weapon 생성자 함수의 인스턴스인 machineGun의 프로토타입 링크는 Weapon 생성자 함수 객체의 프로토타입 영역을 가리키고 있기 때문에 두 객체의 constructor 는 동일한 녀석인 Weapon 생성자 함수를 가리키게 된다.</p>\n<p>두 번째 문제의 경우, machineGun의 프로토타입 링크가 끊어지지 않은 상태에서 Weapon 함수 객체의 프로토타입 영역을 다른 객체로 대체했다. 이렇게 되면 기존 machineGun의 프로토타입 링크는 그대로 유지되는 반면에 새롭게 생성되는 newGun 객체의 프로토타입 링크는 새롭게 정의된 프로토타입 객체를 바라보게 되면서 2번 문제의 경우 다른 객체를 바라보게 됨에 따라 “false”인 결과가 나오게 된다.</p>\n<h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><ul>\n<li><a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=7400243\">인사이드 자바스크립트</a></li>\n<li><a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=6960939\">자바스크립트 객체지향 프로그래밍</a></li>\n</ul>\n"},{"title":"Unit Testing React/Redux","date":"2016-07-11T15:00:00.000Z","_content":"\n# Unit Testing React/Redux\n\n## Why Do We Need to Write Unit Tests?\n코드베이스가 더 커지고 같이 일하게 되는 동료가 늘어남에 따라 모든 코드 베이스(함수, 모듈, 객체 등등)을 수동 혹은 사람이 직접 확인하는 일은 불가능에 가깝다. 만약, 이러한 코드베이스에 대한 개별적인 테스트를 자동화할 수 있다면 개발 시 발생하는 디버깅 소요를 크게 줄일 수 있게 된다.\n![lost](http://i.imgur.com/Msb5kkd.jpg)\n\n유닛 테스트를 작성하여 얻게 되는 이점은 바로 기능 추가/변경/수정에 대하여 일종의 이력을 남기는 효과를 발생하기 때문에 개발자들이 본인이 작성한 코드에 대하여 리팩토링에 대한 고통 혹은 걱정거리를 줄여줄 수 있게 된다. 결국, 테스트에 대한 고통스러운 소요를 줄일 수 있게 되고 이는 곧 안정적인 코드를 만드는 좋은 흐름을 제공하게 되는 것이다.\n\n## What About React/Redux?\nReact & Redux 조합의 어플리케이션에서 사용하는 요소들은 아래와 같다.\n- **Actions**\n- **Reducers**\n- **Components**\n- **Middlewares**\n\n위 네 가지가 주된 테스트의 대상이 될 수 있으며, 경우에 따라 유틸리티 성격의 코드 또한 테스트의 대상이 될 수 있다.\n\n## Prerequisite\n테스트 프레임워크는 Facebook에서 만든 [Jest](https://facebook.github.io/jest/)를 사용하며, 사용과 관련된 기본 튜토리얼은 [링크](https://facebook.github.io/jest/docs/tutorial-react.html#content)를 참고하자. 이외에 사용하는 모듈은 하단과 같고, 설치는 [NPM](https://www.npmjs.com/) 패키지 매니저를 통하여 설치한다.\n\n- [sinon.js](http://sinonjs.org/)\n  - 테스트 더블(SPY, STUB, MOCK) 객체 생성을 도와주는 라이브러리.\n- [nock](https://github.com/node-nock/nock)\n  - HTTP 요청 목 객체 생성.\n- [redux-mock-store](https://github.com/arnaudbenard/redux-mock-store)\n  - Redux Mock Store 생성\n- [redux-thunk](https://github.com/gaearon/redux-thunk)\n  - Redux Store 생성을 위한 미들웨어\n\n## Action Tests\n리덕스 어플리케이션 디자인에서 액션은 단지 객체를 리턴하는 함수에 불과하다. 아래 예제는 **React&Redux 어플리케이션에서 HTTP API를 호출하는 액션 기본 형태** 를 보여준다.\n\n\n```javascript\n// action.js\nimport { callApi } from './api';\nimport * as ActionTypes from './constants';\n\nexport function loadQuestions() {\n  return {\n    type: ActionTypes.LOAD_QUESTIONS,\n    promise: api.loadQuestions()\n  }\n}\n```\n위 예제에서 주목해야 할 부분은 바로 <code>promise</code>프로퍼티이다. **<code>promise</code> 프로퍼티는 <code>promiseMiddleware</code>가 인터셉트하여 액션에 따른 리듀서 호출을 정하게 된다.**\n\n```javascript\n// promiseMiddleware.js\nexport default function promiseMiddleware() {\n  return next => action => {\n    const { promise, type, ...rest } = action;\n\n    if (!promise) return next(action);\n\n    const SUCCESS = `${type}_SUCCESS`;\n    const REQUEST = `${type}_REQUEST`;\n    const FAILURE = `${type}_FAILURE`;\n    next({ ...rest, type: REQUEST });\n    return promise\n      .then(res => {\n        next({ ...rest, res, type: SUCCESS });\n        return true;\n      })\n      .catch(error => {\n        next({ ...rest, error, type: FAILURE });\n        return false;\n      });\n  };\n}\n```\n위 프로미스 미들웨어는 <code>promise</code> 프로퍼티의 존재 유무 및 실행 결과(<code>then()</code> or <code>catch()</code>)에 따라 분기하여 <code>ACTION_NAME_SUCESS</code> -> <code>ACTION_NAME_SUCESS</code> 혹은 <code>ACTION_NAME_FAILURE</code> 액션 프로퍼티를 포함한 객체를 리턴하게 된다.\n\n간단하게 처리 흐름에 대하여 설명했고, 이제 액션 코드에 대하여 테스트 코드를 작성해보자. 테스트는 <code>promise</code>의 구현을 어떻게 해야 할 것인지에 따라 2가지로 나뉠 수 있다.\n- HTTP 목 객체를 활용한 테스트\n- 단순 액션 리턴\n\n```javascript\n\n```\n\n\n## Reducer Tests\n리듀서는 State와 Action을 연결하는 함수로서 새로운 상태 값을 리턴한다. 다시 말해, 리듀서는 액션을 받고 어떤 상태 값으로 바뀌는지에 대한 명세이다.\n> In Redux, a reducer acts like a function that connects a state to an action, and then returns a new state. In other words, a reducer will receive an action, and then decide how the state should be changed based on the action and the current state.\n\n## Middleware Tests\n**Redux 앱에서 미들웨어는 요청을 인터셉트하며 이를 다시 리듀서에 디스패치하는 함수** 이며 리듀서에 디스패치 하는 과정에서 **원래 액션을 변경하거나 추가적인 로직을 수행하는 역할을 한다.** 일반적인 미들웨어 형태는 아래와 같다.\n\n```javascript\nfunction(store) {\n  return function(next) {\n    return function(action) {\n      // middleware behavior...\n    };\n  };\n}\n```\n> In a Redux app, the middleware is responsible for intercepting an action that was dispatched to a reducer and changing the action’s original behavior before it reaches the reducer. The middleware itself is a function with a signature that looks like this:\n\n만약, ES6 개발 환경을 갖춰져 있다면 아래와 같은 형태로 함수 전개가 가능하다.\n```javascript\nstore => next => action => {\n  // middleware behavior...\n}\n```\n\n## Component Tests\n\n\n## 참고\n - [Unit Testing a Redux App](https://www.codementor.io/reactjs/tutorial/redux-unit-test-mocha-mocking)\n - [Unit Testing React/Redux](https://alexzywiak.github.io/unit-testing-react-redux/)\n - [Redux Middleware](http://jonnyreeves.co.uk/2016/redux-middleware/)\n","source":"_posts/JavaScript/React-Redux-Test.md","raw":"---\ntitle: 'Unit Testing React/Redux'\ndate: 2016/7/12 00:00:00\ncategories:\n- JavaScript\n---\n\n# Unit Testing React/Redux\n\n## Why Do We Need to Write Unit Tests?\n코드베이스가 더 커지고 같이 일하게 되는 동료가 늘어남에 따라 모든 코드 베이스(함수, 모듈, 객체 등등)을 수동 혹은 사람이 직접 확인하는 일은 불가능에 가깝다. 만약, 이러한 코드베이스에 대한 개별적인 테스트를 자동화할 수 있다면 개발 시 발생하는 디버깅 소요를 크게 줄일 수 있게 된다.\n![lost](http://i.imgur.com/Msb5kkd.jpg)\n\n유닛 테스트를 작성하여 얻게 되는 이점은 바로 기능 추가/변경/수정에 대하여 일종의 이력을 남기는 효과를 발생하기 때문에 개발자들이 본인이 작성한 코드에 대하여 리팩토링에 대한 고통 혹은 걱정거리를 줄여줄 수 있게 된다. 결국, 테스트에 대한 고통스러운 소요를 줄일 수 있게 되고 이는 곧 안정적인 코드를 만드는 좋은 흐름을 제공하게 되는 것이다.\n\n## What About React/Redux?\nReact & Redux 조합의 어플리케이션에서 사용하는 요소들은 아래와 같다.\n- **Actions**\n- **Reducers**\n- **Components**\n- **Middlewares**\n\n위 네 가지가 주된 테스트의 대상이 될 수 있으며, 경우에 따라 유틸리티 성격의 코드 또한 테스트의 대상이 될 수 있다.\n\n## Prerequisite\n테스트 프레임워크는 Facebook에서 만든 [Jest](https://facebook.github.io/jest/)를 사용하며, 사용과 관련된 기본 튜토리얼은 [링크](https://facebook.github.io/jest/docs/tutorial-react.html#content)를 참고하자. 이외에 사용하는 모듈은 하단과 같고, 설치는 [NPM](https://www.npmjs.com/) 패키지 매니저를 통하여 설치한다.\n\n- [sinon.js](http://sinonjs.org/)\n  - 테스트 더블(SPY, STUB, MOCK) 객체 생성을 도와주는 라이브러리.\n- [nock](https://github.com/node-nock/nock)\n  - HTTP 요청 목 객체 생성.\n- [redux-mock-store](https://github.com/arnaudbenard/redux-mock-store)\n  - Redux Mock Store 생성\n- [redux-thunk](https://github.com/gaearon/redux-thunk)\n  - Redux Store 생성을 위한 미들웨어\n\n## Action Tests\n리덕스 어플리케이션 디자인에서 액션은 단지 객체를 리턴하는 함수에 불과하다. 아래 예제는 **React&Redux 어플리케이션에서 HTTP API를 호출하는 액션 기본 형태** 를 보여준다.\n\n\n```javascript\n// action.js\nimport { callApi } from './api';\nimport * as ActionTypes from './constants';\n\nexport function loadQuestions() {\n  return {\n    type: ActionTypes.LOAD_QUESTIONS,\n    promise: api.loadQuestions()\n  }\n}\n```\n위 예제에서 주목해야 할 부분은 바로 <code>promise</code>프로퍼티이다. **<code>promise</code> 프로퍼티는 <code>promiseMiddleware</code>가 인터셉트하여 액션에 따른 리듀서 호출을 정하게 된다.**\n\n```javascript\n// promiseMiddleware.js\nexport default function promiseMiddleware() {\n  return next => action => {\n    const { promise, type, ...rest } = action;\n\n    if (!promise) return next(action);\n\n    const SUCCESS = `${type}_SUCCESS`;\n    const REQUEST = `${type}_REQUEST`;\n    const FAILURE = `${type}_FAILURE`;\n    next({ ...rest, type: REQUEST });\n    return promise\n      .then(res => {\n        next({ ...rest, res, type: SUCCESS });\n        return true;\n      })\n      .catch(error => {\n        next({ ...rest, error, type: FAILURE });\n        return false;\n      });\n  };\n}\n```\n위 프로미스 미들웨어는 <code>promise</code> 프로퍼티의 존재 유무 및 실행 결과(<code>then()</code> or <code>catch()</code>)에 따라 분기하여 <code>ACTION_NAME_SUCESS</code> -> <code>ACTION_NAME_SUCESS</code> 혹은 <code>ACTION_NAME_FAILURE</code> 액션 프로퍼티를 포함한 객체를 리턴하게 된다.\n\n간단하게 처리 흐름에 대하여 설명했고, 이제 액션 코드에 대하여 테스트 코드를 작성해보자. 테스트는 <code>promise</code>의 구현을 어떻게 해야 할 것인지에 따라 2가지로 나뉠 수 있다.\n- HTTP 목 객체를 활용한 테스트\n- 단순 액션 리턴\n\n```javascript\n\n```\n\n\n## Reducer Tests\n리듀서는 State와 Action을 연결하는 함수로서 새로운 상태 값을 리턴한다. 다시 말해, 리듀서는 액션을 받고 어떤 상태 값으로 바뀌는지에 대한 명세이다.\n> In Redux, a reducer acts like a function that connects a state to an action, and then returns a new state. In other words, a reducer will receive an action, and then decide how the state should be changed based on the action and the current state.\n\n## Middleware Tests\n**Redux 앱에서 미들웨어는 요청을 인터셉트하며 이를 다시 리듀서에 디스패치하는 함수** 이며 리듀서에 디스패치 하는 과정에서 **원래 액션을 변경하거나 추가적인 로직을 수행하는 역할을 한다.** 일반적인 미들웨어 형태는 아래와 같다.\n\n```javascript\nfunction(store) {\n  return function(next) {\n    return function(action) {\n      // middleware behavior...\n    };\n  };\n}\n```\n> In a Redux app, the middleware is responsible for intercepting an action that was dispatched to a reducer and changing the action’s original behavior before it reaches the reducer. The middleware itself is a function with a signature that looks like this:\n\n만약, ES6 개발 환경을 갖춰져 있다면 아래와 같은 형태로 함수 전개가 가능하다.\n```javascript\nstore => next => action => {\n  // middleware behavior...\n}\n```\n\n## Component Tests\n\n\n## 참고\n - [Unit Testing a Redux App](https://www.codementor.io/reactjs/tutorial/redux-unit-test-mocha-mocking)\n - [Unit Testing React/Redux](https://alexzywiak.github.io/unit-testing-react-redux/)\n - [Redux Middleware](http://jonnyreeves.co.uk/2016/redux-middleware/)\n","slug":"JavaScript/React-Redux-Test","published":1,"updated":"2021-08-02T12:28:30.743Z","_id":"ckrsup50j0017tjhv5ef48n46","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Unit-Testing-React-Redux\"><a href=\"#Unit-Testing-React-Redux\" class=\"headerlink\" title=\"Unit Testing React/Redux\"></a>Unit Testing React/Redux</h1><h2 id=\"Why-Do-We-Need-to-Write-Unit-Tests\"><a href=\"#Why-Do-We-Need-to-Write-Unit-Tests\" class=\"headerlink\" title=\"Why Do We Need to Write Unit Tests?\"></a>Why Do We Need to Write Unit Tests?</h2><p>코드베이스가 더 커지고 같이 일하게 되는 동료가 늘어남에 따라 모든 코드 베이스(함수, 모듈, 객체 등등)을 수동 혹은 사람이 직접 확인하는 일은 불가능에 가깝다. 만약, 이러한 코드베이스에 대한 개별적인 테스트를 자동화할 수 있다면 개발 시 발생하는 디버깅 소요를 크게 줄일 수 있게 된다.<br><img src=\"http://i.imgur.com/Msb5kkd.jpg\" alt=\"lost\"></p>\n<p>유닛 테스트를 작성하여 얻게 되는 이점은 바로 기능 추가/변경/수정에 대하여 일종의 이력을 남기는 효과를 발생하기 때문에 개발자들이 본인이 작성한 코드에 대하여 리팩토링에 대한 고통 혹은 걱정거리를 줄여줄 수 있게 된다. 결국, 테스트에 대한 고통스러운 소요를 줄일 수 있게 되고 이는 곧 안정적인 코드를 만드는 좋은 흐름을 제공하게 되는 것이다.</p>\n<h2 id=\"What-About-React-Redux\"><a href=\"#What-About-React-Redux\" class=\"headerlink\" title=\"What About React/Redux?\"></a>What About React/Redux?</h2><p>React &amp; Redux 조합의 어플리케이션에서 사용하는 요소들은 아래와 같다.</p>\n<ul>\n<li><strong>Actions</strong></li>\n<li><strong>Reducers</strong></li>\n<li><strong>Components</strong></li>\n<li><strong>Middlewares</strong></li>\n</ul>\n<p>위 네 가지가 주된 테스트의 대상이 될 수 있으며, 경우에 따라 유틸리티 성격의 코드 또한 테스트의 대상이 될 수 있다.</p>\n<h2 id=\"Prerequisite\"><a href=\"#Prerequisite\" class=\"headerlink\" title=\"Prerequisite\"></a>Prerequisite</h2><p>테스트 프레임워크는 Facebook에서 만든 <a href=\"https://facebook.github.io/jest/\">Jest</a>를 사용하며, 사용과 관련된 기본 튜토리얼은 <a href=\"https://facebook.github.io/jest/docs/tutorial-react.html#content\">링크</a>를 참고하자. 이외에 사용하는 모듈은 하단과 같고, 설치는 <a href=\"https://www.npmjs.com/\">NPM</a> 패키지 매니저를 통하여 설치한다.</p>\n<ul>\n<li><a href=\"http://sinonjs.org/\">sinon.js</a><ul>\n<li>테스트 더블(SPY, STUB, MOCK) 객체 생성을 도와주는 라이브러리.</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/node-nock/nock\">nock</a><ul>\n<li>HTTP 요청 목 객체 생성.</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/arnaudbenard/redux-mock-store\">redux-mock-store</a><ul>\n<li>Redux Mock Store 생성</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/gaearon/redux-thunk\">redux-thunk</a><ul>\n<li>Redux Store 생성을 위한 미들웨어</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Action-Tests\"><a href=\"#Action-Tests\" class=\"headerlink\" title=\"Action Tests\"></a>Action Tests</h2><p>리덕스 어플리케이션 디자인에서 액션은 단지 객체를 리턴하는 함수에 불과하다. 아래 예제는 <strong>React&amp;Redux 어플리케이션에서 HTTP API를 호출하는 액션 기본 형태</strong> 를 보여준다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// action.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; callApi &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./api&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> ActionTypes <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./constants&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadQuestions</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: ActionTypes.LOAD_QUESTIONS,</span><br><span class=\"line\">    <span class=\"attr\">promise</span>: api.loadQuestions()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위 예제에서 주목해야 할 부분은 바로 <code>promise</code>프로퍼티이다. <strong><code>promise</code> 프로퍼티는 <code>promiseMiddleware</code>가 인터셉트하여 액션에 따른 리듀서 호출을 정하게 된다.</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// promiseMiddleware.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">promiseMiddleware</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; promise, type, ...rest &#125; = action;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!promise) <span class=\"keyword\">return</span> next(action);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> SUCCESS = <span class=\"string\">`<span class=\"subst\">$&#123;type&#125;</span>_SUCCESS`</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> REQUEST = <span class=\"string\">`<span class=\"subst\">$&#123;type&#125;</span>_REQUEST`</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> FAILURE = <span class=\"string\">`<span class=\"subst\">$&#123;type&#125;</span>_FAILURE`</span>;</span><br><span class=\"line\">    next(&#123; ...rest, <span class=\"attr\">type</span>: REQUEST &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">        next(&#123; ...rest, res, <span class=\"attr\">type</span>: SUCCESS &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">        next(&#123; ...rest, error, <span class=\"attr\">type</span>: FAILURE &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위 프로미스 미들웨어는 <code>promise</code> 프로퍼티의 존재 유무 및 실행 결과(<code>then()</code> or <code>catch()</code>)에 따라 분기하여 <code>ACTION_NAME_SUCESS</code> -&gt; <code>ACTION_NAME_SUCESS</code> 혹은 <code>ACTION_NAME_FAILURE</code> 액션 프로퍼티를 포함한 객체를 리턴하게 된다.</p>\n<p>간단하게 처리 흐름에 대하여 설명했고, 이제 액션 코드에 대하여 테스트 코드를 작성해보자. 테스트는 <code>promise</code>의 구현을 어떻게 해야 할 것인지에 따라 2가지로 나뉠 수 있다.</p>\n<ul>\n<li>HTTP 목 객체를 활용한 테스트</li>\n<li>단순 액션 리턴</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Reducer-Tests\"><a href=\"#Reducer-Tests\" class=\"headerlink\" title=\"Reducer Tests\"></a>Reducer Tests</h2><p>리듀서는 State와 Action을 연결하는 함수로서 새로운 상태 값을 리턴한다. 다시 말해, 리듀서는 액션을 받고 어떤 상태 값으로 바뀌는지에 대한 명세이다.</p>\n<blockquote>\n<p>In Redux, a reducer acts like a function that connects a state to an action, and then returns a new state. In other words, a reducer will receive an action, and then decide how the state should be changed based on the action and the current state.</p>\n</blockquote>\n<h2 id=\"Middleware-Tests\"><a href=\"#Middleware-Tests\" class=\"headerlink\" title=\"Middleware Tests\"></a>Middleware Tests</h2><p><strong>Redux 앱에서 미들웨어는 요청을 인터셉트하며 이를 다시 리듀서에 디스패치하는 함수</strong> 이며 리듀서에 디스패치 하는 과정에서 <strong>원래 액션을 변경하거나 추가적인 로직을 수행하는 역할을 한다.</strong> 일반적인 미들웨어 형태는 아래와 같다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// middleware behavior...</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>In a Redux app, the middleware is responsible for intercepting an action that was dispatched to a reducer and changing the action’s original behavior before it reaches the reducer. The middleware itself is a function with a signature that looks like this:</p>\n</blockquote>\n<p>만약, ES6 개발 환경을 갖춰져 있다면 아래와 같은 형태로 함수 전개가 가능하다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store =&gt; <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// middleware behavior...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Component-Tests\"><a href=\"#Component-Tests\" class=\"headerlink\" title=\"Component Tests\"></a>Component Tests</h2><h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><ul>\n<li><a href=\"https://www.codementor.io/reactjs/tutorial/redux-unit-test-mocha-mocking\">Unit Testing a Redux App</a></li>\n<li><a href=\"https://alexzywiak.github.io/unit-testing-react-redux/\">Unit Testing React/Redux</a></li>\n<li><a href=\"http://jonnyreeves.co.uk/2016/redux-middleware/\">Redux Middleware</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Unit-Testing-React-Redux\"><a href=\"#Unit-Testing-React-Redux\" class=\"headerlink\" title=\"Unit Testing React/Redux\"></a>Unit Testing React/Redux</h1><h2 id=\"Why-Do-We-Need-to-Write-Unit-Tests\"><a href=\"#Why-Do-We-Need-to-Write-Unit-Tests\" class=\"headerlink\" title=\"Why Do We Need to Write Unit Tests?\"></a>Why Do We Need to Write Unit Tests?</h2><p>코드베이스가 더 커지고 같이 일하게 되는 동료가 늘어남에 따라 모든 코드 베이스(함수, 모듈, 객체 등등)을 수동 혹은 사람이 직접 확인하는 일은 불가능에 가깝다. 만약, 이러한 코드베이스에 대한 개별적인 테스트를 자동화할 수 있다면 개발 시 발생하는 디버깅 소요를 크게 줄일 수 있게 된다.<br><img src=\"http://i.imgur.com/Msb5kkd.jpg\" alt=\"lost\"></p>\n<p>유닛 테스트를 작성하여 얻게 되는 이점은 바로 기능 추가/변경/수정에 대하여 일종의 이력을 남기는 효과를 발생하기 때문에 개발자들이 본인이 작성한 코드에 대하여 리팩토링에 대한 고통 혹은 걱정거리를 줄여줄 수 있게 된다. 결국, 테스트에 대한 고통스러운 소요를 줄일 수 있게 되고 이는 곧 안정적인 코드를 만드는 좋은 흐름을 제공하게 되는 것이다.</p>\n<h2 id=\"What-About-React-Redux\"><a href=\"#What-About-React-Redux\" class=\"headerlink\" title=\"What About React/Redux?\"></a>What About React/Redux?</h2><p>React &amp; Redux 조합의 어플리케이션에서 사용하는 요소들은 아래와 같다.</p>\n<ul>\n<li><strong>Actions</strong></li>\n<li><strong>Reducers</strong></li>\n<li><strong>Components</strong></li>\n<li><strong>Middlewares</strong></li>\n</ul>\n<p>위 네 가지가 주된 테스트의 대상이 될 수 있으며, 경우에 따라 유틸리티 성격의 코드 또한 테스트의 대상이 될 수 있다.</p>\n<h2 id=\"Prerequisite\"><a href=\"#Prerequisite\" class=\"headerlink\" title=\"Prerequisite\"></a>Prerequisite</h2><p>테스트 프레임워크는 Facebook에서 만든 <a href=\"https://facebook.github.io/jest/\">Jest</a>를 사용하며, 사용과 관련된 기본 튜토리얼은 <a href=\"https://facebook.github.io/jest/docs/tutorial-react.html#content\">링크</a>를 참고하자. 이외에 사용하는 모듈은 하단과 같고, 설치는 <a href=\"https://www.npmjs.com/\">NPM</a> 패키지 매니저를 통하여 설치한다.</p>\n<ul>\n<li><a href=\"http://sinonjs.org/\">sinon.js</a><ul>\n<li>테스트 더블(SPY, STUB, MOCK) 객체 생성을 도와주는 라이브러리.</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/node-nock/nock\">nock</a><ul>\n<li>HTTP 요청 목 객체 생성.</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/arnaudbenard/redux-mock-store\">redux-mock-store</a><ul>\n<li>Redux Mock Store 생성</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/gaearon/redux-thunk\">redux-thunk</a><ul>\n<li>Redux Store 생성을 위한 미들웨어</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Action-Tests\"><a href=\"#Action-Tests\" class=\"headerlink\" title=\"Action Tests\"></a>Action Tests</h2><p>리덕스 어플리케이션 디자인에서 액션은 단지 객체를 리턴하는 함수에 불과하다. 아래 예제는 <strong>React&amp;Redux 어플리케이션에서 HTTP API를 호출하는 액션 기본 형태</strong> 를 보여준다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// action.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; callApi &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./api&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> ActionTypes <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./constants&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadQuestions</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: ActionTypes.LOAD_QUESTIONS,</span><br><span class=\"line\">    <span class=\"attr\">promise</span>: api.loadQuestions()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위 예제에서 주목해야 할 부분은 바로 <code>promise</code>프로퍼티이다. <strong><code>promise</code> 프로퍼티는 <code>promiseMiddleware</code>가 인터셉트하여 액션에 따른 리듀서 호출을 정하게 된다.</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// promiseMiddleware.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">promiseMiddleware</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; promise, type, ...rest &#125; = action;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!promise) <span class=\"keyword\">return</span> next(action);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> SUCCESS = <span class=\"string\">`<span class=\"subst\">$&#123;type&#125;</span>_SUCCESS`</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> REQUEST = <span class=\"string\">`<span class=\"subst\">$&#123;type&#125;</span>_REQUEST`</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> FAILURE = <span class=\"string\">`<span class=\"subst\">$&#123;type&#125;</span>_FAILURE`</span>;</span><br><span class=\"line\">    next(&#123; ...rest, <span class=\"attr\">type</span>: REQUEST &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">        next(&#123; ...rest, res, <span class=\"attr\">type</span>: SUCCESS &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">        next(&#123; ...rest, error, <span class=\"attr\">type</span>: FAILURE &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위 프로미스 미들웨어는 <code>promise</code> 프로퍼티의 존재 유무 및 실행 결과(<code>then()</code> or <code>catch()</code>)에 따라 분기하여 <code>ACTION_NAME_SUCESS</code> -&gt; <code>ACTION_NAME_SUCESS</code> 혹은 <code>ACTION_NAME_FAILURE</code> 액션 프로퍼티를 포함한 객체를 리턴하게 된다.</p>\n<p>간단하게 처리 흐름에 대하여 설명했고, 이제 액션 코드에 대하여 테스트 코드를 작성해보자. 테스트는 <code>promise</code>의 구현을 어떻게 해야 할 것인지에 따라 2가지로 나뉠 수 있다.</p>\n<ul>\n<li>HTTP 목 객체를 활용한 테스트</li>\n<li>단순 액션 리턴</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Reducer-Tests\"><a href=\"#Reducer-Tests\" class=\"headerlink\" title=\"Reducer Tests\"></a>Reducer Tests</h2><p>리듀서는 State와 Action을 연결하는 함수로서 새로운 상태 값을 리턴한다. 다시 말해, 리듀서는 액션을 받고 어떤 상태 값으로 바뀌는지에 대한 명세이다.</p>\n<blockquote>\n<p>In Redux, a reducer acts like a function that connects a state to an action, and then returns a new state. In other words, a reducer will receive an action, and then decide how the state should be changed based on the action and the current state.</p>\n</blockquote>\n<h2 id=\"Middleware-Tests\"><a href=\"#Middleware-Tests\" class=\"headerlink\" title=\"Middleware Tests\"></a>Middleware Tests</h2><p><strong>Redux 앱에서 미들웨어는 요청을 인터셉트하며 이를 다시 리듀서에 디스패치하는 함수</strong> 이며 리듀서에 디스패치 하는 과정에서 <strong>원래 액션을 변경하거나 추가적인 로직을 수행하는 역할을 한다.</strong> 일반적인 미들웨어 형태는 아래와 같다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">store</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// middleware behavior...</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>In a Redux app, the middleware is responsible for intercepting an action that was dispatched to a reducer and changing the action’s original behavior before it reaches the reducer. The middleware itself is a function with a signature that looks like this:</p>\n</blockquote>\n<p>만약, ES6 개발 환경을 갖춰져 있다면 아래와 같은 형태로 함수 전개가 가능하다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store =&gt; <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// middleware behavior...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Component-Tests\"><a href=\"#Component-Tests\" class=\"headerlink\" title=\"Component Tests\"></a>Component Tests</h2><h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><ul>\n<li><a href=\"https://www.codementor.io/reactjs/tutorial/redux-unit-test-mocha-mocking\">Unit Testing a Redux App</a></li>\n<li><a href=\"https://alexzywiak.github.io/unit-testing-react-redux/\">Unit Testing React/Redux</a></li>\n<li><a href=\"http://jonnyreeves.co.uk/2016/redux-middleware/\">Redux Middleware</a></li>\n</ul>\n"},{"title":"PM2","date":"2016-07-15T05:54:00.000Z","_content":"\n# PM2\n- Node.js 애플리케이션용 프로덕션 프로세스 관리자\n- 로드 밸런서 기본 제공\n- 앱을 항상 작동 상태로 유지\n- 시스템 가동 중단 없이 앱을 다시 로드\n  - **MAX MEMORY RESTART** 기능을 제공하는데 **커맨드라인/JSON/코드(JS)** 등으로 설정 가능하다.\n- 일반적인 시스템 관리 태스크를 쉽게 처리 가능\n- 애플리케이션 로깅, 모니터링 및 클러스터링을 관리\n  - 클러스터 모드의 경우, 여러개의 프로세스를 생성해놓고, 이를 PM2에서 자동으로 로드밸런싱으로 지원해주기 때문에, 앞단 웹 서버(Nginx, Apache Server 등)에서 프록시 설정만 간단히 해줘도 된다.\n\n## 설치\n```bash\n$ [sudo] npm install pm2 -g\n```\n\n## 기본 사용\n앱을 시작할때 즉시 백그라운드로 보내진다.\n```bash\n$ pm2 start app.js\n```\n\n메뉴얼을 읽으면서 가장 괜찮다고 생각한 부분이 바로 다른 스크립트 언어도 같이 지원하는 부분이었다.\n```\n$ pm2 start echo.pl --interpreter=perl\n\n$ pm2 start echo.coffee\n$ pm2 start echo.php\n$ pm2 start echo.py\n$ pm2 start echo.sh\n$ pm2 start echo.rb\n```\n\n## 어플리케이션 설정 파일 사용\nJSON, YML 포맷으로 만들어진 파일을 일종의 시작 프로파일로 사용할 수 있다.\n```bash\n$ pm2 start start.yml(start.json)\n```\n\n**start.yml**\n```yml\napps:\n  - script   : app.js\n    instances: 4\n    exec_mode: cluster\n  - script : worker.js\n    watch  : true\n    env    :\n      NODE_ENV: development\n    env_production:\n      NODE_ENV: production\n```\n\n**start.json**\n```json\n{\n      \"apps\" : [\n            {\n            \"name\"       : \"bash-worker\",\n            \"script\"     : \"./a-bash-script\",\n            \"exec_interpreter\": \"bash\",\n            \"exec_mode\"  : \"fork_mode\"\n            },\n            {\n            \"name\"       : \"ruby-worker\",\n            \"script\"     : \"./some-ruby-script\",\n            \"exec_interpreter\": \"ruby\",\n            \"exec_mode\"  : \"fork_mode\"\n            }\n      ]\n}\n```\n\n\n## CheatSheat\n- 출처 : [PM2 공식 홈페이지](http://pm2.keymetrics.io/docs/usage/quick-start/#cheat-sheet)\n```bash\n# Fork mode\n$ pm2 start app.js --name my-api # 프로세스 네임 지정\n\n# Cluster mode\n$ pm2 start app.js -i 0     # 가용한 CPU 갯수만큼 클러스터 확장\n$ pm2 start app.js -i max   # 위 설정과 동일하지만 곧 Deprecated 예정?\n\n# Listing\n$ pm2 list               # 모든 프로세스 리스트/상태 확인\n$ pm2 jlist              # 모든 프로세스 리스트/상태 확인(JSON)\n$ pm2 prettylist         # 모든 프로세스 리스트/상태 확인(Beatiful JSON)\n\n$ pm2 describe 0         # 특정 프로세스 정보 확인\n$ pm2 monit              # 모든 프로세스 모니터링\n\n# Logs\n\n$ pm2 logs [--raw]       # Display all processes logs in streaming\n$ pm2 flush              # Empty all log file\n$ pm2 reloadLogs         # Reload all logs\n\n# Actions\n\n$ pm2 stop all           # Stop all processes\n$ pm2 restart all        # Restart all processes\n\n$ pm2 reload all         # Will 0s downtime reload (for NETWORKED apps)\n$ pm2 gracefulReload all # Send exit message then reload (for networked apps)\n\n$ pm2 stop 0             # Stop specific process id\n$ pm2 restart 0          # Restart specific process id\n\n$ pm2 delete 0           # Will remove process from pm2 list\n$ pm2 delete all         # Will remove all processes from pm2 list\n\n# Misc\n\n$ pm2 reset <process>    # Reset meta data (restarted time...)\n$ pm2 updatePM2          # Update in memory pm2\n$ pm2 ping               # Ensure pm2 daemon has been launched\n$ pm2 sendSignal SIGUSR2 my-app # Send system signal to script\n$ pm2 start app.js --no-daemon\n$ pm2 start app.js --no-vizion\n$ pm2 start app.js --no-autorestart\n\n```\n\n\n# 참고\n- [Deploying Node.js with PM2 and Nginx](https://doesnotscale.com/deploying-node-js-with-pm2-and-nginx/)\n- [PM2 를 이용하여 NodeJS 프로세스 관리하기](http://www.tutorialbook.co.kr/entry/PM2-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-NodeJS-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0)\n","source":"_posts/JavaScript/pm2.md","raw":"---\ntitle: 'PM2'\ndate: 2016.7.15. 14:54\ncategories:\n- JavaScript\n---\n\n# PM2\n- Node.js 애플리케이션용 프로덕션 프로세스 관리자\n- 로드 밸런서 기본 제공\n- 앱을 항상 작동 상태로 유지\n- 시스템 가동 중단 없이 앱을 다시 로드\n  - **MAX MEMORY RESTART** 기능을 제공하는데 **커맨드라인/JSON/코드(JS)** 등으로 설정 가능하다.\n- 일반적인 시스템 관리 태스크를 쉽게 처리 가능\n- 애플리케이션 로깅, 모니터링 및 클러스터링을 관리\n  - 클러스터 모드의 경우, 여러개의 프로세스를 생성해놓고, 이를 PM2에서 자동으로 로드밸런싱으로 지원해주기 때문에, 앞단 웹 서버(Nginx, Apache Server 등)에서 프록시 설정만 간단히 해줘도 된다.\n\n## 설치\n```bash\n$ [sudo] npm install pm2 -g\n```\n\n## 기본 사용\n앱을 시작할때 즉시 백그라운드로 보내진다.\n```bash\n$ pm2 start app.js\n```\n\n메뉴얼을 읽으면서 가장 괜찮다고 생각한 부분이 바로 다른 스크립트 언어도 같이 지원하는 부분이었다.\n```\n$ pm2 start echo.pl --interpreter=perl\n\n$ pm2 start echo.coffee\n$ pm2 start echo.php\n$ pm2 start echo.py\n$ pm2 start echo.sh\n$ pm2 start echo.rb\n```\n\n## 어플리케이션 설정 파일 사용\nJSON, YML 포맷으로 만들어진 파일을 일종의 시작 프로파일로 사용할 수 있다.\n```bash\n$ pm2 start start.yml(start.json)\n```\n\n**start.yml**\n```yml\napps:\n  - script   : app.js\n    instances: 4\n    exec_mode: cluster\n  - script : worker.js\n    watch  : true\n    env    :\n      NODE_ENV: development\n    env_production:\n      NODE_ENV: production\n```\n\n**start.json**\n```json\n{\n      \"apps\" : [\n            {\n            \"name\"       : \"bash-worker\",\n            \"script\"     : \"./a-bash-script\",\n            \"exec_interpreter\": \"bash\",\n            \"exec_mode\"  : \"fork_mode\"\n            },\n            {\n            \"name\"       : \"ruby-worker\",\n            \"script\"     : \"./some-ruby-script\",\n            \"exec_interpreter\": \"ruby\",\n            \"exec_mode\"  : \"fork_mode\"\n            }\n      ]\n}\n```\n\n\n## CheatSheat\n- 출처 : [PM2 공식 홈페이지](http://pm2.keymetrics.io/docs/usage/quick-start/#cheat-sheet)\n```bash\n# Fork mode\n$ pm2 start app.js --name my-api # 프로세스 네임 지정\n\n# Cluster mode\n$ pm2 start app.js -i 0     # 가용한 CPU 갯수만큼 클러스터 확장\n$ pm2 start app.js -i max   # 위 설정과 동일하지만 곧 Deprecated 예정?\n\n# Listing\n$ pm2 list               # 모든 프로세스 리스트/상태 확인\n$ pm2 jlist              # 모든 프로세스 리스트/상태 확인(JSON)\n$ pm2 prettylist         # 모든 프로세스 리스트/상태 확인(Beatiful JSON)\n\n$ pm2 describe 0         # 특정 프로세스 정보 확인\n$ pm2 monit              # 모든 프로세스 모니터링\n\n# Logs\n\n$ pm2 logs [--raw]       # Display all processes logs in streaming\n$ pm2 flush              # Empty all log file\n$ pm2 reloadLogs         # Reload all logs\n\n# Actions\n\n$ pm2 stop all           # Stop all processes\n$ pm2 restart all        # Restart all processes\n\n$ pm2 reload all         # Will 0s downtime reload (for NETWORKED apps)\n$ pm2 gracefulReload all # Send exit message then reload (for networked apps)\n\n$ pm2 stop 0             # Stop specific process id\n$ pm2 restart 0          # Restart specific process id\n\n$ pm2 delete 0           # Will remove process from pm2 list\n$ pm2 delete all         # Will remove all processes from pm2 list\n\n# Misc\n\n$ pm2 reset <process>    # Reset meta data (restarted time...)\n$ pm2 updatePM2          # Update in memory pm2\n$ pm2 ping               # Ensure pm2 daemon has been launched\n$ pm2 sendSignal SIGUSR2 my-app # Send system signal to script\n$ pm2 start app.js --no-daemon\n$ pm2 start app.js --no-vizion\n$ pm2 start app.js --no-autorestart\n\n```\n\n\n# 참고\n- [Deploying Node.js with PM2 and Nginx](https://doesnotscale.com/deploying-node-js-with-pm2-and-nginx/)\n- [PM2 를 이용하여 NodeJS 프로세스 관리하기](http://www.tutorialbook.co.kr/entry/PM2-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-NodeJS-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0)\n","slug":"JavaScript/pm2","published":1,"updated":"2021-08-02T12:08:49.522Z","_id":"ckrsup50k0018tjhv77b57v36","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"PM2\"><a href=\"#PM2\" class=\"headerlink\" title=\"PM2\"></a>PM2</h1><ul>\n<li>Node.js 애플리케이션용 프로덕션 프로세스 관리자</li>\n<li>로드 밸런서 기본 제공</li>\n<li>앱을 항상 작동 상태로 유지</li>\n<li>시스템 가동 중단 없이 앱을 다시 로드<ul>\n<li><strong>MAX MEMORY RESTART</strong> 기능을 제공하는데 <strong>커맨드라인/JSON/코드(JS)</strong> 등으로 설정 가능하다.</li>\n</ul>\n</li>\n<li>일반적인 시스템 관리 태스크를 쉽게 처리 가능</li>\n<li>애플리케이션 로깅, 모니터링 및 클러스터링을 관리<ul>\n<li>클러스터 모드의 경우, 여러개의 프로세스를 생성해놓고, 이를 PM2에서 자동으로 로드밸런싱으로 지원해주기 때문에, 앞단 웹 서버(Nginx, Apache Server 등)에서 프록시 설정만 간단히 해줘도 된다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"설치\"><a href=\"#설치\" class=\"headerlink\" title=\"설치\"></a>설치</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ [sudo] npm install pm2 -g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"기본-사용\"><a href=\"#기본-사용\" class=\"headerlink\" title=\"기본 사용\"></a>기본 사용</h2><p>앱을 시작할때 즉시 백그라운드로 보내진다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pm2 start app.js</span><br></pre></td></tr></table></figure>\n\n<p>메뉴얼을 읽으면서 가장 괜찮다고 생각한 부분이 바로 다른 스크립트 언어도 같이 지원하는 부분이었다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pm2 start echo.pl --interpreter=perl</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 start echo.coffee</span><br><span class=\"line\">$ pm2 start echo.php</span><br><span class=\"line\">$ pm2 start echo.py</span><br><span class=\"line\">$ pm2 start echo.sh</span><br><span class=\"line\">$ pm2 start echo.rb</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"어플리케이션-설정-파일-사용\"><a href=\"#어플리케이션-설정-파일-사용\" class=\"headerlink\" title=\"어플리케이션 설정 파일 사용\"></a>어플리케이션 설정 파일 사용</h2><p>JSON, YML 포맷으로 만들어진 파일을 일종의 시작 프로파일로 사용할 수 있다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pm2 start start.yml(start.json)</span><br></pre></td></tr></table></figure>\n\n<p><strong>start.yml</strong></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apps:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">script   :</span> <span class=\"string\">app.js</span></span><br><span class=\"line\">    <span class=\"attr\">instances:</span> <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"attr\">exec_mode:</span> <span class=\"string\">cluster</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">script :</span> <span class=\"string\">worker.js</span></span><br><span class=\"line\">    <span class=\"attr\">watch  :</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">env    :</span></span><br><span class=\"line\">      <span class=\"attr\">NODE_ENV:</span> <span class=\"string\">development</span></span><br><span class=\"line\">    <span class=\"attr\">env_production:</span></span><br><span class=\"line\">      <span class=\"attr\">NODE_ENV:</span> <span class=\"string\">production</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>start.json</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;apps&quot;</span> : [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span>       : <span class=\"string\">&quot;bash-worker&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;script&quot;</span>     : <span class=\"string\">&quot;./a-bash-script&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;exec_interpreter&quot;</span>: <span class=\"string\">&quot;bash&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;exec_mode&quot;</span>  : <span class=\"string\">&quot;fork_mode&quot;</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span>       : <span class=\"string\">&quot;ruby-worker&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;script&quot;</span>     : <span class=\"string\">&quot;./some-ruby-script&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;exec_interpreter&quot;</span>: <span class=\"string\">&quot;ruby&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;exec_mode&quot;</span>  : <span class=\"string\">&quot;fork_mode&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"CheatSheat\"><a href=\"#CheatSheat\" class=\"headerlink\" title=\"CheatSheat\"></a>CheatSheat</h2><ul>\n<li>출처 : <a href=\"http://pm2.keymetrics.io/docs/usage/quick-start/#cheat-sheet\">PM2 공식 홈페이지</a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Fork mode</span></span><br><span class=\"line\">$ pm2 start app.js --name my-api <span class=\"comment\"># 프로세스 네임 지정</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Cluster mode</span></span><br><span class=\"line\">$ pm2 start app.js -i 0     <span class=\"comment\"># 가용한 CPU 갯수만큼 클러스터 확장</span></span><br><span class=\"line\">$ pm2 start app.js -i max   <span class=\"comment\"># 위 설정과 동일하지만 곧 Deprecated 예정?</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Listing</span></span><br><span class=\"line\">$ pm2 list               <span class=\"comment\"># 모든 프로세스 리스트/상태 확인</span></span><br><span class=\"line\">$ pm2 jlist              <span class=\"comment\"># 모든 프로세스 리스트/상태 확인(JSON)</span></span><br><span class=\"line\">$ pm2 prettylist         <span class=\"comment\"># 모든 프로세스 리스트/상태 확인(Beatiful JSON)</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 describe 0         <span class=\"comment\"># 특정 프로세스 정보 확인</span></span><br><span class=\"line\">$ pm2 monit              <span class=\"comment\"># 모든 프로세스 모니터링</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Logs</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 logs [--raw]       <span class=\"comment\"># Display all processes logs in streaming</span></span><br><span class=\"line\">$ pm2 flush              <span class=\"comment\"># Empty all log file</span></span><br><span class=\"line\">$ pm2 reloadLogs         <span class=\"comment\"># Reload all logs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Actions</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 stop all           <span class=\"comment\"># Stop all processes</span></span><br><span class=\"line\">$ pm2 restart all        <span class=\"comment\"># Restart all processes</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 reload all         <span class=\"comment\"># Will 0s downtime reload (for NETWORKED apps)</span></span><br><span class=\"line\">$ pm2 gracefulReload all <span class=\"comment\"># Send exit message then reload (for networked apps)</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 stop 0             <span class=\"comment\"># Stop specific process id</span></span><br><span class=\"line\">$ pm2 restart 0          <span class=\"comment\"># Restart specific process id</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 delete 0           <span class=\"comment\"># Will remove process from pm2 list</span></span><br><span class=\"line\">$ pm2 delete all         <span class=\"comment\"># Will remove all processes from pm2 list</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Misc</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 reset &lt;process&gt;    <span class=\"comment\"># Reset meta data (restarted time...)</span></span><br><span class=\"line\">$ pm2 updatePM2          <span class=\"comment\"># Update in memory pm2</span></span><br><span class=\"line\">$ pm2 ping               <span class=\"comment\"># Ensure pm2 daemon has been launched</span></span><br><span class=\"line\">$ pm2 sendSignal SIGUSR2 my-app <span class=\"comment\"># Send system signal to script</span></span><br><span class=\"line\">$ pm2 start app.js --no-daemon</span><br><span class=\"line\">$ pm2 start app.js --no-vizion</span><br><span class=\"line\">$ pm2 start app.js --no-autorestart</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h1><ul>\n<li><a href=\"https://doesnotscale.com/deploying-node-js-with-pm2-and-nginx/\">Deploying Node.js with PM2 and Nginx</a></li>\n<li><a href=\"http://www.tutorialbook.co.kr/entry/PM2-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-NodeJS-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0\">PM2 를 이용하여 NodeJS 프로세스 관리하기</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"PM2\"><a href=\"#PM2\" class=\"headerlink\" title=\"PM2\"></a>PM2</h1><ul>\n<li>Node.js 애플리케이션용 프로덕션 프로세스 관리자</li>\n<li>로드 밸런서 기본 제공</li>\n<li>앱을 항상 작동 상태로 유지</li>\n<li>시스템 가동 중단 없이 앱을 다시 로드<ul>\n<li><strong>MAX MEMORY RESTART</strong> 기능을 제공하는데 <strong>커맨드라인/JSON/코드(JS)</strong> 등으로 설정 가능하다.</li>\n</ul>\n</li>\n<li>일반적인 시스템 관리 태스크를 쉽게 처리 가능</li>\n<li>애플리케이션 로깅, 모니터링 및 클러스터링을 관리<ul>\n<li>클러스터 모드의 경우, 여러개의 프로세스를 생성해놓고, 이를 PM2에서 자동으로 로드밸런싱으로 지원해주기 때문에, 앞단 웹 서버(Nginx, Apache Server 등)에서 프록시 설정만 간단히 해줘도 된다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"설치\"><a href=\"#설치\" class=\"headerlink\" title=\"설치\"></a>설치</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ [sudo] npm install pm2 -g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"기본-사용\"><a href=\"#기본-사용\" class=\"headerlink\" title=\"기본 사용\"></a>기본 사용</h2><p>앱을 시작할때 즉시 백그라운드로 보내진다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pm2 start app.js</span><br></pre></td></tr></table></figure>\n\n<p>메뉴얼을 읽으면서 가장 괜찮다고 생각한 부분이 바로 다른 스크립트 언어도 같이 지원하는 부분이었다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pm2 start echo.pl --interpreter=perl</span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 start echo.coffee</span><br><span class=\"line\">$ pm2 start echo.php</span><br><span class=\"line\">$ pm2 start echo.py</span><br><span class=\"line\">$ pm2 start echo.sh</span><br><span class=\"line\">$ pm2 start echo.rb</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"어플리케이션-설정-파일-사용\"><a href=\"#어플리케이션-설정-파일-사용\" class=\"headerlink\" title=\"어플리케이션 설정 파일 사용\"></a>어플리케이션 설정 파일 사용</h2><p>JSON, YML 포맷으로 만들어진 파일을 일종의 시작 프로파일로 사용할 수 있다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pm2 start start.yml(start.json)</span><br></pre></td></tr></table></figure>\n\n<p><strong>start.yml</strong></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apps:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">script   :</span> <span class=\"string\">app.js</span></span><br><span class=\"line\">    <span class=\"attr\">instances:</span> <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"attr\">exec_mode:</span> <span class=\"string\">cluster</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">script :</span> <span class=\"string\">worker.js</span></span><br><span class=\"line\">    <span class=\"attr\">watch  :</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">env    :</span></span><br><span class=\"line\">      <span class=\"attr\">NODE_ENV:</span> <span class=\"string\">development</span></span><br><span class=\"line\">    <span class=\"attr\">env_production:</span></span><br><span class=\"line\">      <span class=\"attr\">NODE_ENV:</span> <span class=\"string\">production</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>start.json</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;apps&quot;</span> : [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span>       : <span class=\"string\">&quot;bash-worker&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;script&quot;</span>     : <span class=\"string\">&quot;./a-bash-script&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;exec_interpreter&quot;</span>: <span class=\"string\">&quot;bash&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;exec_mode&quot;</span>  : <span class=\"string\">&quot;fork_mode&quot;</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span>       : <span class=\"string\">&quot;ruby-worker&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;script&quot;</span>     : <span class=\"string\">&quot;./some-ruby-script&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;exec_interpreter&quot;</span>: <span class=\"string\">&quot;ruby&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;exec_mode&quot;</span>  : <span class=\"string\">&quot;fork_mode&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"CheatSheat\"><a href=\"#CheatSheat\" class=\"headerlink\" title=\"CheatSheat\"></a>CheatSheat</h2><ul>\n<li>출처 : <a href=\"http://pm2.keymetrics.io/docs/usage/quick-start/#cheat-sheet\">PM2 공식 홈페이지</a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Fork mode</span></span><br><span class=\"line\">$ pm2 start app.js --name my-api <span class=\"comment\"># 프로세스 네임 지정</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Cluster mode</span></span><br><span class=\"line\">$ pm2 start app.js -i 0     <span class=\"comment\"># 가용한 CPU 갯수만큼 클러스터 확장</span></span><br><span class=\"line\">$ pm2 start app.js -i max   <span class=\"comment\"># 위 설정과 동일하지만 곧 Deprecated 예정?</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Listing</span></span><br><span class=\"line\">$ pm2 list               <span class=\"comment\"># 모든 프로세스 리스트/상태 확인</span></span><br><span class=\"line\">$ pm2 jlist              <span class=\"comment\"># 모든 프로세스 리스트/상태 확인(JSON)</span></span><br><span class=\"line\">$ pm2 prettylist         <span class=\"comment\"># 모든 프로세스 리스트/상태 확인(Beatiful JSON)</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 describe 0         <span class=\"comment\"># 특정 프로세스 정보 확인</span></span><br><span class=\"line\">$ pm2 monit              <span class=\"comment\"># 모든 프로세스 모니터링</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Logs</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 logs [--raw]       <span class=\"comment\"># Display all processes logs in streaming</span></span><br><span class=\"line\">$ pm2 flush              <span class=\"comment\"># Empty all log file</span></span><br><span class=\"line\">$ pm2 reloadLogs         <span class=\"comment\"># Reload all logs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Actions</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 stop all           <span class=\"comment\"># Stop all processes</span></span><br><span class=\"line\">$ pm2 restart all        <span class=\"comment\"># Restart all processes</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 reload all         <span class=\"comment\"># Will 0s downtime reload (for NETWORKED apps)</span></span><br><span class=\"line\">$ pm2 gracefulReload all <span class=\"comment\"># Send exit message then reload (for networked apps)</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 stop 0             <span class=\"comment\"># Stop specific process id</span></span><br><span class=\"line\">$ pm2 restart 0          <span class=\"comment\"># Restart specific process id</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 delete 0           <span class=\"comment\"># Will remove process from pm2 list</span></span><br><span class=\"line\">$ pm2 delete all         <span class=\"comment\"># Will remove all processes from pm2 list</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Misc</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ pm2 reset &lt;process&gt;    <span class=\"comment\"># Reset meta data (restarted time...)</span></span><br><span class=\"line\">$ pm2 updatePM2          <span class=\"comment\"># Update in memory pm2</span></span><br><span class=\"line\">$ pm2 ping               <span class=\"comment\"># Ensure pm2 daemon has been launched</span></span><br><span class=\"line\">$ pm2 sendSignal SIGUSR2 my-app <span class=\"comment\"># Send system signal to script</span></span><br><span class=\"line\">$ pm2 start app.js --no-daemon</span><br><span class=\"line\">$ pm2 start app.js --no-vizion</span><br><span class=\"line\">$ pm2 start app.js --no-autorestart</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h1><ul>\n<li><a href=\"https://doesnotscale.com/deploying-node-js-with-pm2-and-nginx/\">Deploying Node.js with PM2 and Nginx</a></li>\n<li><a href=\"http://www.tutorialbook.co.kr/entry/PM2-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-NodeJS-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0\">PM2 를 이용하여 NodeJS 프로세스 관리하기</a></li>\n</ul>\n"},{"title":"Express.js","date":"2016-07-06T10:07:00.000Z","_content":"\n# Express.js\nHTTP 요청에 대하여 **라우팅** 및 **미들웨어** 기능을 제공하는 웹 프레임워크\n- **라우팅(routing)** 은 기본적으로 어플리케이션 서버에서 경로를 제어하는 목적\n  > 목적지까지 갈 수 있는 여러 경로 중 한 가지 경로를 설정해 주는 과정.\n\n- **미들웨어(middleware)** 는 중간에 껴넣는다는 의미로 부가적인 기능이나 처리를 제공하는 목적\n  > 이기종의 환경을 연결해주는 소프트웨어를 가리킴\n\n  ▶ Express.js에서 사용할 수 있는 **중간처리** 목적의 소프트웨어/모듈\n\n  ▶ 최종 요청 핸들러 이전의 **Express 라우팅 계층에 의해 호출되는 함수**\n\n## 설치\n```bash\nnpm init\nnpm install express --save\n```\n\n## Express Generator\n```bash\nnpm install express-generator -g\n```\n```bash\nexpress -h\n```\n\n\n![express_generator](http://i.imgur.com/8b7CLJe.png)\n\n- **기본적인 어플리케이션 골격 생성**\n- handlebars, hogan, jade 등 템플릿 엔진 추가 가능\n- css, .gitignore 등 옵션 추가 가능\n\n## 기본 라우팅 & 핸들러\n라우팅(Routing) 이란 URL(URI) 요청에 따라 어플리케이션이 응답하는 방법을 결정.\n\n```javascript\nvar express = require('express');\nvar app = express();\n\n/**\n * METHOD : Http Method(GET, POST, PUT, DELETE, PATCH 등)\n * PATH : [경로]\n * HANDLER : [경로 접근 시, 처리 핸들러]\n */\napp.METHOD(PATH, HANDLER)\n```\n\n### 라우팅 형태\n라우팅 URL 패스는 기본적으로 문자열뿐만 아니라 문자열 패턴 혹은 정규식으로 표현이 가능하다.(path-to-regexp)\n\n```javascript\n// Sample\napp.get('/home', function(req, res){\n      res.send(\"Hello World\");\n})\n\n// abcd, abbcd 및 abbbcd\napp.get('/ab+cd', function(req, res) {\n      res.send('ab+cd');\n});\n\n// abcd, abxcd, abRABDOMcd\napp.get('/ab*cd', function(req, res) {\n      res.send('ab*cd');\n});\n\n// abe 및 abcde\napp.get('/ab(cd)?e', function(req, res) {\n      res.send('ab(cd)?e');\n});\n```\n\n라우팅 핸들러(콜백 함수)는 하나 이상으로 설정이 가능하다.(next 인자를 반드시 설정해야 한다.) 라우팅에 대한 핸들링을 2개 이상을 등록하여 사용할 수 있기 때문에 굳이 하나의 핸들러에 모든 로직이나 코드를 넣어서 처리할 이유가 전혀 없다.\n```javascript\nvar cb0 = function (req, res, next) {\n      console.log('CB0');\n      next();\n}\n\nvar cb1 = function (req, res, next) {\n      console.log('CB1');\n      next();\n}\n\napp.get('/example/a', [cb0, cb1], function (req, res, next) {\n      console.log('the response will be sent by the next function ...');\n      next();\n}, function (req, res) {\n      res.send('Hello from A!');\n});\n\napp.get('/example/b',\nfunction (req, res, next) {\n      console.log('first handler');\n      next();\n},\nfunction (req, res) {\n      console.log('second handler');\n      res.send('Hello from B!');\n});\n```\n\n모듈식으로 등록하는 개념으로 express.Router 매소드를 활용하여 파일 단위로 모듈화를 시켜서 라우팅을 등록할 수 있다.\n\n```javascript\n// [birds.js]\nvar express = require('express');\nvar router = express.Router();\n\n// middleware that is specific to this router\nrouter.use(function timeLog(req, res, next) {\n      console.log('Time: ', Date.now());\n      next();\n});\n// define the home page route\nrouter.get('/', function(req, res) {\n      res.send('Birds home page');\n});\n// define the about route\nrouter.get('/about', function(req, res) {\n      res.send('About birds');\n});\n\nmodule.exports = router;\n```\n\n위에서 작성된 bird.js을 하단과 같이 로드하면 /birds/, /birds/about 으로 라우팅이 등록되어 사용할 수 있다. 모듈 단위(파일)로 작성하여 등록하는 방식이기 때문에, 라우팅 관리가 편하며 추후에 라우팅을 추가한다고 해도 확장성이 있어 보인다.\n```javascript\nvar birds = require('./birds');\napp.use('/birds', birds);\n```\n\n## 미들웨어\n- **Application**\n  - **어플리케이션 전체 영역** 에서 처리 가능. 앱에 대한 Request가 발생할 떄 마다 실행\n- **Router**\n  - **라우터 단위** 로 Request가 발생하면 실행\n      ```javascript\n      var app = express();\n      var router = express.Router();\n\n      router.use(function (req, res, next) {\n            console.log('Time:', Date.now());\n            next();\n      });\n      ```\n      > 위에서 설명했던 라우팅 방식 중 모듈 단위(파일) 라우팅 시 사용하면 유용\n\n- **Error Handling**\n  - 기본적으로 4개의 인자가 필요(인자의 숫자로 오류 처리 미들웨어 판별)\n      ```javascript\n      app.use(function(err, req, res, next) {\n            console.error(err.stack);\n            res.status(500).send('Something broke!');\n      });\n      ```  \n- **Basic(Default)**\n  - express.static(root, [options])\n     - 어플리케이션 정적 자원 설정(CSS,HTML,JS) 등\n     - 2개 이상의 정적 디렉토리 설정 가능\n      ```javascript\n      var options = {\n        dotfiles: 'ignore',\n        etag: false,\n        extensions: ['htm', 'html'],\n        index: false,\n        maxAge: '1d',\n        redirect: false,\n        setHeaders: function (res, path, stat) {\n          res.set('x-timestamp', Date.now());\n        }\n      }\n\n      app.use(express.static('public'));\n      app.use(express.static('uploads'));\n      app.use(express.static('files'));\n      ```\n- **Third-Party**\n  - Application Level 및 Router Level에 서트파티 미들웨어 설정이 가능하다\n  - [대표적인 미들웨어 종류](http://expressjs.com/ko/resources/middleware.html)를 참고하여 설정하자.\n  - Express의 경우, 초기버젼과 다르게 대부분 서드파티 미들웨어 사용을 권고하고 있다. 그렇기 때문에, 자주 사용하는 조합을 찾아놓고 사용하는 것이 개발 속도면에서나 안정성면에서나 유리하다.\n\n## Request & Response\n### **Express 어플리케이션 처리 흐름**\n- 미들웨어를 선 처리\n- 개별 라우팅 주소 값에 맞는 라우팅 핸들러를 실행\n- HTTP 요청에 대한 응답을 실행\n\n\n![express-diagram](http://i.imgur.com/oGUSkq8.png)\n\n기본적으로, Request 및 Response는 객체이며 HTTP 요청과 응답과 관련된 매서드와 프로퍼티(상태값 등)을 가지고 있다. **Query String, Parameter, Body, HTTP Header 기타 등등** 심지어 xhr 요청 유무까지 확인 가능한 프로퍼티가 있다. 너무 많기에 관련된 내용은 하단 링크를 통하여 확인하도록 하자\n### [요청 프로퍼티 & 매소드](http://expressjs.com/ko/4x/api.html#req)\n### [응답 프로퍼티 & 매소드](http://expressjs.com/ko/4x/api.html#res)\n\n## Template Engine\n```javascript\n// Setting\napp.set('view engine', 'jade');\n```\n```javascript\n// Router\napp.get('/', function (req, res) {\n      res.render('main', {msg : \"HelloWorld!\"});\n});\n```\n\n\nexpress에서 자주 사용하는 뷰 템플릿 엔진은 하단과 같다.\n- [jade(pug)](https://github.com/pugjs/pug)\n- [ejs](https://www.npmjs.com/package/ejs)\n- [handlebars](http://handlebarsjs.com/)\n\nReact같이 View만을 전문적으로 처리하는 라이브러리가 유행이고, 동형(Isomorphic) 처리라고 하여 서버 사이드에서도 클라이언트 사이드(브라우저)와 같이 뷰를 렌더링하자 라는 테마가 요즘 유행이다.(하지만 나에게는 너무 어렵다...어려워....) 마지막으로 배우고 익혔던 AngularJS도 좋지만 이 녀석은 사용해야 할 성격이 분명히 존재하는거 같다(SEO가 필요한 사이트에서는 쥐약인듯)\n\n\n아무튼 express에서 뷰 렌더링이 필요하다면 위 3개정도가 가장 현실적으로 사용할만한 템플릿 엔진인것은 분명하다. 만약 뷰단까지 같이 셋팅이 되어 있는 프로젝트가 필요하다면 [Yeoman](http://yeoman.io/)이나 [Mega Boilerplate](http://megaboilerplate.com/)에서 필요한 리소스를 확보하면 된다.\n\n\n## 참고\n- [Express.js](http://expressjs.com/)\n- [Express.js Github page](https://github.com/expressjs)\n","source":"_posts/JavaScript/express.js.md","raw":"---\ntitle: 'Express.js'\ndate: 2016.7.6. 19:07\ncategories:\n- JavaScript\n---\n\n# Express.js\nHTTP 요청에 대하여 **라우팅** 및 **미들웨어** 기능을 제공하는 웹 프레임워크\n- **라우팅(routing)** 은 기본적으로 어플리케이션 서버에서 경로를 제어하는 목적\n  > 목적지까지 갈 수 있는 여러 경로 중 한 가지 경로를 설정해 주는 과정.\n\n- **미들웨어(middleware)** 는 중간에 껴넣는다는 의미로 부가적인 기능이나 처리를 제공하는 목적\n  > 이기종의 환경을 연결해주는 소프트웨어를 가리킴\n\n  ▶ Express.js에서 사용할 수 있는 **중간처리** 목적의 소프트웨어/모듈\n\n  ▶ 최종 요청 핸들러 이전의 **Express 라우팅 계층에 의해 호출되는 함수**\n\n## 설치\n```bash\nnpm init\nnpm install express --save\n```\n\n## Express Generator\n```bash\nnpm install express-generator -g\n```\n```bash\nexpress -h\n```\n\n\n![express_generator](http://i.imgur.com/8b7CLJe.png)\n\n- **기본적인 어플리케이션 골격 생성**\n- handlebars, hogan, jade 등 템플릿 엔진 추가 가능\n- css, .gitignore 등 옵션 추가 가능\n\n## 기본 라우팅 & 핸들러\n라우팅(Routing) 이란 URL(URI) 요청에 따라 어플리케이션이 응답하는 방법을 결정.\n\n```javascript\nvar express = require('express');\nvar app = express();\n\n/**\n * METHOD : Http Method(GET, POST, PUT, DELETE, PATCH 등)\n * PATH : [경로]\n * HANDLER : [경로 접근 시, 처리 핸들러]\n */\napp.METHOD(PATH, HANDLER)\n```\n\n### 라우팅 형태\n라우팅 URL 패스는 기본적으로 문자열뿐만 아니라 문자열 패턴 혹은 정규식으로 표현이 가능하다.(path-to-regexp)\n\n```javascript\n// Sample\napp.get('/home', function(req, res){\n      res.send(\"Hello World\");\n})\n\n// abcd, abbcd 및 abbbcd\napp.get('/ab+cd', function(req, res) {\n      res.send('ab+cd');\n});\n\n// abcd, abxcd, abRABDOMcd\napp.get('/ab*cd', function(req, res) {\n      res.send('ab*cd');\n});\n\n// abe 및 abcde\napp.get('/ab(cd)?e', function(req, res) {\n      res.send('ab(cd)?e');\n});\n```\n\n라우팅 핸들러(콜백 함수)는 하나 이상으로 설정이 가능하다.(next 인자를 반드시 설정해야 한다.) 라우팅에 대한 핸들링을 2개 이상을 등록하여 사용할 수 있기 때문에 굳이 하나의 핸들러에 모든 로직이나 코드를 넣어서 처리할 이유가 전혀 없다.\n```javascript\nvar cb0 = function (req, res, next) {\n      console.log('CB0');\n      next();\n}\n\nvar cb1 = function (req, res, next) {\n      console.log('CB1');\n      next();\n}\n\napp.get('/example/a', [cb0, cb1], function (req, res, next) {\n      console.log('the response will be sent by the next function ...');\n      next();\n}, function (req, res) {\n      res.send('Hello from A!');\n});\n\napp.get('/example/b',\nfunction (req, res, next) {\n      console.log('first handler');\n      next();\n},\nfunction (req, res) {\n      console.log('second handler');\n      res.send('Hello from B!');\n});\n```\n\n모듈식으로 등록하는 개념으로 express.Router 매소드를 활용하여 파일 단위로 모듈화를 시켜서 라우팅을 등록할 수 있다.\n\n```javascript\n// [birds.js]\nvar express = require('express');\nvar router = express.Router();\n\n// middleware that is specific to this router\nrouter.use(function timeLog(req, res, next) {\n      console.log('Time: ', Date.now());\n      next();\n});\n// define the home page route\nrouter.get('/', function(req, res) {\n      res.send('Birds home page');\n});\n// define the about route\nrouter.get('/about', function(req, res) {\n      res.send('About birds');\n});\n\nmodule.exports = router;\n```\n\n위에서 작성된 bird.js을 하단과 같이 로드하면 /birds/, /birds/about 으로 라우팅이 등록되어 사용할 수 있다. 모듈 단위(파일)로 작성하여 등록하는 방식이기 때문에, 라우팅 관리가 편하며 추후에 라우팅을 추가한다고 해도 확장성이 있어 보인다.\n```javascript\nvar birds = require('./birds');\napp.use('/birds', birds);\n```\n\n## 미들웨어\n- **Application**\n  - **어플리케이션 전체 영역** 에서 처리 가능. 앱에 대한 Request가 발생할 떄 마다 실행\n- **Router**\n  - **라우터 단위** 로 Request가 발생하면 실행\n      ```javascript\n      var app = express();\n      var router = express.Router();\n\n      router.use(function (req, res, next) {\n            console.log('Time:', Date.now());\n            next();\n      });\n      ```\n      > 위에서 설명했던 라우팅 방식 중 모듈 단위(파일) 라우팅 시 사용하면 유용\n\n- **Error Handling**\n  - 기본적으로 4개의 인자가 필요(인자의 숫자로 오류 처리 미들웨어 판별)\n      ```javascript\n      app.use(function(err, req, res, next) {\n            console.error(err.stack);\n            res.status(500).send('Something broke!');\n      });\n      ```  \n- **Basic(Default)**\n  - express.static(root, [options])\n     - 어플리케이션 정적 자원 설정(CSS,HTML,JS) 등\n     - 2개 이상의 정적 디렉토리 설정 가능\n      ```javascript\n      var options = {\n        dotfiles: 'ignore',\n        etag: false,\n        extensions: ['htm', 'html'],\n        index: false,\n        maxAge: '1d',\n        redirect: false,\n        setHeaders: function (res, path, stat) {\n          res.set('x-timestamp', Date.now());\n        }\n      }\n\n      app.use(express.static('public'));\n      app.use(express.static('uploads'));\n      app.use(express.static('files'));\n      ```\n- **Third-Party**\n  - Application Level 및 Router Level에 서트파티 미들웨어 설정이 가능하다\n  - [대표적인 미들웨어 종류](http://expressjs.com/ko/resources/middleware.html)를 참고하여 설정하자.\n  - Express의 경우, 초기버젼과 다르게 대부분 서드파티 미들웨어 사용을 권고하고 있다. 그렇기 때문에, 자주 사용하는 조합을 찾아놓고 사용하는 것이 개발 속도면에서나 안정성면에서나 유리하다.\n\n## Request & Response\n### **Express 어플리케이션 처리 흐름**\n- 미들웨어를 선 처리\n- 개별 라우팅 주소 값에 맞는 라우팅 핸들러를 실행\n- HTTP 요청에 대한 응답을 실행\n\n\n![express-diagram](http://i.imgur.com/oGUSkq8.png)\n\n기본적으로, Request 및 Response는 객체이며 HTTP 요청과 응답과 관련된 매서드와 프로퍼티(상태값 등)을 가지고 있다. **Query String, Parameter, Body, HTTP Header 기타 등등** 심지어 xhr 요청 유무까지 확인 가능한 프로퍼티가 있다. 너무 많기에 관련된 내용은 하단 링크를 통하여 확인하도록 하자\n### [요청 프로퍼티 & 매소드](http://expressjs.com/ko/4x/api.html#req)\n### [응답 프로퍼티 & 매소드](http://expressjs.com/ko/4x/api.html#res)\n\n## Template Engine\n```javascript\n// Setting\napp.set('view engine', 'jade');\n```\n```javascript\n// Router\napp.get('/', function (req, res) {\n      res.render('main', {msg : \"HelloWorld!\"});\n});\n```\n\n\nexpress에서 자주 사용하는 뷰 템플릿 엔진은 하단과 같다.\n- [jade(pug)](https://github.com/pugjs/pug)\n- [ejs](https://www.npmjs.com/package/ejs)\n- [handlebars](http://handlebarsjs.com/)\n\nReact같이 View만을 전문적으로 처리하는 라이브러리가 유행이고, 동형(Isomorphic) 처리라고 하여 서버 사이드에서도 클라이언트 사이드(브라우저)와 같이 뷰를 렌더링하자 라는 테마가 요즘 유행이다.(하지만 나에게는 너무 어렵다...어려워....) 마지막으로 배우고 익혔던 AngularJS도 좋지만 이 녀석은 사용해야 할 성격이 분명히 존재하는거 같다(SEO가 필요한 사이트에서는 쥐약인듯)\n\n\n아무튼 express에서 뷰 렌더링이 필요하다면 위 3개정도가 가장 현실적으로 사용할만한 템플릿 엔진인것은 분명하다. 만약 뷰단까지 같이 셋팅이 되어 있는 프로젝트가 필요하다면 [Yeoman](http://yeoman.io/)이나 [Mega Boilerplate](http://megaboilerplate.com/)에서 필요한 리소스를 확보하면 된다.\n\n\n## 참고\n- [Express.js](http://expressjs.com/)\n- [Express.js Github page](https://github.com/expressjs)\n","slug":"JavaScript/express.js","published":1,"updated":"2021-08-02T12:08:58.821Z","_id":"ckrsup50k0019tjhvh3hr8qpm","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Express-js\"><a href=\"#Express-js\" class=\"headerlink\" title=\"Express.js\"></a>Express.js</h1><p>HTTP 요청에 대하여 <strong>라우팅</strong> 및 <strong>미들웨어</strong> 기능을 제공하는 웹 프레임워크</p>\n<ul>\n<li><p><strong>라우팅(routing)</strong> 은 기본적으로 어플리케이션 서버에서 경로를 제어하는 목적</p>\n<blockquote>\n<p>목적지까지 갈 수 있는 여러 경로 중 한 가지 경로를 설정해 주는 과정.</p>\n</blockquote>\n</li>\n<li><p><strong>미들웨어(middleware)</strong> 는 중간에 껴넣는다는 의미로 부가적인 기능이나 처리를 제공하는 목적</p>\n<blockquote>\n<p>이기종의 환경을 연결해주는 소프트웨어를 가리킴</p>\n</blockquote>\n<p>▶ Express.js에서 사용할 수 있는 <strong>중간처리</strong> 목적의 소프트웨어/모듈</p>\n<p>▶ 최종 요청 핸들러 이전의 <strong>Express 라우팅 계층에 의해 호출되는 함수</strong></p>\n</li>\n</ul>\n<h2 id=\"설치\"><a href=\"#설치\" class=\"headerlink\" title=\"설치\"></a>설치</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init</span><br><span class=\"line\">npm install express --save</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Express-Generator\"><a href=\"#Express-Generator\" class=\"headerlink\" title=\"Express Generator\"></a>Express Generator</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express-generator -g</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">express -h</span><br></pre></td></tr></table></figure>\n\n\n<p><img src=\"http://i.imgur.com/8b7CLJe.png\" alt=\"express_generator\"></p>\n<ul>\n<li><strong>기본적인 어플리케이션 골격 생성</strong></li>\n<li>handlebars, hogan, jade 등 템플릿 엔진 추가 가능</li>\n<li>css, .gitignore 등 옵션 추가 가능</li>\n</ul>\n<h2 id=\"기본-라우팅-amp-핸들러\"><a href=\"#기본-라우팅-amp-핸들러\" class=\"headerlink\" title=\"기본 라우팅 &amp; 핸들러\"></a>기본 라우팅 &amp; 핸들러</h2><p>라우팅(Routing) 이란 URL(URI) 요청에 따라 어플리케이션이 응답하는 방법을 결정.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;express&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * METHOD : Http Method(GET, POST, PUT, DELETE, PATCH 등)</span></span><br><span class=\"line\"><span class=\"comment\"> * PATH : [경로]</span></span><br><span class=\"line\"><span class=\"comment\"> * HANDLER : [경로 접근 시, 처리 핸들러]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">app.METHOD(PATH, HANDLER)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"라우팅-형태\"><a href=\"#라우팅-형태\" class=\"headerlink\" title=\"라우팅 형태\"></a>라우팅 형태</h3><p>라우팅 URL 패스는 기본적으로 문자열뿐만 아니라 문자열 패턴 혹은 정규식으로 표현이 가능하다.(path-to-regexp)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Sample</span></span><br><span class=\"line\">app.get(<span class=\"string\">&#x27;/home&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)</span>&#123;</span><br><span class=\"line\">      res.send(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// abcd, abbcd 및 abbbcd</span></span><br><span class=\"line\">app.get(<span class=\"string\">&#x27;/ab+cd&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">      res.send(<span class=\"string\">&#x27;ab+cd&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// abcd, abxcd, abRABDOMcd</span></span><br><span class=\"line\">app.get(<span class=\"string\">&#x27;/ab*cd&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">      res.send(<span class=\"string\">&#x27;ab*cd&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// abe 및 abcde</span></span><br><span class=\"line\">app.get(<span class=\"string\">&#x27;/ab(cd)?e&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">      res.send(<span class=\"string\">&#x27;ab(cd)?e&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>라우팅 핸들러(콜백 함수)는 하나 이상으로 설정이 가능하다.(next 인자를 반드시 설정해야 한다.) 라우팅에 대한 핸들링을 2개 이상을 등록하여 사용할 수 있기 때문에 굳이 하나의 핸들러에 모든 로직이나 코드를 넣어서 처리할 이유가 전혀 없다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cb0 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;CB0&#x27;</span>);</span><br><span class=\"line\">      next();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> cb1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;CB1&#x27;</span>);</span><br><span class=\"line\">      next();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">&#x27;/example/a&#x27;</span>, [cb0, cb1], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;the response will be sent by the next function ...&#x27;</span>);</span><br><span class=\"line\">      next();</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">      res.send(<span class=\"string\">&#x27;Hello from A!&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">&#x27;/example/b&#x27;</span>,</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;first handler&#x27;</span>);</span><br><span class=\"line\">      next();</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;second handler&#x27;</span>);</span><br><span class=\"line\">      res.send(<span class=\"string\">&#x27;Hello from B!&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>모듈식으로 등록하는 개념으로 express.Router 매소드를 활용하여 파일 단위로 모듈화를 시켜서 라우팅을 등록할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [birds.js]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;express&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// middleware that is specific to this router</span></span><br><span class=\"line\">router.use(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeLog</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Time: &#x27;</span>, <span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">      next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// define the home page route</span></span><br><span class=\"line\">router.get(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">      res.send(<span class=\"string\">&#x27;Birds home page&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// define the about route</span></span><br><span class=\"line\">router.get(<span class=\"string\">&#x27;/about&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">      res.send(<span class=\"string\">&#x27;About birds&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = router;</span><br></pre></td></tr></table></figure>\n\n<p>위에서 작성된 bird.js을 하단과 같이 로드하면 /birds/, /birds/about 으로 라우팅이 등록되어 사용할 수 있다. 모듈 단위(파일)로 작성하여 등록하는 방식이기 때문에, 라우팅 관리가 편하며 추후에 라우팅을 추가한다고 해도 확장성이 있어 보인다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> birds = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./birds&#x27;</span>);</span><br><span class=\"line\">app.use(<span class=\"string\">&#x27;/birds&#x27;</span>, birds);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"미들웨어\"><a href=\"#미들웨어\" class=\"headerlink\" title=\"미들웨어\"></a>미들웨어</h2><ul>\n<li><p><strong>Application</strong></p>\n<ul>\n<li><strong>어플리케이션 전체 영역</strong> 에서 처리 가능. 앱에 대한 Request가 발생할 떄 마다 실행</li>\n</ul>\n</li>\n<li><p><strong>Router</strong></p>\n<ul>\n<li><strong>라우터 단위</strong> 로 Request가 발생하면 실행  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\">router.use(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Time:&#x27;</span>, <span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">      next();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>위에서 설명했던 라우팅 방식 중 모듈 단위(파일) 라우팅 시 사용하면 유용</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><strong>Error Handling</strong></p>\n<ul>\n<li>기본적으로 4개의 인자가 필요(인자의 숫자로 오류 처리 미들웨어 판별)  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      app.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, req, res, next</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.error(err.stack);</span><br><span class=\"line\">            res.status(<span class=\"number\">500</span>).send(<span class=\"string\">&#x27;Something broke!&#x27;</span>);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      <span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">- **Basic(Default)**</span></span><br><span class=\"line\"><span class=\"string\">  - express.static(root, [options])</span></span><br><span class=\"line\"><span class=\"string\">     - 어플리케이션 정적 자원 설정(CSS,HTML,JS) 등</span></span><br><span class=\"line\"><span class=\"string\">     - 2개 이상의 정적 디렉토리 설정 가능</span></span><br><span class=\"line\"><span class=\"string\">      `</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\">      <span class=\"keyword\">var</span> options = &#123;</span><br><span class=\"line\">        <span class=\"attr\">dotfiles</span>: <span class=\"string\">&#x27;ignore&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">etag</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"attr\">extensions</span>: [<span class=\"string\">&#x27;htm&#x27;</span>, <span class=\"string\">&#x27;html&#x27;</span>],</span><br><span class=\"line\">        <span class=\"attr\">index</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"attr\">maxAge</span>: <span class=\"string\">&#x27;1d&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">redirect</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"attr\">setHeaders</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res, path, stat</span>) </span>&#123;</span><br><span class=\"line\">          res.set(<span class=\"string\">&#x27;x-timestamp&#x27;</span>, <span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      app.use(express.static(<span class=\"string\">&#x27;public&#x27;</span>));</span><br><span class=\"line\">      app.use(express.static(<span class=\"string\">&#x27;uploads&#x27;</span>));</span><br><span class=\"line\">      app.use(express.static(<span class=\"string\">&#x27;files&#x27;</span>));</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>Third-Party</strong></p>\n<ul>\n<li>Application Level 및 Router Level에 서트파티 미들웨어 설정이 가능하다</li>\n<li><a href=\"http://expressjs.com/ko/resources/middleware.html\">대표적인 미들웨어 종류</a>를 참고하여 설정하자.</li>\n<li>Express의 경우, 초기버젼과 다르게 대부분 서드파티 미들웨어 사용을 권고하고 있다. 그렇기 때문에, 자주 사용하는 조합을 찾아놓고 사용하는 것이 개발 속도면에서나 안정성면에서나 유리하다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Request-amp-Response\"><a href=\"#Request-amp-Response\" class=\"headerlink\" title=\"Request &amp; Response\"></a>Request &amp; Response</h2><h3 id=\"Express-어플리케이션-처리-흐름\"><a href=\"#Express-어플리케이션-처리-흐름\" class=\"headerlink\" title=\"Express 어플리케이션 처리 흐름\"></a><strong>Express 어플리케이션 처리 흐름</strong></h3><ul>\n<li>미들웨어를 선 처리</li>\n<li>개별 라우팅 주소 값에 맞는 라우팅 핸들러를 실행</li>\n<li>HTTP 요청에 대한 응답을 실행</li>\n</ul>\n<p><img src=\"http://i.imgur.com/oGUSkq8.png\" alt=\"express-diagram\"></p>\n<p>기본적으로, Request 및 Response는 객체이며 HTTP 요청과 응답과 관련된 매서드와 프로퍼티(상태값 등)을 가지고 있다. <strong>Query String, Parameter, Body, HTTP Header 기타 등등</strong> 심지어 xhr 요청 유무까지 확인 가능한 프로퍼티가 있다. 너무 많기에 관련된 내용은 하단 링크를 통하여 확인하도록 하자</p>\n<h3 id=\"요청-프로퍼티-amp-매소드\"><a href=\"#요청-프로퍼티-amp-매소드\" class=\"headerlink\" title=\"요청 프로퍼티 &amp; 매소드\"></a><a href=\"http://expressjs.com/ko/4x/api.html#req\">요청 프로퍼티 &amp; 매소드</a></h3><h3 id=\"응답-프로퍼티-amp-매소드\"><a href=\"#응답-프로퍼티-amp-매소드\" class=\"headerlink\" title=\"응답 프로퍼티 &amp; 매소드\"></a><a href=\"http://expressjs.com/ko/4x/api.html#res\">응답 프로퍼티 &amp; 매소드</a></h3><h2 id=\"Template-Engine\"><a href=\"#Template-Engine\" class=\"headerlink\" title=\"Template Engine\"></a>Template Engine</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Setting</span></span><br><span class=\"line\">app.set(<span class=\"string\">&#x27;view engine&#x27;</span>, <span class=\"string\">&#x27;jade&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Router</span></span><br><span class=\"line\">app.get(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">      res.render(<span class=\"string\">&#x27;main&#x27;</span>, &#123;<span class=\"attr\">msg</span> : <span class=\"string\">&quot;HelloWorld!&quot;</span>&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<p>express에서 자주 사용하는 뷰 템플릿 엔진은 하단과 같다.</p>\n<ul>\n<li><a href=\"https://github.com/pugjs/pug\">jade(pug)</a></li>\n<li><a href=\"https://www.npmjs.com/package/ejs\">ejs</a></li>\n<li><a href=\"http://handlebarsjs.com/\">handlebars</a></li>\n</ul>\n<p>React같이 View만을 전문적으로 처리하는 라이브러리가 유행이고, 동형(Isomorphic) 처리라고 하여 서버 사이드에서도 클라이언트 사이드(브라우저)와 같이 뷰를 렌더링하자 라는 테마가 요즘 유행이다.(하지만 나에게는 너무 어렵다…어려워….) 마지막으로 배우고 익혔던 AngularJS도 좋지만 이 녀석은 사용해야 할 성격이 분명히 존재하는거 같다(SEO가 필요한 사이트에서는 쥐약인듯)</p>\n<p>아무튼 express에서 뷰 렌더링이 필요하다면 위 3개정도가 가장 현실적으로 사용할만한 템플릿 엔진인것은 분명하다. 만약 뷰단까지 같이 셋팅이 되어 있는 프로젝트가 필요하다면 <a href=\"http://yeoman.io/\">Yeoman</a>이나 <a href=\"http://megaboilerplate.com/\">Mega Boilerplate</a>에서 필요한 리소스를 확보하면 된다.</p>\n<h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><ul>\n<li><a href=\"http://expressjs.com/\">Express.js</a></li>\n<li><a href=\"https://github.com/expressjs\">Express.js Github page</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Express-js\"><a href=\"#Express-js\" class=\"headerlink\" title=\"Express.js\"></a>Express.js</h1><p>HTTP 요청에 대하여 <strong>라우팅</strong> 및 <strong>미들웨어</strong> 기능을 제공하는 웹 프레임워크</p>\n<ul>\n<li><p><strong>라우팅(routing)</strong> 은 기본적으로 어플리케이션 서버에서 경로를 제어하는 목적</p>\n<blockquote>\n<p>목적지까지 갈 수 있는 여러 경로 중 한 가지 경로를 설정해 주는 과정.</p>\n</blockquote>\n</li>\n<li><p><strong>미들웨어(middleware)</strong> 는 중간에 껴넣는다는 의미로 부가적인 기능이나 처리를 제공하는 목적</p>\n<blockquote>\n<p>이기종의 환경을 연결해주는 소프트웨어를 가리킴</p>\n</blockquote>\n<p>▶ Express.js에서 사용할 수 있는 <strong>중간처리</strong> 목적의 소프트웨어/모듈</p>\n<p>▶ 최종 요청 핸들러 이전의 <strong>Express 라우팅 계층에 의해 호출되는 함수</strong></p>\n</li>\n</ul>\n<h2 id=\"설치\"><a href=\"#설치\" class=\"headerlink\" title=\"설치\"></a>설치</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init</span><br><span class=\"line\">npm install express --save</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Express-Generator\"><a href=\"#Express-Generator\" class=\"headerlink\" title=\"Express Generator\"></a>Express Generator</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express-generator -g</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">express -h</span><br></pre></td></tr></table></figure>\n\n\n<p><img src=\"http://i.imgur.com/8b7CLJe.png\" alt=\"express_generator\"></p>\n<ul>\n<li><strong>기본적인 어플리케이션 골격 생성</strong></li>\n<li>handlebars, hogan, jade 등 템플릿 엔진 추가 가능</li>\n<li>css, .gitignore 등 옵션 추가 가능</li>\n</ul>\n<h2 id=\"기본-라우팅-amp-핸들러\"><a href=\"#기본-라우팅-amp-핸들러\" class=\"headerlink\" title=\"기본 라우팅 &amp; 핸들러\"></a>기본 라우팅 &amp; 핸들러</h2><p>라우팅(Routing) 이란 URL(URI) 요청에 따라 어플리케이션이 응답하는 방법을 결정.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;express&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * METHOD : Http Method(GET, POST, PUT, DELETE, PATCH 등)</span></span><br><span class=\"line\"><span class=\"comment\"> * PATH : [경로]</span></span><br><span class=\"line\"><span class=\"comment\"> * HANDLER : [경로 접근 시, 처리 핸들러]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">app.METHOD(PATH, HANDLER)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"라우팅-형태\"><a href=\"#라우팅-형태\" class=\"headerlink\" title=\"라우팅 형태\"></a>라우팅 형태</h3><p>라우팅 URL 패스는 기본적으로 문자열뿐만 아니라 문자열 패턴 혹은 정규식으로 표현이 가능하다.(path-to-regexp)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Sample</span></span><br><span class=\"line\">app.get(<span class=\"string\">&#x27;/home&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)</span>&#123;</span><br><span class=\"line\">      res.send(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// abcd, abbcd 및 abbbcd</span></span><br><span class=\"line\">app.get(<span class=\"string\">&#x27;/ab+cd&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">      res.send(<span class=\"string\">&#x27;ab+cd&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// abcd, abxcd, abRABDOMcd</span></span><br><span class=\"line\">app.get(<span class=\"string\">&#x27;/ab*cd&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">      res.send(<span class=\"string\">&#x27;ab*cd&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// abe 및 abcde</span></span><br><span class=\"line\">app.get(<span class=\"string\">&#x27;/ab(cd)?e&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">      res.send(<span class=\"string\">&#x27;ab(cd)?e&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>라우팅 핸들러(콜백 함수)는 하나 이상으로 설정이 가능하다.(next 인자를 반드시 설정해야 한다.) 라우팅에 대한 핸들링을 2개 이상을 등록하여 사용할 수 있기 때문에 굳이 하나의 핸들러에 모든 로직이나 코드를 넣어서 처리할 이유가 전혀 없다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cb0 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;CB0&#x27;</span>);</span><br><span class=\"line\">      next();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> cb1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;CB1&#x27;</span>);</span><br><span class=\"line\">      next();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">&#x27;/example/a&#x27;</span>, [cb0, cb1], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;the response will be sent by the next function ...&#x27;</span>);</span><br><span class=\"line\">      next();</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">      res.send(<span class=\"string\">&#x27;Hello from A!&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">&#x27;/example/b&#x27;</span>,</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;first handler&#x27;</span>);</span><br><span class=\"line\">      next();</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;second handler&#x27;</span>);</span><br><span class=\"line\">      res.send(<span class=\"string\">&#x27;Hello from B!&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>모듈식으로 등록하는 개념으로 express.Router 매소드를 활용하여 파일 단위로 모듈화를 시켜서 라우팅을 등록할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [birds.js]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;express&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// middleware that is specific to this router</span></span><br><span class=\"line\">router.use(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeLog</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Time: &#x27;</span>, <span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">      next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// define the home page route</span></span><br><span class=\"line\">router.get(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">      res.send(<span class=\"string\">&#x27;Birds home page&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// define the about route</span></span><br><span class=\"line\">router.get(<span class=\"string\">&#x27;/about&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">      res.send(<span class=\"string\">&#x27;About birds&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = router;</span><br></pre></td></tr></table></figure>\n\n<p>위에서 작성된 bird.js을 하단과 같이 로드하면 /birds/, /birds/about 으로 라우팅이 등록되어 사용할 수 있다. 모듈 단위(파일)로 작성하여 등록하는 방식이기 때문에, 라우팅 관리가 편하며 추후에 라우팅을 추가한다고 해도 확장성이 있어 보인다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> birds = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./birds&#x27;</span>);</span><br><span class=\"line\">app.use(<span class=\"string\">&#x27;/birds&#x27;</span>, birds);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"미들웨어\"><a href=\"#미들웨어\" class=\"headerlink\" title=\"미들웨어\"></a>미들웨어</h2><ul>\n<li><p><strong>Application</strong></p>\n<ul>\n<li><strong>어플리케이션 전체 영역</strong> 에서 처리 가능. 앱에 대한 Request가 발생할 떄 마다 실행</li>\n</ul>\n</li>\n<li><p><strong>Router</strong></p>\n<ul>\n<li><strong>라우터 단위</strong> 로 Request가 발생하면 실행  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\">router.use(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Time:&#x27;</span>, <span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">      next();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>위에서 설명했던 라우팅 방식 중 모듈 단위(파일) 라우팅 시 사용하면 유용</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><strong>Error Handling</strong></p>\n<ul>\n<li>기본적으로 4개의 인자가 필요(인자의 숫자로 오류 처리 미들웨어 판별)  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      app.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, req, res, next</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.error(err.stack);</span><br><span class=\"line\">            res.status(<span class=\"number\">500</span>).send(<span class=\"string\">&#x27;Something broke!&#x27;</span>);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      <span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">- **Basic(Default)**</span></span><br><span class=\"line\"><span class=\"string\">  - express.static(root, [options])</span></span><br><span class=\"line\"><span class=\"string\">     - 어플리케이션 정적 자원 설정(CSS,HTML,JS) 등</span></span><br><span class=\"line\"><span class=\"string\">     - 2개 이상의 정적 디렉토리 설정 가능</span></span><br><span class=\"line\"><span class=\"string\">      `</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\">      <span class=\"keyword\">var</span> options = &#123;</span><br><span class=\"line\">        <span class=\"attr\">dotfiles</span>: <span class=\"string\">&#x27;ignore&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">etag</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"attr\">extensions</span>: [<span class=\"string\">&#x27;htm&#x27;</span>, <span class=\"string\">&#x27;html&#x27;</span>],</span><br><span class=\"line\">        <span class=\"attr\">index</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"attr\">maxAge</span>: <span class=\"string\">&#x27;1d&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">redirect</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"attr\">setHeaders</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res, path, stat</span>) </span>&#123;</span><br><span class=\"line\">          res.set(<span class=\"string\">&#x27;x-timestamp&#x27;</span>, <span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      app.use(express.static(<span class=\"string\">&#x27;public&#x27;</span>));</span><br><span class=\"line\">      app.use(express.static(<span class=\"string\">&#x27;uploads&#x27;</span>));</span><br><span class=\"line\">      app.use(express.static(<span class=\"string\">&#x27;files&#x27;</span>));</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>Third-Party</strong></p>\n<ul>\n<li>Application Level 및 Router Level에 서트파티 미들웨어 설정이 가능하다</li>\n<li><a href=\"http://expressjs.com/ko/resources/middleware.html\">대표적인 미들웨어 종류</a>를 참고하여 설정하자.</li>\n<li>Express의 경우, 초기버젼과 다르게 대부분 서드파티 미들웨어 사용을 권고하고 있다. 그렇기 때문에, 자주 사용하는 조합을 찾아놓고 사용하는 것이 개발 속도면에서나 안정성면에서나 유리하다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Request-amp-Response\"><a href=\"#Request-amp-Response\" class=\"headerlink\" title=\"Request &amp; Response\"></a>Request &amp; Response</h2><h3 id=\"Express-어플리케이션-처리-흐름\"><a href=\"#Express-어플리케이션-처리-흐름\" class=\"headerlink\" title=\"Express 어플리케이션 처리 흐름\"></a><strong>Express 어플리케이션 처리 흐름</strong></h3><ul>\n<li>미들웨어를 선 처리</li>\n<li>개별 라우팅 주소 값에 맞는 라우팅 핸들러를 실행</li>\n<li>HTTP 요청에 대한 응답을 실행</li>\n</ul>\n<p><img src=\"http://i.imgur.com/oGUSkq8.png\" alt=\"express-diagram\"></p>\n<p>기본적으로, Request 및 Response는 객체이며 HTTP 요청과 응답과 관련된 매서드와 프로퍼티(상태값 등)을 가지고 있다. <strong>Query String, Parameter, Body, HTTP Header 기타 등등</strong> 심지어 xhr 요청 유무까지 확인 가능한 프로퍼티가 있다. 너무 많기에 관련된 내용은 하단 링크를 통하여 확인하도록 하자</p>\n<h3 id=\"요청-프로퍼티-amp-매소드\"><a href=\"#요청-프로퍼티-amp-매소드\" class=\"headerlink\" title=\"요청 프로퍼티 &amp; 매소드\"></a><a href=\"http://expressjs.com/ko/4x/api.html#req\">요청 프로퍼티 &amp; 매소드</a></h3><h3 id=\"응답-프로퍼티-amp-매소드\"><a href=\"#응답-프로퍼티-amp-매소드\" class=\"headerlink\" title=\"응답 프로퍼티 &amp; 매소드\"></a><a href=\"http://expressjs.com/ko/4x/api.html#res\">응답 프로퍼티 &amp; 매소드</a></h3><h2 id=\"Template-Engine\"><a href=\"#Template-Engine\" class=\"headerlink\" title=\"Template Engine\"></a>Template Engine</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Setting</span></span><br><span class=\"line\">app.set(<span class=\"string\">&#x27;view engine&#x27;</span>, <span class=\"string\">&#x27;jade&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Router</span></span><br><span class=\"line\">app.get(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">      res.render(<span class=\"string\">&#x27;main&#x27;</span>, &#123;<span class=\"attr\">msg</span> : <span class=\"string\">&quot;HelloWorld!&quot;</span>&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<p>express에서 자주 사용하는 뷰 템플릿 엔진은 하단과 같다.</p>\n<ul>\n<li><a href=\"https://github.com/pugjs/pug\">jade(pug)</a></li>\n<li><a href=\"https://www.npmjs.com/package/ejs\">ejs</a></li>\n<li><a href=\"http://handlebarsjs.com/\">handlebars</a></li>\n</ul>\n<p>React같이 View만을 전문적으로 처리하는 라이브러리가 유행이고, 동형(Isomorphic) 처리라고 하여 서버 사이드에서도 클라이언트 사이드(브라우저)와 같이 뷰를 렌더링하자 라는 테마가 요즘 유행이다.(하지만 나에게는 너무 어렵다…어려워….) 마지막으로 배우고 익혔던 AngularJS도 좋지만 이 녀석은 사용해야 할 성격이 분명히 존재하는거 같다(SEO가 필요한 사이트에서는 쥐약인듯)</p>\n<p>아무튼 express에서 뷰 렌더링이 필요하다면 위 3개정도가 가장 현실적으로 사용할만한 템플릿 엔진인것은 분명하다. 만약 뷰단까지 같이 셋팅이 되어 있는 프로젝트가 필요하다면 <a href=\"http://yeoman.io/\">Yeoman</a>이나 <a href=\"http://megaboilerplate.com/\">Mega Boilerplate</a>에서 필요한 리소스를 확보하면 된다.</p>\n<h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><ul>\n<li><a href=\"http://expressjs.com/\">Express.js</a></li>\n<li><a href=\"https://github.com/expressjs\">Express.js Github page</a></li>\n</ul>\n"},{"title":"React-Router","date":"2016-07-11T15:00:00.000Z","_content":"\n# React-Router\n- [API Document](https://github.com/ReactTraining/react-router/blob/master/docs/API.md#indexroute)\n- 어플리케이션 상태 표시, 현재 어떤 부분에 있는지 확인\n- <code>app/routes.js</code>에 라우트 코드가 있으며, 여기에서 URL과 매핑되는 컴포넌트를 리턴하게 된다.\n- 각 라우트 컴포넌트는 <code>path</code>에 매핑되는 <code>component</code>를 지정할 수 있으며, 하위 라우트를 가질 수 있다.\n","source":"_posts/JavaScript/react-route.md","raw":"---\ntitle: 'React-Router'\ndate: 2016/7/12 00:00:00\ncategories:\n- JavaScript\n---\n\n# React-Router\n- [API Document](https://github.com/ReactTraining/react-router/blob/master/docs/API.md#indexroute)\n- 어플리케이션 상태 표시, 현재 어떤 부분에 있는지 확인\n- <code>app/routes.js</code>에 라우트 코드가 있으며, 여기에서 URL과 매핑되는 컴포넌트를 리턴하게 된다.\n- 각 라우트 컴포넌트는 <code>path</code>에 매핑되는 <code>component</code>를 지정할 수 있으며, 하위 라우트를 가질 수 있다.\n","slug":"JavaScript/react-route","published":1,"updated":"2021-08-02T12:28:33.363Z","_id":"ckrsup50l001atjhva2opg0oz","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"React-Router\"><a href=\"#React-Router\" class=\"headerlink\" title=\"React-Router\"></a>React-Router</h1><ul>\n<li><a href=\"https://github.com/ReactTraining/react-router/blob/master/docs/API.md#indexroute\">API Document</a></li>\n<li>어플리케이션 상태 표시, 현재 어떤 부분에 있는지 확인</li>\n<li><code>app/routes.js</code>에 라우트 코드가 있으며, 여기에서 URL과 매핑되는 컴포넌트를 리턴하게 된다.</li>\n<li>각 라우트 컴포넌트는 <code>path</code>에 매핑되는 <code>component</code>를 지정할 수 있으며, 하위 라우트를 가질 수 있다.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"React-Router\"><a href=\"#React-Router\" class=\"headerlink\" title=\"React-Router\"></a>React-Router</h1><ul>\n<li><a href=\"https://github.com/ReactTraining/react-router/blob/master/docs/API.md#indexroute\">API Document</a></li>\n<li>어플리케이션 상태 표시, 현재 어떤 부분에 있는지 확인</li>\n<li><code>app/routes.js</code>에 라우트 코드가 있으며, 여기에서 URL과 매핑되는 컴포넌트를 리턴하게 된다.</li>\n<li>각 라우트 컴포넌트는 <code>path</code>에 매핑되는 <code>component</code>를 지정할 수 있으며, 하위 라우트를 가질 수 있다.</li>\n</ul>\n"},{"title":"Kotlin With Spring","date":"2019-03-02T10:57:00.000Z","_content":"\n# Kotlin With Spring\n\n현재 재직중인 회사에서 코틀린을 주력으로 사용하고 있는데, 지난 1년 정도 코틀린과 스프링부트를 사용해보면서 겪었던 삽질이나 좋았던 점을 스터디를 통하여 한 번 정리하면 좋겠다하는 마음에서 정리하게 됬다. \n\n- 시작하기 어렵지 않다. Spring Intializer에서 Kotlin 프로젝트를 쉽게 생성 할 수 있으며, 물론 버젼의 제약이 있긴 하겠지만 기존 자바 기반으로 운영하고 있더라도 쉽게 Koltin을 통한 추가 기능 개발이 가능하다.\n- 현재 코틀린은 1.3.21 버젼까지 사용할 수 있으며 SpringFramework 5.X, SpringBoot 2.X부터는 공식적으로 코틀린에 대한 지원을 시작했다. \n- SpringFramework 5.2 부터는 코틀린의 협력적 멀티테스킹을 수행할 수 있는 `코루틴`에 대한 지원이 들어갈 예정.\n  * [Reference Document](https://docs.spring.io/spring/docs/5.2.0.BUILD-SNAPSHOT/spring-framework-reference/languages.html#coroutines)\n  * [example](https://github.com/Kotlin/kotlin-coroutines-examples)\n\n기존 자바로 개발을 하던 사람이라면 누구나 쉽게 코틀린에 접근을 할 수 있다고 생각한다. 필자 역시 작년 4월부터 코틀린으로 개발을 시작했을 때, 생각보다 시작할 때의 러닝 커브가 높지 않았고 기존 자바 + 스프링에 대한 경험이 있었던 덕분인지 큰 어려움까지는 없었다.\n\n\n## 코틀린을 쓰면서 편리하거나 좋은 점\n### Null에 대한 편리한 판단, Null 안정성\n```kotlin\nperson.name ?: \"Daniel\"\nperson.name ?: throw IllegalArgumentException()\nperson.name?.toUpperCase() ?: \"UPPERCASE\"\nperson.name?.let {\n    println(\"Null이 아닐때 실행되요\")\n} ?: \"Null이면 여기에요\"\n\n```\n엘비스 연산자(`?:`)와 안전한 호출 연산(`?`)를 활용하면 Null이 될 수 있는 값에 대한 기본 값 지정 및 별도의 표현식을 지정 할 수 있다.\n\n### data class\n```kotlin\ndata class AddressDto(\n\tval street: String, \n\tval zipCode: String,\n\tval city: String\n)\n```\n자동으로 구현해주는 equals와 hashCode가 있어서 기존 자바에서 구현 시 직접 구현해주거나 autoValue 혹은 lombok과 같은 별도의 구현체를 사용하지 않아서 편리하다. \n### 다양한 확장 함수\n기본으로 제공해주는 다양한 확장 함수가 존재한다. 기존 자바로 개발했을 때는 Array를 Collection으로 변환하여 필터 혹은 Map을 하는 등 복잡한 단계가 필요했었는데, 코틀린에서는 이를 확장 함수 형태로 호출 할 수 있도록 기본 API를 제공해주고 있어서 편리하다.\n\n### 편리한 람다 사용 & 중위 연산자\n- 람다에 대한 선언을 변수에 편리하게 지정 할 수 있고 람다를 넘길 수 있는 고차 함수에 편리하게 해당 선언을 넘길 수 있다. 또한 람다에 대한 성능이 걱정된다면 `inline` 함수를 사용하여 이를 최적화 할 수도 있다. 코틀린에서 제공해주는 기본 함수 중 상당수가 `inline` 함수의 형태로 선언되어 있다.\n\n- 중위 연산자(`infix`)를 활용하면 코드가 깔끔하게 표현할 수 있다. 아래는 Pair 선언을 하는 중위 연산자 표현이다.\n```kotlin\nval pair = 10 to 10\nval pairList = listOf(\n\t10 to 10,\n\t10 to 10,\n\t10 to 10\n)\n```\n- 람다와 중위 연산자를 잘 활용하면 간단한 DSL을 쉽게 작성 할 수 있다. 아래는 kotlinx에서 제공해주는 html dsl 관련 예제 코드이다.\n```kotlin\nbody {\n\tdiv {\n        a(\"https://kotlinlang.org\") {\n            target = ATarget.blank\n            +\"Main site\"\n        }\n\t}\n}\n```\n\n\n\n## 겪었던 삽질에 대한 공유 혹은 알아야 하는 내용은?\n### Null이 아니지만 Null인 경우가 있다.\n```java\npublic class Bus {\n    private final int no;\n    private final String title;\n\n    private Bus(int no, String title) {\n        this.no = no;\n        this.title = title;\n    }\n\n    public int getNo() {\n        return no;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public static Bus getNullObject() {\n        return new Bus(10, null);\n    }\n}\n```\n\n```kotlin\nval busTitle: String = Bus.getNullObject().title\nprintln(busTitle.toUpperCase()) // throw Runtime Exception\n```\n\n- Java로 정의 · 선언된 참조 타입을 Kotlin에서는 Platform Type 타입이라고 부른다.\n- 특히 JPA를 사용하면서 null값이 들어가 있는 멤버 변수를 활용하다가 삽질을 겪었던 경험도 있다. 아무튼 상호운용과 관련하여 각별한 주의가 필요한 부분이다.\n- 이를 피하기 위해서는 @Nullable 혹은 @NotNull 어노테이션을 자바 코드에 명시 해줘야 코틀린쪽 컴파일러에서 이를 인지하여 처리할 수 있다. 아래는 비슷한 효과를 내는 어노테이션들 목록이다.\n\t- `@Nullable`\n\t\t- org.jetbrains.annotations.Nullable\n\t\t- android.support.annotation.Nullable\n\t\t- com.android.annotations.Nullable\n\t\t- org.eclipse.jdt.annotation.Nullable\n\t\t- org.checkerframework.checker.nullness.qual.Nullable\n\t\t- javax.annotation.Nullable\n\t\t- javax.annotation.CheckForNull\n\t\t- edu.umd.cs.findbugs.annotations.CheckForNull\n\t\t- edu.umd.cs.findbugs.annotations.Nullable\n\t\t- edu.umd.cs.findbugs.annotations.PossiblyNull\n\t- `@NotNull`\n\t\t- org.jetbrains.annotations.NotNull\n\t\t- edu.umd.cs.findbugs.annotations.NonNull\n\t\t- android.support.annotation.NonNull\n\t\t- com.android.annotations.NonNull\n\t\t- org.eclipse.jdt.annotation.NonNull\n\t\t- org.checkerframework.checker.nullness.qual.NonNull\n\t\t- lombok.NonNull\t\n\n\n### With JPA\n기존 자바에서 JPA를 경험했던 개발자라면 크게 사용상 어려움은 없으리라 생각한다. 하지만 아래에서 설명하는 기본 설정 관련된 부분에 대해 초기에는 신경 쓸 부분이 존재한다. 아래 내용은 JPA 사용 관련하여 알고 있어야 하는 내용 몇개를 정리해봤다.\n\n- 엔티티의 클래스의 경우 인자가 없는 생성자가 필수이기 때문에 이를 코드로 직접 생성해줘야 하는 번거로움이 있다.(자바할때는 당연한거였는데...) 이를 피하기 위해서는 빌드 경로에 kotlin-noarg 컴파일러 플러그인을 넣으면 Hibernate 엔티티에 대해 인수가 없는 생성자가 생성된다.\n```gradle\nbuildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-noarg:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-jpa\"\n```\n\n- **Kotlin 클래스는 기본적으로 Final 클래스이다.** 엔티티의 지연로드를 사용하는 경우 엔티티 클래스는 Final로 선언되어 있으면 안된다. `kotlin-allopen` 플러그인을 사용하여 아래와 같이 엔티티 타입의 클래스에 대해서는 final이 아닌 open 형태로 선언되도록 해야 한다.\n```gradle\nbuildscript {\n    dependencies {\n        classpath(\"org.jetbrains.kotlin:kotlin-allopen:${kotlinVersion}\")\n    }\n}\nallOpen {\n    annotation(\"javax.persistence.Entity\")\n    annotation(\"javax.persistence.MappedSuperclass\")\n    annotation(\"javax.persistence.Embeddable\")\n} \n```\n\n- JPA에 한정된 내용은 아니지만 AnnotationProcessor 사용 시 `kotlin-kapt` 플러그인을 사용하면 된다. 특히 회사에서 `queryDsl`을 공통으로 사용하고 있었기 때문에 해당 설정을 해줬어야 했다.\n\n```\napply plugin: 'kotlin-kapt'\nidea {\n    module {\n        def kaptMain = file('build/generated/source/kapt/main')\n        sourceDirs += kaptMain\n        generatedSourceDirs += kaptMain\n    }\n}\n....\ndependencies {\n\t...\n    implementation(\"com.querydsl:querydsl-jpa:${queryDslVersion}\")\n    kapt(\"com.querydsl:querydsl-apt:${queryDslVersion}:jpa\")\n\t\n}\n```\n\n기존 node.js를 주력으로 서버 어플리케이션 개발을 많이 해왔던 나로서는 코틀린의 유연하고 편리한 구문과 문법은 큰 매력적으로 다가왔고 지금도 이를 잘 알고 활용하고 싶은 마음이 크다. 우스게 소리로 팀원들과 이제 자바로 못돌아가겠다라는 이야기를 자주 하곤 한다. 이 만큼 코틀린으로 개발하는 것이 주는 재미와 더불어 걍력한 생산성이 매력적이라는 이야기이다. \n\n> 코틀린과 관련된 생태계나 관련 구현체를 찾을 때는 [awesome Kotlin](https://github.com/KotlinBy/awesome-kotlin)을 참고하면 많은 도움이 된다. 그리고 주 단위로 발행해주는 [Kotlin-Weekly](https://us12.campaign-archive.com/home/?u=f39692e245b94f7fb693b6d82&id=93b2272cb6)의 기사를 참고하는 것도 역시 많은 도움이 된다.","source":"_posts/Kotlin/Kotlin_With_Spring.md","raw":"---\ntitle: 'Kotlin With Spring'\ndate: 2019.3.2. 19:57\ncategories:\n- Kotlin\n---\n\n# Kotlin With Spring\n\n현재 재직중인 회사에서 코틀린을 주력으로 사용하고 있는데, 지난 1년 정도 코틀린과 스프링부트를 사용해보면서 겪었던 삽질이나 좋았던 점을 스터디를 통하여 한 번 정리하면 좋겠다하는 마음에서 정리하게 됬다. \n\n- 시작하기 어렵지 않다. Spring Intializer에서 Kotlin 프로젝트를 쉽게 생성 할 수 있으며, 물론 버젼의 제약이 있긴 하겠지만 기존 자바 기반으로 운영하고 있더라도 쉽게 Koltin을 통한 추가 기능 개발이 가능하다.\n- 현재 코틀린은 1.3.21 버젼까지 사용할 수 있으며 SpringFramework 5.X, SpringBoot 2.X부터는 공식적으로 코틀린에 대한 지원을 시작했다. \n- SpringFramework 5.2 부터는 코틀린의 협력적 멀티테스킹을 수행할 수 있는 `코루틴`에 대한 지원이 들어갈 예정.\n  * [Reference Document](https://docs.spring.io/spring/docs/5.2.0.BUILD-SNAPSHOT/spring-framework-reference/languages.html#coroutines)\n  * [example](https://github.com/Kotlin/kotlin-coroutines-examples)\n\n기존 자바로 개발을 하던 사람이라면 누구나 쉽게 코틀린에 접근을 할 수 있다고 생각한다. 필자 역시 작년 4월부터 코틀린으로 개발을 시작했을 때, 생각보다 시작할 때의 러닝 커브가 높지 않았고 기존 자바 + 스프링에 대한 경험이 있었던 덕분인지 큰 어려움까지는 없었다.\n\n\n## 코틀린을 쓰면서 편리하거나 좋은 점\n### Null에 대한 편리한 판단, Null 안정성\n```kotlin\nperson.name ?: \"Daniel\"\nperson.name ?: throw IllegalArgumentException()\nperson.name?.toUpperCase() ?: \"UPPERCASE\"\nperson.name?.let {\n    println(\"Null이 아닐때 실행되요\")\n} ?: \"Null이면 여기에요\"\n\n```\n엘비스 연산자(`?:`)와 안전한 호출 연산(`?`)를 활용하면 Null이 될 수 있는 값에 대한 기본 값 지정 및 별도의 표현식을 지정 할 수 있다.\n\n### data class\n```kotlin\ndata class AddressDto(\n\tval street: String, \n\tval zipCode: String,\n\tval city: String\n)\n```\n자동으로 구현해주는 equals와 hashCode가 있어서 기존 자바에서 구현 시 직접 구현해주거나 autoValue 혹은 lombok과 같은 별도의 구현체를 사용하지 않아서 편리하다. \n### 다양한 확장 함수\n기본으로 제공해주는 다양한 확장 함수가 존재한다. 기존 자바로 개발했을 때는 Array를 Collection으로 변환하여 필터 혹은 Map을 하는 등 복잡한 단계가 필요했었는데, 코틀린에서는 이를 확장 함수 형태로 호출 할 수 있도록 기본 API를 제공해주고 있어서 편리하다.\n\n### 편리한 람다 사용 & 중위 연산자\n- 람다에 대한 선언을 변수에 편리하게 지정 할 수 있고 람다를 넘길 수 있는 고차 함수에 편리하게 해당 선언을 넘길 수 있다. 또한 람다에 대한 성능이 걱정된다면 `inline` 함수를 사용하여 이를 최적화 할 수도 있다. 코틀린에서 제공해주는 기본 함수 중 상당수가 `inline` 함수의 형태로 선언되어 있다.\n\n- 중위 연산자(`infix`)를 활용하면 코드가 깔끔하게 표현할 수 있다. 아래는 Pair 선언을 하는 중위 연산자 표현이다.\n```kotlin\nval pair = 10 to 10\nval pairList = listOf(\n\t10 to 10,\n\t10 to 10,\n\t10 to 10\n)\n```\n- 람다와 중위 연산자를 잘 활용하면 간단한 DSL을 쉽게 작성 할 수 있다. 아래는 kotlinx에서 제공해주는 html dsl 관련 예제 코드이다.\n```kotlin\nbody {\n\tdiv {\n        a(\"https://kotlinlang.org\") {\n            target = ATarget.blank\n            +\"Main site\"\n        }\n\t}\n}\n```\n\n\n\n## 겪었던 삽질에 대한 공유 혹은 알아야 하는 내용은?\n### Null이 아니지만 Null인 경우가 있다.\n```java\npublic class Bus {\n    private final int no;\n    private final String title;\n\n    private Bus(int no, String title) {\n        this.no = no;\n        this.title = title;\n    }\n\n    public int getNo() {\n        return no;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public static Bus getNullObject() {\n        return new Bus(10, null);\n    }\n}\n```\n\n```kotlin\nval busTitle: String = Bus.getNullObject().title\nprintln(busTitle.toUpperCase()) // throw Runtime Exception\n```\n\n- Java로 정의 · 선언된 참조 타입을 Kotlin에서는 Platform Type 타입이라고 부른다.\n- 특히 JPA를 사용하면서 null값이 들어가 있는 멤버 변수를 활용하다가 삽질을 겪었던 경험도 있다. 아무튼 상호운용과 관련하여 각별한 주의가 필요한 부분이다.\n- 이를 피하기 위해서는 @Nullable 혹은 @NotNull 어노테이션을 자바 코드에 명시 해줘야 코틀린쪽 컴파일러에서 이를 인지하여 처리할 수 있다. 아래는 비슷한 효과를 내는 어노테이션들 목록이다.\n\t- `@Nullable`\n\t\t- org.jetbrains.annotations.Nullable\n\t\t- android.support.annotation.Nullable\n\t\t- com.android.annotations.Nullable\n\t\t- org.eclipse.jdt.annotation.Nullable\n\t\t- org.checkerframework.checker.nullness.qual.Nullable\n\t\t- javax.annotation.Nullable\n\t\t- javax.annotation.CheckForNull\n\t\t- edu.umd.cs.findbugs.annotations.CheckForNull\n\t\t- edu.umd.cs.findbugs.annotations.Nullable\n\t\t- edu.umd.cs.findbugs.annotations.PossiblyNull\n\t- `@NotNull`\n\t\t- org.jetbrains.annotations.NotNull\n\t\t- edu.umd.cs.findbugs.annotations.NonNull\n\t\t- android.support.annotation.NonNull\n\t\t- com.android.annotations.NonNull\n\t\t- org.eclipse.jdt.annotation.NonNull\n\t\t- org.checkerframework.checker.nullness.qual.NonNull\n\t\t- lombok.NonNull\t\n\n\n### With JPA\n기존 자바에서 JPA를 경험했던 개발자라면 크게 사용상 어려움은 없으리라 생각한다. 하지만 아래에서 설명하는 기본 설정 관련된 부분에 대해 초기에는 신경 쓸 부분이 존재한다. 아래 내용은 JPA 사용 관련하여 알고 있어야 하는 내용 몇개를 정리해봤다.\n\n- 엔티티의 클래스의 경우 인자가 없는 생성자가 필수이기 때문에 이를 코드로 직접 생성해줘야 하는 번거로움이 있다.(자바할때는 당연한거였는데...) 이를 피하기 위해서는 빌드 경로에 kotlin-noarg 컴파일러 플러그인을 넣으면 Hibernate 엔티티에 대해 인수가 없는 생성자가 생성된다.\n```gradle\nbuildscript {\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-noarg:$kotlin_version\"\n    }\n}\n\napply plugin: \"kotlin-jpa\"\n```\n\n- **Kotlin 클래스는 기본적으로 Final 클래스이다.** 엔티티의 지연로드를 사용하는 경우 엔티티 클래스는 Final로 선언되어 있으면 안된다. `kotlin-allopen` 플러그인을 사용하여 아래와 같이 엔티티 타입의 클래스에 대해서는 final이 아닌 open 형태로 선언되도록 해야 한다.\n```gradle\nbuildscript {\n    dependencies {\n        classpath(\"org.jetbrains.kotlin:kotlin-allopen:${kotlinVersion}\")\n    }\n}\nallOpen {\n    annotation(\"javax.persistence.Entity\")\n    annotation(\"javax.persistence.MappedSuperclass\")\n    annotation(\"javax.persistence.Embeddable\")\n} \n```\n\n- JPA에 한정된 내용은 아니지만 AnnotationProcessor 사용 시 `kotlin-kapt` 플러그인을 사용하면 된다. 특히 회사에서 `queryDsl`을 공통으로 사용하고 있었기 때문에 해당 설정을 해줬어야 했다.\n\n```\napply plugin: 'kotlin-kapt'\nidea {\n    module {\n        def kaptMain = file('build/generated/source/kapt/main')\n        sourceDirs += kaptMain\n        generatedSourceDirs += kaptMain\n    }\n}\n....\ndependencies {\n\t...\n    implementation(\"com.querydsl:querydsl-jpa:${queryDslVersion}\")\n    kapt(\"com.querydsl:querydsl-apt:${queryDslVersion}:jpa\")\n\t\n}\n```\n\n기존 node.js를 주력으로 서버 어플리케이션 개발을 많이 해왔던 나로서는 코틀린의 유연하고 편리한 구문과 문법은 큰 매력적으로 다가왔고 지금도 이를 잘 알고 활용하고 싶은 마음이 크다. 우스게 소리로 팀원들과 이제 자바로 못돌아가겠다라는 이야기를 자주 하곤 한다. 이 만큼 코틀린으로 개발하는 것이 주는 재미와 더불어 걍력한 생산성이 매력적이라는 이야기이다. \n\n> 코틀린과 관련된 생태계나 관련 구현체를 찾을 때는 [awesome Kotlin](https://github.com/KotlinBy/awesome-kotlin)을 참고하면 많은 도움이 된다. 그리고 주 단위로 발행해주는 [Kotlin-Weekly](https://us12.campaign-archive.com/home/?u=f39692e245b94f7fb693b6d82&id=93b2272cb6)의 기사를 참고하는 것도 역시 많은 도움이 된다.","slug":"Kotlin/Kotlin_With_Spring","published":1,"updated":"2021-08-02T12:07:04.117Z","_id":"ckrsup50m001btjhvekvr9by9","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Kotlin-With-Spring\"><a href=\"#Kotlin-With-Spring\" class=\"headerlink\" title=\"Kotlin With Spring\"></a>Kotlin With Spring</h1><p>현재 재직중인 회사에서 코틀린을 주력으로 사용하고 있는데, 지난 1년 정도 코틀린과 스프링부트를 사용해보면서 겪었던 삽질이나 좋았던 점을 스터디를 통하여 한 번 정리하면 좋겠다하는 마음에서 정리하게 됬다. </p>\n<ul>\n<li>시작하기 어렵지 않다. Spring Intializer에서 Kotlin 프로젝트를 쉽게 생성 할 수 있으며, 물론 버젼의 제약이 있긴 하겠지만 기존 자바 기반으로 운영하고 있더라도 쉽게 Koltin을 통한 추가 기능 개발이 가능하다.</li>\n<li>현재 코틀린은 1.3.21 버젼까지 사용할 수 있으며 SpringFramework 5.X, SpringBoot 2.X부터는 공식적으로 코틀린에 대한 지원을 시작했다. </li>\n<li>SpringFramework 5.2 부터는 코틀린의 협력적 멀티테스킹을 수행할 수 있는 <code>코루틴</code>에 대한 지원이 들어갈 예정.<ul>\n<li><a href=\"https://docs.spring.io/spring/docs/5.2.0.BUILD-SNAPSHOT/spring-framework-reference/languages.html#coroutines\">Reference Document</a></li>\n<li><a href=\"https://github.com/Kotlin/kotlin-coroutines-examples\">example</a></li>\n</ul>\n</li>\n</ul>\n<p>기존 자바로 개발을 하던 사람이라면 누구나 쉽게 코틀린에 접근을 할 수 있다고 생각한다. 필자 역시 작년 4월부터 코틀린으로 개발을 시작했을 때, 생각보다 시작할 때의 러닝 커브가 높지 않았고 기존 자바 + 스프링에 대한 경험이 있었던 덕분인지 큰 어려움까지는 없었다.</p>\n<h2 id=\"코틀린을-쓰면서-편리하거나-좋은-점\"><a href=\"#코틀린을-쓰면서-편리하거나-좋은-점\" class=\"headerlink\" title=\"코틀린을 쓰면서 편리하거나 좋은 점\"></a>코틀린을 쓰면서 편리하거나 좋은 점</h2><h3 id=\"Null에-대한-편리한-판단-Null-안정성\"><a href=\"#Null에-대한-편리한-판단-Null-안정성\" class=\"headerlink\" title=\"Null에 대한 편리한 판단, Null 안정성\"></a>Null에 대한 편리한 판단, Null 안정성</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person.name ?: <span class=\"string\">&quot;Daniel&quot;</span></span><br><span class=\"line\">person.name ?: <span class=\"keyword\">throw</span> IllegalArgumentException()</span><br><span class=\"line\">person.name?.toUpperCase() ?: <span class=\"string\">&quot;UPPERCASE&quot;</span></span><br><span class=\"line\">person.name?.let &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Null이 아닐때 실행되요&quot;</span>)</span><br><span class=\"line\">&#125; ?: <span class=\"string\">&quot;Null이면 여기에요&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>엘비스 연산자(<code>?:</code>)와 안전한 호출 연산(<code>?</code>)를 활용하면 Null이 될 수 있는 값에 대한 기본 값 지정 및 별도의 표현식을 지정 할 수 있다.</p>\n<h3 id=\"data-class\"><a href=\"#data-class\" class=\"headerlink\" title=\"data class\"></a>data class</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AddressDto</span></span>(</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> street: String, </span><br><span class=\"line\">\t<span class=\"keyword\">val</span> zipCode: String,</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> city: String</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>자동으로 구현해주는 equals와 hashCode가 있어서 기존 자바에서 구현 시 직접 구현해주거나 autoValue 혹은 lombok과 같은 별도의 구현체를 사용하지 않아서 편리하다. </p>\n<h3 id=\"다양한-확장-함수\"><a href=\"#다양한-확장-함수\" class=\"headerlink\" title=\"다양한 확장 함수\"></a>다양한 확장 함수</h3><p>기본으로 제공해주는 다양한 확장 함수가 존재한다. 기존 자바로 개발했을 때는 Array를 Collection으로 변환하여 필터 혹은 Map을 하는 등 복잡한 단계가 필요했었는데, 코틀린에서는 이를 확장 함수 형태로 호출 할 수 있도록 기본 API를 제공해주고 있어서 편리하다.</p>\n<h3 id=\"편리한-람다-사용-amp-중위-연산자\"><a href=\"#편리한-람다-사용-amp-중위-연산자\" class=\"headerlink\" title=\"편리한 람다 사용 &amp; 중위 연산자\"></a>편리한 람다 사용 &amp; 중위 연산자</h3><ul>\n<li><p>람다에 대한 선언을 변수에 편리하게 지정 할 수 있고 람다를 넘길 수 있는 고차 함수에 편리하게 해당 선언을 넘길 수 있다. 또한 람다에 대한 성능이 걱정된다면 <code>inline</code> 함수를 사용하여 이를 최적화 할 수도 있다. 코틀린에서 제공해주는 기본 함수 중 상당수가 <code>inline</code> 함수의 형태로 선언되어 있다.</p>\n</li>\n<li><p>중위 연산자(<code>infix</code>)를 활용하면 코드가 깔끔하게 표현할 수 있다. 아래는 Pair 선언을 하는 중위 연산자 표현이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> pair = <span class=\"number\">10</span> to <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> pairList = listOf(</span><br><span class=\"line\">\t<span class=\"number\">10</span> to <span class=\"number\">10</span>,</span><br><span class=\"line\">\t<span class=\"number\">10</span> to <span class=\"number\">10</span>,</span><br><span class=\"line\">\t<span class=\"number\">10</span> to <span class=\"number\">10</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n<li><p>람다와 중위 연산자를 잘 활용하면 간단한 DSL을 쉽게 작성 할 수 있다. 아래는 kotlinx에서 제공해주는 html dsl 관련 예제 코드이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">body &#123;</span><br><span class=\"line\">\tdiv &#123;</span><br><span class=\"line\">        a(<span class=\"string\">&quot;https://kotlinlang.org&quot;</span>) &#123;</span><br><span class=\"line\">            target = ATarget.blank</span><br><span class=\"line\">            +<span class=\"string\">&quot;Main site&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"겪었던-삽질에-대한-공유-혹은-알아야-하는-내용은\"><a href=\"#겪었던-삽질에-대한-공유-혹은-알아야-하는-내용은\" class=\"headerlink\" title=\"겪었던 삽질에 대한 공유 혹은 알아야 하는 내용은?\"></a>겪었던 삽질에 대한 공유 혹은 알아야 하는 내용은?</h2><h3 id=\"Null이-아니지만-Null인-경우가-있다\"><a href=\"#Null이-아니지만-Null인-경우가-있다\" class=\"headerlink\" title=\"Null이 아니지만 Null인 경우가 있다.\"></a>Null이 아니지만 Null인 경우가 있다.</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bus</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> no;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String title;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Bus</span><span class=\"params\">(<span class=\"keyword\">int</span> no, String title)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.no = no;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getNo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> no;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTitle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Bus <span class=\"title\">getNullObject</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Bus(<span class=\"number\">10</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> busTitle: String = Bus.getNullObject().title</span><br><span class=\"line\">println(busTitle.toUpperCase()) <span class=\"comment\">// throw Runtime Exception</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java로 정의 · 선언된 참조 타입을 Kotlin에서는 Platform Type 타입이라고 부른다.</li>\n<li>특히 JPA를 사용하면서 null값이 들어가 있는 멤버 변수를 활용하다가 삽질을 겪었던 경험도 있다. 아무튼 상호운용과 관련하여 각별한 주의가 필요한 부분이다.</li>\n<li>이를 피하기 위해서는 @Nullable 혹은 @NotNull 어노테이션을 자바 코드에 명시 해줘야 코틀린쪽 컴파일러에서 이를 인지하여 처리할 수 있다. 아래는 비슷한 효과를 내는 어노테이션들 목록이다.<ul>\n<li><code>@Nullable</code><ul>\n<li>org.jetbrains.annotations.Nullable</li>\n<li>android.support.annotation.Nullable</li>\n<li>com.android.annotations.Nullable</li>\n<li>org.eclipse.jdt.annotation.Nullable</li>\n<li>org.checkerframework.checker.nullness.qual.Nullable</li>\n<li>javax.annotation.Nullable</li>\n<li>javax.annotation.CheckForNull</li>\n<li>edu.umd.cs.findbugs.annotations.CheckForNull</li>\n<li>edu.umd.cs.findbugs.annotations.Nullable</li>\n<li>edu.umd.cs.findbugs.annotations.PossiblyNull</li>\n</ul>\n</li>\n<li><code>@NotNull</code><ul>\n<li>org.jetbrains.annotations.NotNull</li>\n<li>edu.umd.cs.findbugs.annotations.NonNull</li>\n<li>android.support.annotation.NonNull</li>\n<li>com.android.annotations.NonNull</li>\n<li>org.eclipse.jdt.annotation.NonNull</li>\n<li>org.checkerframework.checker.nullness.qual.NonNull</li>\n<li>lombok.NonNull    </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"With-JPA\"><a href=\"#With-JPA\" class=\"headerlink\" title=\"With JPA\"></a>With JPA</h3><p>기존 자바에서 JPA를 경험했던 개발자라면 크게 사용상 어려움은 없으리라 생각한다. 하지만 아래에서 설명하는 기본 설정 관련된 부분에 대해 초기에는 신경 쓸 부분이 존재한다. 아래 내용은 JPA 사용 관련하여 알고 있어야 하는 내용 몇개를 정리해봤다.</p>\n<ul>\n<li><p>엔티티의 클래스의 경우 인자가 없는 생성자가 필수이기 때문에 이를 코드로 직접 생성해줘야 하는 번거로움이 있다.(자바할때는 당연한거였는데…) 이를 피하기 위해서는 빌드 경로에 kotlin-noarg 컴파일러 플러그인을 넣으면 Hibernate 엔티티에 대해 인수가 없는 생성자가 생성된다.</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">buildscript</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">classpath</span> <span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">apply plugin: <span class=\"string\">&quot;kotlin-jpa&quot;</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>Kotlin 클래스는 기본적으로 Final 클래스이다.</strong> 엔티티의 지연로드를 사용하는 경우 엔티티 클래스는 Final로 선언되어 있으면 안된다. <code>kotlin-allopen</code> 플러그인을 사용하여 아래와 같이 엔티티 타입의 클래스에 대해서는 final이 아닌 open 형태로 선언되도록 해야 한다.</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">buildscript</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">classpath</span>(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-allopen:$&#123;kotlinVersion&#125;&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">allOpen &#123;</span><br><span class=\"line\">    annotation(<span class=\"string\">&quot;javax.persistence.Entity&quot;</span>)</span><br><span class=\"line\">    annotation(<span class=\"string\">&quot;javax.persistence.MappedSuperclass&quot;</span>)</span><br><span class=\"line\">    annotation(<span class=\"string\">&quot;javax.persistence.Embeddable&quot;</span>)</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure></li>\n<li><p>JPA에 한정된 내용은 아니지만 AnnotationProcessor 사용 시 <code>kotlin-kapt</code> 플러그인을 사용하면 된다. 특히 회사에서 <code>queryDsl</code>을 공통으로 사용하고 있었기 때문에 해당 설정을 해줬어야 했다.</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &#x27;kotlin-kapt&#x27;</span><br><span class=\"line\">idea &#123;</span><br><span class=\"line\">    module &#123;</span><br><span class=\"line\">        def kaptMain = file(&#x27;build/generated/source/kapt/main&#x27;)</span><br><span class=\"line\">        sourceDirs += kaptMain</span><br><span class=\"line\">        generatedSourceDirs += kaptMain</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">....</span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">    implementation(&quot;com.querydsl:querydsl-jpa:$&#123;queryDslVersion&#125;&quot;)</span><br><span class=\"line\">    kapt(&quot;com.querydsl:querydsl-apt:$&#123;queryDslVersion&#125;:jpa&quot;)</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>기존 node.js를 주력으로 서버 어플리케이션 개발을 많이 해왔던 나로서는 코틀린의 유연하고 편리한 구문과 문법은 큰 매력적으로 다가왔고 지금도 이를 잘 알고 활용하고 싶은 마음이 크다. 우스게 소리로 팀원들과 이제 자바로 못돌아가겠다라는 이야기를 자주 하곤 한다. 이 만큼 코틀린으로 개발하는 것이 주는 재미와 더불어 걍력한 생산성이 매력적이라는 이야기이다. </p>\n<blockquote>\n<p>코틀린과 관련된 생태계나 관련 구현체를 찾을 때는 <a href=\"https://github.com/KotlinBy/awesome-kotlin\">awesome Kotlin</a>을 참고하면 많은 도움이 된다. 그리고 주 단위로 발행해주는 <a href=\"https://us12.campaign-archive.com/home/?u=f39692e245b94f7fb693b6d82&id=93b2272cb6\">Kotlin-Weekly</a>의 기사를 참고하는 것도 역시 많은 도움이 된다.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Kotlin-With-Spring\"><a href=\"#Kotlin-With-Spring\" class=\"headerlink\" title=\"Kotlin With Spring\"></a>Kotlin With Spring</h1><p>현재 재직중인 회사에서 코틀린을 주력으로 사용하고 있는데, 지난 1년 정도 코틀린과 스프링부트를 사용해보면서 겪었던 삽질이나 좋았던 점을 스터디를 통하여 한 번 정리하면 좋겠다하는 마음에서 정리하게 됬다. </p>\n<ul>\n<li>시작하기 어렵지 않다. Spring Intializer에서 Kotlin 프로젝트를 쉽게 생성 할 수 있으며, 물론 버젼의 제약이 있긴 하겠지만 기존 자바 기반으로 운영하고 있더라도 쉽게 Koltin을 통한 추가 기능 개발이 가능하다.</li>\n<li>현재 코틀린은 1.3.21 버젼까지 사용할 수 있으며 SpringFramework 5.X, SpringBoot 2.X부터는 공식적으로 코틀린에 대한 지원을 시작했다. </li>\n<li>SpringFramework 5.2 부터는 코틀린의 협력적 멀티테스킹을 수행할 수 있는 <code>코루틴</code>에 대한 지원이 들어갈 예정.<ul>\n<li><a href=\"https://docs.spring.io/spring/docs/5.2.0.BUILD-SNAPSHOT/spring-framework-reference/languages.html#coroutines\">Reference Document</a></li>\n<li><a href=\"https://github.com/Kotlin/kotlin-coroutines-examples\">example</a></li>\n</ul>\n</li>\n</ul>\n<p>기존 자바로 개발을 하던 사람이라면 누구나 쉽게 코틀린에 접근을 할 수 있다고 생각한다. 필자 역시 작년 4월부터 코틀린으로 개발을 시작했을 때, 생각보다 시작할 때의 러닝 커브가 높지 않았고 기존 자바 + 스프링에 대한 경험이 있었던 덕분인지 큰 어려움까지는 없었다.</p>\n<h2 id=\"코틀린을-쓰면서-편리하거나-좋은-점\"><a href=\"#코틀린을-쓰면서-편리하거나-좋은-점\" class=\"headerlink\" title=\"코틀린을 쓰면서 편리하거나 좋은 점\"></a>코틀린을 쓰면서 편리하거나 좋은 점</h2><h3 id=\"Null에-대한-편리한-판단-Null-안정성\"><a href=\"#Null에-대한-편리한-판단-Null-안정성\" class=\"headerlink\" title=\"Null에 대한 편리한 판단, Null 안정성\"></a>Null에 대한 편리한 판단, Null 안정성</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person.name ?: <span class=\"string\">&quot;Daniel&quot;</span></span><br><span class=\"line\">person.name ?: <span class=\"keyword\">throw</span> IllegalArgumentException()</span><br><span class=\"line\">person.name?.toUpperCase() ?: <span class=\"string\">&quot;UPPERCASE&quot;</span></span><br><span class=\"line\">person.name?.let &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Null이 아닐때 실행되요&quot;</span>)</span><br><span class=\"line\">&#125; ?: <span class=\"string\">&quot;Null이면 여기에요&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>엘비스 연산자(<code>?:</code>)와 안전한 호출 연산(<code>?</code>)를 활용하면 Null이 될 수 있는 값에 대한 기본 값 지정 및 별도의 표현식을 지정 할 수 있다.</p>\n<h3 id=\"data-class\"><a href=\"#data-class\" class=\"headerlink\" title=\"data class\"></a>data class</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AddressDto</span></span>(</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> street: String, </span><br><span class=\"line\">\t<span class=\"keyword\">val</span> zipCode: String,</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> city: String</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>자동으로 구현해주는 equals와 hashCode가 있어서 기존 자바에서 구현 시 직접 구현해주거나 autoValue 혹은 lombok과 같은 별도의 구현체를 사용하지 않아서 편리하다. </p>\n<h3 id=\"다양한-확장-함수\"><a href=\"#다양한-확장-함수\" class=\"headerlink\" title=\"다양한 확장 함수\"></a>다양한 확장 함수</h3><p>기본으로 제공해주는 다양한 확장 함수가 존재한다. 기존 자바로 개발했을 때는 Array를 Collection으로 변환하여 필터 혹은 Map을 하는 등 복잡한 단계가 필요했었는데, 코틀린에서는 이를 확장 함수 형태로 호출 할 수 있도록 기본 API를 제공해주고 있어서 편리하다.</p>\n<h3 id=\"편리한-람다-사용-amp-중위-연산자\"><a href=\"#편리한-람다-사용-amp-중위-연산자\" class=\"headerlink\" title=\"편리한 람다 사용 &amp; 중위 연산자\"></a>편리한 람다 사용 &amp; 중위 연산자</h3><ul>\n<li><p>람다에 대한 선언을 변수에 편리하게 지정 할 수 있고 람다를 넘길 수 있는 고차 함수에 편리하게 해당 선언을 넘길 수 있다. 또한 람다에 대한 성능이 걱정된다면 <code>inline</code> 함수를 사용하여 이를 최적화 할 수도 있다. 코틀린에서 제공해주는 기본 함수 중 상당수가 <code>inline</code> 함수의 형태로 선언되어 있다.</p>\n</li>\n<li><p>중위 연산자(<code>infix</code>)를 활용하면 코드가 깔끔하게 표현할 수 있다. 아래는 Pair 선언을 하는 중위 연산자 표현이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> pair = <span class=\"number\">10</span> to <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> pairList = listOf(</span><br><span class=\"line\">\t<span class=\"number\">10</span> to <span class=\"number\">10</span>,</span><br><span class=\"line\">\t<span class=\"number\">10</span> to <span class=\"number\">10</span>,</span><br><span class=\"line\">\t<span class=\"number\">10</span> to <span class=\"number\">10</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n<li><p>람다와 중위 연산자를 잘 활용하면 간단한 DSL을 쉽게 작성 할 수 있다. 아래는 kotlinx에서 제공해주는 html dsl 관련 예제 코드이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">body &#123;</span><br><span class=\"line\">\tdiv &#123;</span><br><span class=\"line\">        a(<span class=\"string\">&quot;https://kotlinlang.org&quot;</span>) &#123;</span><br><span class=\"line\">            target = ATarget.blank</span><br><span class=\"line\">            +<span class=\"string\">&quot;Main site&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"겪었던-삽질에-대한-공유-혹은-알아야-하는-내용은\"><a href=\"#겪었던-삽질에-대한-공유-혹은-알아야-하는-내용은\" class=\"headerlink\" title=\"겪었던 삽질에 대한 공유 혹은 알아야 하는 내용은?\"></a>겪었던 삽질에 대한 공유 혹은 알아야 하는 내용은?</h2><h3 id=\"Null이-아니지만-Null인-경우가-있다\"><a href=\"#Null이-아니지만-Null인-경우가-있다\" class=\"headerlink\" title=\"Null이 아니지만 Null인 경우가 있다.\"></a>Null이 아니지만 Null인 경우가 있다.</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bus</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> no;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String title;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Bus</span><span class=\"params\">(<span class=\"keyword\">int</span> no, String title)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.no = no;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getNo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> no;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTitle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Bus <span class=\"title\">getNullObject</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Bus(<span class=\"number\">10</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> busTitle: String = Bus.getNullObject().title</span><br><span class=\"line\">println(busTitle.toUpperCase()) <span class=\"comment\">// throw Runtime Exception</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java로 정의 · 선언된 참조 타입을 Kotlin에서는 Platform Type 타입이라고 부른다.</li>\n<li>특히 JPA를 사용하면서 null값이 들어가 있는 멤버 변수를 활용하다가 삽질을 겪었던 경험도 있다. 아무튼 상호운용과 관련하여 각별한 주의가 필요한 부분이다.</li>\n<li>이를 피하기 위해서는 @Nullable 혹은 @NotNull 어노테이션을 자바 코드에 명시 해줘야 코틀린쪽 컴파일러에서 이를 인지하여 처리할 수 있다. 아래는 비슷한 효과를 내는 어노테이션들 목록이다.<ul>\n<li><code>@Nullable</code><ul>\n<li>org.jetbrains.annotations.Nullable</li>\n<li>android.support.annotation.Nullable</li>\n<li>com.android.annotations.Nullable</li>\n<li>org.eclipse.jdt.annotation.Nullable</li>\n<li>org.checkerframework.checker.nullness.qual.Nullable</li>\n<li>javax.annotation.Nullable</li>\n<li>javax.annotation.CheckForNull</li>\n<li>edu.umd.cs.findbugs.annotations.CheckForNull</li>\n<li>edu.umd.cs.findbugs.annotations.Nullable</li>\n<li>edu.umd.cs.findbugs.annotations.PossiblyNull</li>\n</ul>\n</li>\n<li><code>@NotNull</code><ul>\n<li>org.jetbrains.annotations.NotNull</li>\n<li>edu.umd.cs.findbugs.annotations.NonNull</li>\n<li>android.support.annotation.NonNull</li>\n<li>com.android.annotations.NonNull</li>\n<li>org.eclipse.jdt.annotation.NonNull</li>\n<li>org.checkerframework.checker.nullness.qual.NonNull</li>\n<li>lombok.NonNull    </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"With-JPA\"><a href=\"#With-JPA\" class=\"headerlink\" title=\"With JPA\"></a>With JPA</h3><p>기존 자바에서 JPA를 경험했던 개발자라면 크게 사용상 어려움은 없으리라 생각한다. 하지만 아래에서 설명하는 기본 설정 관련된 부분에 대해 초기에는 신경 쓸 부분이 존재한다. 아래 내용은 JPA 사용 관련하여 알고 있어야 하는 내용 몇개를 정리해봤다.</p>\n<ul>\n<li><p>엔티티의 클래스의 경우 인자가 없는 생성자가 필수이기 때문에 이를 코드로 직접 생성해줘야 하는 번거로움이 있다.(자바할때는 당연한거였는데…) 이를 피하기 위해서는 빌드 경로에 kotlin-noarg 컴파일러 플러그인을 넣으면 Hibernate 엔티티에 대해 인수가 없는 생성자가 생성된다.</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">buildscript</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">classpath</span> <span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">apply plugin: <span class=\"string\">&quot;kotlin-jpa&quot;</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>Kotlin 클래스는 기본적으로 Final 클래스이다.</strong> 엔티티의 지연로드를 사용하는 경우 엔티티 클래스는 Final로 선언되어 있으면 안된다. <code>kotlin-allopen</code> 플러그인을 사용하여 아래와 같이 엔티티 타입의 클래스에 대해서는 final이 아닌 open 형태로 선언되도록 해야 한다.</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">buildscript</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">classpath</span>(<span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-allopen:$&#123;kotlinVersion&#125;&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">allOpen &#123;</span><br><span class=\"line\">    annotation(<span class=\"string\">&quot;javax.persistence.Entity&quot;</span>)</span><br><span class=\"line\">    annotation(<span class=\"string\">&quot;javax.persistence.MappedSuperclass&quot;</span>)</span><br><span class=\"line\">    annotation(<span class=\"string\">&quot;javax.persistence.Embeddable&quot;</span>)</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure></li>\n<li><p>JPA에 한정된 내용은 아니지만 AnnotationProcessor 사용 시 <code>kotlin-kapt</code> 플러그인을 사용하면 된다. 특히 회사에서 <code>queryDsl</code>을 공통으로 사용하고 있었기 때문에 해당 설정을 해줬어야 했다.</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &#x27;kotlin-kapt&#x27;</span><br><span class=\"line\">idea &#123;</span><br><span class=\"line\">    module &#123;</span><br><span class=\"line\">        def kaptMain = file(&#x27;build/generated/source/kapt/main&#x27;)</span><br><span class=\"line\">        sourceDirs += kaptMain</span><br><span class=\"line\">        generatedSourceDirs += kaptMain</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">....</span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">    implementation(&quot;com.querydsl:querydsl-jpa:$&#123;queryDslVersion&#125;&quot;)</span><br><span class=\"line\">    kapt(&quot;com.querydsl:querydsl-apt:$&#123;queryDslVersion&#125;:jpa&quot;)</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>기존 node.js를 주력으로 서버 어플리케이션 개발을 많이 해왔던 나로서는 코틀린의 유연하고 편리한 구문과 문법은 큰 매력적으로 다가왔고 지금도 이를 잘 알고 활용하고 싶은 마음이 크다. 우스게 소리로 팀원들과 이제 자바로 못돌아가겠다라는 이야기를 자주 하곤 한다. 이 만큼 코틀린으로 개발하는 것이 주는 재미와 더불어 걍력한 생산성이 매력적이라는 이야기이다. </p>\n<blockquote>\n<p>코틀린과 관련된 생태계나 관련 구현체를 찾을 때는 <a href=\"https://github.com/KotlinBy/awesome-kotlin\">awesome Kotlin</a>을 참고하면 많은 도움이 된다. 그리고 주 단위로 발행해주는 <a href=\"https://us12.campaign-archive.com/home/?u=f39692e245b94f7fb693b6d82&id=93b2272cb6\">Kotlin-Weekly</a>의 기사를 참고하는 것도 역시 많은 도움이 된다.</p>\n</blockquote>\n"},{"title":"Kotlin 참고 링크","date":"2019-07-11T15:00:00.000Z","_content":"\n# 참고\n- [FunctionalKoltin](http://solutionsproj.net/software/functional_kotlin.pdf)\n- [FPKotlin](https://books.google.co.kr/books?id=_uhODwAAQBAJ&pg=PA289&lpg=PA289&dq=kotlin+arrow+pipe&source=bl&ots=C1gQmxSDKr&sig=ACfU3U2MgrRdUav_M-HKx9IZEbQojQZepQ&hl=ko&sa=X&ved=2ahUKEwiZlsbdr7jhAhWpyYsBHRopDmoQ6AEwB3oECAkQAQ#v=onepage&q=kotlin%20arrow%20pipe&f=false)","source":"_posts/Kotlin/Reference.md","raw":"---\ntitle: 'Kotlin 참고 링크'\ndate: 2019/7/12 00:00:00\ncategories:\n- Kotlin\n---\n\n# 참고\n- [FunctionalKoltin](http://solutionsproj.net/software/functional_kotlin.pdf)\n- [FPKotlin](https://books.google.co.kr/books?id=_uhODwAAQBAJ&pg=PA289&lpg=PA289&dq=kotlin+arrow+pipe&source=bl&ots=C1gQmxSDKr&sig=ACfU3U2MgrRdUav_M-HKx9IZEbQojQZepQ&hl=ko&sa=X&ved=2ahUKEwiZlsbdr7jhAhWpyYsBHRopDmoQ6AEwB3oECAkQAQ#v=onepage&q=kotlin%20arrow%20pipe&f=false)","slug":"Kotlin/Reference","published":1,"updated":"2021-08-02T12:26:02.435Z","_id":"ckrsup50n001ctjhvfiapao6w","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h1><ul>\n<li><a href=\"http://solutionsproj.net/software/functional_kotlin.pdf\">FunctionalKoltin</a></li>\n<li><a href=\"https://books.google.co.kr/books?id=_uhODwAAQBAJ&pg=PA289&lpg=PA289&dq=kotlin+arrow+pipe&source=bl&ots=C1gQmxSDKr&sig=ACfU3U2MgrRdUav_M-HKx9IZEbQojQZepQ&hl=ko&sa=X&ved=2ahUKEwiZlsbdr7jhAhWpyYsBHRopDmoQ6AEwB3oECAkQAQ#v=onepage&q=kotlin%20arrow%20pipe&f=false\">FPKotlin</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h1><ul>\n<li><a href=\"http://solutionsproj.net/software/functional_kotlin.pdf\">FunctionalKoltin</a></li>\n<li><a href=\"https://books.google.co.kr/books?id=_uhODwAAQBAJ&pg=PA289&lpg=PA289&dq=kotlin+arrow+pipe&source=bl&ots=C1gQmxSDKr&sig=ACfU3U2MgrRdUav_M-HKx9IZEbQojQZepQ&hl=ko&sa=X&ved=2ahUKEwiZlsbdr7jhAhWpyYsBHRopDmoQ6AEwB3oECAkQAQ#v=onepage&q=kotlin%20arrow%20pipe&f=false\">FPKotlin</a></li>\n</ul>\n"},{"title":"RxKotlin #1","date":"2019-05-06T09:09:00.000Z","_content":"\n# RxKotlin #1\n\n# Reactive Programming\n- 데이터가 통지되면 이에 반응하여 데이터를 처리 하는 방식의 프로그래밍 모델. 즉, 프로그램에서 필요한 데이터를 직접 가지고와서 처리하는 방식(pull)이 아닌 데이터를 받은 시점에 처리하는 방식(push). \n- 이를 구현하기 위해 데이터를 만들어내는 `생산자`와 이를 소비하게 되는 `소비자`로 역할을 나눠 처리하는 프로세스를 가지게 된다.\n- 소비자와 생산자의 역할이 분리되어 있으므로, 생산자는 데이터를 생산하여 전달하는 역할까지 수행하며, 소비자는 데이터를 받아서 처리하는 역할만을 수행한다. 즉, 생산자와 소비자는 각각의 역할만 충실하게 수행하면 되고, 반대편에서 어떤 처리를 하는지에 대해서는 관심 밖의 일이다.\n> 이처럼, 역할이 분리됨에 따라 쉽게 비동기 구현이 가능\n\n# Reactive Stream\n- `데이터 스트림`을 `비동기`로 처리 할 수 있는 공통 메커니즘/인터페이스.\n- Reactive Stream은 인터페이스만 제공하고 상세 구현은 각 라이브러리/프레임워크에서 책임을 가져간다.\n## 구현체\n- [위키피디아 참고](https://en.wikipedia.org/wiki/Reactive_Streams#cite_note-17)\n![](https://cdn-images-1.medium.com/max/1600/1*70ZfCOn5Qadc8nZ_k_JhKQ.png)\n\n\n## 데이터스트림\n- Collection과 같이 이미 생성한 데이터를 포함하여 `앞으로 생성할 데이터` 혹은 `발생 가능성이 있는 데이터`까지 포함하는 개념. \n- 키보드 혹은 마우스 같은 UI상에서의 이벤트가 발생 했을 때, 해당 이벤트가 발생하는 시점의 데이터까지 포함하는 개념으로 볼 수 있다.\n- 데이터스트림의 소스 종류들은?\n  - SQL 쿼리들\n  - GUI 이벤트\n  - HTTP 기반 서비스\n  - TCP 소켓\n  - 파일 시스템\n  - Kafka같은 메시지 큐들\n  - 기타 등등\n\n\n## 구성\n- Reactive Stream은 Publisher와 Subscriber로 구성되며, Subscriber가 Publisher를 구독하면 Publisher가 통보하는 데이터를 받을 수 있음\n```puml\n@startuml\nactor 생산자 as A\nactor 소비자 as B\nautonumber\nB -> A: 구독(subscribe)\nA -> B: 데이터 통보 준비 완료(onSubscribe)\nB -> A: 데이터 요청(Subscription.request)\nA -> A: 데이터 생산\nA -> B: 데이터 통보(onNext)\nB -> B: 통보받은 데이터를 처리\nB -> A: 데이터 요청(Subscription.request)\nalt 데이터 통보를 모두 마쳤을 경우\nA -> B: 데이터 통보 완료 통보(onComplete)\nelse 처리 중 에러가 발생했을 경우\nA -> B: 에러 통보(onError)\nend\n@enduml\n```\n- 구독(subscribe)가 발생하면 이에 대한 Subscription이 생성된다.\n- Subscriber가 Publisher를 구독하지 않으면 이후 단계는 진행되지 않는다.\n- onComplete, onError와 같이, 확정 Action이 발생하면 소비자에게 통보한다.\n- Subscriber는 Publisher에게 받을 데이터 개수를 요청 할 수 있으며, 요청 받은 Publisher는 다시 데이터를 생산하여 Subscriber에게 전달(onNext)한다.\n- 받을 데이터 개수를 요청하는 것은 생산자측의 처리 속도와 소비자측의 처리 속도가 다를 수 있기 때문에, 이를 제어 할 수 있는 적절한 수단이 필요하기 때문\n\n## 표준 인터페이스\n|인터페이스|설명|\n|---|---|\n|Publisher|데이터 생성/통보|\n|Subscriber|데이터 처리|\n|Subscription|데이터 요청/ 구독 해지 가능|\n|Processor|Publisher & Subscriber의 역할을 모두 가지고 있음|\n\n위 표준 인터페이스를 보면 알 수 있듯이, 분명하게 `역할 분리`가 되어 있음을 알 수 있다. 이는 곧 처리 단위 별로 개별 책임을 가져 갈 수 있음을 뜻함.\n\n## 규칙\nReactive Stream은 인터페이스를 통하여 데이터를 통지하는 구조이며, Reactive Stream에서 정해놓은 규약을 충분하게 지켜야 구조가 제대로 동작한다.\n\n1. 구독 시작 통지(onSubscribe)는 구독에서 한 번만 발생\n2. 데이터 통지는 순차적으로 이뤄진다.\n3. null을 통지하지 않는다.\n4. Publisher는 처리 완료(onComplete) 혹은 에러(onError)를 통하여 종료한다.\n\n> [주의] 같은 인스턴스를 활용하여 구독(subscribe)를 할 경우, Publisher/Subscriber의 내부 상태를 초기화하지 않으면 의도하지 않은 결과로 이어질 수 있다. 왜냐하면, onComplete 혹은 onError의 통지가 이뤄진 이후 시점에는 Publisher는 처리가 끝마친 것으로 판단하기 때문이다.\n\n## RxJava,Kotlin에서 꼭 알아야 할 구조는?\n\n### 생산자/소비자/구독\n| ReactiveStream 지원 유/무  | 생산자  | 소비자  | 관계 |\n|---|---|---|---|\n| O  | Flowable  | Subscriber  | Subscription |\n| X  | Observable  | Observer  | Disposable |\n\n\n> 지원 유무의 가장 큰 차이점은 `배압(Backpressure)`의 적용 유무, 배압이 적용되어 있지 않기 때문에, 별도로 소비자측에서는 데이터를 요청하지 않음. 배압 외에는 처리 모델은 거의 똑같다.\n\n```puml\n@startuml\nactor 생산자 as A\nactor 소비자 as B\nparticipant 구독 as C\nautonumber\nB -> A: 구독(subscribe)\nA -> C: 구독 관계에 대한 참조 객체 생생(Subscription)\nA -> B: 데이터 통보 준비 완료(onSubscribe)\n\nloop 통보할 데이터가 없을 때까지\nB -> C: 데이터 요청(Subscription.request)\n\nalt 구독 해지 상태가 아닐 경우\n\tA -> A: 데이터 생산\n\tA -> B: 데이터 통보(onNext)\nend\n\n\nalt 소비자가 계속 데이터를 받을 경우\n\tB -> B: 통보받은 데이터를 처리\n\tB -> C: 데이터 요청(Subscription.request)\nelse 구독을 해지 하는 경우\n\tB -> C: 구독 해지 요청\nend\nend\n\nalt 데이터 통보를 모두 마쳤을 경우\nA -> B: 데이터 통보 완료 통보(onComplete)\nelse 처리 중 에러가 발생했을 경우\nA -> B: 에러 통보(onError)\nend\n@enduml\n```\n\n### 연산자\n`map`, `flatMap` 및 `filter` 등과 같이 기존 Stream을 다루거나 함수형 라이브러리에서 제공해주는 연산자를 비슷하게 제공해주고 있음. 연산자별로 생성되는 Flowable/Observable의 성격이 상이한 부분이 존재하며, 또한 실행순서에 영향을 주는 연산자도 존재함.\n\n#### 순차 처리의 예\n```kotlin\n    Flowable.just(1,2,3,4,5,6,7,8,9,10)\n        .filter { it % 2 == 0 }\n        .map { it * 100 }\n        .subscribe { println(\"${Thread.currentThread().name}, data: $it\") }\n```\n> [결과]\nmain, data: 200\nmain, data: 400\nmain, data: 600\nmain, data: 800\nmain, data: 1000\n\n#### 순차 처리가 안되는 예\n```kotlin\nFlowable.just(\"A\", \"B\", \"C\")\n\t.flatMap {\n\t\tFlowable.just(it).delay(1000L, TimeUnit.MILLISECONDS)\n\t}.subscribe {\n\t\tprintln(\"${Thread.currentThread().name}: $it\")\n\t}\n```\n> [결과]\nRxComputationThreadPool-3: C\nRxComputationThreadPool-1: A\nRxComputationThreadPool-1: B\n\n### 비동기 처리\n***생산자와 소비자는 별도의 지정이 없을 경우, 메인스레드 혹은 실행 스레드에서 순차 처리 됨.*** \n\n하지만 시간 관련 Flowable/Observable 생성자의 경우, 별도의 스레드에서 실행이 되는 경우도 있음. 비동기 처리를 지정해야 할 경우 `생산자 측(subscribeOn())`과 `소비자 측(observeOn())`에 `스레드 스캐줄러`를 지정하면 되며, 스캐쥴러(`Schedulers`)의 종류는 `io`, `computation` 등이 있다.\n\n\n### 외부 자원에 대한 참조는?\n생산자/소비자는 여러 스레드에서 실행이 될 수 있기 때문에, 공유 자원에 대해서 동기화 작업을 반드시 수행해줘야 한다. 이런 동기화를 피하는 가장 좋은 방법은 아래와 같다.\n- 순수 함수(함수형 인터페이스)의 사용\n  - 외부 자원 참조 X\n  - 함수 단위로 코드를 전개하여 처리 안정성을 확보\n  - 불변 객체의 사용, 큰 오버헤드가 존재하지 않으면 객체는 복사를 하여 사용하는 것이 좋다.\n\n> 여러 개의 생산자/소비자가 존재 할 경우는 `merge`등의 연산자를 통하여 해당 생산자/소비자를 실행하는 스레드가 공유 자원에 대해 동기화하여 접근 할 수 있도록 할 수 있다.\n\n#### 공유 자원에 대한 잘못된 접근의 예\n아래의 2개의 생산자/소비자의 구조에서 2개의 소비자 모두 변수 `num`에 접근하여 값을 수정하고 있는데, 이는 각각의 소비자에서 스레드에 대한 적절한 동기화 없이 접근하는 안티패턴의 가장 좋은 예라고 할 수 있다. \n```kotlin\nvar num = 0\nFlowable.range(1, 100_000)\n\t.subscribeOn(Schedulers.computation())\n\t.observeOn(Schedulers.computation())\n\t.subscribe(\n\t\t{ ++num },\n\t\t{ println(\"에러=$it\") },\n\t\t{ println(\"counter.get()= $num\") }\n\t)\n\nFlowable.range(1, 100_000)\n\t.subscribeOn(Schedulers.computation())\n\t.observeOn(Schedulers.computation())\n\t.subscribe(\n\t\t{ ++num },\n\t\t{ println(\"에러=$it\") },\n\t\t{ println(\"counter.get()= $num\") }\n\t)\n```\n\n#### merge 연산자를 사용한 예\n위에서 보았던 안티패턴을 Rx에서는 스레드에 대한 동기화 처리를 진행해주는 `merge` 연산자를 사용하여 해결이 가능하다. 여러 생산자에서 발행하는 데이터의 타임라인을 하나로 만들어주며, 발행하는 순서를 아래의 그림과 같이 시간순 혹은 실행순으로 만들 수 있다.\n> [요약] 여러 Observable의 출력을 결합하여 단일 Observable처럼 작동하도록 할 수 있다.\n\n![](http://reactivex.io/documentation/operators/images/merge.png)\n```kotlin\nvar num = 0\nval source1 = Flowable.range(1, 100_000)\n\t.subscribeOn(Schedulers.computation())\n\t.observeOn(Schedulers.computation())\n\n\nval source2 = Flowable.range(1, 100_000)\n\t.subscribeOn(Schedulers.computation())\n\t.observeOn(Schedulers.computation())\n\nFlowable\n.merge(source1, source2)\n.subscribe(\n\t{ ++num },\n\t{ println(\"에러=$it\") },\n\t{ println(\"counter.get()= $num\") }\n)\n```\n\n## Flowable vs Observable 어떤걸 써야 하는거지?\n### Flowable\n  - 대량 데이터를 처리 할 경우\n  - 네트워크 통신/파일 등 IO를 처리 할 경우\n### Observable\n  - GUI 이벤트\n  - 소량의 데이터를 처리 할 경우\n  - 자바의 Stream을 대신하여 사용할 경우\n\n대량의 데이터와 더불어 IO를 처리 해야 할 경우에는 `Flowable`을 사용하여 적절한 배압 정책을 적용하는 것이 유리하다. 반면에 GUI의 이벤트 처리 혹은 소량의 데이터를 처리 할 경우 배압이 없는 `Observable`을 사용하는 것이 유리하다고 한다. `Observable`은 배압 기능이 없는 만큼 `Flowable`에 비하여 오버헤드가 적은 것이 특징이다.\n\n> 배압 기능을 사용하면, 쏟아지는 데이터 대한 적절한 제어 뿐만 아니라 에러 처리도 할 수 있다. 물론, 다루는 데이터의 성격에 따라 달라질 수 있는 부분이지만 생산자와 소비자간의 처리 속도 차이에 따라 발생하는 데이터 유실에 대한 부분도 반드시 고려해서 배압 정책을 적용한 코드를 작성해야 한다.\n","source":"_posts/Kotlin/Rx_Kotlin_1.md","raw":"---\ntitle: 'RxKotlin #1'\ndate: 2019.5.6. 18:09\ncategories:\n- Kotlin\n---\n\n# RxKotlin #1\n\n# Reactive Programming\n- 데이터가 통지되면 이에 반응하여 데이터를 처리 하는 방식의 프로그래밍 모델. 즉, 프로그램에서 필요한 데이터를 직접 가지고와서 처리하는 방식(pull)이 아닌 데이터를 받은 시점에 처리하는 방식(push). \n- 이를 구현하기 위해 데이터를 만들어내는 `생산자`와 이를 소비하게 되는 `소비자`로 역할을 나눠 처리하는 프로세스를 가지게 된다.\n- 소비자와 생산자의 역할이 분리되어 있으므로, 생산자는 데이터를 생산하여 전달하는 역할까지 수행하며, 소비자는 데이터를 받아서 처리하는 역할만을 수행한다. 즉, 생산자와 소비자는 각각의 역할만 충실하게 수행하면 되고, 반대편에서 어떤 처리를 하는지에 대해서는 관심 밖의 일이다.\n> 이처럼, 역할이 분리됨에 따라 쉽게 비동기 구현이 가능\n\n# Reactive Stream\n- `데이터 스트림`을 `비동기`로 처리 할 수 있는 공통 메커니즘/인터페이스.\n- Reactive Stream은 인터페이스만 제공하고 상세 구현은 각 라이브러리/프레임워크에서 책임을 가져간다.\n## 구현체\n- [위키피디아 참고](https://en.wikipedia.org/wiki/Reactive_Streams#cite_note-17)\n![](https://cdn-images-1.medium.com/max/1600/1*70ZfCOn5Qadc8nZ_k_JhKQ.png)\n\n\n## 데이터스트림\n- Collection과 같이 이미 생성한 데이터를 포함하여 `앞으로 생성할 데이터` 혹은 `발생 가능성이 있는 데이터`까지 포함하는 개념. \n- 키보드 혹은 마우스 같은 UI상에서의 이벤트가 발생 했을 때, 해당 이벤트가 발생하는 시점의 데이터까지 포함하는 개념으로 볼 수 있다.\n- 데이터스트림의 소스 종류들은?\n  - SQL 쿼리들\n  - GUI 이벤트\n  - HTTP 기반 서비스\n  - TCP 소켓\n  - 파일 시스템\n  - Kafka같은 메시지 큐들\n  - 기타 등등\n\n\n## 구성\n- Reactive Stream은 Publisher와 Subscriber로 구성되며, Subscriber가 Publisher를 구독하면 Publisher가 통보하는 데이터를 받을 수 있음\n```puml\n@startuml\nactor 생산자 as A\nactor 소비자 as B\nautonumber\nB -> A: 구독(subscribe)\nA -> B: 데이터 통보 준비 완료(onSubscribe)\nB -> A: 데이터 요청(Subscription.request)\nA -> A: 데이터 생산\nA -> B: 데이터 통보(onNext)\nB -> B: 통보받은 데이터를 처리\nB -> A: 데이터 요청(Subscription.request)\nalt 데이터 통보를 모두 마쳤을 경우\nA -> B: 데이터 통보 완료 통보(onComplete)\nelse 처리 중 에러가 발생했을 경우\nA -> B: 에러 통보(onError)\nend\n@enduml\n```\n- 구독(subscribe)가 발생하면 이에 대한 Subscription이 생성된다.\n- Subscriber가 Publisher를 구독하지 않으면 이후 단계는 진행되지 않는다.\n- onComplete, onError와 같이, 확정 Action이 발생하면 소비자에게 통보한다.\n- Subscriber는 Publisher에게 받을 데이터 개수를 요청 할 수 있으며, 요청 받은 Publisher는 다시 데이터를 생산하여 Subscriber에게 전달(onNext)한다.\n- 받을 데이터 개수를 요청하는 것은 생산자측의 처리 속도와 소비자측의 처리 속도가 다를 수 있기 때문에, 이를 제어 할 수 있는 적절한 수단이 필요하기 때문\n\n## 표준 인터페이스\n|인터페이스|설명|\n|---|---|\n|Publisher|데이터 생성/통보|\n|Subscriber|데이터 처리|\n|Subscription|데이터 요청/ 구독 해지 가능|\n|Processor|Publisher & Subscriber의 역할을 모두 가지고 있음|\n\n위 표준 인터페이스를 보면 알 수 있듯이, 분명하게 `역할 분리`가 되어 있음을 알 수 있다. 이는 곧 처리 단위 별로 개별 책임을 가져 갈 수 있음을 뜻함.\n\n## 규칙\nReactive Stream은 인터페이스를 통하여 데이터를 통지하는 구조이며, Reactive Stream에서 정해놓은 규약을 충분하게 지켜야 구조가 제대로 동작한다.\n\n1. 구독 시작 통지(onSubscribe)는 구독에서 한 번만 발생\n2. 데이터 통지는 순차적으로 이뤄진다.\n3. null을 통지하지 않는다.\n4. Publisher는 처리 완료(onComplete) 혹은 에러(onError)를 통하여 종료한다.\n\n> [주의] 같은 인스턴스를 활용하여 구독(subscribe)를 할 경우, Publisher/Subscriber의 내부 상태를 초기화하지 않으면 의도하지 않은 결과로 이어질 수 있다. 왜냐하면, onComplete 혹은 onError의 통지가 이뤄진 이후 시점에는 Publisher는 처리가 끝마친 것으로 판단하기 때문이다.\n\n## RxJava,Kotlin에서 꼭 알아야 할 구조는?\n\n### 생산자/소비자/구독\n| ReactiveStream 지원 유/무  | 생산자  | 소비자  | 관계 |\n|---|---|---|---|\n| O  | Flowable  | Subscriber  | Subscription |\n| X  | Observable  | Observer  | Disposable |\n\n\n> 지원 유무의 가장 큰 차이점은 `배압(Backpressure)`의 적용 유무, 배압이 적용되어 있지 않기 때문에, 별도로 소비자측에서는 데이터를 요청하지 않음. 배압 외에는 처리 모델은 거의 똑같다.\n\n```puml\n@startuml\nactor 생산자 as A\nactor 소비자 as B\nparticipant 구독 as C\nautonumber\nB -> A: 구독(subscribe)\nA -> C: 구독 관계에 대한 참조 객체 생생(Subscription)\nA -> B: 데이터 통보 준비 완료(onSubscribe)\n\nloop 통보할 데이터가 없을 때까지\nB -> C: 데이터 요청(Subscription.request)\n\nalt 구독 해지 상태가 아닐 경우\n\tA -> A: 데이터 생산\n\tA -> B: 데이터 통보(onNext)\nend\n\n\nalt 소비자가 계속 데이터를 받을 경우\n\tB -> B: 통보받은 데이터를 처리\n\tB -> C: 데이터 요청(Subscription.request)\nelse 구독을 해지 하는 경우\n\tB -> C: 구독 해지 요청\nend\nend\n\nalt 데이터 통보를 모두 마쳤을 경우\nA -> B: 데이터 통보 완료 통보(onComplete)\nelse 처리 중 에러가 발생했을 경우\nA -> B: 에러 통보(onError)\nend\n@enduml\n```\n\n### 연산자\n`map`, `flatMap` 및 `filter` 등과 같이 기존 Stream을 다루거나 함수형 라이브러리에서 제공해주는 연산자를 비슷하게 제공해주고 있음. 연산자별로 생성되는 Flowable/Observable의 성격이 상이한 부분이 존재하며, 또한 실행순서에 영향을 주는 연산자도 존재함.\n\n#### 순차 처리의 예\n```kotlin\n    Flowable.just(1,2,3,4,5,6,7,8,9,10)\n        .filter { it % 2 == 0 }\n        .map { it * 100 }\n        .subscribe { println(\"${Thread.currentThread().name}, data: $it\") }\n```\n> [결과]\nmain, data: 200\nmain, data: 400\nmain, data: 600\nmain, data: 800\nmain, data: 1000\n\n#### 순차 처리가 안되는 예\n```kotlin\nFlowable.just(\"A\", \"B\", \"C\")\n\t.flatMap {\n\t\tFlowable.just(it).delay(1000L, TimeUnit.MILLISECONDS)\n\t}.subscribe {\n\t\tprintln(\"${Thread.currentThread().name}: $it\")\n\t}\n```\n> [결과]\nRxComputationThreadPool-3: C\nRxComputationThreadPool-1: A\nRxComputationThreadPool-1: B\n\n### 비동기 처리\n***생산자와 소비자는 별도의 지정이 없을 경우, 메인스레드 혹은 실행 스레드에서 순차 처리 됨.*** \n\n하지만 시간 관련 Flowable/Observable 생성자의 경우, 별도의 스레드에서 실행이 되는 경우도 있음. 비동기 처리를 지정해야 할 경우 `생산자 측(subscribeOn())`과 `소비자 측(observeOn())`에 `스레드 스캐줄러`를 지정하면 되며, 스캐쥴러(`Schedulers`)의 종류는 `io`, `computation` 등이 있다.\n\n\n### 외부 자원에 대한 참조는?\n생산자/소비자는 여러 스레드에서 실행이 될 수 있기 때문에, 공유 자원에 대해서 동기화 작업을 반드시 수행해줘야 한다. 이런 동기화를 피하는 가장 좋은 방법은 아래와 같다.\n- 순수 함수(함수형 인터페이스)의 사용\n  - 외부 자원 참조 X\n  - 함수 단위로 코드를 전개하여 처리 안정성을 확보\n  - 불변 객체의 사용, 큰 오버헤드가 존재하지 않으면 객체는 복사를 하여 사용하는 것이 좋다.\n\n> 여러 개의 생산자/소비자가 존재 할 경우는 `merge`등의 연산자를 통하여 해당 생산자/소비자를 실행하는 스레드가 공유 자원에 대해 동기화하여 접근 할 수 있도록 할 수 있다.\n\n#### 공유 자원에 대한 잘못된 접근의 예\n아래의 2개의 생산자/소비자의 구조에서 2개의 소비자 모두 변수 `num`에 접근하여 값을 수정하고 있는데, 이는 각각의 소비자에서 스레드에 대한 적절한 동기화 없이 접근하는 안티패턴의 가장 좋은 예라고 할 수 있다. \n```kotlin\nvar num = 0\nFlowable.range(1, 100_000)\n\t.subscribeOn(Schedulers.computation())\n\t.observeOn(Schedulers.computation())\n\t.subscribe(\n\t\t{ ++num },\n\t\t{ println(\"에러=$it\") },\n\t\t{ println(\"counter.get()= $num\") }\n\t)\n\nFlowable.range(1, 100_000)\n\t.subscribeOn(Schedulers.computation())\n\t.observeOn(Schedulers.computation())\n\t.subscribe(\n\t\t{ ++num },\n\t\t{ println(\"에러=$it\") },\n\t\t{ println(\"counter.get()= $num\") }\n\t)\n```\n\n#### merge 연산자를 사용한 예\n위에서 보았던 안티패턴을 Rx에서는 스레드에 대한 동기화 처리를 진행해주는 `merge` 연산자를 사용하여 해결이 가능하다. 여러 생산자에서 발행하는 데이터의 타임라인을 하나로 만들어주며, 발행하는 순서를 아래의 그림과 같이 시간순 혹은 실행순으로 만들 수 있다.\n> [요약] 여러 Observable의 출력을 결합하여 단일 Observable처럼 작동하도록 할 수 있다.\n\n![](http://reactivex.io/documentation/operators/images/merge.png)\n```kotlin\nvar num = 0\nval source1 = Flowable.range(1, 100_000)\n\t.subscribeOn(Schedulers.computation())\n\t.observeOn(Schedulers.computation())\n\n\nval source2 = Flowable.range(1, 100_000)\n\t.subscribeOn(Schedulers.computation())\n\t.observeOn(Schedulers.computation())\n\nFlowable\n.merge(source1, source2)\n.subscribe(\n\t{ ++num },\n\t{ println(\"에러=$it\") },\n\t{ println(\"counter.get()= $num\") }\n)\n```\n\n## Flowable vs Observable 어떤걸 써야 하는거지?\n### Flowable\n  - 대량 데이터를 처리 할 경우\n  - 네트워크 통신/파일 등 IO를 처리 할 경우\n### Observable\n  - GUI 이벤트\n  - 소량의 데이터를 처리 할 경우\n  - 자바의 Stream을 대신하여 사용할 경우\n\n대량의 데이터와 더불어 IO를 처리 해야 할 경우에는 `Flowable`을 사용하여 적절한 배압 정책을 적용하는 것이 유리하다. 반면에 GUI의 이벤트 처리 혹은 소량의 데이터를 처리 할 경우 배압이 없는 `Observable`을 사용하는 것이 유리하다고 한다. `Observable`은 배압 기능이 없는 만큼 `Flowable`에 비하여 오버헤드가 적은 것이 특징이다.\n\n> 배압 기능을 사용하면, 쏟아지는 데이터 대한 적절한 제어 뿐만 아니라 에러 처리도 할 수 있다. 물론, 다루는 데이터의 성격에 따라 달라질 수 있는 부분이지만 생산자와 소비자간의 처리 속도 차이에 따라 발생하는 데이터 유실에 대한 부분도 반드시 고려해서 배압 정책을 적용한 코드를 작성해야 한다.\n","slug":"Kotlin/Rx_Kotlin_1","published":1,"updated":"2021-08-02T12:05:46.957Z","_id":"ckrsup50n001dtjhv4ta97fnh","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"RxKotlin-1\"><a href=\"#RxKotlin-1\" class=\"headerlink\" title=\"RxKotlin #1\"></a>RxKotlin #1</h1><h1 id=\"Reactive-Programming\"><a href=\"#Reactive-Programming\" class=\"headerlink\" title=\"Reactive Programming\"></a>Reactive Programming</h1><ul>\n<li>데이터가 통지되면 이에 반응하여 데이터를 처리 하는 방식의 프로그래밍 모델. 즉, 프로그램에서 필요한 데이터를 직접 가지고와서 처리하는 방식(pull)이 아닌 데이터를 받은 시점에 처리하는 방식(push). </li>\n<li>이를 구현하기 위해 데이터를 만들어내는 <code>생산자</code>와 이를 소비하게 되는 <code>소비자</code>로 역할을 나눠 처리하는 프로세스를 가지게 된다.</li>\n<li>소비자와 생산자의 역할이 분리되어 있으므로, 생산자는 데이터를 생산하여 전달하는 역할까지 수행하며, 소비자는 데이터를 받아서 처리하는 역할만을 수행한다. 즉, 생산자와 소비자는 각각의 역할만 충실하게 수행하면 되고, 반대편에서 어떤 처리를 하는지에 대해서는 관심 밖의 일이다.<blockquote>\n<p>이처럼, 역할이 분리됨에 따라 쉽게 비동기 구현이 가능</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"Reactive-Stream\"><a href=\"#Reactive-Stream\" class=\"headerlink\" title=\"Reactive Stream\"></a>Reactive Stream</h1><ul>\n<li><code>데이터 스트림</code>을 <code>비동기</code>로 처리 할 수 있는 공통 메커니즘/인터페이스.</li>\n<li>Reactive Stream은 인터페이스만 제공하고 상세 구현은 각 라이브러리/프레임워크에서 책임을 가져간다.<h2 id=\"구현체\"><a href=\"#구현체\" class=\"headerlink\" title=\"구현체\"></a>구현체</h2></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Reactive_Streams#cite_note-17\">위키피디아 참고</a><br><img src=\"https://cdn-images-1.medium.com/max/1600/1*70ZfCOn5Qadc8nZ_k_JhKQ.png\"></li>\n</ul>\n<h2 id=\"데이터스트림\"><a href=\"#데이터스트림\" class=\"headerlink\" title=\"데이터스트림\"></a>데이터스트림</h2><ul>\n<li>Collection과 같이 이미 생성한 데이터를 포함하여 <code>앞으로 생성할 데이터</code> 혹은 <code>발생 가능성이 있는 데이터</code>까지 포함하는 개념. </li>\n<li>키보드 혹은 마우스 같은 UI상에서의 이벤트가 발생 했을 때, 해당 이벤트가 발생하는 시점의 데이터까지 포함하는 개념으로 볼 수 있다.</li>\n<li>데이터스트림의 소스 종류들은?<ul>\n<li>SQL 쿼리들</li>\n<li>GUI 이벤트</li>\n<li>HTTP 기반 서비스</li>\n<li>TCP 소켓</li>\n<li>파일 시스템</li>\n<li>Kafka같은 메시지 큐들</li>\n<li>기타 등등</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"구성\"><a href=\"#구성\" class=\"headerlink\" title=\"구성\"></a>구성</h2><ul>\n<li>Reactive Stream은 Publisher와 Subscriber로 구성되며, Subscriber가 Publisher를 구독하면 Publisher가 통보하는 데이터를 받을 수 있음<img src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U2NyaXB0VHlwZT0iYXBwbGljYXRpb24vZWNtYXNjcmlwdCIgY29udGVudFN0eWxlVHlwZT0idGV4dC9jc3MiIGhlaWdodD0iNTI2cHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDo0NjNweDtoZWlnaHQ6NTI2cHg7YmFja2dyb3VuZDojRkZGRkZGOyIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgNDYzIDUyNiIgd2lkdGg9IjQ2M3B4IiB6b29tQW5kUGFuPSJtYWduaWZ5Ij48ZGVmcz48ZmlsdGVyIGhlaWdodD0iMzAwJSIgaWQ9ImYxYnB4YWx3Z2g5d2x4IiB3aWR0aD0iMzAwJSIgeD0iLTEiIHk9Ii0xIj48ZmVHYXVzc2lhbkJsdXIgcmVzdWx0PSJibHVyT3V0IiBzdGREZXZpYXRpb249IjIuMCIvPjxmZUNvbG9yTWF0cml4IGluPSJibHVyT3V0IiByZXN1bHQ9ImJsdXJPdXQyIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgLjQgMCIvPjxmZU9mZnNldCBkeD0iNC4wIiBkeT0iNC4wIiBpbj0iYmx1ck91dDIiIHJlc3VsdD0iYmx1ck91dDMiLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJibHVyT3V0MyIgbW9kZT0ibm9ybWFsIi8+PC9maWx0ZXI+PC9kZWZzPjxnPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGZpbHRlcj0idXJsKCNmMWJweGFsd2doOXdseCkiIGhlaWdodD0iOTAuMjAzMSIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjA7IiB3aWR0aD0iMzIyIiB4PSIxMCIgeT0iMzM1LjIyNjYiLz48cmVjdCBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjQzLjkzNzUiIHN0eWxlPSJzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MS4wOyIgd2lkdGg9IjMyMiIgeD0iMTAiIHk9IjM4MS40OTIyIi8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9IjQ0IiB4Mj0iNDQiIHkxPSI4OC4yOTY5IiB5Mj0iNDQyLjQyOTciLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjUuMCw1LjA7IiB4MT0iMjk4IiB4Mj0iMjk4IiB5MT0iODguMjk2OSIgeTI9IjQ0Mi40Mjk3Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDIiIHg9IjIwIiB5PSI4NC45OTUxIj7sg53sgrDsnpA8L3RleHQ+PGVsbGlwc2UgY3g9IjQ0IiBjeT0iMTUiIGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMWJweGFsd2doOXdseCkiIHJ4PSI4IiByeT0iOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHBhdGggZD0iTTQ0LDIzIEw0NCw1MCBNMzEsMzEgTDU3LDMxIE00NCw1MCBMMzEsNjUgTTQ0LDUwIEw1Nyw2NSAiIGZpbGw9Im5vbmUiIGZpbHRlcj0idXJsKCNmMWJweGFsd2doOXdseCkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6Mi4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQyIiB4PSIyMCIgeT0iNDU0LjQyNDgiPuyDneyCsOyekDwvdGV4dD48ZWxsaXBzZSBjeD0iNDQiIGN5PSI0NjcuNzI2NiIgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxYnB4YWx3Z2g5d2x4KSIgcng9IjgiIHJ5PSI4IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48cGF0aCBkPSJNNDQsNDc1LjcyNjYgTDQ0LDUwMi43MjY2IE0zMSw0ODMuNzI2NiBMNTcsNDgzLjcyNjYgTTQ0LDUwMi43MjY2IEwzMSw1MTcuNzI2NiBNNDQsNTAyLjcyNjYgTDU3LDUxNy43MjY2ICIgZmlsbD0ibm9uZSIgZmlsdGVyPSJ1cmwoI2YxYnB4YWx3Z2g5d2x4KSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDIiIHg9IjI3NCIgeT0iODQuOTk1MSI+7IaM67mE7J6QPC90ZXh0PjxlbGxpcHNlIGN4PSIyOTgiIGN5PSIxNSIgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxYnB4YWx3Z2g5d2x4KSIgcng9IjgiIHJ5PSI4IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48cGF0aCBkPSJNMjk4LDIzIEwyOTgsNTAgTTI4NSwzMSBMMzExLDMxIE0yOTgsNTAgTDI4NSw2NSBNMjk4LDUwIEwzMTEsNjUgIiBmaWxsPSJub25lIiBmaWx0ZXI9InVybCgjZjFicHhhbHdnaDl3bHgpIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI0MiIgeD0iMjc0IiB5PSI0NTQuNDI0OCI+7IaM67mE7J6QPC90ZXh0PjxlbGxpcHNlIGN4PSIyOTgiIGN5PSI0NjcuNzI2NiIgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxYnB4YWx3Z2g5d2x4KSIgcng9IjgiIHJ5PSI4IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48cGF0aCBkPSJNMjk4LDQ3NS43MjY2IEwyOTgsNTAyLjcyNjYgTTI4NSw0ODMuNzI2NiBMMzExLDQ4My43MjY2IE0yOTgsNTAyLjcyNjYgTDI4NSw1MTcuNzI2NiBNMjk4LDUwMi43MjY2IEwzMTEsNTE3LjcyNjYgIiBmaWxsPSJub25lIiBmaWx0ZXI9InVybCgjZjFicHhhbHdnaDl3bHgpIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjU1LDExNS40Mjk3LDQ1LDExOS40Mjk3LDU1LDEyMy40Mjk3LDUxLDExOS40Mjk3IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI0OSIgeDI9IjI5NyIgeTE9IjExOS40Mjk3IiB5Mj0iMTE5LjQyOTciLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iNjEiIHk9IjExNC4zNjM4Ij4xPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk3IiB4PSI3NCIgeT0iMTE0LjM2MzgiPuq1rOuPhShzdWJzY3JpYmUpPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMjg2LDE0NC41NjI1LDI5NiwxNDguNTYyNSwyODYsMTUyLjU2MjUsMjkwLDE0OC41NjI1IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI0NCIgeDI9IjI5MiIgeTE9IjE0OC41NjI1IiB5Mj0iMTQ4LjU2MjUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iNTEiIHk9IjE0My40OTY2Ij4yPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIxNyIgeD0iNjQiIHk9IjE0My40OTY2Ij7rjbDsnbTthLAg7Ya167O0IOykgOu5hCDsmYTro4wob25TdWJzY3JpYmUpPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNTUsMTczLjY5NTMsNDUsMTc3LjY5NTMsNTUsMTgxLjY5NTMsNTEsMTc3LjY5NTMiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjQ5IiB4Mj0iMjk3IiB5MT0iMTc3LjY5NTMiIHkyPSIxNzcuNjk1MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI4IiB4PSI2MSIgeT0iMTcyLjYyOTQiPjM8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjEwIiB4PSI3MyIgeT0iMTcyLjYyOTQiPuuNsOydtO2EsCDsmpTssq0oU3Vic2NyaXB0aW9uLnJlcXVlc3QpPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjQ0IiB4Mj0iODYiIHkxPSIyMDYuODI4MSIgeTI9IjIwNi44MjgxIi8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iODYiIHgyPSI4NiIgeTE9IjIwNi44MjgxIiB5Mj0iMjE5LjgyODEiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI0NSIgeDI9Ijg2IiB5MT0iMjE5LjgyODEiIHkyPSIyMTkuODI4MSIvPjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNTUsMjE1LjgyODEsNDUsMjE5LjgyODEsNTUsMjIzLjgyODEsNTEsMjE5LjgyODEiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5IiB4PSI1MSIgeT0iMjAxLjc2MjIiPjQ8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNjkiIHg9IjY0IiB5PSIyMDEuNzYyMiI+642w7J207YSwIOyDneyCsDwvdGV4dD48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjI4NiwyNDQuOTYwOSwyOTYsMjQ4Ljk2MDksMjg2LDI1Mi45NjA5LDI5MCwyNDguOTYwOSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iNDQiIHgyPSIyOTIiIHkxPSIyNDguOTYwOSIgeTI9IjI0OC45NjA5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkiIHg9IjUxIiB5PSIyNDMuODk1Ij41PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyNSIgeD0iNjQiIHk9IjI0My44OTUiPuuNsOydtO2EsCDthrXrs7Qob25OZXh0KTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIyOTgiIHgyPSIzNDAiIHkxPSIyNzguMDkzOCIgeTI9IjI3OC4wOTM4Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMzQwIiB4Mj0iMzQwIiB5MT0iMjc4LjA5MzgiIHkyPSIyOTEuMDkzOCIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjI5OSIgeDI9IjM0MCIgeTE9IjI5MS4wOTM4IiB5Mj0iMjkxLjA5MzgiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjMwOSwyODcuMDkzOCwyOTksMjkxLjA5MzgsMzA5LDI5NS4wOTM4LDMwNSwyOTEuMDkzOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkiIHg9IjMwNSIgeT0iMjczLjAyNzgiPjY8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTM4IiB4PSIzMTgiIHk9IjI3My4wMjc4Ij7thrXrs7TrsJvsnYAg642w7J207YSw66W8IOyymOumrDwvdGV4dD48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjU1LDMxNi4yMjY2LDQ1LDMyMC4yMjY2LDU1LDMyNC4yMjY2LDUxLDMyMC4yMjY2IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI0OSIgeDI9IjI5NyIgeTE9IjMyMC4yMjY2IiB5Mj0iMzIwLjIyNjYiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iNjEiIHk9IjMxNS4xNjA2Ij43PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIxMCIgeD0iNzQiIHk9IjMxNS4xNjA2Ij7rjbDsnbTthLAg7JqU7LKtKFN1YnNjcmlwdGlvbi5yZXF1ZXN0KTwvdGV4dD48cGF0aCBkPSJNMTAsMzM1LjIyNjYgTDc2LDMzNS4yMjY2IEw3NiwzNDIuMjI2NiBMNjYsMzUyLjIyNjYgTDEwLDM1Mi4yMjY2IEwxMCwzMzUuMjI2NiAiIGZpbGw9IiNFRUVFRUUiIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9Im5vbmUiIGhlaWdodD0iOTAuMjAzMSIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjA7IiB3aWR0aD0iMzIyIiB4PSIxMCIgeT0iMzM1LjIyNjYiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjEiIHg9IjI1IiB5PSIzNDguMjkzNSI+YWx0PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjExIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNjkiIHg9IjkxIiB5PSIzNDcuNDM3Ij5b642w7J207YSwIO2GteuztOulvCDrqqjrkZAg66eI7LOk7J2EIOqyveyasF08L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIyODYsMzY5LjQ5MjIsMjk2LDM3My40OTIyLDI4NiwzNzcuNDkyMiwyOTAsMzczLjQ5MjIiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjQ0IiB4Mj0iMjkyIiB5MT0iMzczLjQ5MjIiIHkyPSIzNzMuNDkyMiIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5IiB4PSI1MSIgeT0iMzY4LjQyNjMiPjg8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjE3IiB4PSI2NCIgeT0iMzY4LjQyNjMiPuuNsOydtO2EsCDthrXrs7Qg7JmE66OMIO2GteuztChvbkNvbXBsZXRlKTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjIuMCwyLjA7IiB4MT0iMTAiIHgyPSIzMzIiIHkxPSIzODIuNDkyMiIgeTI9IjM4Mi40OTIyIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTEiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE1OCIgeD0iMTUiIHk9IjM5Mi43MDI2Ij5b7LKY66asIOykkSDsl5Drn6zqsIAg67Cc7IOd7ZaI7J2EIOqyveyasF08L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIyODYsNDEzLjQyOTcsMjk2LDQxNy40Mjk3LDI4Niw0MjEuNDI5NywyOTAsNDE3LjQyOTciIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjQ0IiB4Mj0iMjkyIiB5MT0iNDE3LjQyOTciIHkyPSI0MTcuNDI5NyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5IiB4PSI1MSIgeT0iNDEyLjM2MzgiPjk8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTEzIiB4PSI2NCIgeT0iNDEyLjM2MzgiPuyXkOufrCDthrXrs7Qob25FcnJvcik8L3RleHQ+PCEtLU1ENT1bMGZjODcxZTVhYjQxNjczZmU0MDFhNmMxNTcyYjhlNjVdCkBzdGFydHVtbA0KYWN0b3Ig7IOd7IKw7J6QIGFzIEENCmFjdG9yIOyGjOu5hOyekCBhcyBCDQphdXRvbnVtYmVyDQpCIC0+IEE6IOq1rOuPhShzdWJzY3JpYmUpDQpBIC0+IEI6IOuNsOydtO2EsCDthrXrs7Qg7KSA67mEIOyZhOujjChvblN1YnNjcmliZSkNCkIgLT4gQTog642w7J207YSwIOyalOyyrShTdWJzY3JpcHRpb24ucmVxdWVzdCkNCkEgLT4gQTog642w7J207YSwIOyDneyCsA0KQSAtPiBCOiDrjbDsnbTthLAg7Ya167O0KG9uTmV4dCkNCkIgLT4gQjog7Ya167O067Cb7J2AIOuNsOydtO2EsOulvCDsspjrpqwNCkIgLT4gQTog642w7J207YSwIOyalOyyrShTdWJzY3JpcHRpb24ucmVxdWVzdCkNCmFsdCDrjbDsnbTthLAg7Ya167O066W8IOuqqOuRkCDrp4jss6TsnYQg6rK97JqwDQpBIC0+IEI6IOuNsOydtO2EsCDthrXrs7Qg7JmE66OMIO2GteuztChvbkNvbXBsZXRlKQ0KZWxzZSDsspjrpqwg7KSRIOyXkOufrOqwgCDrsJzsg53tlojsnYQg6rK97JqwDQpBIC0+IEI6IOyXkOufrCDthrXrs7Qob25FcnJvcikNCmVuZA0KQGVuZHVtbA0KClBsYW50VU1MIHZlcnNpb24gMS4yMDIxLjEwYmV0YTIoVW5rbm93biBjb21waWxlIHRpbWUpCihHUEwgc291cmNlIGRpc3RyaWJ1dGlvbikKSmF2YSBSdW50aW1lOiBKYXZhKFRNKSBTRSBSdW50aW1lIEVudmlyb25tZW50CkpWTTogSmF2YSBIb3RTcG90KFRNKSA2NC1CaXQgU2VydmVyIFZNCkRlZmF1bHQgRW5jb2Rpbmc6IFVURi04Ckxhbmd1YWdlOiBlbgpDb3VudHJ5OiBVUwotLT48L2c+PC9zdmc+'></li>\n<li>구독(subscribe)가 발생하면 이에 대한 Subscription이 생성된다.</li>\n<li>Subscriber가 Publisher를 구독하지 않으면 이후 단계는 진행되지 않는다.</li>\n<li>onComplete, onError와 같이, 확정 Action이 발생하면 소비자에게 통보한다.</li>\n<li>Subscriber는 Publisher에게 받을 데이터 개수를 요청 할 수 있으며, 요청 받은 Publisher는 다시 데이터를 생산하여 Subscriber에게 전달(onNext)한다.</li>\n<li>받을 데이터 개수를 요청하는 것은 생산자측의 처리 속도와 소비자측의 처리 속도가 다를 수 있기 때문에, 이를 제어 할 수 있는 적절한 수단이 필요하기 때문</li>\n</ul>\n<h2 id=\"표준-인터페이스\"><a href=\"#표준-인터페이스\" class=\"headerlink\" title=\"표준 인터페이스\"></a>표준 인터페이스</h2><table>\n<thead>\n<tr>\n<th>인터페이스</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Publisher</td>\n<td>데이터 생성/통보</td>\n</tr>\n<tr>\n<td>Subscriber</td>\n<td>데이터 처리</td>\n</tr>\n<tr>\n<td>Subscription</td>\n<td>데이터 요청/ 구독 해지 가능</td>\n</tr>\n<tr>\n<td>Processor</td>\n<td>Publisher &amp; Subscriber의 역할을 모두 가지고 있음</td>\n</tr>\n</tbody></table>\n<p>위 표준 인터페이스를 보면 알 수 있듯이, 분명하게 <code>역할 분리</code>가 되어 있음을 알 수 있다. 이는 곧 처리 단위 별로 개별 책임을 가져 갈 수 있음을 뜻함.</p>\n<h2 id=\"규칙\"><a href=\"#규칙\" class=\"headerlink\" title=\"규칙\"></a>규칙</h2><p>Reactive Stream은 인터페이스를 통하여 데이터를 통지하는 구조이며, Reactive Stream에서 정해놓은 규약을 충분하게 지켜야 구조가 제대로 동작한다.</p>\n<ol>\n<li>구독 시작 통지(onSubscribe)는 구독에서 한 번만 발생</li>\n<li>데이터 통지는 순차적으로 이뤄진다.</li>\n<li>null을 통지하지 않는다.</li>\n<li>Publisher는 처리 완료(onComplete) 혹은 에러(onError)를 통하여 종료한다.</li>\n</ol>\n<blockquote>\n<p>[주의] 같은 인스턴스를 활용하여 구독(subscribe)를 할 경우, Publisher/Subscriber의 내부 상태를 초기화하지 않으면 의도하지 않은 결과로 이어질 수 있다. 왜냐하면, onComplete 혹은 onError의 통지가 이뤄진 이후 시점에는 Publisher는 처리가 끝마친 것으로 판단하기 때문이다.</p>\n</blockquote>\n<h2 id=\"RxJava-Kotlin에서-꼭-알아야-할-구조는\"><a href=\"#RxJava-Kotlin에서-꼭-알아야-할-구조는\" class=\"headerlink\" title=\"RxJava,Kotlin에서 꼭 알아야 할 구조는?\"></a>RxJava,Kotlin에서 꼭 알아야 할 구조는?</h2><h3 id=\"생산자-소비자-구독\"><a href=\"#생산자-소비자-구독\" class=\"headerlink\" title=\"생산자/소비자/구독\"></a>생산자/소비자/구독</h3><table>\n<thead>\n<tr>\n<th>ReactiveStream 지원 유/무</th>\n<th>생산자</th>\n<th>소비자</th>\n<th>관계</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>O</td>\n<td>Flowable</td>\n<td>Subscriber</td>\n<td>Subscription</td>\n</tr>\n<tr>\n<td>X</td>\n<td>Observable</td>\n<td>Observer</td>\n<td>Disposable</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>지원 유무의 가장 큰 차이점은 <code>배압(Backpressure)</code>의 적용 유무, 배압이 적용되어 있지 않기 때문에, 별도로 소비자측에서는 데이터를 요청하지 않음. 배압 외에는 처리 모델은 거의 똑같다.</p>\n</blockquote>\n<img src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U2NyaXB0VHlwZT0iYXBwbGljYXRpb24vZWNtYXNjcmlwdCIgY29udGVudFN0eWxlVHlwZT0idGV4dC9jc3MiIGhlaWdodD0iNjkzcHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDo2MjJweDtoZWlnaHQ6NjkzcHg7YmFja2dyb3VuZDojRkZGRkZGOyIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgNjIyIDY5MyIgd2lkdGg9IjYyMnB4IiB6b29tQW5kUGFuPSJtYWduaWZ5Ij48ZGVmcz48ZmlsdGVyIGhlaWdodD0iMzAwJSIgaWQ9ImYxdDN3ODNkN3lnZ2JjIiB3aWR0aD0iMzAwJSIgeD0iLTEiIHk9Ii0xIj48ZmVHYXVzc2lhbkJsdXIgcmVzdWx0PSJibHVyT3V0IiBzdGREZXZpYXRpb249IjIuMCIvPjxmZUNvbG9yTWF0cml4IGluPSJibHVyT3V0IiByZXN1bHQ9ImJsdXJPdXQyIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgLjQgMCIvPjxmZU9mZnNldCBkeD0iNC4wIiBkeT0iNC4wIiBpbj0iYmx1ck91dDIiIHJlc3VsdD0iYmx1ck91dDMiLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJibHVyT3V0MyIgbW9kZT0ibm9ybWFsIi8+PC9maWx0ZXI+PC9kZWZzPjxnPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGZpbHRlcj0idXJsKCNmMXQzdzgzZDd5Z2diYykiIGhlaWdodD0iMjk1IiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjIuMDsiIHdpZHRoPSI1OTgiIHg9IjEwIiB5PSIxOTIuNjk1MyIvPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGZpbHRlcj0idXJsKCNmMXQzdzgzZDd5Z2diYykiIGhlaWdodD0iODguMzk4NCIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjA7IiB3aWR0aD0iMzMyIiB4PSIyMCIgeT0iMjQ1Ljk2MDkiLz48cmVjdCBmaWxsPSIjRkZGRkZGIiBmaWx0ZXI9InVybCgjZjF0M3c4M2Q3eWdnYmMpIiBoZWlnaHQ9IjEzMi4zMzU5IiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjIuMDsiIHdpZHRoPSIzMTQiIHg9IjI4NCIgeT0iMzQ4LjM1OTQiLz48cmVjdCBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjQzLjkzNzUiIHN0eWxlPSJzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MS4wOyIgd2lkdGg9IjMxNCIgeD0iMjg0IiB5PSI0MzYuNzU3OCIvPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGZpbHRlcj0idXJsKCNmMXQzdzgzZDd5Z2diYykiIGhlaWdodD0iOTAuMjAzMSIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjA7IiB3aWR0aD0iMzMyIiB4PSIyMCIgeT0iNTAxLjY5NTMiLz48cmVjdCBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjQzLjkzNzUiIHN0eWxlPSJzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MS4wOyIgd2lkdGg9IjMzMiIgeD0iMjAiIHk9IjU0Ny45NjA5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9IjU0IiB4Mj0iNTQiIHkxPSI4OC4yOTY5IiB5Mj0iNjA4Ljg5ODQiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjUuMCw1LjA7IiB4MT0iMzE4IiB4Mj0iMzE4IiB5MT0iODguMjk2OSIgeTI9IjYwOC44OTg0Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9IjU2NSIgeDI9IjU2NSIgeTE9Ijg4LjI5NjkiIHkyPSI2MDguODk4NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQyIiB4PSIzMCIgeT0iODQuOTk1MSI+7IOd7IKw7J6QPC90ZXh0PjxlbGxpcHNlIGN4PSI1NCIgY3k9IjE1IiBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjF0M3c4M2Q3eWdnYmMpIiByeD0iOCIgcnk9IjgiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6Mi4wOyIvPjxwYXRoIGQ9Ik01NCwyMyBMNTQsNTAgTTQxLDMxIEw2NywzMSBNNTQsNTAgTDQxLDY1IE01NCw1MCBMNjcsNjUgIiBmaWxsPSJub25lIiBmaWx0ZXI9InVybCgjZjF0M3c4M2Q3eWdnYmMpIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI0MiIgeD0iMzAiIHk9IjYyMC44OTM2Ij7sg53sgrDsnpA8L3RleHQ+PGVsbGlwc2UgY3g9IjU0IiBjeT0iNjM0LjE5NTMiIGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMXQzdzgzZDd5Z2diYykiIHJ4PSI4IiByeT0iOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHBhdGggZD0iTTU0LDY0Mi4xOTUzIEw1NCw2NjkuMTk1MyBNNDEsNjUwLjE5NTMgTDY3LDY1MC4xOTUzIE01NCw2NjkuMTk1MyBMNDEsNjg0LjE5NTMgTTU0LDY2OS4xOTUzIEw2Nyw2ODQuMTk1MyAiIGZpbGw9Im5vbmUiIGZpbHRlcj0idXJsKCNmMXQzdzgzZDd5Z2diYykiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6Mi4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQyIiB4PSIyOTQiIHk9Ijg0Ljk5NTEiPuyGjOu5hOyekDwvdGV4dD48ZWxsaXBzZSBjeD0iMzE4IiBjeT0iMTUiIGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMXQzdzgzZDd5Z2diYykiIHJ4PSI4IiByeT0iOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHBhdGggZD0iTTMxOCwyMyBMMzE4LDUwIE0zMDUsMzEgTDMzMSwzMSBNMzE4LDUwIEwzMDUsNjUgTTMxOCw1MCBMMzMxLDY1ICIgZmlsbD0ibm9uZSIgZmlsdGVyPSJ1cmwoI2YxdDN3ODNkN3lnZ2JjKSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDIiIHg9IjI5NCIgeT0iNjIwLjg5MzYiPuyGjOu5hOyekDwvdGV4dD48ZWxsaXBzZSBjeD0iMzE4IiBjeT0iNjM0LjE5NTMiIGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMXQzdzgzZDd5Z2diYykiIHJ4PSI4IiByeT0iOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHBhdGggZD0iTTMxOCw2NDIuMTk1MyBMMzE4LDY2OS4xOTUzIE0zMDUsNjUwLjE5NTMgTDMzMSw2NTAuMTk1MyBNMzE4LDY2OS4xOTUzIEwzMDUsNjg0LjE5NTMgTTMxOCw2NjkuMTk1MyBMMzMxLDY4NC4xOTUzICIgZmlsbD0ibm9uZSIgZmlsdGVyPSJ1cmwoI2YxdDN3ODNkN3lnZ2JjKSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxdDN3ODNkN3lnZ2JjKSIgaGVpZ2h0PSIzMC4yOTY5IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI0MiIgeD0iNTQyIiB5PSI1MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI4IiB4PSI1NDkiIHk9IjcyLjk5NTEiPuq1rOuPhTwvdGV4dD48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjF0M3c4M2Q3eWdnYmMpIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjQyIiB4PSI1NDIiIHk9IjYwNy44OTg0Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjgiIHg9IjU0OSIgeT0iNjI3Ljg5MzYiPuq1rOuPhTwvdGV4dD48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjY1LDExNS40Mjk3LDU1LDExOS40Mjk3LDY1LDEyMy40Mjk3LDYxLDExOS40Mjk3IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI1OSIgeDI9IjMxNyIgeTE9IjExOS40Mjk3IiB5Mj0iMTE5LjQyOTciLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iNzEiIHk9IjExNC4zNjM4Ij4xPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk3IiB4PSI4NCIgeT0iMTE0LjM2MzgiPuq1rOuPhShzdWJzY3JpYmUpPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNTUzLDE0NC41NjI1LDU2MywxNDguNTYyNSw1NTMsMTUyLjU2MjUsNTU3LDE0OC41NjI1IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI1NCIgeDI9IjU1OSIgeTE9IjE0OC41NjI1IiB5Mj0iMTQ4LjU2MjUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iNjEiIHk9IjE0My40OTY2Ij4yPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI3NyIgeD0iNzQiIHk9IjE0My40OTY2Ij7qtazrj4Ug6rSA6rOE7JeQIOuMgO2VnCDssLjsobAg6rCd7LK0IOyDneyDnShTdWJzY3JpcHRpb24pPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMzA2LDE3My42OTUzLDMxNiwxNzcuNjk1MywzMDYsMTgxLjY5NTMsMzEwLDE3Ny42OTUzIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI1NCIgeDI9IjMxMiIgeTE9IjE3Ny42OTUzIiB5Mj0iMTc3LjY5NTMiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOCIgeD0iNjEiIHk9IjE3Mi42Mjk0Ij4zPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIxNyIgeD0iNzMiIHk9IjE3Mi42Mjk0Ij7rjbDsnbTthLAg7Ya167O0IOykgOu5hCDsmYTro4wob25TdWJzY3JpYmUpPC90ZXh0PjxwYXRoIGQ9Ik0xMCwxOTIuNjk1MyBMODgsMTkyLjY5NTMgTDg4LDE5OS42OTUzIEw3OCwyMDkuNjk1MyBMMTAsMjA5LjY5NTMgTDEwLDE5Mi42OTUzICIgZmlsbD0iI0VFRUVFRSIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0ibm9uZSIgaGVpZ2h0PSIyOTUiIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6Mi4wOyIgd2lkdGg9IjU5OCIgeD0iMTAiIHk9IjE5Mi42OTUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjMzIiB4PSIyNSIgeT0iMjA1Ljc2MjIiPmxvb3A8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTEiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE1NCIgeD0iMTAzIiB5PSIyMDQuOTA1OCI+W+2GteuztO2VoCDrjbDsnbTthLDqsIAg7JeG7J2EIOuVjOq5jOyngF08L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSI1NTMsMjI2Ljk2MDksNTYzLDIzMC45NjA5LDU1MywyMzQuOTYwOSw1NTcsMjMwLjk2MDkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjMxOCIgeDI9IjU1OSIgeTE9IjIzMC45NjA5IiB5Mj0iMjMwLjk2MDkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iMzI1IiB5PSIyMjUuODk1Ij40PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIxMCIgeD0iMzM4IiB5PSIyMjUuODk1Ij7rjbDsnbTthLAg7JqU7LKtKFN1YnNjcmlwdGlvbi5yZXF1ZXN0KTwvdGV4dD48cGF0aCBkPSJNMjAsMjQ1Ljk2MDkgTDg2LDI0NS45NjA5IEw4NiwyNTIuOTYwOSBMNzYsMjYyLjk2MDkgTDIwLDI2Mi45NjA5IEwyMCwyNDUuOTYwOSAiIGZpbGw9IiNFRUVFRUUiIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9Im5vbmUiIGhlaWdodD0iODguMzk4NCIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjA7IiB3aWR0aD0iMzMyIiB4PSIyMCIgeT0iMjQ1Ljk2MDkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjEiIHg9IjM1IiB5PSIyNTkuMDI3OCI+YWx0PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjExIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNDciIHg9IjEwMSIgeT0iMjU4LjE3MTQiPlvqtazrj4Ug7ZW07KeAIOyDge2DnOqwgCDslYTri5Ag6rK97JqwXTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI1NCIgeDI9Ijk2IiB5MT0iMjg0LjIyNjYiIHkyPSIyODQuMjI2NiIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9Ijk2IiB4Mj0iOTYiIHkxPSIyODQuMjI2NiIgeTI9IjI5Ny4yMjY2Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iNTUiIHgyPSI5NiIgeTE9IjI5Ny4yMjY2IiB5Mj0iMjk3LjIyNjYiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjY1LDI5My4yMjY2LDU1LDI5Ny4yMjY2LDY1LDMwMS4yMjY2LDYxLDI5Ny4yMjY2IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iNjEiIHk9IjI3OS4xNjA2Ij41PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5IiB4PSI3NCIgeT0iMjc5LjE2MDYiPuuNsOydtO2EsCDsg53sgrA8L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIzMDYsMzIyLjM1OTQsMzE2LDMyNi4zNTk0LDMwNiwzMzAuMzU5NCwzMTAsMzI2LjM1OTQiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjU0IiB4Mj0iMzEyIiB5MT0iMzI2LjM1OTQiIHkyPSIzMjYuMzU5NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5IiB4PSI2MSIgeT0iMzIxLjI5MzUiPjY8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTI1IiB4PSI3NCIgeT0iMzIxLjI5MzUiPuuNsOydtO2EsCDthrXrs7Qob25OZXh0KTwvdGV4dD48cGF0aCBkPSJNMjg0LDM0OC4zNTk0IEwzNTAsMzQ4LjM1OTQgTDM1MCwzNTUuMzU5NCBMMzQwLDM2NS4zNTk0IEwyODQsMzY1LjM1OTQgTDI4NCwzNDguMzU5NCAiIGZpbGw9IiNFRUVFRUUiIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9Im5vbmUiIGhlaWdodD0iMTMyLjMzNTkiIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6Mi4wOyIgd2lkdGg9IjMxNCIgeD0iMjg0IiB5PSIzNDguMzU5NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMSIgeD0iMjk5IiB5PSIzNjEuNDI2MyI+YWx0PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjExIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxODAiIHg9IjM2NSIgeT0iMzYwLjU2OTgiPlvshozruYTsnpDqsIAg6rOE7IaNIOuNsOydtO2EsOulvCDrsJvsnYQg6rK97JqwXTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIzMTgiIHgyPSIzNjAiIHkxPSIzODYuNjI1IiB5Mj0iMzg2LjYyNSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjM2MCIgeDI9IjM2MCIgeTE9IjM4Ni42MjUiIHkyPSIzOTkuNjI1Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMzE5IiB4Mj0iMzYwIiB5MT0iMzk5LjYyNSIgeTI9IjM5OS42MjUiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjMyOSwzOTUuNjI1LDMxOSwzOTkuNjI1LDMyOSw0MDMuNjI1LDMyNSwzOTkuNjI1IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iMzI1IiB5PSIzODEuNTU5MSI+NzwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMzgiIHg9IjMzOCIgeT0iMzgxLjU1OTEiPu2GteuztOuwm+ydgCDrjbDsnbTthLDrpbwg7LKY66asPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNTUzLDQyNC43NTc4LDU2Myw0MjguNzU3OCw1NTMsNDMyLjc1NzgsNTU3LDQyOC43NTc4IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIzMTgiIHgyPSI1NTkiIHkxPSI0MjguNzU3OCIgeTI9IjQyOC43NTc4Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkiIHg9IjMyNSIgeT0iNDIzLjY5MTkiPjg8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjEwIiB4PSIzMzgiIHk9IjQyMy42OTE5Ij7rjbDsnbTthLAg7JqU7LKtKFN1YnNjcmlwdGlvbi5yZXF1ZXN0KTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjIuMCwyLjA7IiB4MT0iMjg0IiB4Mj0iNTk4IiB5MT0iNDM3Ljc1NzgiIHkyPSI0MzcuNzU3OCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjExIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMjEiIHg9IjI4OSIgeT0iNDQ3Ljk2ODMiPlvqtazrj4XsnYQg7ZW07KeAIO2VmOuKlCDqsr3smrBdPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNTUzLDQ2OC42OTUzLDU2Myw0NzIuNjk1Myw1NTMsNDc2LjY5NTMsNTU3LDQ3Mi42OTUzIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIzMTgiIHgyPSI1NTkiIHkxPSI0NzIuNjk1MyIgeTI9IjQ3Mi42OTUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkiIHg9IjMyNSIgeT0iNDY3LjYyOTQiPjk8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODYiIHg9IjMzOCIgeT0iNDY3LjYyOTQiPuq1rOuPhSDtlbTsp4Ag7JqU7LKtPC90ZXh0PjxwYXRoIGQ9Ik0yMCw1MDEuNjk1MyBMODYsNTAxLjY5NTMgTDg2LDUwOC42OTUzIEw3Niw1MTguNjk1MyBMMjAsNTE4LjY5NTMgTDIwLDUwMS42OTUzICIgZmlsbD0iI0VFRUVFRSIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0ibm9uZSIgaGVpZ2h0PSI5MC4yMDMxIiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjIuMDsiIHdpZHRoPSIzMzIiIHg9IjIwIiB5PSI1MDEuNjk1MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMSIgeD0iMzUiIHk9IjUxNC43NjIyIj5hbHQ8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTEiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE2OSIgeD0iMTAxIiB5PSI1MTMuOTA1OCI+W+uNsOydtO2EsCDthrXrs7Trpbwg66qo65GQIOuniOyzpOydhCDqsr3smrBdPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMzA2LDUzNS45NjA5LDMxNiw1MzkuOTYwOSwzMDYsNTQzLjk2MDksMzEwLDUzOS45NjA5IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI1NCIgeDI9IjMxMiIgeTE9IjUzOS45NjA5IiB5Mj0iNTM5Ljk2MDkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTkiIHg9IjYxIiB5PSI1MzQuODk1Ij4xMDwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMTciIHg9Ijg0IiB5PSI1MzQuODk1Ij7rjbDsnbTthLAg7Ya167O0IOyZhOujjCDthrXrs7Qob25Db21wbGV0ZSk8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheToyLjAsMi4wOyIgeDE9IjIwIiB4Mj0iMzUyIiB5MT0iNTQ4Ljk2MDkiIHkyPSI1NDguOTYwOSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjExIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNTgiIHg9IjI1IiB5PSI1NTkuMTcxNCI+W+yymOumrCDspJEg7JeQ65+s6rCAIOuwnOyDne2WiOydhCDqsr3smrBdPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMzA2LDU3OS44OTg0LDMxNiw1ODMuODk4NCwzMDYsNTg3Ljg5ODQsMzEwLDU4My44OTg0IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI1NCIgeDI9IjMxMiIgeTE9IjU4My44OTg0IiB5Mj0iNTgzLjg5ODQiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTgiIHg9IjYxIiB5PSI1NzguODMyNSI+MTE8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTEzIiB4PSI4MyIgeT0iNTc4LjgzMjUiPuyXkOufrCDthrXrs7Qob25FcnJvcik8L3RleHQ+PCEtLU1ENT1bZWY4OTYzYjEyMjlkZjU4NzE1MWM4YzI2MjQwZGFlMTRdCkBzdGFydHVtbA0KYWN0b3Ig7IOd7IKw7J6QIGFzIEENCmFjdG9yIOyGjOu5hOyekCBhcyBCDQpwYXJ0aWNpcGFudCDqtazrj4UgYXMgQw0KYXV0b251bWJlcg0KQiAtPiBBOiDqtazrj4Uoc3Vic2NyaWJlKQ0KQSAtPiBDOiDqtazrj4Ug6rSA6rOE7JeQIOuMgO2VnCDssLjsobAg6rCd7LK0IOyDneyDnShTdWJzY3JpcHRpb24pDQpBIC0+IEI6IOuNsOydtO2EsCDthrXrs7Qg7KSA67mEIOyZhOujjChvblN1YnNjcmliZSkNCg0KbG9vcCDthrXrs7TtlaAg642w7J207YSw6rCAIOyXhuydhCDrlYzquYzsp4ANCkIgLT4gQzog642w7J207YSwIOyalOyyrShTdWJzY3JpcHRpb24ucmVxdWVzdCkNCg0KYWx0IOq1rOuPhSDtlbTsp4Ag7IOB7YOc6rCAIOyVhOuLkCDqsr3smrANCglBIC0+IEE6IOuNsOydtO2EsCDsg53sgrANCglBIC0+IEI6IOuNsOydtO2EsCDthrXrs7Qob25OZXh0KQ0KZW5kDQoNCg0KYWx0IOyGjOu5hOyekOqwgCDqs4Tsho0g642w7J207YSw66W8IOuwm+ydhCDqsr3smrANCglCIC0+IEI6IO2GteuztOuwm+ydgCDrjbDsnbTthLDrpbwg7LKY66asDQoJQiAtPiBDOiDrjbDsnbTthLAg7JqU7LKtKFN1YnNjcmlwdGlvbi5yZXF1ZXN0KQ0KZWxzZSDqtazrj4XsnYQg7ZW07KeAIO2VmOuKlCDqsr3smrANCglCIC0+IEM6IOq1rOuPhSDtlbTsp4Ag7JqU7LKtDQplbmQNCmVuZA0KDQphbHQg642w7J207YSwIO2GteuztOulvCDrqqjrkZAg66eI7LOk7J2EIOqyveyasA0KQSAtPiBCOiDrjbDsnbTthLAg7Ya167O0IOyZhOujjCDthrXrs7Qob25Db21wbGV0ZSkNCmVsc2Ug7LKY66asIOykkSDsl5Drn6zqsIAg67Cc7IOd7ZaI7J2EIOqyveyasA0KQSAtPiBCOiDsl5Drn6wg7Ya167O0KG9uRXJyb3IpDQplbmQNCkBlbmR1bWwNCgpQbGFudFVNTCB2ZXJzaW9uIDEuMjAyMS4xMGJldGEyKFVua25vd24gY29tcGlsZSB0aW1lKQooR1BMIHNvdXJjZSBkaXN0cmlidXRpb24pCkphdmEgUnVudGltZTogSmF2YShUTSkgU0UgUnVudGltZSBFbnZpcm9ubWVudApKVk06IEphdmEgSG90U3BvdChUTSkgNjQtQml0IFNlcnZlciBWTQpEZWZhdWx0IEVuY29kaW5nOiBVVEYtOApMYW5ndWFnZTogZW4KQ291bnRyeTogVVMKLS0+PC9nPjwvc3ZnPg=='>\n\n<h3 id=\"연산자\"><a href=\"#연산자\" class=\"headerlink\" title=\"연산자\"></a>연산자</h3><p><code>map</code>, <code>flatMap</code> 및 <code>filter</code> 등과 같이 기존 Stream을 다루거나 함수형 라이브러리에서 제공해주는 연산자를 비슷하게 제공해주고 있음. 연산자별로 생성되는 Flowable/Observable의 성격이 상이한 부분이 존재하며, 또한 실행순서에 영향을 주는 연산자도 존재함.</p>\n<h4 id=\"순차-처리의-예\"><a href=\"#순차-처리의-예\" class=\"headerlink\" title=\"순차 처리의 예\"></a>순차 처리의 예</h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flowable.just(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\">    .filter &#123; it % <span class=\"number\">2</span> == <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">    .map &#123; it * <span class=\"number\">100</span> &#125;</span><br><span class=\"line\">    .subscribe &#123; println(<span class=\"string\">&quot;<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>, data: <span class=\"variable\">$it</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>[결과]<br>main, data: 200<br>main, data: 400<br>main, data: 600<br>main, data: 800<br>main, data: 1000</p>\n</blockquote>\n<h4 id=\"순차-처리가-안되는-예\"><a href=\"#순차-처리가-안되는-예\" class=\"headerlink\" title=\"순차 처리가 안되는 예\"></a>순차 처리가 안되는 예</h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flowable.just(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>)</span><br><span class=\"line\">\t.flatMap &#123;</span><br><span class=\"line\">\t\tFlowable.just(it).delay(<span class=\"number\">1000L</span>, TimeUnit.MILLISECONDS)</span><br><span class=\"line\">\t&#125;.subscribe &#123;</span><br><span class=\"line\">\t\tprintln(<span class=\"string\">&quot;<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>: <span class=\"variable\">$it</span>&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>[결과]<br>RxComputationThreadPool-3: C<br>RxComputationThreadPool-1: A<br>RxComputationThreadPool-1: B</p>\n</blockquote>\n<h3 id=\"비동기-처리\"><a href=\"#비동기-처리\" class=\"headerlink\" title=\"비동기 처리\"></a>비동기 처리</h3><p><em><strong>생산자와 소비자는 별도의 지정이 없을 경우, 메인스레드 혹은 실행 스레드에서 순차 처리 됨.</strong></em> </p>\n<p>하지만 시간 관련 Flowable/Observable 생성자의 경우, 별도의 스레드에서 실행이 되는 경우도 있음. 비동기 처리를 지정해야 할 경우 <code>생산자 측(subscribeOn())</code>과 <code>소비자 측(observeOn())</code>에 <code>스레드 스캐줄러</code>를 지정하면 되며, 스캐쥴러(<code>Schedulers</code>)의 종류는 <code>io</code>, <code>computation</code> 등이 있다.</p>\n<h3 id=\"외부-자원에-대한-참조는\"><a href=\"#외부-자원에-대한-참조는\" class=\"headerlink\" title=\"외부 자원에 대한 참조는?\"></a>외부 자원에 대한 참조는?</h3><p>생산자/소비자는 여러 스레드에서 실행이 될 수 있기 때문에, 공유 자원에 대해서 동기화 작업을 반드시 수행해줘야 한다. 이런 동기화를 피하는 가장 좋은 방법은 아래와 같다.</p>\n<ul>\n<li>순수 함수(함수형 인터페이스)의 사용<ul>\n<li>외부 자원 참조 X</li>\n<li>함수 단위로 코드를 전개하여 처리 안정성을 확보</li>\n<li>불변 객체의 사용, 큰 오버헤드가 존재하지 않으면 객체는 복사를 하여 사용하는 것이 좋다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>여러 개의 생산자/소비자가 존재 할 경우는 <code>merge</code>등의 연산자를 통하여 해당 생산자/소비자를 실행하는 스레드가 공유 자원에 대해 동기화하여 접근 할 수 있도록 할 수 있다.</p>\n</blockquote>\n<h4 id=\"공유-자원에-대한-잘못된-접근의-예\"><a href=\"#공유-자원에-대한-잘못된-접근의-예\" class=\"headerlink\" title=\"공유 자원에 대한 잘못된 접근의 예\"></a>공유 자원에 대한 잘못된 접근의 예</h4><p>아래의 2개의 생산자/소비자의 구조에서 2개의 소비자 모두 변수 <code>num</code>에 접근하여 값을 수정하고 있는데, 이는 각각의 소비자에서 스레드에 대한 적절한 동기화 없이 접근하는 안티패턴의 가장 좋은 예라고 할 수 있다. </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">0</span></span><br><span class=\"line\">Flowable.range(<span class=\"number\">1</span>, <span class=\"number\">100_000</span>)</span><br><span class=\"line\">\t.subscribeOn(Schedulers.computation())</span><br><span class=\"line\">\t.observeOn(Schedulers.computation())</span><br><span class=\"line\">\t.subscribe(</span><br><span class=\"line\">\t\t&#123; ++num &#125;,</span><br><span class=\"line\">\t\t&#123; println(<span class=\"string\">&quot;에러=<span class=\"variable\">$it</span>&quot;</span>) &#125;,</span><br><span class=\"line\">\t\t&#123; println(<span class=\"string\">&quot;counter.get()= <span class=\"variable\">$num</span>&quot;</span>) &#125;</span><br><span class=\"line\">\t)</span><br><span class=\"line\"></span><br><span class=\"line\">Flowable.range(<span class=\"number\">1</span>, <span class=\"number\">100_000</span>)</span><br><span class=\"line\">\t.subscribeOn(Schedulers.computation())</span><br><span class=\"line\">\t.observeOn(Schedulers.computation())</span><br><span class=\"line\">\t.subscribe(</span><br><span class=\"line\">\t\t&#123; ++num &#125;,</span><br><span class=\"line\">\t\t&#123; println(<span class=\"string\">&quot;에러=<span class=\"variable\">$it</span>&quot;</span>) &#125;,</span><br><span class=\"line\">\t\t&#123; println(<span class=\"string\">&quot;counter.get()= <span class=\"variable\">$num</span>&quot;</span>) &#125;</span><br><span class=\"line\">\t)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"merge-연산자를-사용한-예\"><a href=\"#merge-연산자를-사용한-예\" class=\"headerlink\" title=\"merge 연산자를 사용한 예\"></a>merge 연산자를 사용한 예</h4><p>위에서 보았던 안티패턴을 Rx에서는 스레드에 대한 동기화 처리를 진행해주는 <code>merge</code> 연산자를 사용하여 해결이 가능하다. 여러 생산자에서 발행하는 데이터의 타임라인을 하나로 만들어주며, 발행하는 순서를 아래의 그림과 같이 시간순 혹은 실행순으로 만들 수 있다.</p>\n<blockquote>\n<p>[요약] 여러 Observable의 출력을 결합하여 단일 Observable처럼 작동하도록 할 수 있다.</p>\n</blockquote>\n<p><img src=\"http://reactivex.io/documentation/operators/images/merge.png\"></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> source1 = Flowable.range(<span class=\"number\">1</span>, <span class=\"number\">100_000</span>)</span><br><span class=\"line\">\t.subscribeOn(Schedulers.computation())</span><br><span class=\"line\">\t.observeOn(Schedulers.computation())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> source2 = Flowable.range(<span class=\"number\">1</span>, <span class=\"number\">100_000</span>)</span><br><span class=\"line\">\t.subscribeOn(Schedulers.computation())</span><br><span class=\"line\">\t.observeOn(Schedulers.computation())</span><br><span class=\"line\"></span><br><span class=\"line\">Flowable</span><br><span class=\"line\">.merge(source1, source2)</span><br><span class=\"line\">.subscribe(</span><br><span class=\"line\">\t&#123; ++num &#125;,</span><br><span class=\"line\">\t&#123; println(<span class=\"string\">&quot;에러=<span class=\"variable\">$it</span>&quot;</span>) &#125;,</span><br><span class=\"line\">\t&#123; println(<span class=\"string\">&quot;counter.get()= <span class=\"variable\">$num</span>&quot;</span>) &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Flowable-vs-Observable-어떤걸-써야-하는거지\"><a href=\"#Flowable-vs-Observable-어떤걸-써야-하는거지\" class=\"headerlink\" title=\"Flowable vs Observable 어떤걸 써야 하는거지?\"></a>Flowable vs Observable 어떤걸 써야 하는거지?</h2><h3 id=\"Flowable\"><a href=\"#Flowable\" class=\"headerlink\" title=\"Flowable\"></a>Flowable</h3><ul>\n<li>대량 데이터를 처리 할 경우</li>\n<li>네트워크 통신/파일 등 IO를 처리 할 경우<h3 id=\"Observable\"><a href=\"#Observable\" class=\"headerlink\" title=\"Observable\"></a>Observable</h3></li>\n<li>GUI 이벤트</li>\n<li>소량의 데이터를 처리 할 경우</li>\n<li>자바의 Stream을 대신하여 사용할 경우</li>\n</ul>\n<p>대량의 데이터와 더불어 IO를 처리 해야 할 경우에는 <code>Flowable</code>을 사용하여 적절한 배압 정책을 적용하는 것이 유리하다. 반면에 GUI의 이벤트 처리 혹은 소량의 데이터를 처리 할 경우 배압이 없는 <code>Observable</code>을 사용하는 것이 유리하다고 한다. <code>Observable</code>은 배압 기능이 없는 만큼 <code>Flowable</code>에 비하여 오버헤드가 적은 것이 특징이다.</p>\n<blockquote>\n<p>배압 기능을 사용하면, 쏟아지는 데이터 대한 적절한 제어 뿐만 아니라 에러 처리도 할 수 있다. 물론, 다루는 데이터의 성격에 따라 달라질 수 있는 부분이지만 생산자와 소비자간의 처리 속도 차이에 따라 발생하는 데이터 유실에 대한 부분도 반드시 고려해서 배압 정책을 적용한 코드를 작성해야 한다.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"RxKotlin-1\"><a href=\"#RxKotlin-1\" class=\"headerlink\" title=\"RxKotlin #1\"></a>RxKotlin #1</h1><h1 id=\"Reactive-Programming\"><a href=\"#Reactive-Programming\" class=\"headerlink\" title=\"Reactive Programming\"></a>Reactive Programming</h1><ul>\n<li>데이터가 통지되면 이에 반응하여 데이터를 처리 하는 방식의 프로그래밍 모델. 즉, 프로그램에서 필요한 데이터를 직접 가지고와서 처리하는 방식(pull)이 아닌 데이터를 받은 시점에 처리하는 방식(push). </li>\n<li>이를 구현하기 위해 데이터를 만들어내는 <code>생산자</code>와 이를 소비하게 되는 <code>소비자</code>로 역할을 나눠 처리하는 프로세스를 가지게 된다.</li>\n<li>소비자와 생산자의 역할이 분리되어 있으므로, 생산자는 데이터를 생산하여 전달하는 역할까지 수행하며, 소비자는 데이터를 받아서 처리하는 역할만을 수행한다. 즉, 생산자와 소비자는 각각의 역할만 충실하게 수행하면 되고, 반대편에서 어떤 처리를 하는지에 대해서는 관심 밖의 일이다.<blockquote>\n<p>이처럼, 역할이 분리됨에 따라 쉽게 비동기 구현이 가능</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"Reactive-Stream\"><a href=\"#Reactive-Stream\" class=\"headerlink\" title=\"Reactive Stream\"></a>Reactive Stream</h1><ul>\n<li><code>데이터 스트림</code>을 <code>비동기</code>로 처리 할 수 있는 공통 메커니즘/인터페이스.</li>\n<li>Reactive Stream은 인터페이스만 제공하고 상세 구현은 각 라이브러리/프레임워크에서 책임을 가져간다.<h2 id=\"구현체\"><a href=\"#구현체\" class=\"headerlink\" title=\"구현체\"></a>구현체</h2></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Reactive_Streams#cite_note-17\">위키피디아 참고</a><br><img src=\"https://cdn-images-1.medium.com/max/1600/1*70ZfCOn5Qadc8nZ_k_JhKQ.png\"></li>\n</ul>\n<h2 id=\"데이터스트림\"><a href=\"#데이터스트림\" class=\"headerlink\" title=\"데이터스트림\"></a>데이터스트림</h2><ul>\n<li>Collection과 같이 이미 생성한 데이터를 포함하여 <code>앞으로 생성할 데이터</code> 혹은 <code>발생 가능성이 있는 데이터</code>까지 포함하는 개념. </li>\n<li>키보드 혹은 마우스 같은 UI상에서의 이벤트가 발생 했을 때, 해당 이벤트가 발생하는 시점의 데이터까지 포함하는 개념으로 볼 수 있다.</li>\n<li>데이터스트림의 소스 종류들은?<ul>\n<li>SQL 쿼리들</li>\n<li>GUI 이벤트</li>\n<li>HTTP 기반 서비스</li>\n<li>TCP 소켓</li>\n<li>파일 시스템</li>\n<li>Kafka같은 메시지 큐들</li>\n<li>기타 등등</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"구성\"><a href=\"#구성\" class=\"headerlink\" title=\"구성\"></a>구성</h2><ul>\n<li>Reactive Stream은 Publisher와 Subscriber로 구성되며, Subscriber가 Publisher를 구독하면 Publisher가 통보하는 데이터를 받을 수 있음<img src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U2NyaXB0VHlwZT0iYXBwbGljYXRpb24vZWNtYXNjcmlwdCIgY29udGVudFN0eWxlVHlwZT0idGV4dC9jc3MiIGhlaWdodD0iNTI2cHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDo0NjNweDtoZWlnaHQ6NTI2cHg7YmFja2dyb3VuZDojRkZGRkZGOyIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgNDYzIDUyNiIgd2lkdGg9IjQ2M3B4IiB6b29tQW5kUGFuPSJtYWduaWZ5Ij48ZGVmcz48ZmlsdGVyIGhlaWdodD0iMzAwJSIgaWQ9ImYxYnB4YWx3Z2g5d2x4IiB3aWR0aD0iMzAwJSIgeD0iLTEiIHk9Ii0xIj48ZmVHYXVzc2lhbkJsdXIgcmVzdWx0PSJibHVyT3V0IiBzdGREZXZpYXRpb249IjIuMCIvPjxmZUNvbG9yTWF0cml4IGluPSJibHVyT3V0IiByZXN1bHQ9ImJsdXJPdXQyIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgLjQgMCIvPjxmZU9mZnNldCBkeD0iNC4wIiBkeT0iNC4wIiBpbj0iYmx1ck91dDIiIHJlc3VsdD0iYmx1ck91dDMiLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJibHVyT3V0MyIgbW9kZT0ibm9ybWFsIi8+PC9maWx0ZXI+PC9kZWZzPjxnPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGZpbHRlcj0idXJsKCNmMWJweGFsd2doOXdseCkiIGhlaWdodD0iOTAuMjAzMSIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjA7IiB3aWR0aD0iMzIyIiB4PSIxMCIgeT0iMzM1LjIyNjYiLz48cmVjdCBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjQzLjkzNzUiIHN0eWxlPSJzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MS4wOyIgd2lkdGg9IjMyMiIgeD0iMTAiIHk9IjM4MS40OTIyIi8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9IjQ0IiB4Mj0iNDQiIHkxPSI4OC4yOTY5IiB5Mj0iNDQyLjQyOTciLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjUuMCw1LjA7IiB4MT0iMjk4IiB4Mj0iMjk4IiB5MT0iODguMjk2OSIgeTI9IjQ0Mi40Mjk3Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDIiIHg9IjIwIiB5PSI4NC45OTUxIj7sg53sgrDsnpA8L3RleHQ+PGVsbGlwc2UgY3g9IjQ0IiBjeT0iMTUiIGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMWJweGFsd2doOXdseCkiIHJ4PSI4IiByeT0iOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHBhdGggZD0iTTQ0LDIzIEw0NCw1MCBNMzEsMzEgTDU3LDMxIE00NCw1MCBMMzEsNjUgTTQ0LDUwIEw1Nyw2NSAiIGZpbGw9Im5vbmUiIGZpbHRlcj0idXJsKCNmMWJweGFsd2doOXdseCkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6Mi4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQyIiB4PSIyMCIgeT0iNDU0LjQyNDgiPuyDneyCsOyekDwvdGV4dD48ZWxsaXBzZSBjeD0iNDQiIGN5PSI0NjcuNzI2NiIgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxYnB4YWx3Z2g5d2x4KSIgcng9IjgiIHJ5PSI4IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48cGF0aCBkPSJNNDQsNDc1LjcyNjYgTDQ0LDUwMi43MjY2IE0zMSw0ODMuNzI2NiBMNTcsNDgzLjcyNjYgTTQ0LDUwMi43MjY2IEwzMSw1MTcuNzI2NiBNNDQsNTAyLjcyNjYgTDU3LDUxNy43MjY2ICIgZmlsbD0ibm9uZSIgZmlsdGVyPSJ1cmwoI2YxYnB4YWx3Z2g5d2x4KSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDIiIHg9IjI3NCIgeT0iODQuOTk1MSI+7IaM67mE7J6QPC90ZXh0PjxlbGxpcHNlIGN4PSIyOTgiIGN5PSIxNSIgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxYnB4YWx3Z2g5d2x4KSIgcng9IjgiIHJ5PSI4IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48cGF0aCBkPSJNMjk4LDIzIEwyOTgsNTAgTTI4NSwzMSBMMzExLDMxIE0yOTgsNTAgTDI4NSw2NSBNMjk4LDUwIEwzMTEsNjUgIiBmaWxsPSJub25lIiBmaWx0ZXI9InVybCgjZjFicHhhbHdnaDl3bHgpIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI0MiIgeD0iMjc0IiB5PSI0NTQuNDI0OCI+7IaM67mE7J6QPC90ZXh0PjxlbGxpcHNlIGN4PSIyOTgiIGN5PSI0NjcuNzI2NiIgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxYnB4YWx3Z2g5d2x4KSIgcng9IjgiIHJ5PSI4IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48cGF0aCBkPSJNMjk4LDQ3NS43MjY2IEwyOTgsNTAyLjcyNjYgTTI4NSw0ODMuNzI2NiBMMzExLDQ4My43MjY2IE0yOTgsNTAyLjcyNjYgTDI4NSw1MTcuNzI2NiBNMjk4LDUwMi43MjY2IEwzMTEsNTE3LjcyNjYgIiBmaWxsPSJub25lIiBmaWx0ZXI9InVybCgjZjFicHhhbHdnaDl3bHgpIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjU1LDExNS40Mjk3LDQ1LDExOS40Mjk3LDU1LDEyMy40Mjk3LDUxLDExOS40Mjk3IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI0OSIgeDI9IjI5NyIgeTE9IjExOS40Mjk3IiB5Mj0iMTE5LjQyOTciLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iNjEiIHk9IjExNC4zNjM4Ij4xPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk3IiB4PSI3NCIgeT0iMTE0LjM2MzgiPuq1rOuPhShzdWJzY3JpYmUpPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMjg2LDE0NC41NjI1LDI5NiwxNDguNTYyNSwyODYsMTUyLjU2MjUsMjkwLDE0OC41NjI1IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI0NCIgeDI9IjI5MiIgeTE9IjE0OC41NjI1IiB5Mj0iMTQ4LjU2MjUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iNTEiIHk9IjE0My40OTY2Ij4yPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIxNyIgeD0iNjQiIHk9IjE0My40OTY2Ij7rjbDsnbTthLAg7Ya167O0IOykgOu5hCDsmYTro4wob25TdWJzY3JpYmUpPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNTUsMTczLjY5NTMsNDUsMTc3LjY5NTMsNTUsMTgxLjY5NTMsNTEsMTc3LjY5NTMiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjQ5IiB4Mj0iMjk3IiB5MT0iMTc3LjY5NTMiIHkyPSIxNzcuNjk1MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI4IiB4PSI2MSIgeT0iMTcyLjYyOTQiPjM8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjEwIiB4PSI3MyIgeT0iMTcyLjYyOTQiPuuNsOydtO2EsCDsmpTssq0oU3Vic2NyaXB0aW9uLnJlcXVlc3QpPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjQ0IiB4Mj0iODYiIHkxPSIyMDYuODI4MSIgeTI9IjIwNi44MjgxIi8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iODYiIHgyPSI4NiIgeTE9IjIwNi44MjgxIiB5Mj0iMjE5LjgyODEiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI0NSIgeDI9Ijg2IiB5MT0iMjE5LjgyODEiIHkyPSIyMTkuODI4MSIvPjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNTUsMjE1LjgyODEsNDUsMjE5LjgyODEsNTUsMjIzLjgyODEsNTEsMjE5LjgyODEiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5IiB4PSI1MSIgeT0iMjAxLjc2MjIiPjQ8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNjkiIHg9IjY0IiB5PSIyMDEuNzYyMiI+642w7J207YSwIOyDneyCsDwvdGV4dD48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjI4NiwyNDQuOTYwOSwyOTYsMjQ4Ljk2MDksMjg2LDI1Mi45NjA5LDI5MCwyNDguOTYwOSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iNDQiIHgyPSIyOTIiIHkxPSIyNDguOTYwOSIgeTI9IjI0OC45NjA5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkiIHg9IjUxIiB5PSIyNDMuODk1Ij41PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyNSIgeD0iNjQiIHk9IjI0My44OTUiPuuNsOydtO2EsCDthrXrs7Qob25OZXh0KTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIyOTgiIHgyPSIzNDAiIHkxPSIyNzguMDkzOCIgeTI9IjI3OC4wOTM4Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMzQwIiB4Mj0iMzQwIiB5MT0iMjc4LjA5MzgiIHkyPSIyOTEuMDkzOCIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjI5OSIgeDI9IjM0MCIgeTE9IjI5MS4wOTM4IiB5Mj0iMjkxLjA5MzgiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjMwOSwyODcuMDkzOCwyOTksMjkxLjA5MzgsMzA5LDI5NS4wOTM4LDMwNSwyOTEuMDkzOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkiIHg9IjMwNSIgeT0iMjczLjAyNzgiPjY8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTM4IiB4PSIzMTgiIHk9IjI3My4wMjc4Ij7thrXrs7TrsJvsnYAg642w7J207YSw66W8IOyymOumrDwvdGV4dD48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjU1LDMxNi4yMjY2LDQ1LDMyMC4yMjY2LDU1LDMyNC4yMjY2LDUxLDMyMC4yMjY2IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI0OSIgeDI9IjI5NyIgeTE9IjMyMC4yMjY2IiB5Mj0iMzIwLjIyNjYiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iNjEiIHk9IjMxNS4xNjA2Ij43PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIxMCIgeD0iNzQiIHk9IjMxNS4xNjA2Ij7rjbDsnbTthLAg7JqU7LKtKFN1YnNjcmlwdGlvbi5yZXF1ZXN0KTwvdGV4dD48cGF0aCBkPSJNMTAsMzM1LjIyNjYgTDc2LDMzNS4yMjY2IEw3NiwzNDIuMjI2NiBMNjYsMzUyLjIyNjYgTDEwLDM1Mi4yMjY2IEwxMCwzMzUuMjI2NiAiIGZpbGw9IiNFRUVFRUUiIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9Im5vbmUiIGhlaWdodD0iOTAuMjAzMSIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjA7IiB3aWR0aD0iMzIyIiB4PSIxMCIgeT0iMzM1LjIyNjYiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjEiIHg9IjI1IiB5PSIzNDguMjkzNSI+YWx0PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjExIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNjkiIHg9IjkxIiB5PSIzNDcuNDM3Ij5b642w7J207YSwIO2GteuztOulvCDrqqjrkZAg66eI7LOk7J2EIOqyveyasF08L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIyODYsMzY5LjQ5MjIsMjk2LDM3My40OTIyLDI4NiwzNzcuNDkyMiwyOTAsMzczLjQ5MjIiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjQ0IiB4Mj0iMjkyIiB5MT0iMzczLjQ5MjIiIHkyPSIzNzMuNDkyMiIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5IiB4PSI1MSIgeT0iMzY4LjQyNjMiPjg8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjE3IiB4PSI2NCIgeT0iMzY4LjQyNjMiPuuNsOydtO2EsCDthrXrs7Qg7JmE66OMIO2GteuztChvbkNvbXBsZXRlKTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjIuMCwyLjA7IiB4MT0iMTAiIHgyPSIzMzIiIHkxPSIzODIuNDkyMiIgeTI9IjM4Mi40OTIyIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTEiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE1OCIgeD0iMTUiIHk9IjM5Mi43MDI2Ij5b7LKY66asIOykkSDsl5Drn6zqsIAg67Cc7IOd7ZaI7J2EIOqyveyasF08L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIyODYsNDEzLjQyOTcsMjk2LDQxNy40Mjk3LDI4Niw0MjEuNDI5NywyOTAsNDE3LjQyOTciIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjQ0IiB4Mj0iMjkyIiB5MT0iNDE3LjQyOTciIHkyPSI0MTcuNDI5NyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5IiB4PSI1MSIgeT0iNDEyLjM2MzgiPjk8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTEzIiB4PSI2NCIgeT0iNDEyLjM2MzgiPuyXkOufrCDthrXrs7Qob25FcnJvcik8L3RleHQ+PCEtLU1ENT1bMGZjODcxZTVhYjQxNjczZmU0MDFhNmMxNTcyYjhlNjVdCkBzdGFydHVtbA0KYWN0b3Ig7IOd7IKw7J6QIGFzIEENCmFjdG9yIOyGjOu5hOyekCBhcyBCDQphdXRvbnVtYmVyDQpCIC0+IEE6IOq1rOuPhShzdWJzY3JpYmUpDQpBIC0+IEI6IOuNsOydtO2EsCDthrXrs7Qg7KSA67mEIOyZhOujjChvblN1YnNjcmliZSkNCkIgLT4gQTog642w7J207YSwIOyalOyyrShTdWJzY3JpcHRpb24ucmVxdWVzdCkNCkEgLT4gQTog642w7J207YSwIOyDneyCsA0KQSAtPiBCOiDrjbDsnbTthLAg7Ya167O0KG9uTmV4dCkNCkIgLT4gQjog7Ya167O067Cb7J2AIOuNsOydtO2EsOulvCDsspjrpqwNCkIgLT4gQTog642w7J207YSwIOyalOyyrShTdWJzY3JpcHRpb24ucmVxdWVzdCkNCmFsdCDrjbDsnbTthLAg7Ya167O066W8IOuqqOuRkCDrp4jss6TsnYQg6rK97JqwDQpBIC0+IEI6IOuNsOydtO2EsCDthrXrs7Qg7JmE66OMIO2GteuztChvbkNvbXBsZXRlKQ0KZWxzZSDsspjrpqwg7KSRIOyXkOufrOqwgCDrsJzsg53tlojsnYQg6rK97JqwDQpBIC0+IEI6IOyXkOufrCDthrXrs7Qob25FcnJvcikNCmVuZA0KQGVuZHVtbA0KClBsYW50VU1MIHZlcnNpb24gMS4yMDIxLjEwYmV0YTIoVW5rbm93biBjb21waWxlIHRpbWUpCihHUEwgc291cmNlIGRpc3RyaWJ1dGlvbikKSmF2YSBSdW50aW1lOiBKYXZhKFRNKSBTRSBSdW50aW1lIEVudmlyb25tZW50CkpWTTogSmF2YSBIb3RTcG90KFRNKSA2NC1CaXQgU2VydmVyIFZNCkRlZmF1bHQgRW5jb2Rpbmc6IFVURi04Ckxhbmd1YWdlOiBlbgpDb3VudHJ5OiBVUwotLT48L2c+PC9zdmc+'></li>\n<li>구독(subscribe)가 발생하면 이에 대한 Subscription이 생성된다.</li>\n<li>Subscriber가 Publisher를 구독하지 않으면 이후 단계는 진행되지 않는다.</li>\n<li>onComplete, onError와 같이, 확정 Action이 발생하면 소비자에게 통보한다.</li>\n<li>Subscriber는 Publisher에게 받을 데이터 개수를 요청 할 수 있으며, 요청 받은 Publisher는 다시 데이터를 생산하여 Subscriber에게 전달(onNext)한다.</li>\n<li>받을 데이터 개수를 요청하는 것은 생산자측의 처리 속도와 소비자측의 처리 속도가 다를 수 있기 때문에, 이를 제어 할 수 있는 적절한 수단이 필요하기 때문</li>\n</ul>\n<h2 id=\"표준-인터페이스\"><a href=\"#표준-인터페이스\" class=\"headerlink\" title=\"표준 인터페이스\"></a>표준 인터페이스</h2><table>\n<thead>\n<tr>\n<th>인터페이스</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Publisher</td>\n<td>데이터 생성/통보</td>\n</tr>\n<tr>\n<td>Subscriber</td>\n<td>데이터 처리</td>\n</tr>\n<tr>\n<td>Subscription</td>\n<td>데이터 요청/ 구독 해지 가능</td>\n</tr>\n<tr>\n<td>Processor</td>\n<td>Publisher &amp; Subscriber의 역할을 모두 가지고 있음</td>\n</tr>\n</tbody></table>\n<p>위 표준 인터페이스를 보면 알 수 있듯이, 분명하게 <code>역할 분리</code>가 되어 있음을 알 수 있다. 이는 곧 처리 단위 별로 개별 책임을 가져 갈 수 있음을 뜻함.</p>\n<h2 id=\"규칙\"><a href=\"#규칙\" class=\"headerlink\" title=\"규칙\"></a>규칙</h2><p>Reactive Stream은 인터페이스를 통하여 데이터를 통지하는 구조이며, Reactive Stream에서 정해놓은 규약을 충분하게 지켜야 구조가 제대로 동작한다.</p>\n<ol>\n<li>구독 시작 통지(onSubscribe)는 구독에서 한 번만 발생</li>\n<li>데이터 통지는 순차적으로 이뤄진다.</li>\n<li>null을 통지하지 않는다.</li>\n<li>Publisher는 처리 완료(onComplete) 혹은 에러(onError)를 통하여 종료한다.</li>\n</ol>\n<blockquote>\n<p>[주의] 같은 인스턴스를 활용하여 구독(subscribe)를 할 경우, Publisher/Subscriber의 내부 상태를 초기화하지 않으면 의도하지 않은 결과로 이어질 수 있다. 왜냐하면, onComplete 혹은 onError의 통지가 이뤄진 이후 시점에는 Publisher는 처리가 끝마친 것으로 판단하기 때문이다.</p>\n</blockquote>\n<h2 id=\"RxJava-Kotlin에서-꼭-알아야-할-구조는\"><a href=\"#RxJava-Kotlin에서-꼭-알아야-할-구조는\" class=\"headerlink\" title=\"RxJava,Kotlin에서 꼭 알아야 할 구조는?\"></a>RxJava,Kotlin에서 꼭 알아야 할 구조는?</h2><h3 id=\"생산자-소비자-구독\"><a href=\"#생산자-소비자-구독\" class=\"headerlink\" title=\"생산자/소비자/구독\"></a>생산자/소비자/구독</h3><table>\n<thead>\n<tr>\n<th>ReactiveStream 지원 유/무</th>\n<th>생산자</th>\n<th>소비자</th>\n<th>관계</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>O</td>\n<td>Flowable</td>\n<td>Subscriber</td>\n<td>Subscription</td>\n</tr>\n<tr>\n<td>X</td>\n<td>Observable</td>\n<td>Observer</td>\n<td>Disposable</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>지원 유무의 가장 큰 차이점은 <code>배압(Backpressure)</code>의 적용 유무, 배압이 적용되어 있지 않기 때문에, 별도로 소비자측에서는 데이터를 요청하지 않음. 배압 외에는 처리 모델은 거의 똑같다.</p>\n</blockquote>\n<img src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U2NyaXB0VHlwZT0iYXBwbGljYXRpb24vZWNtYXNjcmlwdCIgY29udGVudFN0eWxlVHlwZT0idGV4dC9jc3MiIGhlaWdodD0iNjkzcHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDo2MjJweDtoZWlnaHQ6NjkzcHg7YmFja2dyb3VuZDojRkZGRkZGOyIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgNjIyIDY5MyIgd2lkdGg9IjYyMnB4IiB6b29tQW5kUGFuPSJtYWduaWZ5Ij48ZGVmcz48ZmlsdGVyIGhlaWdodD0iMzAwJSIgaWQ9ImYxdDN3ODNkN3lnZ2JjIiB3aWR0aD0iMzAwJSIgeD0iLTEiIHk9Ii0xIj48ZmVHYXVzc2lhbkJsdXIgcmVzdWx0PSJibHVyT3V0IiBzdGREZXZpYXRpb249IjIuMCIvPjxmZUNvbG9yTWF0cml4IGluPSJibHVyT3V0IiByZXN1bHQ9ImJsdXJPdXQyIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgLjQgMCIvPjxmZU9mZnNldCBkeD0iNC4wIiBkeT0iNC4wIiBpbj0iYmx1ck91dDIiIHJlc3VsdD0iYmx1ck91dDMiLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJibHVyT3V0MyIgbW9kZT0ibm9ybWFsIi8+PC9maWx0ZXI+PC9kZWZzPjxnPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGZpbHRlcj0idXJsKCNmMXQzdzgzZDd5Z2diYykiIGhlaWdodD0iMjk1IiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjIuMDsiIHdpZHRoPSI1OTgiIHg9IjEwIiB5PSIxOTIuNjk1MyIvPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGZpbHRlcj0idXJsKCNmMXQzdzgzZDd5Z2diYykiIGhlaWdodD0iODguMzk4NCIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjA7IiB3aWR0aD0iMzMyIiB4PSIyMCIgeT0iMjQ1Ljk2MDkiLz48cmVjdCBmaWxsPSIjRkZGRkZGIiBmaWx0ZXI9InVybCgjZjF0M3c4M2Q3eWdnYmMpIiBoZWlnaHQ9IjEzMi4zMzU5IiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjIuMDsiIHdpZHRoPSIzMTQiIHg9IjI4NCIgeT0iMzQ4LjM1OTQiLz48cmVjdCBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjQzLjkzNzUiIHN0eWxlPSJzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MS4wOyIgd2lkdGg9IjMxNCIgeD0iMjg0IiB5PSI0MzYuNzU3OCIvPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGZpbHRlcj0idXJsKCNmMXQzdzgzZDd5Z2diYykiIGhlaWdodD0iOTAuMjAzMSIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjA7IiB3aWR0aD0iMzMyIiB4PSIyMCIgeT0iNTAxLjY5NTMiLz48cmVjdCBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjQzLjkzNzUiIHN0eWxlPSJzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MS4wOyIgd2lkdGg9IjMzMiIgeD0iMjAiIHk9IjU0Ny45NjA5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9IjU0IiB4Mj0iNTQiIHkxPSI4OC4yOTY5IiB5Mj0iNjA4Ljg5ODQiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjUuMCw1LjA7IiB4MT0iMzE4IiB4Mj0iMzE4IiB5MT0iODguMjk2OSIgeTI9IjYwOC44OTg0Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9IjU2NSIgeDI9IjU2NSIgeTE9Ijg4LjI5NjkiIHkyPSI2MDguODk4NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQyIiB4PSIzMCIgeT0iODQuOTk1MSI+7IOd7IKw7J6QPC90ZXh0PjxlbGxpcHNlIGN4PSI1NCIgY3k9IjE1IiBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjF0M3c4M2Q3eWdnYmMpIiByeD0iOCIgcnk9IjgiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6Mi4wOyIvPjxwYXRoIGQ9Ik01NCwyMyBMNTQsNTAgTTQxLDMxIEw2NywzMSBNNTQsNTAgTDQxLDY1IE01NCw1MCBMNjcsNjUgIiBmaWxsPSJub25lIiBmaWx0ZXI9InVybCgjZjF0M3c4M2Q3eWdnYmMpIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI0MiIgeD0iMzAiIHk9IjYyMC44OTM2Ij7sg53sgrDsnpA8L3RleHQ+PGVsbGlwc2UgY3g9IjU0IiBjeT0iNjM0LjE5NTMiIGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMXQzdzgzZDd5Z2diYykiIHJ4PSI4IiByeT0iOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHBhdGggZD0iTTU0LDY0Mi4xOTUzIEw1NCw2NjkuMTk1MyBNNDEsNjUwLjE5NTMgTDY3LDY1MC4xOTUzIE01NCw2NjkuMTk1MyBMNDEsNjg0LjE5NTMgTTU0LDY2OS4xOTUzIEw2Nyw2ODQuMTk1MyAiIGZpbGw9Im5vbmUiIGZpbHRlcj0idXJsKCNmMXQzdzgzZDd5Z2diYykiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6Mi4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQyIiB4PSIyOTQiIHk9Ijg0Ljk5NTEiPuyGjOu5hOyekDwvdGV4dD48ZWxsaXBzZSBjeD0iMzE4IiBjeT0iMTUiIGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMXQzdzgzZDd5Z2diYykiIHJ4PSI4IiByeT0iOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHBhdGggZD0iTTMxOCwyMyBMMzE4LDUwIE0zMDUsMzEgTDMzMSwzMSBNMzE4LDUwIEwzMDUsNjUgTTMxOCw1MCBMMzMxLDY1ICIgZmlsbD0ibm9uZSIgZmlsdGVyPSJ1cmwoI2YxdDN3ODNkN3lnZ2JjKSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDIiIHg9IjI5NCIgeT0iNjIwLjg5MzYiPuyGjOu5hOyekDwvdGV4dD48ZWxsaXBzZSBjeD0iMzE4IiBjeT0iNjM0LjE5NTMiIGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMXQzdzgzZDd5Z2diYykiIHJ4PSI4IiByeT0iOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHBhdGggZD0iTTMxOCw2NDIuMTk1MyBMMzE4LDY2OS4xOTUzIE0zMDUsNjUwLjE5NTMgTDMzMSw2NTAuMTk1MyBNMzE4LDY2OS4xOTUzIEwzMDUsNjg0LjE5NTMgTTMxOCw2NjkuMTk1MyBMMzMxLDY4NC4xOTUzICIgZmlsbD0ibm9uZSIgZmlsdGVyPSJ1cmwoI2YxdDN3ODNkN3lnZ2JjKSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxdDN3ODNkN3lnZ2JjKSIgaGVpZ2h0PSIzMC4yOTY5IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI0MiIgeD0iNTQyIiB5PSI1MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI4IiB4PSI1NDkiIHk9IjcyLjk5NTEiPuq1rOuPhTwvdGV4dD48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjF0M3c4M2Q3eWdnYmMpIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjQyIiB4PSI1NDIiIHk9IjYwNy44OTg0Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjgiIHg9IjU0OSIgeT0iNjI3Ljg5MzYiPuq1rOuPhTwvdGV4dD48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjY1LDExNS40Mjk3LDU1LDExOS40Mjk3LDY1LDEyMy40Mjk3LDYxLDExOS40Mjk3IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI1OSIgeDI9IjMxNyIgeTE9IjExOS40Mjk3IiB5Mj0iMTE5LjQyOTciLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iNzEiIHk9IjExNC4zNjM4Ij4xPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk3IiB4PSI4NCIgeT0iMTE0LjM2MzgiPuq1rOuPhShzdWJzY3JpYmUpPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNTUzLDE0NC41NjI1LDU2MywxNDguNTYyNSw1NTMsMTUyLjU2MjUsNTU3LDE0OC41NjI1IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI1NCIgeDI9IjU1OSIgeTE9IjE0OC41NjI1IiB5Mj0iMTQ4LjU2MjUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iNjEiIHk9IjE0My40OTY2Ij4yPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI3NyIgeD0iNzQiIHk9IjE0My40OTY2Ij7qtazrj4Ug6rSA6rOE7JeQIOuMgO2VnCDssLjsobAg6rCd7LK0IOyDneyDnShTdWJzY3JpcHRpb24pPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMzA2LDE3My42OTUzLDMxNiwxNzcuNjk1MywzMDYsMTgxLjY5NTMsMzEwLDE3Ny42OTUzIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI1NCIgeDI9IjMxMiIgeTE9IjE3Ny42OTUzIiB5Mj0iMTc3LjY5NTMiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOCIgeD0iNjEiIHk9IjE3Mi42Mjk0Ij4zPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIxNyIgeD0iNzMiIHk9IjE3Mi42Mjk0Ij7rjbDsnbTthLAg7Ya167O0IOykgOu5hCDsmYTro4wob25TdWJzY3JpYmUpPC90ZXh0PjxwYXRoIGQ9Ik0xMCwxOTIuNjk1MyBMODgsMTkyLjY5NTMgTDg4LDE5OS42OTUzIEw3OCwyMDkuNjk1MyBMMTAsMjA5LjY5NTMgTDEwLDE5Mi42OTUzICIgZmlsbD0iI0VFRUVFRSIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0ibm9uZSIgaGVpZ2h0PSIyOTUiIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6Mi4wOyIgd2lkdGg9IjU5OCIgeD0iMTAiIHk9IjE5Mi42OTUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjMzIiB4PSIyNSIgeT0iMjA1Ljc2MjIiPmxvb3A8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTEiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE1NCIgeD0iMTAzIiB5PSIyMDQuOTA1OCI+W+2GteuztO2VoCDrjbDsnbTthLDqsIAg7JeG7J2EIOuVjOq5jOyngF08L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSI1NTMsMjI2Ljk2MDksNTYzLDIzMC45NjA5LDU1MywyMzQuOTYwOSw1NTcsMjMwLjk2MDkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjMxOCIgeDI9IjU1OSIgeTE9IjIzMC45NjA5IiB5Mj0iMjMwLjk2MDkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iMzI1IiB5PSIyMjUuODk1Ij40PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIxMCIgeD0iMzM4IiB5PSIyMjUuODk1Ij7rjbDsnbTthLAg7JqU7LKtKFN1YnNjcmlwdGlvbi5yZXF1ZXN0KTwvdGV4dD48cGF0aCBkPSJNMjAsMjQ1Ljk2MDkgTDg2LDI0NS45NjA5IEw4NiwyNTIuOTYwOSBMNzYsMjYyLjk2MDkgTDIwLDI2Mi45NjA5IEwyMCwyNDUuOTYwOSAiIGZpbGw9IiNFRUVFRUUiIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9Im5vbmUiIGhlaWdodD0iODguMzk4NCIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjA7IiB3aWR0aD0iMzMyIiB4PSIyMCIgeT0iMjQ1Ljk2MDkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjEiIHg9IjM1IiB5PSIyNTkuMDI3OCI+YWx0PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjExIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNDciIHg9IjEwMSIgeT0iMjU4LjE3MTQiPlvqtazrj4Ug7ZW07KeAIOyDge2DnOqwgCDslYTri5Ag6rK97JqwXTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI1NCIgeDI9Ijk2IiB5MT0iMjg0LjIyNjYiIHkyPSIyODQuMjI2NiIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9Ijk2IiB4Mj0iOTYiIHkxPSIyODQuMjI2NiIgeTI9IjI5Ny4yMjY2Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iNTUiIHgyPSI5NiIgeTE9IjI5Ny4yMjY2IiB5Mj0iMjk3LjIyNjYiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjY1LDI5My4yMjY2LDU1LDI5Ny4yMjY2LDY1LDMwMS4yMjY2LDYxLDI5Ny4yMjY2IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iNjEiIHk9IjI3OS4xNjA2Ij41PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5IiB4PSI3NCIgeT0iMjc5LjE2MDYiPuuNsOydtO2EsCDsg53sgrA8L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIzMDYsMzIyLjM1OTQsMzE2LDMyNi4zNTk0LDMwNiwzMzAuMzU5NCwzMTAsMzI2LjM1OTQiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjU0IiB4Mj0iMzEyIiB5MT0iMzI2LjM1OTQiIHkyPSIzMjYuMzU5NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5IiB4PSI2MSIgeT0iMzIxLjI5MzUiPjY8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTI1IiB4PSI3NCIgeT0iMzIxLjI5MzUiPuuNsOydtO2EsCDthrXrs7Qob25OZXh0KTwvdGV4dD48cGF0aCBkPSJNMjg0LDM0OC4zNTk0IEwzNTAsMzQ4LjM1OTQgTDM1MCwzNTUuMzU5NCBMMzQwLDM2NS4zNTk0IEwyODQsMzY1LjM1OTQgTDI4NCwzNDguMzU5NCAiIGZpbGw9IiNFRUVFRUUiIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9Im5vbmUiIGhlaWdodD0iMTMyLjMzNTkiIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6Mi4wOyIgd2lkdGg9IjMxNCIgeD0iMjg0IiB5PSIzNDguMzU5NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMSIgeD0iMjk5IiB5PSIzNjEuNDI2MyI+YWx0PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjExIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxODAiIHg9IjM2NSIgeT0iMzYwLjU2OTgiPlvshozruYTsnpDqsIAg6rOE7IaNIOuNsOydtO2EsOulvCDrsJvsnYQg6rK97JqwXTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIzMTgiIHgyPSIzNjAiIHkxPSIzODYuNjI1IiB5Mj0iMzg2LjYyNSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjM2MCIgeDI9IjM2MCIgeTE9IjM4Ni42MjUiIHkyPSIzOTkuNjI1Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMzE5IiB4Mj0iMzYwIiB5MT0iMzk5LjYyNSIgeTI9IjM5OS42MjUiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjMyOSwzOTUuNjI1LDMxOSwzOTkuNjI1LDMyOSw0MDMuNjI1LDMyNSwzOTkuNjI1IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iMzI1IiB5PSIzODEuNTU5MSI+NzwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMzgiIHg9IjMzOCIgeT0iMzgxLjU1OTEiPu2GteuztOuwm+ydgCDrjbDsnbTthLDrpbwg7LKY66asPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNTUzLDQyNC43NTc4LDU2Myw0MjguNzU3OCw1NTMsNDMyLjc1NzgsNTU3LDQyOC43NTc4IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIzMTgiIHgyPSI1NTkiIHkxPSI0MjguNzU3OCIgeTI9IjQyOC43NTc4Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkiIHg9IjMyNSIgeT0iNDIzLjY5MTkiPjg8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjEwIiB4PSIzMzgiIHk9IjQyMy42OTE5Ij7rjbDsnbTthLAg7JqU7LKtKFN1YnNjcmlwdGlvbi5yZXF1ZXN0KTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjIuMCwyLjA7IiB4MT0iMjg0IiB4Mj0iNTk4IiB5MT0iNDM3Ljc1NzgiIHkyPSI0MzcuNzU3OCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjExIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMjEiIHg9IjI4OSIgeT0iNDQ3Ljk2ODMiPlvqtazrj4XsnYQg7ZW07KeAIO2VmOuKlCDqsr3smrBdPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNTUzLDQ2OC42OTUzLDU2Myw0NzIuNjk1Myw1NTMsNDc2LjY5NTMsNTU3LDQ3Mi42OTUzIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIzMTgiIHgyPSI1NTkiIHkxPSI0NzIuNjk1MyIgeTI9IjQ3Mi42OTUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkiIHg9IjMyNSIgeT0iNDY3LjYyOTQiPjk8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODYiIHg9IjMzOCIgeT0iNDY3LjYyOTQiPuq1rOuPhSDtlbTsp4Ag7JqU7LKtPC90ZXh0PjxwYXRoIGQ9Ik0yMCw1MDEuNjk1MyBMODYsNTAxLjY5NTMgTDg2LDUwOC42OTUzIEw3Niw1MTguNjk1MyBMMjAsNTE4LjY5NTMgTDIwLDUwMS42OTUzICIgZmlsbD0iI0VFRUVFRSIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0ibm9uZSIgaGVpZ2h0PSI5MC4yMDMxIiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjIuMDsiIHdpZHRoPSIzMzIiIHg9IjIwIiB5PSI1MDEuNjk1MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMSIgeD0iMzUiIHk9IjUxNC43NjIyIj5hbHQ8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTEiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE2OSIgeD0iMTAxIiB5PSI1MTMuOTA1OCI+W+uNsOydtO2EsCDthrXrs7Trpbwg66qo65GQIOuniOyzpOydhCDqsr3smrBdPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMzA2LDUzNS45NjA5LDMxNiw1MzkuOTYwOSwzMDYsNTQzLjk2MDksMzEwLDUzOS45NjA5IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI1NCIgeDI9IjMxMiIgeTE9IjUzOS45NjA5IiB5Mj0iNTM5Ljk2MDkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTkiIHg9IjYxIiB5PSI1MzQuODk1Ij4xMDwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMTciIHg9Ijg0IiB5PSI1MzQuODk1Ij7rjbDsnbTthLAg7Ya167O0IOyZhOujjCDthrXrs7Qob25Db21wbGV0ZSk8L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheToyLjAsMi4wOyIgeDE9IjIwIiB4Mj0iMzUyIiB5MT0iNTQ4Ljk2MDkiIHkyPSI1NDguOTYwOSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjExIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNTgiIHg9IjI1IiB5PSI1NTkuMTcxNCI+W+yymOumrCDspJEg7JeQ65+s6rCAIOuwnOyDne2WiOydhCDqsr3smrBdPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMzA2LDU3OS44OTg0LDMxNiw1ODMuODk4NCwzMDYsNTg3Ljg5ODQsMzEwLDU4My44OTg0IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI1NCIgeDI9IjMxMiIgeTE9IjU4My44OTg0IiB5Mj0iNTgzLjg5ODQiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTgiIHg9IjYxIiB5PSI1NzguODMyNSI+MTE8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTEzIiB4PSI4MyIgeT0iNTc4LjgzMjUiPuyXkOufrCDthrXrs7Qob25FcnJvcik8L3RleHQ+PCEtLU1ENT1bZWY4OTYzYjEyMjlkZjU4NzE1MWM4YzI2MjQwZGFlMTRdCkBzdGFydHVtbA0KYWN0b3Ig7IOd7IKw7J6QIGFzIEENCmFjdG9yIOyGjOu5hOyekCBhcyBCDQpwYXJ0aWNpcGFudCDqtazrj4UgYXMgQw0KYXV0b251bWJlcg0KQiAtPiBBOiDqtazrj4Uoc3Vic2NyaWJlKQ0KQSAtPiBDOiDqtazrj4Ug6rSA6rOE7JeQIOuMgO2VnCDssLjsobAg6rCd7LK0IOyDneyDnShTdWJzY3JpcHRpb24pDQpBIC0+IEI6IOuNsOydtO2EsCDthrXrs7Qg7KSA67mEIOyZhOujjChvblN1YnNjcmliZSkNCg0KbG9vcCDthrXrs7TtlaAg642w7J207YSw6rCAIOyXhuydhCDrlYzquYzsp4ANCkIgLT4gQzog642w7J207YSwIOyalOyyrShTdWJzY3JpcHRpb24ucmVxdWVzdCkNCg0KYWx0IOq1rOuPhSDtlbTsp4Ag7IOB7YOc6rCAIOyVhOuLkCDqsr3smrANCglBIC0+IEE6IOuNsOydtO2EsCDsg53sgrANCglBIC0+IEI6IOuNsOydtO2EsCDthrXrs7Qob25OZXh0KQ0KZW5kDQoNCg0KYWx0IOyGjOu5hOyekOqwgCDqs4Tsho0g642w7J207YSw66W8IOuwm+ydhCDqsr3smrANCglCIC0+IEI6IO2GteuztOuwm+ydgCDrjbDsnbTthLDrpbwg7LKY66asDQoJQiAtPiBDOiDrjbDsnbTthLAg7JqU7LKtKFN1YnNjcmlwdGlvbi5yZXF1ZXN0KQ0KZWxzZSDqtazrj4XsnYQg7ZW07KeAIO2VmOuKlCDqsr3smrANCglCIC0+IEM6IOq1rOuPhSDtlbTsp4Ag7JqU7LKtDQplbmQNCmVuZA0KDQphbHQg642w7J207YSwIO2GteuztOulvCDrqqjrkZAg66eI7LOk7J2EIOqyveyasA0KQSAtPiBCOiDrjbDsnbTthLAg7Ya167O0IOyZhOujjCDthrXrs7Qob25Db21wbGV0ZSkNCmVsc2Ug7LKY66asIOykkSDsl5Drn6zqsIAg67Cc7IOd7ZaI7J2EIOqyveyasA0KQSAtPiBCOiDsl5Drn6wg7Ya167O0KG9uRXJyb3IpDQplbmQNCkBlbmR1bWwNCgpQbGFudFVNTCB2ZXJzaW9uIDEuMjAyMS4xMGJldGEyKFVua25vd24gY29tcGlsZSB0aW1lKQooR1BMIHNvdXJjZSBkaXN0cmlidXRpb24pCkphdmEgUnVudGltZTogSmF2YShUTSkgU0UgUnVudGltZSBFbnZpcm9ubWVudApKVk06IEphdmEgSG90U3BvdChUTSkgNjQtQml0IFNlcnZlciBWTQpEZWZhdWx0IEVuY29kaW5nOiBVVEYtOApMYW5ndWFnZTogZW4KQ291bnRyeTogVVMKLS0+PC9nPjwvc3ZnPg=='>\n\n<h3 id=\"연산자\"><a href=\"#연산자\" class=\"headerlink\" title=\"연산자\"></a>연산자</h3><p><code>map</code>, <code>flatMap</code> 및 <code>filter</code> 등과 같이 기존 Stream을 다루거나 함수형 라이브러리에서 제공해주는 연산자를 비슷하게 제공해주고 있음. 연산자별로 생성되는 Flowable/Observable의 성격이 상이한 부분이 존재하며, 또한 실행순서에 영향을 주는 연산자도 존재함.</p>\n<h4 id=\"순차-처리의-예\"><a href=\"#순차-처리의-예\" class=\"headerlink\" title=\"순차 처리의 예\"></a>순차 처리의 예</h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flowable.just(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\">    .filter &#123; it % <span class=\"number\">2</span> == <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">    .map &#123; it * <span class=\"number\">100</span> &#125;</span><br><span class=\"line\">    .subscribe &#123; println(<span class=\"string\">&quot;<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>, data: <span class=\"variable\">$it</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>[결과]<br>main, data: 200<br>main, data: 400<br>main, data: 600<br>main, data: 800<br>main, data: 1000</p>\n</blockquote>\n<h4 id=\"순차-처리가-안되는-예\"><a href=\"#순차-처리가-안되는-예\" class=\"headerlink\" title=\"순차 처리가 안되는 예\"></a>순차 처리가 안되는 예</h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flowable.just(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>)</span><br><span class=\"line\">\t.flatMap &#123;</span><br><span class=\"line\">\t\tFlowable.just(it).delay(<span class=\"number\">1000L</span>, TimeUnit.MILLISECONDS)</span><br><span class=\"line\">\t&#125;.subscribe &#123;</span><br><span class=\"line\">\t\tprintln(<span class=\"string\">&quot;<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>: <span class=\"variable\">$it</span>&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>[결과]<br>RxComputationThreadPool-3: C<br>RxComputationThreadPool-1: A<br>RxComputationThreadPool-1: B</p>\n</blockquote>\n<h3 id=\"비동기-처리\"><a href=\"#비동기-처리\" class=\"headerlink\" title=\"비동기 처리\"></a>비동기 처리</h3><p><em><strong>생산자와 소비자는 별도의 지정이 없을 경우, 메인스레드 혹은 실행 스레드에서 순차 처리 됨.</strong></em> </p>\n<p>하지만 시간 관련 Flowable/Observable 생성자의 경우, 별도의 스레드에서 실행이 되는 경우도 있음. 비동기 처리를 지정해야 할 경우 <code>생산자 측(subscribeOn())</code>과 <code>소비자 측(observeOn())</code>에 <code>스레드 스캐줄러</code>를 지정하면 되며, 스캐쥴러(<code>Schedulers</code>)의 종류는 <code>io</code>, <code>computation</code> 등이 있다.</p>\n<h3 id=\"외부-자원에-대한-참조는\"><a href=\"#외부-자원에-대한-참조는\" class=\"headerlink\" title=\"외부 자원에 대한 참조는?\"></a>외부 자원에 대한 참조는?</h3><p>생산자/소비자는 여러 스레드에서 실행이 될 수 있기 때문에, 공유 자원에 대해서 동기화 작업을 반드시 수행해줘야 한다. 이런 동기화를 피하는 가장 좋은 방법은 아래와 같다.</p>\n<ul>\n<li>순수 함수(함수형 인터페이스)의 사용<ul>\n<li>외부 자원 참조 X</li>\n<li>함수 단위로 코드를 전개하여 처리 안정성을 확보</li>\n<li>불변 객체의 사용, 큰 오버헤드가 존재하지 않으면 객체는 복사를 하여 사용하는 것이 좋다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>여러 개의 생산자/소비자가 존재 할 경우는 <code>merge</code>등의 연산자를 통하여 해당 생산자/소비자를 실행하는 스레드가 공유 자원에 대해 동기화하여 접근 할 수 있도록 할 수 있다.</p>\n</blockquote>\n<h4 id=\"공유-자원에-대한-잘못된-접근의-예\"><a href=\"#공유-자원에-대한-잘못된-접근의-예\" class=\"headerlink\" title=\"공유 자원에 대한 잘못된 접근의 예\"></a>공유 자원에 대한 잘못된 접근의 예</h4><p>아래의 2개의 생산자/소비자의 구조에서 2개의 소비자 모두 변수 <code>num</code>에 접근하여 값을 수정하고 있는데, 이는 각각의 소비자에서 스레드에 대한 적절한 동기화 없이 접근하는 안티패턴의 가장 좋은 예라고 할 수 있다. </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">0</span></span><br><span class=\"line\">Flowable.range(<span class=\"number\">1</span>, <span class=\"number\">100_000</span>)</span><br><span class=\"line\">\t.subscribeOn(Schedulers.computation())</span><br><span class=\"line\">\t.observeOn(Schedulers.computation())</span><br><span class=\"line\">\t.subscribe(</span><br><span class=\"line\">\t\t&#123; ++num &#125;,</span><br><span class=\"line\">\t\t&#123; println(<span class=\"string\">&quot;에러=<span class=\"variable\">$it</span>&quot;</span>) &#125;,</span><br><span class=\"line\">\t\t&#123; println(<span class=\"string\">&quot;counter.get()= <span class=\"variable\">$num</span>&quot;</span>) &#125;</span><br><span class=\"line\">\t)</span><br><span class=\"line\"></span><br><span class=\"line\">Flowable.range(<span class=\"number\">1</span>, <span class=\"number\">100_000</span>)</span><br><span class=\"line\">\t.subscribeOn(Schedulers.computation())</span><br><span class=\"line\">\t.observeOn(Schedulers.computation())</span><br><span class=\"line\">\t.subscribe(</span><br><span class=\"line\">\t\t&#123; ++num &#125;,</span><br><span class=\"line\">\t\t&#123; println(<span class=\"string\">&quot;에러=<span class=\"variable\">$it</span>&quot;</span>) &#125;,</span><br><span class=\"line\">\t\t&#123; println(<span class=\"string\">&quot;counter.get()= <span class=\"variable\">$num</span>&quot;</span>) &#125;</span><br><span class=\"line\">\t)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"merge-연산자를-사용한-예\"><a href=\"#merge-연산자를-사용한-예\" class=\"headerlink\" title=\"merge 연산자를 사용한 예\"></a>merge 연산자를 사용한 예</h4><p>위에서 보았던 안티패턴을 Rx에서는 스레드에 대한 동기화 처리를 진행해주는 <code>merge</code> 연산자를 사용하여 해결이 가능하다. 여러 생산자에서 발행하는 데이터의 타임라인을 하나로 만들어주며, 발행하는 순서를 아래의 그림과 같이 시간순 혹은 실행순으로 만들 수 있다.</p>\n<blockquote>\n<p>[요약] 여러 Observable의 출력을 결합하여 단일 Observable처럼 작동하도록 할 수 있다.</p>\n</blockquote>\n<p><img src=\"http://reactivex.io/documentation/operators/images/merge.png\"></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> source1 = Flowable.range(<span class=\"number\">1</span>, <span class=\"number\">100_000</span>)</span><br><span class=\"line\">\t.subscribeOn(Schedulers.computation())</span><br><span class=\"line\">\t.observeOn(Schedulers.computation())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> source2 = Flowable.range(<span class=\"number\">1</span>, <span class=\"number\">100_000</span>)</span><br><span class=\"line\">\t.subscribeOn(Schedulers.computation())</span><br><span class=\"line\">\t.observeOn(Schedulers.computation())</span><br><span class=\"line\"></span><br><span class=\"line\">Flowable</span><br><span class=\"line\">.merge(source1, source2)</span><br><span class=\"line\">.subscribe(</span><br><span class=\"line\">\t&#123; ++num &#125;,</span><br><span class=\"line\">\t&#123; println(<span class=\"string\">&quot;에러=<span class=\"variable\">$it</span>&quot;</span>) &#125;,</span><br><span class=\"line\">\t&#123; println(<span class=\"string\">&quot;counter.get()= <span class=\"variable\">$num</span>&quot;</span>) &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Flowable-vs-Observable-어떤걸-써야-하는거지\"><a href=\"#Flowable-vs-Observable-어떤걸-써야-하는거지\" class=\"headerlink\" title=\"Flowable vs Observable 어떤걸 써야 하는거지?\"></a>Flowable vs Observable 어떤걸 써야 하는거지?</h2><h3 id=\"Flowable\"><a href=\"#Flowable\" class=\"headerlink\" title=\"Flowable\"></a>Flowable</h3><ul>\n<li>대량 데이터를 처리 할 경우</li>\n<li>네트워크 통신/파일 등 IO를 처리 할 경우<h3 id=\"Observable\"><a href=\"#Observable\" class=\"headerlink\" title=\"Observable\"></a>Observable</h3></li>\n<li>GUI 이벤트</li>\n<li>소량의 데이터를 처리 할 경우</li>\n<li>자바의 Stream을 대신하여 사용할 경우</li>\n</ul>\n<p>대량의 데이터와 더불어 IO를 처리 해야 할 경우에는 <code>Flowable</code>을 사용하여 적절한 배압 정책을 적용하는 것이 유리하다. 반면에 GUI의 이벤트 처리 혹은 소량의 데이터를 처리 할 경우 배압이 없는 <code>Observable</code>을 사용하는 것이 유리하다고 한다. <code>Observable</code>은 배압 기능이 없는 만큼 <code>Flowable</code>에 비하여 오버헤드가 적은 것이 특징이다.</p>\n<blockquote>\n<p>배압 기능을 사용하면, 쏟아지는 데이터 대한 적절한 제어 뿐만 아니라 에러 처리도 할 수 있다. 물론, 다루는 데이터의 성격에 따라 달라질 수 있는 부분이지만 생산자와 소비자간의 처리 속도 차이에 따라 발생하는 데이터 유실에 대한 부분도 반드시 고려해서 배압 정책을 적용한 코드를 작성해야 한다.</p>\n</blockquote>\n"},{"title":"RxKotlin #2","date":"2019-05-07T09:09:00.000Z","_content":"\n# RxKotlin #2\n# Flowable과 Observable의 생성 연산자\n## Rx에서의 연산자 분류는?\nRxJava와 RxKotlin는 Reactive Stream 구현체에 해당하는 `Flowable`과 `Observable`을 생성 할 수 있는 다양한 연산자를 제공하고 있는데, 생성하는 연산자뿐만 아니라 `변환`, `필터`, `결합`, `상태통지`, `집계` 등의 다양한 연산자를 제공하고 있다. 다양한 연산자는 메서드체인(MethodChain) 혹은 FluentAPI 방식으로 실제 소비자에게 전달해야 하는 최종 형태의 데이터로 쉽게 변환이 가능하다. 연산자의 종류별로 기본적으로 실행하는 스레드가 달라질 수 있으며, 이에 대한 지정은 별도 스캐줄러 지정을 통하여 변경이 가능하다.\n\n연산자에 대한 자세한 분류는 [링크](http://reactivex.io/documentation/operators.html)를 통하여 확인이 가능하다. 불행한(?) 사실은 RxJava의 경우 2.0 버젼에 해당하는 문서화가 완벽하게 안되어 있음을 확인 할 수 있다. 대부분은 플로우는 다른 구현체의 마블다이어그램을 통하여 확인 할 수 있으니 크게 상관하지 않아도 될듯 싶다.\n\n## 생성 연산자\n말 그대로 Flowable과 Observable을 생성하는 연산자이다. 연산자의 종류는 아래와 같다.\n- create\n- just\n- fromArray\n- fromIterable\n- fromCallable\n- interval\n- timer\n- error\n","source":"_posts/Kotlin/Rx_Kotlin_2.md","raw":"---\ntitle: 'RxKotlin #2'\ndate: 2019.5.7. 18:09\ncategories:\n- Kotlin\n---\n\n# RxKotlin #2\n# Flowable과 Observable의 생성 연산자\n## Rx에서의 연산자 분류는?\nRxJava와 RxKotlin는 Reactive Stream 구현체에 해당하는 `Flowable`과 `Observable`을 생성 할 수 있는 다양한 연산자를 제공하고 있는데, 생성하는 연산자뿐만 아니라 `변환`, `필터`, `결합`, `상태통지`, `집계` 등의 다양한 연산자를 제공하고 있다. 다양한 연산자는 메서드체인(MethodChain) 혹은 FluentAPI 방식으로 실제 소비자에게 전달해야 하는 최종 형태의 데이터로 쉽게 변환이 가능하다. 연산자의 종류별로 기본적으로 실행하는 스레드가 달라질 수 있으며, 이에 대한 지정은 별도 스캐줄러 지정을 통하여 변경이 가능하다.\n\n연산자에 대한 자세한 분류는 [링크](http://reactivex.io/documentation/operators.html)를 통하여 확인이 가능하다. 불행한(?) 사실은 RxJava의 경우 2.0 버젼에 해당하는 문서화가 완벽하게 안되어 있음을 확인 할 수 있다. 대부분은 플로우는 다른 구현체의 마블다이어그램을 통하여 확인 할 수 있으니 크게 상관하지 않아도 될듯 싶다.\n\n## 생성 연산자\n말 그대로 Flowable과 Observable을 생성하는 연산자이다. 연산자의 종류는 아래와 같다.\n- create\n- just\n- fromArray\n- fromIterable\n- fromCallable\n- interval\n- timer\n- error\n","slug":"Kotlin/Rx_Kotlin_2","published":1,"updated":"2021-08-02T12:05:51.834Z","_id":"ckrsup50o001etjhvhrj6dd90","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"RxKotlin-2\"><a href=\"#RxKotlin-2\" class=\"headerlink\" title=\"RxKotlin #2\"></a>RxKotlin #2</h1><h1 id=\"Flowable과-Observable의-생성-연산자\"><a href=\"#Flowable과-Observable의-생성-연산자\" class=\"headerlink\" title=\"Flowable과 Observable의 생성 연산자\"></a>Flowable과 Observable의 생성 연산자</h1><h2 id=\"Rx에서의-연산자-분류는\"><a href=\"#Rx에서의-연산자-분류는\" class=\"headerlink\" title=\"Rx에서의 연산자 분류는?\"></a>Rx에서의 연산자 분류는?</h2><p>RxJava와 RxKotlin는 Reactive Stream 구현체에 해당하는 <code>Flowable</code>과 <code>Observable</code>을 생성 할 수 있는 다양한 연산자를 제공하고 있는데, 생성하는 연산자뿐만 아니라 <code>변환</code>, <code>필터</code>, <code>결합</code>, <code>상태통지</code>, <code>집계</code> 등의 다양한 연산자를 제공하고 있다. 다양한 연산자는 메서드체인(MethodChain) 혹은 FluentAPI 방식으로 실제 소비자에게 전달해야 하는 최종 형태의 데이터로 쉽게 변환이 가능하다. 연산자의 종류별로 기본적으로 실행하는 스레드가 달라질 수 있으며, 이에 대한 지정은 별도 스캐줄러 지정을 통하여 변경이 가능하다.</p>\n<p>연산자에 대한 자세한 분류는 <a href=\"http://reactivex.io/documentation/operators.html\">링크</a>를 통하여 확인이 가능하다. 불행한(?) 사실은 RxJava의 경우 2.0 버젼에 해당하는 문서화가 완벽하게 안되어 있음을 확인 할 수 있다. 대부분은 플로우는 다른 구현체의 마블다이어그램을 통하여 확인 할 수 있으니 크게 상관하지 않아도 될듯 싶다.</p>\n<h2 id=\"생성-연산자\"><a href=\"#생성-연산자\" class=\"headerlink\" title=\"생성 연산자\"></a>생성 연산자</h2><p>말 그대로 Flowable과 Observable을 생성하는 연산자이다. 연산자의 종류는 아래와 같다.</p>\n<ul>\n<li>create</li>\n<li>just</li>\n<li>fromArray</li>\n<li>fromIterable</li>\n<li>fromCallable</li>\n<li>interval</li>\n<li>timer</li>\n<li>error</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"RxKotlin-2\"><a href=\"#RxKotlin-2\" class=\"headerlink\" title=\"RxKotlin #2\"></a>RxKotlin #2</h1><h1 id=\"Flowable과-Observable의-생성-연산자\"><a href=\"#Flowable과-Observable의-생성-연산자\" class=\"headerlink\" title=\"Flowable과 Observable의 생성 연산자\"></a>Flowable과 Observable의 생성 연산자</h1><h2 id=\"Rx에서의-연산자-분류는\"><a href=\"#Rx에서의-연산자-분류는\" class=\"headerlink\" title=\"Rx에서의 연산자 분류는?\"></a>Rx에서의 연산자 분류는?</h2><p>RxJava와 RxKotlin는 Reactive Stream 구현체에 해당하는 <code>Flowable</code>과 <code>Observable</code>을 생성 할 수 있는 다양한 연산자를 제공하고 있는데, 생성하는 연산자뿐만 아니라 <code>변환</code>, <code>필터</code>, <code>결합</code>, <code>상태통지</code>, <code>집계</code> 등의 다양한 연산자를 제공하고 있다. 다양한 연산자는 메서드체인(MethodChain) 혹은 FluentAPI 방식으로 실제 소비자에게 전달해야 하는 최종 형태의 데이터로 쉽게 변환이 가능하다. 연산자의 종류별로 기본적으로 실행하는 스레드가 달라질 수 있으며, 이에 대한 지정은 별도 스캐줄러 지정을 통하여 변경이 가능하다.</p>\n<p>연산자에 대한 자세한 분류는 <a href=\"http://reactivex.io/documentation/operators.html\">링크</a>를 통하여 확인이 가능하다. 불행한(?) 사실은 RxJava의 경우 2.0 버젼에 해당하는 문서화가 완벽하게 안되어 있음을 확인 할 수 있다. 대부분은 플로우는 다른 구현체의 마블다이어그램을 통하여 확인 할 수 있으니 크게 상관하지 않아도 될듯 싶다.</p>\n<h2 id=\"생성-연산자\"><a href=\"#생성-연산자\" class=\"headerlink\" title=\"생성 연산자\"></a>생성 연산자</h2><p>말 그대로 Flowable과 Observable을 생성하는 연산자이다. 연산자의 종류는 아래와 같다.</p>\n<ul>\n<li>create</li>\n<li>just</li>\n<li>fromArray</li>\n<li>fromIterable</li>\n<li>fromCallable</li>\n<li>interval</li>\n<li>timer</li>\n<li>error</li>\n</ul>\n"},{"title":"표준함수","date":"2019-07-15T15:00:00.000Z","_content":"\n# 표준함수\n### 개요\n코틀린 코드를 보다보면 람다를 인자로 받는 `표준함수`를 사용하여 작성한 코드를 심심찮게 구경할 수 있게 된다. 표준함수를 잘 활용하면 중복으로 발생할 수 있는 코드를 많이 줄일 수 있고 여러모로 편한 부분이 존재한다. 표준함수로 널리 사용하는 `run`, `apply`, `let`, `also`, `with`, `takeIf`에 대해서 내용 정리를 해보려고 한다.\n\n위에 나열한 함수들은 코틀린의 대표적인 `확장함수`이며 확장함수를 실행하는 주체를 가리켜서 `수신자` 혹은 `수신객체`라고 한다. 수신자는 확장함수 호출 시 람다에 참조가 전달된다. \n\n### apply\n수신자 객체를 구성하는 목적으로 사용하며, 람다 내부에서 수신자에 속한 함수들을 연속적으로 호출할 수도 있다. 주로 반복되는 코드의 양을 줄이기 위해서 사용된다.\n\n```kotlin\nval menuFile = File(\"menu-file.txt\")\nmenuFile.setReadable(true)\nmenuFile.setWritable(true)\nmenuFile.setExecutable(false)\n```\n위와 같은 코드가 있다고 할때, apply를 사용하면 아래와 같이 반복되는 참조인 menuFile을 생략하여 사용할 수 있다.\n```kotlin\nval menuFile = File(\"menu-file.txt\").apply {\n\tsetReadable(true)\n\tsetWritable(true)\n\tsetExecutable(false)\n}\n```\n인자로 전달하는 람다 내부에서의 모든 함수 호출이 수신자 객체와 관련되는데, 이를 가리켜서 연관 범위 혹은 암시적 호출이라고 한다.\n\n### let\nlet 함수의 인자로 전달되는 람다를 실행한 결과를 반환한다. 이전 apply 함수와 다른 점은 apply의 경우 수신자 객체를 그대로 반환하지만 let의 경우 람다의 마지막 혹은 명시적으로 리턴한 값을 반환하게 된다.\n\n```kotlin\nval firstItemSquared = listOf(1,2,3).first().let {\n\tit * it\n}\n```\n만약 위 코드와 같이 리스트에서 첫 번째 값을 제곱해야 하는 코드가 있다고 하면 let을 사용하면 간단하게 라인 수를 줄여볼 수 있다. 만약 이러한 코드를 let을 사용안하고 사용하면 아래와 같이 작성해볼 수 있다.\n```kotlin\nval firstElement = listOf(1,2,3).first()\nval firstItemSquared = firstElement * firstElement\n```\n라인 수는 줄지 않았지만 변수 선언이 하나 늘어난 것을 볼 수 있다. 사실 let의 강력함은 null에 제어를 해야 할 상황에 있다.\n\n```kotlin\nfun formatGreeting(vipGuest: String?): String {\n\treturn vipGuest?.let {\n\t\t\"Hello $it, We Ready\"\n\t} ?: \"We Ready\"\n}\n```\n널이 가능한 변수에 대해서 엘비스 연산자와 함께 사용하는 예제인데, vipGuest의 값이 만약 null로 호출된다면 엘비스 연산자 이후 부분이 반환될것이며, 그렇지않고 문자열 값이 잘 들어온다면 let 이하의 람수 함수의 마지막 줄이 반환될 것이다.\n\n만약 let과 엘비스 연산자를 사용안하는 코드라면 아래와 if/else의 구성으로 작성해볼 수 있는데 코드의 indent가 늘어나기도 하고 다소 장황해보인다.\n```kotlin\nfun formatGreeting(vipGuest: String?): String {\n\treturn if (vipGuest != null) {\n\t\t\"Hello $it, We Ready\"\n\t} else \"We Ready\"\n}\n```\n\nlet은 어떤 종류/타입의 수신자 객체에서도 호출할 수 있으며, 위에서 설명한대로 람다의 실행 결과(리턴/마지막 라인)를 반환한다. apply와의 차이점을 다시 말하자면, apply의 경우 호출하는 수신자 객체를 전달하지 않지만, let의 경우 호출하는 수신자 객체를 참조로 전달하게 된다. \n\n```kotlin\n\"OLD\".let {\n\tit = \"NEW\" // 변경 불가능\n}\n```\n또한, let이 람다에 전달하는 수신자 객체의 인자 값은 불변으로 변경이 불가능하다.\n\n### run\n```kotlin\nval menuFile = File(\"menu-file.txt\")\nval servesDragonBreath = menuFile.run {\n\treadText().contains(\"Dragon's Beath)\n}\n```\nrun의 경우 apply와 마찬가지로 람다 내부에서 같은 접근 범위를 가진다. 차이점은 run의 경우 let과 마찬가지로 람다 본문의 마지막 라인/리턴 구문에 의하여 값이 반환된다는 점이다. \n\n```kotlin\nfun nameIsLong(name: String) = name.length >= 20\n\n\"Object\".run(::nameIsLong)\n```\n함수에 대한 참조 연산자(::)를 사용하여 인자로 전달하는 코드이다. run을 유용하게 사용할 수 있는 케이스는 아래와 같이 연속적인 함수 호출의 경우이다. \n\n```kotlin\nfun nameIsLong(name: String) = name.length >= 20\nfun playerCreateMessage(nameTooLong: Boolean): String {\n\treturn if (nameTooLong) {\n\t\t\"Too Long\"\n\t} else \"Short\"\n}\n\n\"Object\"\n.run(::nameIsLong)\n.run(::playerCreateMessage)\n.run(::println)\n```\nrun을 사용하지 않고 함수 호출을 연속적으로 해야 한다면 아래와 같이 작성해야 할 것이다.\n\n```kotlin\nprintln(playerCreateMessage(nameIsLong(\"Object\")))\n```\n\n중첩 함수 호출의 경우 코드의 가독성적인 측면에서 이해하기 어렵다고 할 수 있다. 왜냐하면 최초 호출 함수가 가장 안쪽부터 시작하기 때문에도 그렇고 호출 연산자를 중첩하여 사용하기 때문에 코드를 바로 보고 이해하기 어려울 수 있기 때문이다.\n\n### with\nwith의 경우 run과 비슷하지만, 수신 객체를 지정하여 사용한다는 차이점이 있다.\n```kotlin\nwith(\"Object\") {\n\tlength >= 20\n}\n```\nrun과 마찬가지로 람다 마지막 라인/명시적인 리턴으로 값이 반환한다.\n\n### also\nalso의 경우 let과 유사하게 작동한다. 하지만 also의 경우 람다의 결과를 반환하지 않고 수신객체 자신을 반환한다. 그렇기 때문에 also를 연속적으로 사용할 경우, 연속적으로 같은 수신객체를 참조하는 람다를 실행할 수도 있다.\n```kotlin\nvar fileContents: List<String>\nFile(\"file.txt)\n.also { println(it.name) }\n.also { fileContents = it.readLines() }\n```\n\n### takeIf\n개인적으로 아마 가장 유용하게 사용할 수 있는 확장함수라고 생각하는 `takeIf`이다. 람다에 제공된 조건식(predicate)를 실행한 후 결과에 따라 true 또는 false를 반환한다. 결과가 true이면 수신 객체가 반환되며, false일 경우 null을 반환한다. \n\n```kotlin\nval fileContents = File(\"myFile.txt\")\n\t\t.takeIf { it.canRead() && it.canWrite() }\n\t\t?.readText() ?: \"\"\n```\n위 코드에서 볼 수 있듯이, 변수에 값을 지정하는 데 어떤 조건, 또는 처리를 계속하기 전에 만족되어야 하는 조건을 검사하는 데 유용하다. if와 비슷한 개념이지만 참조변수가 필요없고 특정 객체의 함수를 직접 호출할 수 있다는 장점이 있다.\n\n### takeUnless\n`takeIf`와 반대로 실행한 결과가 `takeUnless`이다. 지정한 predicate가 false일 경우 원래 객체를 반환하며 true일 경우 null을 반환하게 된다. 코드를 이해하기 힘들 수 있으므로 `takeIf`를 사용하는 것이 차라리 나을거 같다.\n\n|함수     |수신자를 람다의 인자로 전달  |연관 범위 유무  |반환         |\n|--------|----------------------|-------------|-----------|\n| `let`    | O(it 참조)            | X           | 람다의 결과  |\n| `apply`  | X(this 참조, 생략가능)  | O           | 수신객체     |\n| `run`    | X(this 참조, 생략가능)  | O           | 람다의 결과  |\n| `with`   | X(this 참조, 생략가능)  | O           | 람다의 결과  |\n| `also`   | O(it 참조)            | X           | 수신객체    |\n| `takeIf` | O(it 참조)            | X           | 수신객체의 nullable 형태  |\n\n","source":"_posts/Kotlin/StandardFunction.md","raw":"---\ntitle: '표준함수'\ndate: 2019/7/16 00:00:00\ncategories:\n- Kotlin\n---\n\n# 표준함수\n### 개요\n코틀린 코드를 보다보면 람다를 인자로 받는 `표준함수`를 사용하여 작성한 코드를 심심찮게 구경할 수 있게 된다. 표준함수를 잘 활용하면 중복으로 발생할 수 있는 코드를 많이 줄일 수 있고 여러모로 편한 부분이 존재한다. 표준함수로 널리 사용하는 `run`, `apply`, `let`, `also`, `with`, `takeIf`에 대해서 내용 정리를 해보려고 한다.\n\n위에 나열한 함수들은 코틀린의 대표적인 `확장함수`이며 확장함수를 실행하는 주체를 가리켜서 `수신자` 혹은 `수신객체`라고 한다. 수신자는 확장함수 호출 시 람다에 참조가 전달된다. \n\n### apply\n수신자 객체를 구성하는 목적으로 사용하며, 람다 내부에서 수신자에 속한 함수들을 연속적으로 호출할 수도 있다. 주로 반복되는 코드의 양을 줄이기 위해서 사용된다.\n\n```kotlin\nval menuFile = File(\"menu-file.txt\")\nmenuFile.setReadable(true)\nmenuFile.setWritable(true)\nmenuFile.setExecutable(false)\n```\n위와 같은 코드가 있다고 할때, apply를 사용하면 아래와 같이 반복되는 참조인 menuFile을 생략하여 사용할 수 있다.\n```kotlin\nval menuFile = File(\"menu-file.txt\").apply {\n\tsetReadable(true)\n\tsetWritable(true)\n\tsetExecutable(false)\n}\n```\n인자로 전달하는 람다 내부에서의 모든 함수 호출이 수신자 객체와 관련되는데, 이를 가리켜서 연관 범위 혹은 암시적 호출이라고 한다.\n\n### let\nlet 함수의 인자로 전달되는 람다를 실행한 결과를 반환한다. 이전 apply 함수와 다른 점은 apply의 경우 수신자 객체를 그대로 반환하지만 let의 경우 람다의 마지막 혹은 명시적으로 리턴한 값을 반환하게 된다.\n\n```kotlin\nval firstItemSquared = listOf(1,2,3).first().let {\n\tit * it\n}\n```\n만약 위 코드와 같이 리스트에서 첫 번째 값을 제곱해야 하는 코드가 있다고 하면 let을 사용하면 간단하게 라인 수를 줄여볼 수 있다. 만약 이러한 코드를 let을 사용안하고 사용하면 아래와 같이 작성해볼 수 있다.\n```kotlin\nval firstElement = listOf(1,2,3).first()\nval firstItemSquared = firstElement * firstElement\n```\n라인 수는 줄지 않았지만 변수 선언이 하나 늘어난 것을 볼 수 있다. 사실 let의 강력함은 null에 제어를 해야 할 상황에 있다.\n\n```kotlin\nfun formatGreeting(vipGuest: String?): String {\n\treturn vipGuest?.let {\n\t\t\"Hello $it, We Ready\"\n\t} ?: \"We Ready\"\n}\n```\n널이 가능한 변수에 대해서 엘비스 연산자와 함께 사용하는 예제인데, vipGuest의 값이 만약 null로 호출된다면 엘비스 연산자 이후 부분이 반환될것이며, 그렇지않고 문자열 값이 잘 들어온다면 let 이하의 람수 함수의 마지막 줄이 반환될 것이다.\n\n만약 let과 엘비스 연산자를 사용안하는 코드라면 아래와 if/else의 구성으로 작성해볼 수 있는데 코드의 indent가 늘어나기도 하고 다소 장황해보인다.\n```kotlin\nfun formatGreeting(vipGuest: String?): String {\n\treturn if (vipGuest != null) {\n\t\t\"Hello $it, We Ready\"\n\t} else \"We Ready\"\n}\n```\n\nlet은 어떤 종류/타입의 수신자 객체에서도 호출할 수 있으며, 위에서 설명한대로 람다의 실행 결과(리턴/마지막 라인)를 반환한다. apply와의 차이점을 다시 말하자면, apply의 경우 호출하는 수신자 객체를 전달하지 않지만, let의 경우 호출하는 수신자 객체를 참조로 전달하게 된다. \n\n```kotlin\n\"OLD\".let {\n\tit = \"NEW\" // 변경 불가능\n}\n```\n또한, let이 람다에 전달하는 수신자 객체의 인자 값은 불변으로 변경이 불가능하다.\n\n### run\n```kotlin\nval menuFile = File(\"menu-file.txt\")\nval servesDragonBreath = menuFile.run {\n\treadText().contains(\"Dragon's Beath)\n}\n```\nrun의 경우 apply와 마찬가지로 람다 내부에서 같은 접근 범위를 가진다. 차이점은 run의 경우 let과 마찬가지로 람다 본문의 마지막 라인/리턴 구문에 의하여 값이 반환된다는 점이다. \n\n```kotlin\nfun nameIsLong(name: String) = name.length >= 20\n\n\"Object\".run(::nameIsLong)\n```\n함수에 대한 참조 연산자(::)를 사용하여 인자로 전달하는 코드이다. run을 유용하게 사용할 수 있는 케이스는 아래와 같이 연속적인 함수 호출의 경우이다. \n\n```kotlin\nfun nameIsLong(name: String) = name.length >= 20\nfun playerCreateMessage(nameTooLong: Boolean): String {\n\treturn if (nameTooLong) {\n\t\t\"Too Long\"\n\t} else \"Short\"\n}\n\n\"Object\"\n.run(::nameIsLong)\n.run(::playerCreateMessage)\n.run(::println)\n```\nrun을 사용하지 않고 함수 호출을 연속적으로 해야 한다면 아래와 같이 작성해야 할 것이다.\n\n```kotlin\nprintln(playerCreateMessage(nameIsLong(\"Object\")))\n```\n\n중첩 함수 호출의 경우 코드의 가독성적인 측면에서 이해하기 어렵다고 할 수 있다. 왜냐하면 최초 호출 함수가 가장 안쪽부터 시작하기 때문에도 그렇고 호출 연산자를 중첩하여 사용하기 때문에 코드를 바로 보고 이해하기 어려울 수 있기 때문이다.\n\n### with\nwith의 경우 run과 비슷하지만, 수신 객체를 지정하여 사용한다는 차이점이 있다.\n```kotlin\nwith(\"Object\") {\n\tlength >= 20\n}\n```\nrun과 마찬가지로 람다 마지막 라인/명시적인 리턴으로 값이 반환한다.\n\n### also\nalso의 경우 let과 유사하게 작동한다. 하지만 also의 경우 람다의 결과를 반환하지 않고 수신객체 자신을 반환한다. 그렇기 때문에 also를 연속적으로 사용할 경우, 연속적으로 같은 수신객체를 참조하는 람다를 실행할 수도 있다.\n```kotlin\nvar fileContents: List<String>\nFile(\"file.txt)\n.also { println(it.name) }\n.also { fileContents = it.readLines() }\n```\n\n### takeIf\n개인적으로 아마 가장 유용하게 사용할 수 있는 확장함수라고 생각하는 `takeIf`이다. 람다에 제공된 조건식(predicate)를 실행한 후 결과에 따라 true 또는 false를 반환한다. 결과가 true이면 수신 객체가 반환되며, false일 경우 null을 반환한다. \n\n```kotlin\nval fileContents = File(\"myFile.txt\")\n\t\t.takeIf { it.canRead() && it.canWrite() }\n\t\t?.readText() ?: \"\"\n```\n위 코드에서 볼 수 있듯이, 변수에 값을 지정하는 데 어떤 조건, 또는 처리를 계속하기 전에 만족되어야 하는 조건을 검사하는 데 유용하다. if와 비슷한 개념이지만 참조변수가 필요없고 특정 객체의 함수를 직접 호출할 수 있다는 장점이 있다.\n\n### takeUnless\n`takeIf`와 반대로 실행한 결과가 `takeUnless`이다. 지정한 predicate가 false일 경우 원래 객체를 반환하며 true일 경우 null을 반환하게 된다. 코드를 이해하기 힘들 수 있으므로 `takeIf`를 사용하는 것이 차라리 나을거 같다.\n\n|함수     |수신자를 람다의 인자로 전달  |연관 범위 유무  |반환         |\n|--------|----------------------|-------------|-----------|\n| `let`    | O(it 참조)            | X           | 람다의 결과  |\n| `apply`  | X(this 참조, 생략가능)  | O           | 수신객체     |\n| `run`    | X(this 참조, 생략가능)  | O           | 람다의 결과  |\n| `with`   | X(this 참조, 생략가능)  | O           | 람다의 결과  |\n| `also`   | O(it 참조)            | X           | 수신객체    |\n| `takeIf` | O(it 참조)            | X           | 수신객체의 nullable 형태  |\n\n","slug":"Kotlin/StandardFunction","published":1,"updated":"2021-08-02T12:26:29.300Z","_id":"ckrsup50p001ftjhvc5y9azw1","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"표준함수\"><a href=\"#표준함수\" class=\"headerlink\" title=\"표준함수\"></a>표준함수</h1><h3 id=\"개요\"><a href=\"#개요\" class=\"headerlink\" title=\"개요\"></a>개요</h3><p>코틀린 코드를 보다보면 람다를 인자로 받는 <code>표준함수</code>를 사용하여 작성한 코드를 심심찮게 구경할 수 있게 된다. 표준함수를 잘 활용하면 중복으로 발생할 수 있는 코드를 많이 줄일 수 있고 여러모로 편한 부분이 존재한다. 표준함수로 널리 사용하는 <code>run</code>, <code>apply</code>, <code>let</code>, <code>also</code>, <code>with</code>, <code>takeIf</code>에 대해서 내용 정리를 해보려고 한다.</p>\n<p>위에 나열한 함수들은 코틀린의 대표적인 <code>확장함수</code>이며 확장함수를 실행하는 주체를 가리켜서 <code>수신자</code> 혹은 <code>수신객체</code>라고 한다. 수신자는 확장함수 호출 시 람다에 참조가 전달된다. </p>\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><p>수신자 객체를 구성하는 목적으로 사용하며, 람다 내부에서 수신자에 속한 함수들을 연속적으로 호출할 수도 있다. 주로 반복되는 코드의 양을 줄이기 위해서 사용된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> menuFile = File(<span class=\"string\">&quot;menu-file.txt&quot;</span>)</span><br><span class=\"line\">menuFile.setReadable(<span class=\"literal\">true</span>)</span><br><span class=\"line\">menuFile.setWritable(<span class=\"literal\">true</span>)</span><br><span class=\"line\">menuFile.setExecutable(<span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure>\n<p>위와 같은 코드가 있다고 할때, apply를 사용하면 아래와 같이 반복되는 참조인 menuFile을 생략하여 사용할 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> menuFile = File(<span class=\"string\">&quot;menu-file.txt&quot;</span>).apply &#123;</span><br><span class=\"line\">\tsetReadable(<span class=\"literal\">true</span>)</span><br><span class=\"line\">\tsetWritable(<span class=\"literal\">true</span>)</span><br><span class=\"line\">\tsetExecutable(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>인자로 전달하는 람다 내부에서의 모든 함수 호출이 수신자 객체와 관련되는데, 이를 가리켜서 연관 범위 혹은 암시적 호출이라고 한다.</p>\n<h3 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h3><p>let 함수의 인자로 전달되는 람다를 실행한 결과를 반환한다. 이전 apply 함수와 다른 점은 apply의 경우 수신자 객체를 그대로 반환하지만 let의 경우 람다의 마지막 혹은 명시적으로 리턴한 값을 반환하게 된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> firstItemSquared = listOf(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>).first().let &#123;</span><br><span class=\"line\">\tit * it</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>만약 위 코드와 같이 리스트에서 첫 번째 값을 제곱해야 하는 코드가 있다고 하면 let을 사용하면 간단하게 라인 수를 줄여볼 수 있다. 만약 이러한 코드를 let을 사용안하고 사용하면 아래와 같이 작성해볼 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> firstElement = listOf(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>).first()</span><br><span class=\"line\"><span class=\"keyword\">val</span> firstItemSquared = firstElement * firstElement</span><br></pre></td></tr></table></figure>\n<p>라인 수는 줄지 않았지만 변수 선언이 하나 늘어난 것을 볼 수 있다. 사실 let의 강력함은 null에 제어를 해야 할 상황에 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">formatGreeting</span><span class=\"params\">(vipGuest: <span class=\"type\">String</span>?)</span></span>: String &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> vipGuest?.let &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;Hello <span class=\"variable\">$it</span>, We Ready&quot;</span></span><br><span class=\"line\">\t&#125; ?: <span class=\"string\">&quot;We Ready&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>널이 가능한 변수에 대해서 엘비스 연산자와 함께 사용하는 예제인데, vipGuest의 값이 만약 null로 호출된다면 엘비스 연산자 이후 부분이 반환될것이며, 그렇지않고 문자열 값이 잘 들어온다면 let 이하의 람수 함수의 마지막 줄이 반환될 것이다.</p>\n<p>만약 let과 엘비스 연산자를 사용안하는 코드라면 아래와 if/else의 구성으로 작성해볼 수 있는데 코드의 indent가 늘어나기도 하고 다소 장황해보인다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">formatGreeting</span><span class=\"params\">(vipGuest: <span class=\"type\">String</span>?)</span></span>: String &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">if</span> (vipGuest != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;Hello <span class=\"variable\">$it</span>, We Ready&quot;</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"string\">&quot;We Ready&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>let은 어떤 종류/타입의 수신자 객체에서도 호출할 수 있으며, 위에서 설명한대로 람다의 실행 결과(리턴/마지막 라인)를 반환한다. apply와의 차이점을 다시 말하자면, apply의 경우 호출하는 수신자 객체를 전달하지 않지만, let의 경우 호출하는 수신자 객체를 참조로 전달하게 된다. </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;OLD&quot;</span>.let &#123;</span><br><span class=\"line\">\tit = <span class=\"string\">&quot;NEW&quot;</span> <span class=\"comment\">// 변경 불가능</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>또한, let이 람다에 전달하는 수신자 객체의 인자 값은 불변으로 변경이 불가능하다.</p>\n<h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> menuFile = File(<span class=\"string\">&quot;menu-file.txt&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> servesDragonBreath = menuFile.run &#123;</span><br><span class=\"line\">\treadText().contains(<span class=\"string\">&quot;Dragon&#x27;s Beath)</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>run의 경우 apply와 마찬가지로 람다 내부에서 같은 접근 범위를 가진다. 차이점은 run의 경우 let과 마찬가지로 람다 본문의 마지막 라인/리턴 구문에 의하여 값이 반환된다는 점이다. </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">nameIsLong</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> = name.length &gt;= <span class=\"number\">20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Object&quot;</span>.run(::nameIsLong)</span><br></pre></td></tr></table></figure>\n<p>함수에 대한 참조 연산자(::)를 사용하여 인자로 전달하는 코드이다. run을 유용하게 사용할 수 있는 케이스는 아래와 같이 연속적인 함수 호출의 경우이다. </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">nameIsLong</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> = name.length &gt;= <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">playerCreateMessage</span><span class=\"params\">(nameTooLong: <span class=\"type\">Boolean</span>)</span></span>: String &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">if</span> (nameTooLong) &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;Too Long&quot;</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"string\">&quot;Short&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Object&quot;</span></span><br><span class=\"line\">.run(::nameIsLong)</span><br><span class=\"line\">.run(::playerCreateMessage)</span><br><span class=\"line\">.run(::println)</span><br></pre></td></tr></table></figure>\n<p>run을 사용하지 않고 함수 호출을 연속적으로 해야 한다면 아래와 같이 작성해야 할 것이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(playerCreateMessage(nameIsLong(<span class=\"string\">&quot;Object&quot;</span>)))</span><br></pre></td></tr></table></figure>\n\n<p>중첩 함수 호출의 경우 코드의 가독성적인 측면에서 이해하기 어렵다고 할 수 있다. 왜냐하면 최초 호출 함수가 가장 안쪽부터 시작하기 때문에도 그렇고 호출 연산자를 중첩하여 사용하기 때문에 코드를 바로 보고 이해하기 어려울 수 있기 때문이다.</p>\n<h3 id=\"with\"><a href=\"#with\" class=\"headerlink\" title=\"with\"></a>with</h3><p>with의 경우 run과 비슷하지만, 수신 객체를 지정하여 사용한다는 차이점이 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with(<span class=\"string\">&quot;Object&quot;</span>) &#123;</span><br><span class=\"line\">\tlength &gt;= <span class=\"number\">20</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>run과 마찬가지로 람다 마지막 라인/명시적인 리턴으로 값이 반환한다.</p>\n<h3 id=\"also\"><a href=\"#also\" class=\"headerlink\" title=\"also\"></a>also</h3><p>also의 경우 let과 유사하게 작동한다. 하지만 also의 경우 람다의 결과를 반환하지 않고 수신객체 자신을 반환한다. 그렇기 때문에 also를 연속적으로 사용할 경우, 연속적으로 같은 수신객체를 참조하는 람다를 실행할 수도 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fileContents: List&lt;String&gt;</span><br><span class=\"line\">File(<span class=\"string\">&quot;file.txt)</span></span><br><span class=\"line\"><span class=\"string\">.also &#123; println(it.name) &#125;</span></span><br><span class=\"line\"><span class=\"string\">.also &#123; fileContents = it.readLines() &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"takeIf\"><a href=\"#takeIf\" class=\"headerlink\" title=\"takeIf\"></a>takeIf</h3><p>개인적으로 아마 가장 유용하게 사용할 수 있는 확장함수라고 생각하는 <code>takeIf</code>이다. 람다에 제공된 조건식(predicate)를 실행한 후 결과에 따라 true 또는 false를 반환한다. 결과가 true이면 수신 객체가 반환되며, false일 경우 null을 반환한다. </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> fileContents = File(<span class=\"string\">&quot;myFile.txt&quot;</span>)</span><br><span class=\"line\">\t\t.takeIf &#123; it.canRead() &amp;&amp; it.canWrite() &#125;</span><br><span class=\"line\">\t\t?.readText() ?: <span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n<p>위 코드에서 볼 수 있듯이, 변수에 값을 지정하는 데 어떤 조건, 또는 처리를 계속하기 전에 만족되어야 하는 조건을 검사하는 데 유용하다. if와 비슷한 개념이지만 참조변수가 필요없고 특정 객체의 함수를 직접 호출할 수 있다는 장점이 있다.</p>\n<h3 id=\"takeUnless\"><a href=\"#takeUnless\" class=\"headerlink\" title=\"takeUnless\"></a>takeUnless</h3><p><code>takeIf</code>와 반대로 실행한 결과가 <code>takeUnless</code>이다. 지정한 predicate가 false일 경우 원래 객체를 반환하며 true일 경우 null을 반환하게 된다. 코드를 이해하기 힘들 수 있으므로 <code>takeIf</code>를 사용하는 것이 차라리 나을거 같다.</p>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>수신자를 람다의 인자로 전달</th>\n<th>연관 범위 유무</th>\n<th>반환</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>let</code></td>\n<td>O(it 참조)</td>\n<td>X</td>\n<td>람다의 결과</td>\n</tr>\n<tr>\n<td><code>apply</code></td>\n<td>X(this 참조, 생략가능)</td>\n<td>O</td>\n<td>수신객체</td>\n</tr>\n<tr>\n<td><code>run</code></td>\n<td>X(this 참조, 생략가능)</td>\n<td>O</td>\n<td>람다의 결과</td>\n</tr>\n<tr>\n<td><code>with</code></td>\n<td>X(this 참조, 생략가능)</td>\n<td>O</td>\n<td>람다의 결과</td>\n</tr>\n<tr>\n<td><code>also</code></td>\n<td>O(it 참조)</td>\n<td>X</td>\n<td>수신객체</td>\n</tr>\n<tr>\n<td><code>takeIf</code></td>\n<td>O(it 참조)</td>\n<td>X</td>\n<td>수신객체의 nullable 형태</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"표준함수\"><a href=\"#표준함수\" class=\"headerlink\" title=\"표준함수\"></a>표준함수</h1><h3 id=\"개요\"><a href=\"#개요\" class=\"headerlink\" title=\"개요\"></a>개요</h3><p>코틀린 코드를 보다보면 람다를 인자로 받는 <code>표준함수</code>를 사용하여 작성한 코드를 심심찮게 구경할 수 있게 된다. 표준함수를 잘 활용하면 중복으로 발생할 수 있는 코드를 많이 줄일 수 있고 여러모로 편한 부분이 존재한다. 표준함수로 널리 사용하는 <code>run</code>, <code>apply</code>, <code>let</code>, <code>also</code>, <code>with</code>, <code>takeIf</code>에 대해서 내용 정리를 해보려고 한다.</p>\n<p>위에 나열한 함수들은 코틀린의 대표적인 <code>확장함수</code>이며 확장함수를 실행하는 주체를 가리켜서 <code>수신자</code> 혹은 <code>수신객체</code>라고 한다. 수신자는 확장함수 호출 시 람다에 참조가 전달된다. </p>\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><p>수신자 객체를 구성하는 목적으로 사용하며, 람다 내부에서 수신자에 속한 함수들을 연속적으로 호출할 수도 있다. 주로 반복되는 코드의 양을 줄이기 위해서 사용된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> menuFile = File(<span class=\"string\">&quot;menu-file.txt&quot;</span>)</span><br><span class=\"line\">menuFile.setReadable(<span class=\"literal\">true</span>)</span><br><span class=\"line\">menuFile.setWritable(<span class=\"literal\">true</span>)</span><br><span class=\"line\">menuFile.setExecutable(<span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure>\n<p>위와 같은 코드가 있다고 할때, apply를 사용하면 아래와 같이 반복되는 참조인 menuFile을 생략하여 사용할 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> menuFile = File(<span class=\"string\">&quot;menu-file.txt&quot;</span>).apply &#123;</span><br><span class=\"line\">\tsetReadable(<span class=\"literal\">true</span>)</span><br><span class=\"line\">\tsetWritable(<span class=\"literal\">true</span>)</span><br><span class=\"line\">\tsetExecutable(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>인자로 전달하는 람다 내부에서의 모든 함수 호출이 수신자 객체와 관련되는데, 이를 가리켜서 연관 범위 혹은 암시적 호출이라고 한다.</p>\n<h3 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h3><p>let 함수의 인자로 전달되는 람다를 실행한 결과를 반환한다. 이전 apply 함수와 다른 점은 apply의 경우 수신자 객체를 그대로 반환하지만 let의 경우 람다의 마지막 혹은 명시적으로 리턴한 값을 반환하게 된다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> firstItemSquared = listOf(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>).first().let &#123;</span><br><span class=\"line\">\tit * it</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>만약 위 코드와 같이 리스트에서 첫 번째 값을 제곱해야 하는 코드가 있다고 하면 let을 사용하면 간단하게 라인 수를 줄여볼 수 있다. 만약 이러한 코드를 let을 사용안하고 사용하면 아래와 같이 작성해볼 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> firstElement = listOf(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>).first()</span><br><span class=\"line\"><span class=\"keyword\">val</span> firstItemSquared = firstElement * firstElement</span><br></pre></td></tr></table></figure>\n<p>라인 수는 줄지 않았지만 변수 선언이 하나 늘어난 것을 볼 수 있다. 사실 let의 강력함은 null에 제어를 해야 할 상황에 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">formatGreeting</span><span class=\"params\">(vipGuest: <span class=\"type\">String</span>?)</span></span>: String &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> vipGuest?.let &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;Hello <span class=\"variable\">$it</span>, We Ready&quot;</span></span><br><span class=\"line\">\t&#125; ?: <span class=\"string\">&quot;We Ready&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>널이 가능한 변수에 대해서 엘비스 연산자와 함께 사용하는 예제인데, vipGuest의 값이 만약 null로 호출된다면 엘비스 연산자 이후 부분이 반환될것이며, 그렇지않고 문자열 값이 잘 들어온다면 let 이하의 람수 함수의 마지막 줄이 반환될 것이다.</p>\n<p>만약 let과 엘비스 연산자를 사용안하는 코드라면 아래와 if/else의 구성으로 작성해볼 수 있는데 코드의 indent가 늘어나기도 하고 다소 장황해보인다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">formatGreeting</span><span class=\"params\">(vipGuest: <span class=\"type\">String</span>?)</span></span>: String &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">if</span> (vipGuest != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;Hello <span class=\"variable\">$it</span>, We Ready&quot;</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"string\">&quot;We Ready&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>let은 어떤 종류/타입의 수신자 객체에서도 호출할 수 있으며, 위에서 설명한대로 람다의 실행 결과(리턴/마지막 라인)를 반환한다. apply와의 차이점을 다시 말하자면, apply의 경우 호출하는 수신자 객체를 전달하지 않지만, let의 경우 호출하는 수신자 객체를 참조로 전달하게 된다. </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;OLD&quot;</span>.let &#123;</span><br><span class=\"line\">\tit = <span class=\"string\">&quot;NEW&quot;</span> <span class=\"comment\">// 변경 불가능</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>또한, let이 람다에 전달하는 수신자 객체의 인자 값은 불변으로 변경이 불가능하다.</p>\n<h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> menuFile = File(<span class=\"string\">&quot;menu-file.txt&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> servesDragonBreath = menuFile.run &#123;</span><br><span class=\"line\">\treadText().contains(<span class=\"string\">&quot;Dragon&#x27;s Beath)</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>run의 경우 apply와 마찬가지로 람다 내부에서 같은 접근 범위를 가진다. 차이점은 run의 경우 let과 마찬가지로 람다 본문의 마지막 라인/리턴 구문에 의하여 값이 반환된다는 점이다. </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">nameIsLong</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> = name.length &gt;= <span class=\"number\">20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Object&quot;</span>.run(::nameIsLong)</span><br></pre></td></tr></table></figure>\n<p>함수에 대한 참조 연산자(::)를 사용하여 인자로 전달하는 코드이다. run을 유용하게 사용할 수 있는 케이스는 아래와 같이 연속적인 함수 호출의 경우이다. </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">nameIsLong</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span> = name.length &gt;= <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">playerCreateMessage</span><span class=\"params\">(nameTooLong: <span class=\"type\">Boolean</span>)</span></span>: String &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">if</span> (nameTooLong) &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;Too Long&quot;</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"string\">&quot;Short&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;Object&quot;</span></span><br><span class=\"line\">.run(::nameIsLong)</span><br><span class=\"line\">.run(::playerCreateMessage)</span><br><span class=\"line\">.run(::println)</span><br></pre></td></tr></table></figure>\n<p>run을 사용하지 않고 함수 호출을 연속적으로 해야 한다면 아래와 같이 작성해야 할 것이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(playerCreateMessage(nameIsLong(<span class=\"string\">&quot;Object&quot;</span>)))</span><br></pre></td></tr></table></figure>\n\n<p>중첩 함수 호출의 경우 코드의 가독성적인 측면에서 이해하기 어렵다고 할 수 있다. 왜냐하면 최초 호출 함수가 가장 안쪽부터 시작하기 때문에도 그렇고 호출 연산자를 중첩하여 사용하기 때문에 코드를 바로 보고 이해하기 어려울 수 있기 때문이다.</p>\n<h3 id=\"with\"><a href=\"#with\" class=\"headerlink\" title=\"with\"></a>with</h3><p>with의 경우 run과 비슷하지만, 수신 객체를 지정하여 사용한다는 차이점이 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with(<span class=\"string\">&quot;Object&quot;</span>) &#123;</span><br><span class=\"line\">\tlength &gt;= <span class=\"number\">20</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>run과 마찬가지로 람다 마지막 라인/명시적인 리턴으로 값이 반환한다.</p>\n<h3 id=\"also\"><a href=\"#also\" class=\"headerlink\" title=\"also\"></a>also</h3><p>also의 경우 let과 유사하게 작동한다. 하지만 also의 경우 람다의 결과를 반환하지 않고 수신객체 자신을 반환한다. 그렇기 때문에 also를 연속적으로 사용할 경우, 연속적으로 같은 수신객체를 참조하는 람다를 실행할 수도 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fileContents: List&lt;String&gt;</span><br><span class=\"line\">File(<span class=\"string\">&quot;file.txt)</span></span><br><span class=\"line\"><span class=\"string\">.also &#123; println(it.name) &#125;</span></span><br><span class=\"line\"><span class=\"string\">.also &#123; fileContents = it.readLines() &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"takeIf\"><a href=\"#takeIf\" class=\"headerlink\" title=\"takeIf\"></a>takeIf</h3><p>개인적으로 아마 가장 유용하게 사용할 수 있는 확장함수라고 생각하는 <code>takeIf</code>이다. 람다에 제공된 조건식(predicate)를 실행한 후 결과에 따라 true 또는 false를 반환한다. 결과가 true이면 수신 객체가 반환되며, false일 경우 null을 반환한다. </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> fileContents = File(<span class=\"string\">&quot;myFile.txt&quot;</span>)</span><br><span class=\"line\">\t\t.takeIf &#123; it.canRead() &amp;&amp; it.canWrite() &#125;</span><br><span class=\"line\">\t\t?.readText() ?: <span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n<p>위 코드에서 볼 수 있듯이, 변수에 값을 지정하는 데 어떤 조건, 또는 처리를 계속하기 전에 만족되어야 하는 조건을 검사하는 데 유용하다. if와 비슷한 개념이지만 참조변수가 필요없고 특정 객체의 함수를 직접 호출할 수 있다는 장점이 있다.</p>\n<h3 id=\"takeUnless\"><a href=\"#takeUnless\" class=\"headerlink\" title=\"takeUnless\"></a>takeUnless</h3><p><code>takeIf</code>와 반대로 실행한 결과가 <code>takeUnless</code>이다. 지정한 predicate가 false일 경우 원래 객체를 반환하며 true일 경우 null을 반환하게 된다. 코드를 이해하기 힘들 수 있으므로 <code>takeIf</code>를 사용하는 것이 차라리 나을거 같다.</p>\n<table>\n<thead>\n<tr>\n<th>함수</th>\n<th>수신자를 람다의 인자로 전달</th>\n<th>연관 범위 유무</th>\n<th>반환</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>let</code></td>\n<td>O(it 참조)</td>\n<td>X</td>\n<td>람다의 결과</td>\n</tr>\n<tr>\n<td><code>apply</code></td>\n<td>X(this 참조, 생략가능)</td>\n<td>O</td>\n<td>수신객체</td>\n</tr>\n<tr>\n<td><code>run</code></td>\n<td>X(this 참조, 생략가능)</td>\n<td>O</td>\n<td>람다의 결과</td>\n</tr>\n<tr>\n<td><code>with</code></td>\n<td>X(this 참조, 생략가능)</td>\n<td>O</td>\n<td>람다의 결과</td>\n</tr>\n<tr>\n<td><code>also</code></td>\n<td>O(it 참조)</td>\n<td>X</td>\n<td>수신객체</td>\n</tr>\n<tr>\n<td><code>takeIf</code></td>\n<td>O(it 참조)</td>\n<td>X</td>\n<td>수신객체의 nullable 형태</td>\n</tr>\n</tbody></table>\n"},{"title":"Kotlin With Java","date":"2019-08-09T15:00:00.000Z","_content":"\n# Kotlin With Java\n\n### 개요\nJVM에서의 코틀린 코드는 자바 바이트코드로 컴파일이 된다. 이 말인 즉슨, 기존 자바 프로젝트와 같이 공존할 수 있다는 이야기이며, 또한 기존 자바 코드를 코틀린으로 서서히 이전할 수도 있다는 이야기이다. 상호운용 시, 기존 자바 대비 향상된 코틀린의 기능을 포기해야 되는 상황을 우려 할 수 있는데, 코틀린은 상호운용이 가능하도록 언어가 만들어졌기 때문에 이에 대한 걱정은 할 필요가 없다고 할 수 있다. \n\n상호운용 시, 각 언어의 차이점을 이해하고 이를 극복할 수 있는 메타 어노테이션을 잘 활용하면 충분히 가능한 일이다. 어노테이션은 클래스, 인터페이스, 함수, 매개변수, 속성, 생성자, 표현식 등에 상태 혹은 메타 데이터를 표현하는 목적으로 사용되며 특히 코틀린 그리고 자바 상호운용 관련된 어노테이션의 경우 코틀린 컴파일러가 컴파일 시 사용하게 된다. 이에 대한 적절한 학습 그리고 차이점을 이해한다면 상호운용도 어렵지 않게 해낼 수 있다.\n\n### null 관련 처리\n자바의 모든 객체는 null이 될 수 있다. 하지만, 코틀린에서 자바 코드를 사용하게 될때 이에 대한 정보를 알 수 없기 때문에 각별한 주의가 필요한 부분이다. 다시 말해, 자바에서 반환되는 null에 대한 정보를 코틀린 컴파일러가 알 수 없다. 상호 운용을 하게 된다면 이에 대한 적절한 조치가 필요해보인다. 이처럼, 코틀린에서 사용하는 자바의 변수의 null 상태를 알 수 없을때 이를 가리켜서 플랫폼 변수라고 부른다. String을 예로 들어 살펴보자면, 코틀린에서는 String이 크게 String, String?으로 나뉠 수 있는데, 자바에서 넘어오게 되는 변수에 대해서 null에 대한 정보가 없다면 이를 String!로 나타내게 된다. 여기서 String!가 바로 플랫폼 변수이다. \n\n```java\npublic class Jhava {\n\tpublic String utterGreeting() {\n\t\treturn \"BLARGH\";\n\t}\n\n\tpublic String determineFriendShipLevel() {\n\t\treturn null;\n\t}\n}\n```\n\n```kotlin\nfun main(args: Array<String>) {\n\tval adversary = Jhava()\n\tprintln(adversary.utterGreeting())\n\n\tval friendshipLevel = adversary.determineFriendShipLevel()\n\tprintln(friendshipLevel.toLowerCase())\n}\n```\n\n위와 같이 상호운용하는 상황이 있다면, 자바 코드를 호출하는 코틀린 코드의 결과는 아래와 같다.\n```\nException in thread \"main\"\njava.lang.IllegalStateException: friendshipLevel must not be null\n```\n\n위에서 설명한것처럼 자바 코드에서 발생하는 null에 대한 정보를 코틀린 컴파일러가 알수 없기 때문에 발생한 것이다. 이를 막기 위해서는 자바 코드에 null과 관련된 정보를 심어줘어하는데, 이때 사용하는 것이 바로 `@Nullable`이다. 해당 어노테이션을 지정하게 되면 코틀린 컴파일러는 null 값을 반환할 수 있다는 정보를 알 수 있게 되어 반환 타입을 `String?`으로 간주하게 된다.\n\n```java\npublic class Jhava {\n\tpublic String utterGreeting() {\n\t\treturn \"BLARGH\";\n\t}\n\n\t@Nullable\n\tpublic String determineFriendShipLevel() {\n\t\treturn null;\n\t}\n}\n```\n\n```kotlin\nfun main(args: Array<String>) {\n\tval adversary = Jhava()\n\tprintln(adversary.utterGreeting())\n\n\tval friendshipLevel = adversary.determineFriendShipLevel()\n\tprintln(friendshipLevel?.toLowerCase() ?: \"Null 처리\")\n}\n```\n\n`@Nullable`과 반대로 `@NotNull`을 사용하게 되면 절대로 null 값을 반환하지 않는다는 것을 알려줄 수 있다.\n\n```java\npublic class Jhava {\n\t@NotNull\n\tpublic String utterGreeting() {\n\t\treturn \"BLARGH\";\n\t}\n}\n```\n\nNull 관련 어노테이션은 함수/메서드의 반환값, 매개변수, 필드에 사용될 수 있다.\n\n### 타입 매핑\n코틀린의 타입은 자바 타입과 일대일로 매핑된다. 하지만, 코틀린과 자바 간에 일대일로 매핑되지 않는 타입들도 존재하는데, 기본 타입의 경우 자바에서는 내장 키워드를 통하여 기본 데이터 타입을 가리키는데 이헤 반해 코틀린은 기본 타입을 포함하여 모든 타입이 객체이다. 코틀린 컴파일러가 자바 기본 타입을 가장 유사한 코틀린 타입으로 매핑시켜 준다. \n\n```java\npublic class Jhava {\n\tpublic int hitPoints = 52489112;\n}\n```\n\n```kotlin\nfun main(args: Array<String>) {\n\tval adversary = Jhava()\n\tval adversaryHitPoints: Int = adversary.hitPoints\n}\n```\n자바에서는 int로 정의 되어 있지만, 코틀린 코드에서는 Int 타입으로 참조해도 아무 문제가 없는 것을 확인 할 수 있다.(타입 추론 가능하다.) 자바에서는 기본 타입에 대하여 메소드 호출을 할 수 없지만, 코틀린에서는 Int로 변환이 되기 때문에 Int 클래스에 정의되어 있는 메서드를 사용할 수 있다. 이 밖에도 실제 자바 바이트코드로 변환 시, 성능 향상을 위해 상황에 따라 자동으로 자바 기본 타입으로 매핑시켜준다.\n\n","source":"_posts/Kotlin/WithJava.md","raw":"---\ntitle: 'Kotlin With Java'\ndate: 2019/8/10 00:00:00\ncategories:\n- Kotlin\n---\n\n# Kotlin With Java\n\n### 개요\nJVM에서의 코틀린 코드는 자바 바이트코드로 컴파일이 된다. 이 말인 즉슨, 기존 자바 프로젝트와 같이 공존할 수 있다는 이야기이며, 또한 기존 자바 코드를 코틀린으로 서서히 이전할 수도 있다는 이야기이다. 상호운용 시, 기존 자바 대비 향상된 코틀린의 기능을 포기해야 되는 상황을 우려 할 수 있는데, 코틀린은 상호운용이 가능하도록 언어가 만들어졌기 때문에 이에 대한 걱정은 할 필요가 없다고 할 수 있다. \n\n상호운용 시, 각 언어의 차이점을 이해하고 이를 극복할 수 있는 메타 어노테이션을 잘 활용하면 충분히 가능한 일이다. 어노테이션은 클래스, 인터페이스, 함수, 매개변수, 속성, 생성자, 표현식 등에 상태 혹은 메타 데이터를 표현하는 목적으로 사용되며 특히 코틀린 그리고 자바 상호운용 관련된 어노테이션의 경우 코틀린 컴파일러가 컴파일 시 사용하게 된다. 이에 대한 적절한 학습 그리고 차이점을 이해한다면 상호운용도 어렵지 않게 해낼 수 있다.\n\n### null 관련 처리\n자바의 모든 객체는 null이 될 수 있다. 하지만, 코틀린에서 자바 코드를 사용하게 될때 이에 대한 정보를 알 수 없기 때문에 각별한 주의가 필요한 부분이다. 다시 말해, 자바에서 반환되는 null에 대한 정보를 코틀린 컴파일러가 알 수 없다. 상호 운용을 하게 된다면 이에 대한 적절한 조치가 필요해보인다. 이처럼, 코틀린에서 사용하는 자바의 변수의 null 상태를 알 수 없을때 이를 가리켜서 플랫폼 변수라고 부른다. String을 예로 들어 살펴보자면, 코틀린에서는 String이 크게 String, String?으로 나뉠 수 있는데, 자바에서 넘어오게 되는 변수에 대해서 null에 대한 정보가 없다면 이를 String!로 나타내게 된다. 여기서 String!가 바로 플랫폼 변수이다. \n\n```java\npublic class Jhava {\n\tpublic String utterGreeting() {\n\t\treturn \"BLARGH\";\n\t}\n\n\tpublic String determineFriendShipLevel() {\n\t\treturn null;\n\t}\n}\n```\n\n```kotlin\nfun main(args: Array<String>) {\n\tval adversary = Jhava()\n\tprintln(adversary.utterGreeting())\n\n\tval friendshipLevel = adversary.determineFriendShipLevel()\n\tprintln(friendshipLevel.toLowerCase())\n}\n```\n\n위와 같이 상호운용하는 상황이 있다면, 자바 코드를 호출하는 코틀린 코드의 결과는 아래와 같다.\n```\nException in thread \"main\"\njava.lang.IllegalStateException: friendshipLevel must not be null\n```\n\n위에서 설명한것처럼 자바 코드에서 발생하는 null에 대한 정보를 코틀린 컴파일러가 알수 없기 때문에 발생한 것이다. 이를 막기 위해서는 자바 코드에 null과 관련된 정보를 심어줘어하는데, 이때 사용하는 것이 바로 `@Nullable`이다. 해당 어노테이션을 지정하게 되면 코틀린 컴파일러는 null 값을 반환할 수 있다는 정보를 알 수 있게 되어 반환 타입을 `String?`으로 간주하게 된다.\n\n```java\npublic class Jhava {\n\tpublic String utterGreeting() {\n\t\treturn \"BLARGH\";\n\t}\n\n\t@Nullable\n\tpublic String determineFriendShipLevel() {\n\t\treturn null;\n\t}\n}\n```\n\n```kotlin\nfun main(args: Array<String>) {\n\tval adversary = Jhava()\n\tprintln(adversary.utterGreeting())\n\n\tval friendshipLevel = adversary.determineFriendShipLevel()\n\tprintln(friendshipLevel?.toLowerCase() ?: \"Null 처리\")\n}\n```\n\n`@Nullable`과 반대로 `@NotNull`을 사용하게 되면 절대로 null 값을 반환하지 않는다는 것을 알려줄 수 있다.\n\n```java\npublic class Jhava {\n\t@NotNull\n\tpublic String utterGreeting() {\n\t\treturn \"BLARGH\";\n\t}\n}\n```\n\nNull 관련 어노테이션은 함수/메서드의 반환값, 매개변수, 필드에 사용될 수 있다.\n\n### 타입 매핑\n코틀린의 타입은 자바 타입과 일대일로 매핑된다. 하지만, 코틀린과 자바 간에 일대일로 매핑되지 않는 타입들도 존재하는데, 기본 타입의 경우 자바에서는 내장 키워드를 통하여 기본 데이터 타입을 가리키는데 이헤 반해 코틀린은 기본 타입을 포함하여 모든 타입이 객체이다. 코틀린 컴파일러가 자바 기본 타입을 가장 유사한 코틀린 타입으로 매핑시켜 준다. \n\n```java\npublic class Jhava {\n\tpublic int hitPoints = 52489112;\n}\n```\n\n```kotlin\nfun main(args: Array<String>) {\n\tval adversary = Jhava()\n\tval adversaryHitPoints: Int = adversary.hitPoints\n}\n```\n자바에서는 int로 정의 되어 있지만, 코틀린 코드에서는 Int 타입으로 참조해도 아무 문제가 없는 것을 확인 할 수 있다.(타입 추론 가능하다.) 자바에서는 기본 타입에 대하여 메소드 호출을 할 수 없지만, 코틀린에서는 Int로 변환이 되기 때문에 Int 클래스에 정의되어 있는 메서드를 사용할 수 있다. 이 밖에도 실제 자바 바이트코드로 변환 시, 성능 향상을 위해 상황에 따라 자동으로 자바 기본 타입으로 매핑시켜준다.\n\n","slug":"Kotlin/WithJava","published":1,"updated":"2021-08-02T12:26:47.252Z","_id":"ckrsup50p001gtjhv4oi89ho4","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Kotlin-With-Java\"><a href=\"#Kotlin-With-Java\" class=\"headerlink\" title=\"Kotlin With Java\"></a>Kotlin With Java</h1><h3 id=\"개요\"><a href=\"#개요\" class=\"headerlink\" title=\"개요\"></a>개요</h3><p>JVM에서의 코틀린 코드는 자바 바이트코드로 컴파일이 된다. 이 말인 즉슨, 기존 자바 프로젝트와 같이 공존할 수 있다는 이야기이며, 또한 기존 자바 코드를 코틀린으로 서서히 이전할 수도 있다는 이야기이다. 상호운용 시, 기존 자바 대비 향상된 코틀린의 기능을 포기해야 되는 상황을 우려 할 수 있는데, 코틀린은 상호운용이 가능하도록 언어가 만들어졌기 때문에 이에 대한 걱정은 할 필요가 없다고 할 수 있다. </p>\n<p>상호운용 시, 각 언어의 차이점을 이해하고 이를 극복할 수 있는 메타 어노테이션을 잘 활용하면 충분히 가능한 일이다. 어노테이션은 클래스, 인터페이스, 함수, 매개변수, 속성, 생성자, 표현식 등에 상태 혹은 메타 데이터를 표현하는 목적으로 사용되며 특히 코틀린 그리고 자바 상호운용 관련된 어노테이션의 경우 코틀린 컴파일러가 컴파일 시 사용하게 된다. 이에 대한 적절한 학습 그리고 차이점을 이해한다면 상호운용도 어렵지 않게 해낼 수 있다.</p>\n<h3 id=\"null-관련-처리\"><a href=\"#null-관련-처리\" class=\"headerlink\" title=\"null 관련 처리\"></a>null 관련 처리</h3><p>자바의 모든 객체는 null이 될 수 있다. 하지만, 코틀린에서 자바 코드를 사용하게 될때 이에 대한 정보를 알 수 없기 때문에 각별한 주의가 필요한 부분이다. 다시 말해, 자바에서 반환되는 null에 대한 정보를 코틀린 컴파일러가 알 수 없다. 상호 운용을 하게 된다면 이에 대한 적절한 조치가 필요해보인다. 이처럼, 코틀린에서 사용하는 자바의 변수의 null 상태를 알 수 없을때 이를 가리켜서 플랫폼 변수라고 부른다. String을 예로 들어 살펴보자면, 코틀린에서는 String이 크게 String, String?으로 나뉠 수 있는데, 자바에서 넘어오게 되는 변수에 대해서 null에 대한 정보가 없다면 이를 String!로 나타내게 된다. 여기서 String!가 바로 플랫폼 변수이다. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Jhava</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">utterGreeting</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;BLARGH&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">determineFriendShipLevel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> adversary = Jhava()</span><br><span class=\"line\">\tprintln(adversary.utterGreeting())</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">val</span> friendshipLevel = adversary.determineFriendShipLevel()</span><br><span class=\"line\">\tprintln(friendshipLevel.toLowerCase())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위와 같이 상호운용하는 상황이 있다면, 자바 코드를 호출하는 코틀린 코드의 결과는 아래와 같다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot;</span><br><span class=\"line\">java.lang.IllegalStateException: friendshipLevel must not be null</span><br></pre></td></tr></table></figure>\n\n<p>위에서 설명한것처럼 자바 코드에서 발생하는 null에 대한 정보를 코틀린 컴파일러가 알수 없기 때문에 발생한 것이다. 이를 막기 위해서는 자바 코드에 null과 관련된 정보를 심어줘어하는데, 이때 사용하는 것이 바로 <code>@Nullable</code>이다. 해당 어노테이션을 지정하게 되면 코틀린 컴파일러는 null 값을 반환할 수 있다는 정보를 알 수 있게 되어 반환 타입을 <code>String?</code>으로 간주하게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Jhava</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">utterGreeting</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;BLARGH&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">determineFriendShipLevel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> adversary = Jhava()</span><br><span class=\"line\">\tprintln(adversary.utterGreeting())</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">val</span> friendshipLevel = adversary.determineFriendShipLevel()</span><br><span class=\"line\">\tprintln(friendshipLevel?.toLowerCase() ?: <span class=\"string\">&quot;Null 처리&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@Nullable</code>과 반대로 <code>@NotNull</code>을 사용하게 되면 절대로 null 값을 반환하지 않는다는 것을 알려줄 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Jhava</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@NotNull</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">utterGreeting</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;BLARGH&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Null 관련 어노테이션은 함수/메서드의 반환값, 매개변수, 필드에 사용될 수 있다.</p>\n<h3 id=\"타입-매핑\"><a href=\"#타입-매핑\" class=\"headerlink\" title=\"타입 매핑\"></a>타입 매핑</h3><p>코틀린의 타입은 자바 타입과 일대일로 매핑된다. 하지만, 코틀린과 자바 간에 일대일로 매핑되지 않는 타입들도 존재하는데, 기본 타입의 경우 자바에서는 내장 키워드를 통하여 기본 데이터 타입을 가리키는데 이헤 반해 코틀린은 기본 타입을 포함하여 모든 타입이 객체이다. 코틀린 컴파일러가 자바 기본 타입을 가장 유사한 코틀린 타입으로 매핑시켜 준다. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Jhava</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">int</span> hitPoints = <span class=\"number\">52489112</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> adversary = Jhava()</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> adversaryHitPoints: <span class=\"built_in\">Int</span> = adversary.hitPoints</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>자바에서는 int로 정의 되어 있지만, 코틀린 코드에서는 Int 타입으로 참조해도 아무 문제가 없는 것을 확인 할 수 있다.(타입 추론 가능하다.) 자바에서는 기본 타입에 대하여 메소드 호출을 할 수 없지만, 코틀린에서는 Int로 변환이 되기 때문에 Int 클래스에 정의되어 있는 메서드를 사용할 수 있다. 이 밖에도 실제 자바 바이트코드로 변환 시, 성능 향상을 위해 상황에 따라 자동으로 자바 기본 타입으로 매핑시켜준다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Kotlin-With-Java\"><a href=\"#Kotlin-With-Java\" class=\"headerlink\" title=\"Kotlin With Java\"></a>Kotlin With Java</h1><h3 id=\"개요\"><a href=\"#개요\" class=\"headerlink\" title=\"개요\"></a>개요</h3><p>JVM에서의 코틀린 코드는 자바 바이트코드로 컴파일이 된다. 이 말인 즉슨, 기존 자바 프로젝트와 같이 공존할 수 있다는 이야기이며, 또한 기존 자바 코드를 코틀린으로 서서히 이전할 수도 있다는 이야기이다. 상호운용 시, 기존 자바 대비 향상된 코틀린의 기능을 포기해야 되는 상황을 우려 할 수 있는데, 코틀린은 상호운용이 가능하도록 언어가 만들어졌기 때문에 이에 대한 걱정은 할 필요가 없다고 할 수 있다. </p>\n<p>상호운용 시, 각 언어의 차이점을 이해하고 이를 극복할 수 있는 메타 어노테이션을 잘 활용하면 충분히 가능한 일이다. 어노테이션은 클래스, 인터페이스, 함수, 매개변수, 속성, 생성자, 표현식 등에 상태 혹은 메타 데이터를 표현하는 목적으로 사용되며 특히 코틀린 그리고 자바 상호운용 관련된 어노테이션의 경우 코틀린 컴파일러가 컴파일 시 사용하게 된다. 이에 대한 적절한 학습 그리고 차이점을 이해한다면 상호운용도 어렵지 않게 해낼 수 있다.</p>\n<h3 id=\"null-관련-처리\"><a href=\"#null-관련-처리\" class=\"headerlink\" title=\"null 관련 처리\"></a>null 관련 처리</h3><p>자바의 모든 객체는 null이 될 수 있다. 하지만, 코틀린에서 자바 코드를 사용하게 될때 이에 대한 정보를 알 수 없기 때문에 각별한 주의가 필요한 부분이다. 다시 말해, 자바에서 반환되는 null에 대한 정보를 코틀린 컴파일러가 알 수 없다. 상호 운용을 하게 된다면 이에 대한 적절한 조치가 필요해보인다. 이처럼, 코틀린에서 사용하는 자바의 변수의 null 상태를 알 수 없을때 이를 가리켜서 플랫폼 변수라고 부른다. String을 예로 들어 살펴보자면, 코틀린에서는 String이 크게 String, String?으로 나뉠 수 있는데, 자바에서 넘어오게 되는 변수에 대해서 null에 대한 정보가 없다면 이를 String!로 나타내게 된다. 여기서 String!가 바로 플랫폼 변수이다. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Jhava</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">utterGreeting</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;BLARGH&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">determineFriendShipLevel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> adversary = Jhava()</span><br><span class=\"line\">\tprintln(adversary.utterGreeting())</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">val</span> friendshipLevel = adversary.determineFriendShipLevel()</span><br><span class=\"line\">\tprintln(friendshipLevel.toLowerCase())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위와 같이 상호운용하는 상황이 있다면, 자바 코드를 호출하는 코틀린 코드의 결과는 아래와 같다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot;</span><br><span class=\"line\">java.lang.IllegalStateException: friendshipLevel must not be null</span><br></pre></td></tr></table></figure>\n\n<p>위에서 설명한것처럼 자바 코드에서 발생하는 null에 대한 정보를 코틀린 컴파일러가 알수 없기 때문에 발생한 것이다. 이를 막기 위해서는 자바 코드에 null과 관련된 정보를 심어줘어하는데, 이때 사용하는 것이 바로 <code>@Nullable</code>이다. 해당 어노테이션을 지정하게 되면 코틀린 컴파일러는 null 값을 반환할 수 있다는 정보를 알 수 있게 되어 반환 타입을 <code>String?</code>으로 간주하게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Jhava</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">utterGreeting</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;BLARGH&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">determineFriendShipLevel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> adversary = Jhava()</span><br><span class=\"line\">\tprintln(adversary.utterGreeting())</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">val</span> friendshipLevel = adversary.determineFriendShipLevel()</span><br><span class=\"line\">\tprintln(friendshipLevel?.toLowerCase() ?: <span class=\"string\">&quot;Null 처리&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@Nullable</code>과 반대로 <code>@NotNull</code>을 사용하게 되면 절대로 null 값을 반환하지 않는다는 것을 알려줄 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Jhava</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@NotNull</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">utterGreeting</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;BLARGH&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Null 관련 어노테이션은 함수/메서드의 반환값, 매개변수, 필드에 사용될 수 있다.</p>\n<h3 id=\"타입-매핑\"><a href=\"#타입-매핑\" class=\"headerlink\" title=\"타입 매핑\"></a>타입 매핑</h3><p>코틀린의 타입은 자바 타입과 일대일로 매핑된다. 하지만, 코틀린과 자바 간에 일대일로 매핑되지 않는 타입들도 존재하는데, 기본 타입의 경우 자바에서는 내장 키워드를 통하여 기본 데이터 타입을 가리키는데 이헤 반해 코틀린은 기본 타입을 포함하여 모든 타입이 객체이다. 코틀린 컴파일러가 자바 기본 타입을 가장 유사한 코틀린 타입으로 매핑시켜 준다. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Jhava</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">int</span> hitPoints = <span class=\"number\">52489112</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> adversary = Jhava()</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> adversaryHitPoints: <span class=\"built_in\">Int</span> = adversary.hitPoints</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>자바에서는 int로 정의 되어 있지만, 코틀린 코드에서는 Int 타입으로 참조해도 아무 문제가 없는 것을 확인 할 수 있다.(타입 추론 가능하다.) 자바에서는 기본 타입에 대하여 메소드 호출을 할 수 없지만, 코틀린에서는 Int로 변환이 되기 때문에 Int 클래스에 정의되어 있는 메서드를 사용할 수 있다. 이 밖에도 실제 자바 바이트코드로 변환 시, 성능 향상을 위해 상황에 따라 자동으로 자바 기본 타입으로 매핑시켜준다.</p>\n"},{"title":"Redisson","date":"2020-04-16T15:00:00.000Z","_content":"\n## Why Redisson?\n큐를 사용한 DB 적재 로직을 개발을 진행하면서, 동기화에 대한 처리가 필요하여 이를 해결할 수 있는 방법을 모색하다 분산락을 고민하게 되었다. \n\n멀티 인스턴스 상황에서 락을 공유하는 방법은 결국 특정 스토리지를 참조하고 이를 통하여 락을 구현하는 방법밖에 없다고 생각이 들었고, 이에 따라 개발환경에 셋팅이 되어 있는 레디스를 활용하는 쪽으로 방향을 잡았다.\n\n[Distributed locks with Redis](https://redis.io/topics/distlock)\n\n위 문서에서는 레디스를 활용한 락에 대한 구현을 설명하고 있는데 요약하자면 아래와 같다.\n\n- Redis를 사용하여 리소스를 잠그는 가장 간단한 방법은 인스턴스에서 키를 만드는 것\n- 이 키는 일반적으로 Redis expires 기능을 사용하여 제한된 수명으로 생성되므로 결국 키가 해제됨. 클라이언트는 리소스를 해제해야 할 때 해당 키를 삭제 처리\n\n> 레디스 인스턴스가 장애가 발생하는 상황(SPOF)이라면, 레디스 클러스터를 사용하여 슬레이브가 마스터로 승격이 되는 상황에 키에 대한 락 잠금 키에 대한 중복 생성이 생길 수 있다. 클러스터 설정에 따라 다르겠지만, 이럴 경우를 대비하여 클러스터 각 노드에 리플리케이션 노드까지 붙인다면 이에 대한 적절한 솔루션이 될 수 있다고 한다.","source":"_posts/MESSAGING/REDISSON.md","raw":"---\ntitle: 'Redisson'\ndate: 2020/4/17 00:00:00\ncategories:\n- MESSAGING\n---\n\n## Why Redisson?\n큐를 사용한 DB 적재 로직을 개발을 진행하면서, 동기화에 대한 처리가 필요하여 이를 해결할 수 있는 방법을 모색하다 분산락을 고민하게 되었다. \n\n멀티 인스턴스 상황에서 락을 공유하는 방법은 결국 특정 스토리지를 참조하고 이를 통하여 락을 구현하는 방법밖에 없다고 생각이 들었고, 이에 따라 개발환경에 셋팅이 되어 있는 레디스를 활용하는 쪽으로 방향을 잡았다.\n\n[Distributed locks with Redis](https://redis.io/topics/distlock)\n\n위 문서에서는 레디스를 활용한 락에 대한 구현을 설명하고 있는데 요약하자면 아래와 같다.\n\n- Redis를 사용하여 리소스를 잠그는 가장 간단한 방법은 인스턴스에서 키를 만드는 것\n- 이 키는 일반적으로 Redis expires 기능을 사용하여 제한된 수명으로 생성되므로 결국 키가 해제됨. 클라이언트는 리소스를 해제해야 할 때 해당 키를 삭제 처리\n\n> 레디스 인스턴스가 장애가 발생하는 상황(SPOF)이라면, 레디스 클러스터를 사용하여 슬레이브가 마스터로 승격이 되는 상황에 키에 대한 락 잠금 키에 대한 중복 생성이 생길 수 있다. 클러스터 설정에 따라 다르겠지만, 이럴 경우를 대비하여 클러스터 각 노드에 리플리케이션 노드까지 붙인다면 이에 대한 적절한 솔루션이 될 수 있다고 한다.","slug":"MESSAGING/REDISSON","published":1,"updated":"2021-08-02T12:21:09.943Z","_id":"ckrsup50q001htjhvcwr6247y","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Why-Redisson\"><a href=\"#Why-Redisson\" class=\"headerlink\" title=\"Why Redisson?\"></a>Why Redisson?</h2><p>큐를 사용한 DB 적재 로직을 개발을 진행하면서, 동기화에 대한 처리가 필요하여 이를 해결할 수 있는 방법을 모색하다 분산락을 고민하게 되었다. </p>\n<p>멀티 인스턴스 상황에서 락을 공유하는 방법은 결국 특정 스토리지를 참조하고 이를 통하여 락을 구현하는 방법밖에 없다고 생각이 들었고, 이에 따라 개발환경에 셋팅이 되어 있는 레디스를 활용하는 쪽으로 방향을 잡았다.</p>\n<p><a href=\"https://redis.io/topics/distlock\">Distributed locks with Redis</a></p>\n<p>위 문서에서는 레디스를 활용한 락에 대한 구현을 설명하고 있는데 요약하자면 아래와 같다.</p>\n<ul>\n<li>Redis를 사용하여 리소스를 잠그는 가장 간단한 방법은 인스턴스에서 키를 만드는 것</li>\n<li>이 키는 일반적으로 Redis expires 기능을 사용하여 제한된 수명으로 생성되므로 결국 키가 해제됨. 클라이언트는 리소스를 해제해야 할 때 해당 키를 삭제 처리</li>\n</ul>\n<blockquote>\n<p>레디스 인스턴스가 장애가 발생하는 상황(SPOF)이라면, 레디스 클러스터를 사용하여 슬레이브가 마스터로 승격이 되는 상황에 키에 대한 락 잠금 키에 대한 중복 생성이 생길 수 있다. 클러스터 설정에 따라 다르겠지만, 이럴 경우를 대비하여 클러스터 각 노드에 리플리케이션 노드까지 붙인다면 이에 대한 적절한 솔루션이 될 수 있다고 한다.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Why-Redisson\"><a href=\"#Why-Redisson\" class=\"headerlink\" title=\"Why Redisson?\"></a>Why Redisson?</h2><p>큐를 사용한 DB 적재 로직을 개발을 진행하면서, 동기화에 대한 처리가 필요하여 이를 해결할 수 있는 방법을 모색하다 분산락을 고민하게 되었다. </p>\n<p>멀티 인스턴스 상황에서 락을 공유하는 방법은 결국 특정 스토리지를 참조하고 이를 통하여 락을 구현하는 방법밖에 없다고 생각이 들었고, 이에 따라 개발환경에 셋팅이 되어 있는 레디스를 활용하는 쪽으로 방향을 잡았다.</p>\n<p><a href=\"https://redis.io/topics/distlock\">Distributed locks with Redis</a></p>\n<p>위 문서에서는 레디스를 활용한 락에 대한 구현을 설명하고 있는데 요약하자면 아래와 같다.</p>\n<ul>\n<li>Redis를 사용하여 리소스를 잠그는 가장 간단한 방법은 인스턴스에서 키를 만드는 것</li>\n<li>이 키는 일반적으로 Redis expires 기능을 사용하여 제한된 수명으로 생성되므로 결국 키가 해제됨. 클라이언트는 리소스를 해제해야 할 때 해당 키를 삭제 처리</li>\n</ul>\n<blockquote>\n<p>레디스 인스턴스가 장애가 발생하는 상황(SPOF)이라면, 레디스 클러스터를 사용하여 슬레이브가 마스터로 승격이 되는 상황에 키에 대한 락 잠금 키에 대한 중복 생성이 생길 수 있다. 클러스터 설정에 따라 다르겠지만, 이럴 경우를 대비하여 클러스터 각 노드에 리플리케이션 노드까지 붙인다면 이에 대한 적절한 솔루션이 될 수 있다고 한다.</p>\n</blockquote>\n"},{"title":"RabbitMQ 관련 링크 정리","date":"2020-03-04T15:00:00.000Z","_content":"\n# RabbitMQ 관련 링크 정리\n\n- [Consumer Acknowledgements and Publisher Confirms](https://www.rabbitmq.com/confirms.html)\n- [비동기 worker를 위한 RabbitMQ 가볍게 살펴보기](https://blurblah.net/1569)\n- [Spring RabbitMQ - using manual channel acknowledgement on a service with @RabbitListener configuration](https://stackoverflow.com/questions/38728668/spring-rabbitmq-using-manual-channel-acknowledgement-on-a-service-with-rabbit)\n- [Part 1: RabbitMQ Best Practices](https://www.cloudamqp.com/blog/2017-12-29-part1-rabbitmq-best-practice.html)\n- [Implementing At Least Once Delivery With RabbitMQ and Spring’s RabbitTemplate](https://synyx.de/blog/implementing-at-least-once-delivery-with-rabbitmq-and-springs-rabbittemplate/)","source":"_posts/MESSAGING/RabbitMQ.md","raw":"---\ntitle: 'RabbitMQ 관련 링크 정리'\ndate: 2020/3/5 00:00:00\ncategories:\n- MESSAGING\n---\n\n# RabbitMQ 관련 링크 정리\n\n- [Consumer Acknowledgements and Publisher Confirms](https://www.rabbitmq.com/confirms.html)\n- [비동기 worker를 위한 RabbitMQ 가볍게 살펴보기](https://blurblah.net/1569)\n- [Spring RabbitMQ - using manual channel acknowledgement on a service with @RabbitListener configuration](https://stackoverflow.com/questions/38728668/spring-rabbitmq-using-manual-channel-acknowledgement-on-a-service-with-rabbit)\n- [Part 1: RabbitMQ Best Practices](https://www.cloudamqp.com/blog/2017-12-29-part1-rabbitmq-best-practice.html)\n- [Implementing At Least Once Delivery With RabbitMQ and Spring’s RabbitTemplate](https://synyx.de/blog/implementing-at-least-once-delivery-with-rabbitmq-and-springs-rabbittemplate/)","slug":"MESSAGING/RabbitMQ","published":1,"updated":"2021-08-02T12:21:39.070Z","_id":"ckrsup50q001itjhv8vrnd1o6","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"RabbitMQ-관련-링크-정리\"><a href=\"#RabbitMQ-관련-링크-정리\" class=\"headerlink\" title=\"RabbitMQ 관련 링크 정리\"></a>RabbitMQ 관련 링크 정리</h1><ul>\n<li><a href=\"https://www.rabbitmq.com/confirms.html\">Consumer Acknowledgements and Publisher Confirms</a></li>\n<li><a href=\"https://blurblah.net/1569\">비동기 worker를 위한 RabbitMQ 가볍게 살펴보기</a></li>\n<li><a href=\"https://stackoverflow.com/questions/38728668/spring-rabbitmq-using-manual-channel-acknowledgement-on-a-service-with-rabbit\">Spring RabbitMQ - using manual channel acknowledgement on a service with @RabbitListener configuration</a></li>\n<li><a href=\"https://www.cloudamqp.com/blog/2017-12-29-part1-rabbitmq-best-practice.html\">Part 1: RabbitMQ Best Practices</a></li>\n<li><a href=\"https://synyx.de/blog/implementing-at-least-once-delivery-with-rabbitmq-and-springs-rabbittemplate/\">Implementing At Least Once Delivery With RabbitMQ and Spring’s RabbitTemplate</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"RabbitMQ-관련-링크-정리\"><a href=\"#RabbitMQ-관련-링크-정리\" class=\"headerlink\" title=\"RabbitMQ 관련 링크 정리\"></a>RabbitMQ 관련 링크 정리</h1><ul>\n<li><a href=\"https://www.rabbitmq.com/confirms.html\">Consumer Acknowledgements and Publisher Confirms</a></li>\n<li><a href=\"https://blurblah.net/1569\">비동기 worker를 위한 RabbitMQ 가볍게 살펴보기</a></li>\n<li><a href=\"https://stackoverflow.com/questions/38728668/spring-rabbitmq-using-manual-channel-acknowledgement-on-a-service-with-rabbit\">Spring RabbitMQ - using manual channel acknowledgement on a service with @RabbitListener configuration</a></li>\n<li><a href=\"https://www.cloudamqp.com/blog/2017-12-29-part1-rabbitmq-best-practice.html\">Part 1: RabbitMQ Best Practices</a></li>\n<li><a href=\"https://synyx.de/blog/implementing-at-least-once-delivery-with-rabbitmq-and-springs-rabbittemplate/\">Implementing At Least Once Delivery With RabbitMQ and Spring’s RabbitTemplate</a></li>\n</ul>\n"},{"title":"Alternatives to JPA","date":"2019-05-01T05:33:00.000Z","_content":"\n# Alternatives to JPA\n\n같이 근무했던 시니어 개발자분께서 내용이 좋다면서 추천해주셔서 [링크](https://www.youtube.com/watch?v=2zQdmC0vnFU)를 통하여 동영상을 시청했다. 분량은 대충 1시간 가량 되는데, JPA를 사용하면서도 하이버네이트에 대한 충분한 학습을 하지 못해서 겪었던 지난 1년간의 많은 시행착오들이 생각이 났고, Kotlin을 메인으로 사용했을때의 다양한 선택지에 대해서 고민을 해볼 수 있었던거 같아서 매우 유익했다고 할 수 있다. \n\n- 데이터를 표현하는 관점에 따라 달라 질 수 있다. \n  - Relational\n  - OOP\n- 두 가지 관점 중 어디를 중점으로 설계 하느냐에 따라 방향이 크게 달라질 수 있다.\n- 데이터 중심(data-centric)의 경우, OOP적인 설계가 크게 맞지 않을 수 있고, 요즘 ORM을 사용하는 것이 유행인것 마냥 흘러가고 있어서 이에 대한 진지한 고민이 필요해보인다.\n- Hibernate가 커버하는 SQL은 약 95프로에 가까운데, 나머지 5프로에 대해서는 커버를 못하기 때문에 실제로 하이엔드 성능을 요구하는 상황에서는 ORM이 맞지 않다고 볼 수 있다.\n\n## JPA의 장단점?\n### 장점\n- 비즈니스 레이어에 대해 DB 중심적인 사고가 아닌 어플리케이션 레이어에서 이를 처리해본 사람들은 NoSQL을 사용했을 때의 접근이 수월했다.\n- 디비 벤더 종속적으로 개발을 하지 않아도 된다.\n- SQL문장에 대해 크게 학습을 하지 않아도 된다.\n  - 문장으로 쓰느냐 vs 코드(API)로 이를 표현하느냐?\n  - API로 사용하는 것이 Type-safe한 전개가 가능하기 때문에 안정적이다.\n- Stateful, Statless에 대한 지원\n### 단점\n- SQL에 친숙한 사람들의 경우, JPQL에 대한 반감 혹은 적응이 힘들 수 있다. 두 가지 접근 방법에 대해 상이한 부분이 존재하며 결국 둘다 배워야 하는 점이 생긴다.\n- Hibernate에 대한 러닝커브가 상당히 높다.\n- Bulk Operation의 성능이 좋지 않다.\n- JPA Vendor에서 제공해주는 기능에 대해서 학습 비용이 발생한다.\n  - HQL, @DynamicInsert, @LazyCollection\n  - 2nd Cache(recommend JCache(JSR-305))\n\n## 그래서 쿠팡은 어떻게?\n- 성능보다는 생산성을 위주로 사용했으며, 오픈 후 성능이 나오질 않아서 JPA에 대한 학습도 진행하고 튜닝하는 등의 작업을 진행했었다.\n- Not Deep Dive\n  - Missing Override(hashCode, equals and toString)\n  - No Using @NatualId: 비즈니스적인 필요에 의해 @NatualId가 필요한 경우가 있다.\n- Best Practice가 존재하질 않아 제대로 사용하지 못한 케이스가 많았다.\n- 퍼포먼스가 나오질 않다보니 비용 측면에서도 충분히 줄일 수 있는 부분이 많은데, 제대로 학습을 하지 못해서 생긴 이슈 아닌 이슈가 많았다고 한다.\n\n\n## 그래서 JPA에 대안이 될 수 있는 솔루션들은?\n- 단점은 버리고 장점을 취할 수 있는 다른 대안들은 뭐가 있을까?\n- Design Principle\n  - OOP 기반의 Multi-DB Vendor\n  - No Need stateful for Reference Object\n  - Support association, inheritance, converter in JPA\n- Performance\n  - Speed up to Plain SQL\n  - Stateless\n  - Support Asynchronous or Reactive\n  - Support Bulk or Batch Operation\n\n### Slick\n- Database Access Library\n- ORM => Functional Relational Mapping\n- Relational Model to Scala OOP\n- Natural fit\n- Stateless\n- Matures(Slick version 3)(Non-Blocking DBIO)\n\n### jOOQ\n가장 도입하기 쉽고 러닝커브가 낮음\n- SQL과 유사하게 API를 사용할 수 있으며, Type-Safe한 성격은 그래도 가져갈 수 있다.\n- DB-First, DB Schema로부터 자바의 엔티티 클래스를 만들어야 하는 단점이 존재한다.\n- Stateless\n- Need DBMS Owner Authority\n\n\n### Requery\n- No Refelection - apt code generation\n- Fast Startup & Performance\n- Schema Generation\n- Non-Blocking\n- upsert\n- compile time entity validation\n- Support alomost JPA Annotations\n\n### Exposed - Kotlin SQL Framework\n- Lightweight SQL Framework\n- Two Layers of data access\n  - Typesafe SQL wrapping DSL\n  - Lightweight Data Access Object\n- Not Mature...\n\n### 그래서 적합한 대안은?\n- 기존 레거시 데이터베이스가 존재하는 경우? 자바만 하는 경우?\n  - jOOQ, requery\n- Scala만 사용하는 경우?\n  - Slick\n- Kotlin Only?\n  - requery, Exposed\n- 언어와 상관 없다면?\n  - requery\n- Reactive Programming?\n  - requery with kotlinx-requery\n  - kotlinx-rxjava2-jdbc\n\n## Requery Overview\n- 안드로이드에서만 쓰이는 것이 아니다.\n- 충분히 서버 어플리케이션에서도 사용이 가능하다.\n- 하이버네이트의 Proxy 개념이 없다. 즉, Lazy Initialize라는 개념 자체가 없다. Mybatis랑 비슷한 개념으로 생각해도 좋다. 속도가 생각보다 빠르다.\n- 부가적으로 라이브러리는 필요없다. \n- Upsert 기능이 굉장히 매력적이다.\n- Compile Time Entity/Query Validation\n- Entity is stateless\n- Thread에 제한을 받지 않음(vs JPA EntityManager)\n- Support RxJava, Async Operations on Java8\n\n### Why Requery?\n- Provide Benefit of ORM\n  - Entity Mapping\n  - Schema Generation\n  - Compile Time Error Detecting\n\nBulk Operation은 JPA에 비해서 거의 100배 가량 빠르다고 한다. REST API 호출에서 퍼포먼스 Checking을 했을 때는 약 10배 가량 JPA를 사용했을때보다 빠르다고 한다. Upsert 기능이 제공되고 레이지한 로드(프록시를 사용한 접근이 아닌 특정 컬럼만 일부 Fetch하고 추후에 필요한 데이터를 가져오는 방식)도 가능하다.\n\n### Define Entity - Java, Kotlin\nJPA와 Hibernate보다는 간결한 기능을 제공하고 있다. 간결한 기능을 제공한다는 것은 JPA와 Hibernate보다는 기능적인 가지 수가 좀 적을 수 있다는 이야기이다. \n\n### EntityDataStore\n- FindByKey\n- select/insert/update/upsert/delete\n- where/eq,lte,lt,gt,gte,like,in,not\n- groupBy / having / limit / offset\n- support SQL Functions\n  - count, sum, avg, upper, lower ...\n- raw query\n\n### CoroutineEntityDataStore\n- 코틀린에서는 코루틴을 통하여 비동기 프로그래밍이 가능하다. JDBC가 블록킹 구간이 존재하지만 엔티티를 ResultSet으로부터 인스턴싱하는 과정을 비동기로하면 CPU를 좀 더 효율적으로 사용할 수 있다.\n- requery는 자바의 CompletableFuture를 사용\n\n### spring-data-requery\n  - 운영 시스템은 아니더라도 개인 프로젝트에 적용해본다면 별 문제 없겠지만, 운영시스템에 이걸 적용한다면 ..... 상황을 겪을 수 있다. 그래서 만든 것이 spring-data-requery 프로젝트라고 한다.\n  - RequeryOperations\n  - RequeryTransactionManager for TransactionManager\n    - Support Spring @Transactional\n  - Better performance than spring-data-jpa\n    - exists, paging할때, 매번 연관된 엔티티를 모두 조회하지 않는다.\n  - Repository build in SQL\n  - ByPropertyName Auto Generation Methods\n  - @Query, Native SQL Query\n  - Query By Example\n  - Not Support\n    - 조인에 대해서는 개발자가 명시를 해줘야 한다. Annotation Path에 대한 자동으로 Query를 만들어 주지는 않는다.\n    - Named Parameter의 경우 현재 지원하지 않지만, 추후 지원이 가능 할거라고 한다.\n### Query By Example\n  - 검색 조건에 대한 Predicate를 작성하는 거랑 비슷함\n### Query By Property\n  - JPA의 가장 강력한 부분인데, 이에 대한 지원은 하고 있는데, Association에 대한 지원은 위에서 말한대로 현재 없다고 한다.\n  - JPA의 findXXX 매소드 시그니처를 사용 하듯이 사용하면 된다.\n\n### Exists\n  - 현재 JPA에서는 ExistExecution에서 모든 조회 결과를 가져오고 이에대한 존재 유무를 체크하게 된다고 한다.\n  - spring-data-requery에서는 ExistExecution 처리 시, 조회 결과를 단건만 가져와서 조회 조건에 대한 존재 유무를 체크한다고 한다.\n\n\n### Delete in JPA\n- 연관 관계가 어떻게 되는지 모두 파악 후 Delete에 대한 실행이 진행된다.\n- 연관 관계에 대한 모든 파악을 진행 후 진행해야 하기 때문에 결국 `Read` 작업이 선행될 수 밖에 없다.\n- Bulk Operation의 경우, 성능상 손실이 많이 발생한다.\n- Bulk Operation의 원래 의도는 Set 방식으로 바로 지우는 것을 원하게 되는데, 이렇게 Read 액션이 먼저 발생하게 되면 성능적으로 느려질 수 밖에 없는 상황이다. Set 방식으로 움직여야 하는 것은 Direct로 SQL 구문을 사용하여 처리 할 수 있도록 가이드를 해주는 것이 중요하다. 깊게 이해하여 사용하는 것이 너무 중요하다.\n- 작게는 3배 많게는 100배 가량 퍼포먼스 차이가 발생할 수 있다고 한다.\n\n### Future Works\n- Named Parameter\n- `@Param` in Spring Data\n- Complicated Aggregation Operations\n- Requery for Apache Phoenix(Hbase)\n- CoroutineEntityStore \n\n\n## QnA\n- MySQL에서 넘어가는 이유가 뭔가요?\n  - Money!!\n  - AWS RDS Aurora가 비용이 너무 비쌈...ㅠㅠ\n  - 벤치마크 했을 때, 포스트그래가 생각보다 성능이 좋았다.\n  - JPA를 쓴 것이 성능이 느려서 고생을 했었는데, DB 벤더를 바꿈으로서 얻게 되는 이점이 생각보다 많이 있을 거라고 생각하여 변경을 하게 됐다.","source":"_posts/Persistence/Alternative_JPA.md","raw":"---\ntitle: 'Alternatives to JPA'\ndate: 2019.5.1. 14:33\ncategories:\n- Persistence\n---\n\n# Alternatives to JPA\n\n같이 근무했던 시니어 개발자분께서 내용이 좋다면서 추천해주셔서 [링크](https://www.youtube.com/watch?v=2zQdmC0vnFU)를 통하여 동영상을 시청했다. 분량은 대충 1시간 가량 되는데, JPA를 사용하면서도 하이버네이트에 대한 충분한 학습을 하지 못해서 겪었던 지난 1년간의 많은 시행착오들이 생각이 났고, Kotlin을 메인으로 사용했을때의 다양한 선택지에 대해서 고민을 해볼 수 있었던거 같아서 매우 유익했다고 할 수 있다. \n\n- 데이터를 표현하는 관점에 따라 달라 질 수 있다. \n  - Relational\n  - OOP\n- 두 가지 관점 중 어디를 중점으로 설계 하느냐에 따라 방향이 크게 달라질 수 있다.\n- 데이터 중심(data-centric)의 경우, OOP적인 설계가 크게 맞지 않을 수 있고, 요즘 ORM을 사용하는 것이 유행인것 마냥 흘러가고 있어서 이에 대한 진지한 고민이 필요해보인다.\n- Hibernate가 커버하는 SQL은 약 95프로에 가까운데, 나머지 5프로에 대해서는 커버를 못하기 때문에 실제로 하이엔드 성능을 요구하는 상황에서는 ORM이 맞지 않다고 볼 수 있다.\n\n## JPA의 장단점?\n### 장점\n- 비즈니스 레이어에 대해 DB 중심적인 사고가 아닌 어플리케이션 레이어에서 이를 처리해본 사람들은 NoSQL을 사용했을 때의 접근이 수월했다.\n- 디비 벤더 종속적으로 개발을 하지 않아도 된다.\n- SQL문장에 대해 크게 학습을 하지 않아도 된다.\n  - 문장으로 쓰느냐 vs 코드(API)로 이를 표현하느냐?\n  - API로 사용하는 것이 Type-safe한 전개가 가능하기 때문에 안정적이다.\n- Stateful, Statless에 대한 지원\n### 단점\n- SQL에 친숙한 사람들의 경우, JPQL에 대한 반감 혹은 적응이 힘들 수 있다. 두 가지 접근 방법에 대해 상이한 부분이 존재하며 결국 둘다 배워야 하는 점이 생긴다.\n- Hibernate에 대한 러닝커브가 상당히 높다.\n- Bulk Operation의 성능이 좋지 않다.\n- JPA Vendor에서 제공해주는 기능에 대해서 학습 비용이 발생한다.\n  - HQL, @DynamicInsert, @LazyCollection\n  - 2nd Cache(recommend JCache(JSR-305))\n\n## 그래서 쿠팡은 어떻게?\n- 성능보다는 생산성을 위주로 사용했으며, 오픈 후 성능이 나오질 않아서 JPA에 대한 학습도 진행하고 튜닝하는 등의 작업을 진행했었다.\n- Not Deep Dive\n  - Missing Override(hashCode, equals and toString)\n  - No Using @NatualId: 비즈니스적인 필요에 의해 @NatualId가 필요한 경우가 있다.\n- Best Practice가 존재하질 않아 제대로 사용하지 못한 케이스가 많았다.\n- 퍼포먼스가 나오질 않다보니 비용 측면에서도 충분히 줄일 수 있는 부분이 많은데, 제대로 학습을 하지 못해서 생긴 이슈 아닌 이슈가 많았다고 한다.\n\n\n## 그래서 JPA에 대안이 될 수 있는 솔루션들은?\n- 단점은 버리고 장점을 취할 수 있는 다른 대안들은 뭐가 있을까?\n- Design Principle\n  - OOP 기반의 Multi-DB Vendor\n  - No Need stateful for Reference Object\n  - Support association, inheritance, converter in JPA\n- Performance\n  - Speed up to Plain SQL\n  - Stateless\n  - Support Asynchronous or Reactive\n  - Support Bulk or Batch Operation\n\n### Slick\n- Database Access Library\n- ORM => Functional Relational Mapping\n- Relational Model to Scala OOP\n- Natural fit\n- Stateless\n- Matures(Slick version 3)(Non-Blocking DBIO)\n\n### jOOQ\n가장 도입하기 쉽고 러닝커브가 낮음\n- SQL과 유사하게 API를 사용할 수 있으며, Type-Safe한 성격은 그래도 가져갈 수 있다.\n- DB-First, DB Schema로부터 자바의 엔티티 클래스를 만들어야 하는 단점이 존재한다.\n- Stateless\n- Need DBMS Owner Authority\n\n\n### Requery\n- No Refelection - apt code generation\n- Fast Startup & Performance\n- Schema Generation\n- Non-Blocking\n- upsert\n- compile time entity validation\n- Support alomost JPA Annotations\n\n### Exposed - Kotlin SQL Framework\n- Lightweight SQL Framework\n- Two Layers of data access\n  - Typesafe SQL wrapping DSL\n  - Lightweight Data Access Object\n- Not Mature...\n\n### 그래서 적합한 대안은?\n- 기존 레거시 데이터베이스가 존재하는 경우? 자바만 하는 경우?\n  - jOOQ, requery\n- Scala만 사용하는 경우?\n  - Slick\n- Kotlin Only?\n  - requery, Exposed\n- 언어와 상관 없다면?\n  - requery\n- Reactive Programming?\n  - requery with kotlinx-requery\n  - kotlinx-rxjava2-jdbc\n\n## Requery Overview\n- 안드로이드에서만 쓰이는 것이 아니다.\n- 충분히 서버 어플리케이션에서도 사용이 가능하다.\n- 하이버네이트의 Proxy 개념이 없다. 즉, Lazy Initialize라는 개념 자체가 없다. Mybatis랑 비슷한 개념으로 생각해도 좋다. 속도가 생각보다 빠르다.\n- 부가적으로 라이브러리는 필요없다. \n- Upsert 기능이 굉장히 매력적이다.\n- Compile Time Entity/Query Validation\n- Entity is stateless\n- Thread에 제한을 받지 않음(vs JPA EntityManager)\n- Support RxJava, Async Operations on Java8\n\n### Why Requery?\n- Provide Benefit of ORM\n  - Entity Mapping\n  - Schema Generation\n  - Compile Time Error Detecting\n\nBulk Operation은 JPA에 비해서 거의 100배 가량 빠르다고 한다. REST API 호출에서 퍼포먼스 Checking을 했을 때는 약 10배 가량 JPA를 사용했을때보다 빠르다고 한다. Upsert 기능이 제공되고 레이지한 로드(프록시를 사용한 접근이 아닌 특정 컬럼만 일부 Fetch하고 추후에 필요한 데이터를 가져오는 방식)도 가능하다.\n\n### Define Entity - Java, Kotlin\nJPA와 Hibernate보다는 간결한 기능을 제공하고 있다. 간결한 기능을 제공한다는 것은 JPA와 Hibernate보다는 기능적인 가지 수가 좀 적을 수 있다는 이야기이다. \n\n### EntityDataStore\n- FindByKey\n- select/insert/update/upsert/delete\n- where/eq,lte,lt,gt,gte,like,in,not\n- groupBy / having / limit / offset\n- support SQL Functions\n  - count, sum, avg, upper, lower ...\n- raw query\n\n### CoroutineEntityDataStore\n- 코틀린에서는 코루틴을 통하여 비동기 프로그래밍이 가능하다. JDBC가 블록킹 구간이 존재하지만 엔티티를 ResultSet으로부터 인스턴싱하는 과정을 비동기로하면 CPU를 좀 더 효율적으로 사용할 수 있다.\n- requery는 자바의 CompletableFuture를 사용\n\n### spring-data-requery\n  - 운영 시스템은 아니더라도 개인 프로젝트에 적용해본다면 별 문제 없겠지만, 운영시스템에 이걸 적용한다면 ..... 상황을 겪을 수 있다. 그래서 만든 것이 spring-data-requery 프로젝트라고 한다.\n  - RequeryOperations\n  - RequeryTransactionManager for TransactionManager\n    - Support Spring @Transactional\n  - Better performance than spring-data-jpa\n    - exists, paging할때, 매번 연관된 엔티티를 모두 조회하지 않는다.\n  - Repository build in SQL\n  - ByPropertyName Auto Generation Methods\n  - @Query, Native SQL Query\n  - Query By Example\n  - Not Support\n    - 조인에 대해서는 개발자가 명시를 해줘야 한다. Annotation Path에 대한 자동으로 Query를 만들어 주지는 않는다.\n    - Named Parameter의 경우 현재 지원하지 않지만, 추후 지원이 가능 할거라고 한다.\n### Query By Example\n  - 검색 조건에 대한 Predicate를 작성하는 거랑 비슷함\n### Query By Property\n  - JPA의 가장 강력한 부분인데, 이에 대한 지원은 하고 있는데, Association에 대한 지원은 위에서 말한대로 현재 없다고 한다.\n  - JPA의 findXXX 매소드 시그니처를 사용 하듯이 사용하면 된다.\n\n### Exists\n  - 현재 JPA에서는 ExistExecution에서 모든 조회 결과를 가져오고 이에대한 존재 유무를 체크하게 된다고 한다.\n  - spring-data-requery에서는 ExistExecution 처리 시, 조회 결과를 단건만 가져와서 조회 조건에 대한 존재 유무를 체크한다고 한다.\n\n\n### Delete in JPA\n- 연관 관계가 어떻게 되는지 모두 파악 후 Delete에 대한 실행이 진행된다.\n- 연관 관계에 대한 모든 파악을 진행 후 진행해야 하기 때문에 결국 `Read` 작업이 선행될 수 밖에 없다.\n- Bulk Operation의 경우, 성능상 손실이 많이 발생한다.\n- Bulk Operation의 원래 의도는 Set 방식으로 바로 지우는 것을 원하게 되는데, 이렇게 Read 액션이 먼저 발생하게 되면 성능적으로 느려질 수 밖에 없는 상황이다. Set 방식으로 움직여야 하는 것은 Direct로 SQL 구문을 사용하여 처리 할 수 있도록 가이드를 해주는 것이 중요하다. 깊게 이해하여 사용하는 것이 너무 중요하다.\n- 작게는 3배 많게는 100배 가량 퍼포먼스 차이가 발생할 수 있다고 한다.\n\n### Future Works\n- Named Parameter\n- `@Param` in Spring Data\n- Complicated Aggregation Operations\n- Requery for Apache Phoenix(Hbase)\n- CoroutineEntityStore \n\n\n## QnA\n- MySQL에서 넘어가는 이유가 뭔가요?\n  - Money!!\n  - AWS RDS Aurora가 비용이 너무 비쌈...ㅠㅠ\n  - 벤치마크 했을 때, 포스트그래가 생각보다 성능이 좋았다.\n  - JPA를 쓴 것이 성능이 느려서 고생을 했었는데, DB 벤더를 바꿈으로서 얻게 되는 이점이 생각보다 많이 있을 거라고 생각하여 변경을 하게 됐다.","slug":"Persistence/Alternative_JPA","published":1,"updated":"2021-08-02T12:06:33.667Z","_id":"ckrsup50r001jtjhv16h0cy93","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Alternatives-to-JPA\"><a href=\"#Alternatives-to-JPA\" class=\"headerlink\" title=\"Alternatives to JPA\"></a>Alternatives to JPA</h1><p>같이 근무했던 시니어 개발자분께서 내용이 좋다면서 추천해주셔서 <a href=\"https://www.youtube.com/watch?v=2zQdmC0vnFU\">링크</a>를 통하여 동영상을 시청했다. 분량은 대충 1시간 가량 되는데, JPA를 사용하면서도 하이버네이트에 대한 충분한 학습을 하지 못해서 겪었던 지난 1년간의 많은 시행착오들이 생각이 났고, Kotlin을 메인으로 사용했을때의 다양한 선택지에 대해서 고민을 해볼 수 있었던거 같아서 매우 유익했다고 할 수 있다. </p>\n<ul>\n<li>데이터를 표현하는 관점에 따라 달라 질 수 있다. <ul>\n<li>Relational</li>\n<li>OOP</li>\n</ul>\n</li>\n<li>두 가지 관점 중 어디를 중점으로 설계 하느냐에 따라 방향이 크게 달라질 수 있다.</li>\n<li>데이터 중심(data-centric)의 경우, OOP적인 설계가 크게 맞지 않을 수 있고, 요즘 ORM을 사용하는 것이 유행인것 마냥 흘러가고 있어서 이에 대한 진지한 고민이 필요해보인다.</li>\n<li>Hibernate가 커버하는 SQL은 약 95프로에 가까운데, 나머지 5프로에 대해서는 커버를 못하기 때문에 실제로 하이엔드 성능을 요구하는 상황에서는 ORM이 맞지 않다고 볼 수 있다.</li>\n</ul>\n<h2 id=\"JPA의-장단점\"><a href=\"#JPA의-장단점\" class=\"headerlink\" title=\"JPA의 장단점?\"></a>JPA의 장단점?</h2><h3 id=\"장점\"><a href=\"#장점\" class=\"headerlink\" title=\"장점\"></a>장점</h3><ul>\n<li>비즈니스 레이어에 대해 DB 중심적인 사고가 아닌 어플리케이션 레이어에서 이를 처리해본 사람들은 NoSQL을 사용했을 때의 접근이 수월했다.</li>\n<li>디비 벤더 종속적으로 개발을 하지 않아도 된다.</li>\n<li>SQL문장에 대해 크게 학습을 하지 않아도 된다.<ul>\n<li>문장으로 쓰느냐 vs 코드(API)로 이를 표현하느냐?</li>\n<li>API로 사용하는 것이 Type-safe한 전개가 가능하기 때문에 안정적이다.</li>\n</ul>\n</li>\n<li>Stateful, Statless에 대한 지원<h3 id=\"단점\"><a href=\"#단점\" class=\"headerlink\" title=\"단점\"></a>단점</h3></li>\n<li>SQL에 친숙한 사람들의 경우, JPQL에 대한 반감 혹은 적응이 힘들 수 있다. 두 가지 접근 방법에 대해 상이한 부분이 존재하며 결국 둘다 배워야 하는 점이 생긴다.</li>\n<li>Hibernate에 대한 러닝커브가 상당히 높다.</li>\n<li>Bulk Operation의 성능이 좋지 않다.</li>\n<li>JPA Vendor에서 제공해주는 기능에 대해서 학습 비용이 발생한다.<ul>\n<li>HQL, @DynamicInsert, @LazyCollection</li>\n<li>2nd Cache(recommend JCache(JSR-305))</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"그래서-쿠팡은-어떻게\"><a href=\"#그래서-쿠팡은-어떻게\" class=\"headerlink\" title=\"그래서 쿠팡은 어떻게?\"></a>그래서 쿠팡은 어떻게?</h2><ul>\n<li>성능보다는 생산성을 위주로 사용했으며, 오픈 후 성능이 나오질 않아서 JPA에 대한 학습도 진행하고 튜닝하는 등의 작업을 진행했었다.</li>\n<li>Not Deep Dive<ul>\n<li>Missing Override(hashCode, equals and toString)</li>\n<li>No Using @NatualId: 비즈니스적인 필요에 의해 @NatualId가 필요한 경우가 있다.</li>\n</ul>\n</li>\n<li>Best Practice가 존재하질 않아 제대로 사용하지 못한 케이스가 많았다.</li>\n<li>퍼포먼스가 나오질 않다보니 비용 측면에서도 충분히 줄일 수 있는 부분이 많은데, 제대로 학습을 하지 못해서 생긴 이슈 아닌 이슈가 많았다고 한다.</li>\n</ul>\n<h2 id=\"그래서-JPA에-대안이-될-수-있는-솔루션들은\"><a href=\"#그래서-JPA에-대안이-될-수-있는-솔루션들은\" class=\"headerlink\" title=\"그래서 JPA에 대안이 될 수 있는 솔루션들은?\"></a>그래서 JPA에 대안이 될 수 있는 솔루션들은?</h2><ul>\n<li>단점은 버리고 장점을 취할 수 있는 다른 대안들은 뭐가 있을까?</li>\n<li>Design Principle<ul>\n<li>OOP 기반의 Multi-DB Vendor</li>\n<li>No Need stateful for Reference Object</li>\n<li>Support association, inheritance, converter in JPA</li>\n</ul>\n</li>\n<li>Performance<ul>\n<li>Speed up to Plain SQL</li>\n<li>Stateless</li>\n<li>Support Asynchronous or Reactive</li>\n<li>Support Bulk or Batch Operation</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Slick\"><a href=\"#Slick\" class=\"headerlink\" title=\"Slick\"></a>Slick</h3><ul>\n<li>Database Access Library</li>\n<li>ORM =&gt; Functional Relational Mapping</li>\n<li>Relational Model to Scala OOP</li>\n<li>Natural fit</li>\n<li>Stateless</li>\n<li>Matures(Slick version 3)(Non-Blocking DBIO)</li>\n</ul>\n<h3 id=\"jOOQ\"><a href=\"#jOOQ\" class=\"headerlink\" title=\"jOOQ\"></a>jOOQ</h3><p>가장 도입하기 쉽고 러닝커브가 낮음</p>\n<ul>\n<li>SQL과 유사하게 API를 사용할 수 있으며, Type-Safe한 성격은 그래도 가져갈 수 있다.</li>\n<li>DB-First, DB Schema로부터 자바의 엔티티 클래스를 만들어야 하는 단점이 존재한다.</li>\n<li>Stateless</li>\n<li>Need DBMS Owner Authority</li>\n</ul>\n<h3 id=\"Requery\"><a href=\"#Requery\" class=\"headerlink\" title=\"Requery\"></a>Requery</h3><ul>\n<li>No Refelection - apt code generation</li>\n<li>Fast Startup &amp; Performance</li>\n<li>Schema Generation</li>\n<li>Non-Blocking</li>\n<li>upsert</li>\n<li>compile time entity validation</li>\n<li>Support alomost JPA Annotations</li>\n</ul>\n<h3 id=\"Exposed-Kotlin-SQL-Framework\"><a href=\"#Exposed-Kotlin-SQL-Framework\" class=\"headerlink\" title=\"Exposed - Kotlin SQL Framework\"></a>Exposed - Kotlin SQL Framework</h3><ul>\n<li>Lightweight SQL Framework</li>\n<li>Two Layers of data access<ul>\n<li>Typesafe SQL wrapping DSL</li>\n<li>Lightweight Data Access Object</li>\n</ul>\n</li>\n<li>Not Mature…</li>\n</ul>\n<h3 id=\"그래서-적합한-대안은\"><a href=\"#그래서-적합한-대안은\" class=\"headerlink\" title=\"그래서 적합한 대안은?\"></a>그래서 적합한 대안은?</h3><ul>\n<li>기존 레거시 데이터베이스가 존재하는 경우? 자바만 하는 경우?<ul>\n<li>jOOQ, requery</li>\n</ul>\n</li>\n<li>Scala만 사용하는 경우?<ul>\n<li>Slick</li>\n</ul>\n</li>\n<li>Kotlin Only?<ul>\n<li>requery, Exposed</li>\n</ul>\n</li>\n<li>언어와 상관 없다면?<ul>\n<li>requery</li>\n</ul>\n</li>\n<li>Reactive Programming?<ul>\n<li>requery with kotlinx-requery</li>\n<li>kotlinx-rxjava2-jdbc</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Requery-Overview\"><a href=\"#Requery-Overview\" class=\"headerlink\" title=\"Requery Overview\"></a>Requery Overview</h2><ul>\n<li>안드로이드에서만 쓰이는 것이 아니다.</li>\n<li>충분히 서버 어플리케이션에서도 사용이 가능하다.</li>\n<li>하이버네이트의 Proxy 개념이 없다. 즉, Lazy Initialize라는 개념 자체가 없다. Mybatis랑 비슷한 개념으로 생각해도 좋다. 속도가 생각보다 빠르다.</li>\n<li>부가적으로 라이브러리는 필요없다. </li>\n<li>Upsert 기능이 굉장히 매력적이다.</li>\n<li>Compile Time Entity/Query Validation</li>\n<li>Entity is stateless</li>\n<li>Thread에 제한을 받지 않음(vs JPA EntityManager)</li>\n<li>Support RxJava, Async Operations on Java8</li>\n</ul>\n<h3 id=\"Why-Requery\"><a href=\"#Why-Requery\" class=\"headerlink\" title=\"Why Requery?\"></a>Why Requery?</h3><ul>\n<li>Provide Benefit of ORM<ul>\n<li>Entity Mapping</li>\n<li>Schema Generation</li>\n<li>Compile Time Error Detecting</li>\n</ul>\n</li>\n</ul>\n<p>Bulk Operation은 JPA에 비해서 거의 100배 가량 빠르다고 한다. REST API 호출에서 퍼포먼스 Checking을 했을 때는 약 10배 가량 JPA를 사용했을때보다 빠르다고 한다. Upsert 기능이 제공되고 레이지한 로드(프록시를 사용한 접근이 아닌 특정 컬럼만 일부 Fetch하고 추후에 필요한 데이터를 가져오는 방식)도 가능하다.</p>\n<h3 id=\"Define-Entity-Java-Kotlin\"><a href=\"#Define-Entity-Java-Kotlin\" class=\"headerlink\" title=\"Define Entity - Java, Kotlin\"></a>Define Entity - Java, Kotlin</h3><p>JPA와 Hibernate보다는 간결한 기능을 제공하고 있다. 간결한 기능을 제공한다는 것은 JPA와 Hibernate보다는 기능적인 가지 수가 좀 적을 수 있다는 이야기이다. </p>\n<h3 id=\"EntityDataStore\"><a href=\"#EntityDataStore\" class=\"headerlink\" title=\"EntityDataStore\"></a>EntityDataStore</h3><ul>\n<li>FindByKey</li>\n<li>select/insert/update/upsert/delete</li>\n<li>where/eq,lte,lt,gt,gte,like,in,not</li>\n<li>groupBy / having / limit / offset</li>\n<li>support SQL Functions<ul>\n<li>count, sum, avg, upper, lower …</li>\n</ul>\n</li>\n<li>raw query</li>\n</ul>\n<h3 id=\"CoroutineEntityDataStore\"><a href=\"#CoroutineEntityDataStore\" class=\"headerlink\" title=\"CoroutineEntityDataStore\"></a>CoroutineEntityDataStore</h3><ul>\n<li>코틀린에서는 코루틴을 통하여 비동기 프로그래밍이 가능하다. JDBC가 블록킹 구간이 존재하지만 엔티티를 ResultSet으로부터 인스턴싱하는 과정을 비동기로하면 CPU를 좀 더 효율적으로 사용할 수 있다.</li>\n<li>requery는 자바의 CompletableFuture를 사용</li>\n</ul>\n<h3 id=\"spring-data-requery\"><a href=\"#spring-data-requery\" class=\"headerlink\" title=\"spring-data-requery\"></a>spring-data-requery</h3><ul>\n<li>운영 시스템은 아니더라도 개인 프로젝트에 적용해본다면 별 문제 없겠지만, 운영시스템에 이걸 적용한다면 ….. 상황을 겪을 수 있다. 그래서 만든 것이 spring-data-requery 프로젝트라고 한다.</li>\n<li>RequeryOperations</li>\n<li>RequeryTransactionManager for TransactionManager<ul>\n<li>Support Spring @Transactional</li>\n</ul>\n</li>\n<li>Better performance than spring-data-jpa<ul>\n<li>exists, paging할때, 매번 연관된 엔티티를 모두 조회하지 않는다.</li>\n</ul>\n</li>\n<li>Repository build in SQL</li>\n<li>ByPropertyName Auto Generation Methods</li>\n<li>@Query, Native SQL Query</li>\n<li>Query By Example</li>\n<li>Not Support<ul>\n<li>조인에 대해서는 개발자가 명시를 해줘야 한다. Annotation Path에 대한 자동으로 Query를 만들어 주지는 않는다.</li>\n<li>Named Parameter의 경우 현재 지원하지 않지만, 추후 지원이 가능 할거라고 한다.<h3 id=\"Query-By-Example\"><a href=\"#Query-By-Example\" class=\"headerlink\" title=\"Query By Example\"></a>Query By Example</h3></li>\n</ul>\n</li>\n<li>검색 조건에 대한 Predicate를 작성하는 거랑 비슷함<h3 id=\"Query-By-Property\"><a href=\"#Query-By-Property\" class=\"headerlink\" title=\"Query By Property\"></a>Query By Property</h3></li>\n<li>JPA의 가장 강력한 부분인데, 이에 대한 지원은 하고 있는데, Association에 대한 지원은 위에서 말한대로 현재 없다고 한다.</li>\n<li>JPA의 findXXX 매소드 시그니처를 사용 하듯이 사용하면 된다.</li>\n</ul>\n<h3 id=\"Exists\"><a href=\"#Exists\" class=\"headerlink\" title=\"Exists\"></a>Exists</h3><ul>\n<li>현재 JPA에서는 ExistExecution에서 모든 조회 결과를 가져오고 이에대한 존재 유무를 체크하게 된다고 한다.</li>\n<li>spring-data-requery에서는 ExistExecution 처리 시, 조회 결과를 단건만 가져와서 조회 조건에 대한 존재 유무를 체크한다고 한다.</li>\n</ul>\n<h3 id=\"Delete-in-JPA\"><a href=\"#Delete-in-JPA\" class=\"headerlink\" title=\"Delete in JPA\"></a>Delete in JPA</h3><ul>\n<li>연관 관계가 어떻게 되는지 모두 파악 후 Delete에 대한 실행이 진행된다.</li>\n<li>연관 관계에 대한 모든 파악을 진행 후 진행해야 하기 때문에 결국 <code>Read</code> 작업이 선행될 수 밖에 없다.</li>\n<li>Bulk Operation의 경우, 성능상 손실이 많이 발생한다.</li>\n<li>Bulk Operation의 원래 의도는 Set 방식으로 바로 지우는 것을 원하게 되는데, 이렇게 Read 액션이 먼저 발생하게 되면 성능적으로 느려질 수 밖에 없는 상황이다. Set 방식으로 움직여야 하는 것은 Direct로 SQL 구문을 사용하여 처리 할 수 있도록 가이드를 해주는 것이 중요하다. 깊게 이해하여 사용하는 것이 너무 중요하다.</li>\n<li>작게는 3배 많게는 100배 가량 퍼포먼스 차이가 발생할 수 있다고 한다.</li>\n</ul>\n<h3 id=\"Future-Works\"><a href=\"#Future-Works\" class=\"headerlink\" title=\"Future Works\"></a>Future Works</h3><ul>\n<li>Named Parameter</li>\n<li><code>@Param</code> in Spring Data</li>\n<li>Complicated Aggregation Operations</li>\n<li>Requery for Apache Phoenix(Hbase)</li>\n<li>CoroutineEntityStore </li>\n</ul>\n<h2 id=\"QnA\"><a href=\"#QnA\" class=\"headerlink\" title=\"QnA\"></a>QnA</h2><ul>\n<li>MySQL에서 넘어가는 이유가 뭔가요?<ul>\n<li>Money!!</li>\n<li>AWS RDS Aurora가 비용이 너무 비쌈…ㅠㅠ</li>\n<li>벤치마크 했을 때, 포스트그래가 생각보다 성능이 좋았다.</li>\n<li>JPA를 쓴 것이 성능이 느려서 고생을 했었는데, DB 벤더를 바꿈으로서 얻게 되는 이점이 생각보다 많이 있을 거라고 생각하여 변경을 하게 됐다.</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Alternatives-to-JPA\"><a href=\"#Alternatives-to-JPA\" class=\"headerlink\" title=\"Alternatives to JPA\"></a>Alternatives to JPA</h1><p>같이 근무했던 시니어 개발자분께서 내용이 좋다면서 추천해주셔서 <a href=\"https://www.youtube.com/watch?v=2zQdmC0vnFU\">링크</a>를 통하여 동영상을 시청했다. 분량은 대충 1시간 가량 되는데, JPA를 사용하면서도 하이버네이트에 대한 충분한 학습을 하지 못해서 겪었던 지난 1년간의 많은 시행착오들이 생각이 났고, Kotlin을 메인으로 사용했을때의 다양한 선택지에 대해서 고민을 해볼 수 있었던거 같아서 매우 유익했다고 할 수 있다. </p>\n<ul>\n<li>데이터를 표현하는 관점에 따라 달라 질 수 있다. <ul>\n<li>Relational</li>\n<li>OOP</li>\n</ul>\n</li>\n<li>두 가지 관점 중 어디를 중점으로 설계 하느냐에 따라 방향이 크게 달라질 수 있다.</li>\n<li>데이터 중심(data-centric)의 경우, OOP적인 설계가 크게 맞지 않을 수 있고, 요즘 ORM을 사용하는 것이 유행인것 마냥 흘러가고 있어서 이에 대한 진지한 고민이 필요해보인다.</li>\n<li>Hibernate가 커버하는 SQL은 약 95프로에 가까운데, 나머지 5프로에 대해서는 커버를 못하기 때문에 실제로 하이엔드 성능을 요구하는 상황에서는 ORM이 맞지 않다고 볼 수 있다.</li>\n</ul>\n<h2 id=\"JPA의-장단점\"><a href=\"#JPA의-장단점\" class=\"headerlink\" title=\"JPA의 장단점?\"></a>JPA의 장단점?</h2><h3 id=\"장점\"><a href=\"#장점\" class=\"headerlink\" title=\"장점\"></a>장점</h3><ul>\n<li>비즈니스 레이어에 대해 DB 중심적인 사고가 아닌 어플리케이션 레이어에서 이를 처리해본 사람들은 NoSQL을 사용했을 때의 접근이 수월했다.</li>\n<li>디비 벤더 종속적으로 개발을 하지 않아도 된다.</li>\n<li>SQL문장에 대해 크게 학습을 하지 않아도 된다.<ul>\n<li>문장으로 쓰느냐 vs 코드(API)로 이를 표현하느냐?</li>\n<li>API로 사용하는 것이 Type-safe한 전개가 가능하기 때문에 안정적이다.</li>\n</ul>\n</li>\n<li>Stateful, Statless에 대한 지원<h3 id=\"단점\"><a href=\"#단점\" class=\"headerlink\" title=\"단점\"></a>단점</h3></li>\n<li>SQL에 친숙한 사람들의 경우, JPQL에 대한 반감 혹은 적응이 힘들 수 있다. 두 가지 접근 방법에 대해 상이한 부분이 존재하며 결국 둘다 배워야 하는 점이 생긴다.</li>\n<li>Hibernate에 대한 러닝커브가 상당히 높다.</li>\n<li>Bulk Operation의 성능이 좋지 않다.</li>\n<li>JPA Vendor에서 제공해주는 기능에 대해서 학습 비용이 발생한다.<ul>\n<li>HQL, @DynamicInsert, @LazyCollection</li>\n<li>2nd Cache(recommend JCache(JSR-305))</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"그래서-쿠팡은-어떻게\"><a href=\"#그래서-쿠팡은-어떻게\" class=\"headerlink\" title=\"그래서 쿠팡은 어떻게?\"></a>그래서 쿠팡은 어떻게?</h2><ul>\n<li>성능보다는 생산성을 위주로 사용했으며, 오픈 후 성능이 나오질 않아서 JPA에 대한 학습도 진행하고 튜닝하는 등의 작업을 진행했었다.</li>\n<li>Not Deep Dive<ul>\n<li>Missing Override(hashCode, equals and toString)</li>\n<li>No Using @NatualId: 비즈니스적인 필요에 의해 @NatualId가 필요한 경우가 있다.</li>\n</ul>\n</li>\n<li>Best Practice가 존재하질 않아 제대로 사용하지 못한 케이스가 많았다.</li>\n<li>퍼포먼스가 나오질 않다보니 비용 측면에서도 충분히 줄일 수 있는 부분이 많은데, 제대로 학습을 하지 못해서 생긴 이슈 아닌 이슈가 많았다고 한다.</li>\n</ul>\n<h2 id=\"그래서-JPA에-대안이-될-수-있는-솔루션들은\"><a href=\"#그래서-JPA에-대안이-될-수-있는-솔루션들은\" class=\"headerlink\" title=\"그래서 JPA에 대안이 될 수 있는 솔루션들은?\"></a>그래서 JPA에 대안이 될 수 있는 솔루션들은?</h2><ul>\n<li>단점은 버리고 장점을 취할 수 있는 다른 대안들은 뭐가 있을까?</li>\n<li>Design Principle<ul>\n<li>OOP 기반의 Multi-DB Vendor</li>\n<li>No Need stateful for Reference Object</li>\n<li>Support association, inheritance, converter in JPA</li>\n</ul>\n</li>\n<li>Performance<ul>\n<li>Speed up to Plain SQL</li>\n<li>Stateless</li>\n<li>Support Asynchronous or Reactive</li>\n<li>Support Bulk or Batch Operation</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Slick\"><a href=\"#Slick\" class=\"headerlink\" title=\"Slick\"></a>Slick</h3><ul>\n<li>Database Access Library</li>\n<li>ORM =&gt; Functional Relational Mapping</li>\n<li>Relational Model to Scala OOP</li>\n<li>Natural fit</li>\n<li>Stateless</li>\n<li>Matures(Slick version 3)(Non-Blocking DBIO)</li>\n</ul>\n<h3 id=\"jOOQ\"><a href=\"#jOOQ\" class=\"headerlink\" title=\"jOOQ\"></a>jOOQ</h3><p>가장 도입하기 쉽고 러닝커브가 낮음</p>\n<ul>\n<li>SQL과 유사하게 API를 사용할 수 있으며, Type-Safe한 성격은 그래도 가져갈 수 있다.</li>\n<li>DB-First, DB Schema로부터 자바의 엔티티 클래스를 만들어야 하는 단점이 존재한다.</li>\n<li>Stateless</li>\n<li>Need DBMS Owner Authority</li>\n</ul>\n<h3 id=\"Requery\"><a href=\"#Requery\" class=\"headerlink\" title=\"Requery\"></a>Requery</h3><ul>\n<li>No Refelection - apt code generation</li>\n<li>Fast Startup &amp; Performance</li>\n<li>Schema Generation</li>\n<li>Non-Blocking</li>\n<li>upsert</li>\n<li>compile time entity validation</li>\n<li>Support alomost JPA Annotations</li>\n</ul>\n<h3 id=\"Exposed-Kotlin-SQL-Framework\"><a href=\"#Exposed-Kotlin-SQL-Framework\" class=\"headerlink\" title=\"Exposed - Kotlin SQL Framework\"></a>Exposed - Kotlin SQL Framework</h3><ul>\n<li>Lightweight SQL Framework</li>\n<li>Two Layers of data access<ul>\n<li>Typesafe SQL wrapping DSL</li>\n<li>Lightweight Data Access Object</li>\n</ul>\n</li>\n<li>Not Mature…</li>\n</ul>\n<h3 id=\"그래서-적합한-대안은\"><a href=\"#그래서-적합한-대안은\" class=\"headerlink\" title=\"그래서 적합한 대안은?\"></a>그래서 적합한 대안은?</h3><ul>\n<li>기존 레거시 데이터베이스가 존재하는 경우? 자바만 하는 경우?<ul>\n<li>jOOQ, requery</li>\n</ul>\n</li>\n<li>Scala만 사용하는 경우?<ul>\n<li>Slick</li>\n</ul>\n</li>\n<li>Kotlin Only?<ul>\n<li>requery, Exposed</li>\n</ul>\n</li>\n<li>언어와 상관 없다면?<ul>\n<li>requery</li>\n</ul>\n</li>\n<li>Reactive Programming?<ul>\n<li>requery with kotlinx-requery</li>\n<li>kotlinx-rxjava2-jdbc</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Requery-Overview\"><a href=\"#Requery-Overview\" class=\"headerlink\" title=\"Requery Overview\"></a>Requery Overview</h2><ul>\n<li>안드로이드에서만 쓰이는 것이 아니다.</li>\n<li>충분히 서버 어플리케이션에서도 사용이 가능하다.</li>\n<li>하이버네이트의 Proxy 개념이 없다. 즉, Lazy Initialize라는 개념 자체가 없다. Mybatis랑 비슷한 개념으로 생각해도 좋다. 속도가 생각보다 빠르다.</li>\n<li>부가적으로 라이브러리는 필요없다. </li>\n<li>Upsert 기능이 굉장히 매력적이다.</li>\n<li>Compile Time Entity/Query Validation</li>\n<li>Entity is stateless</li>\n<li>Thread에 제한을 받지 않음(vs JPA EntityManager)</li>\n<li>Support RxJava, Async Operations on Java8</li>\n</ul>\n<h3 id=\"Why-Requery\"><a href=\"#Why-Requery\" class=\"headerlink\" title=\"Why Requery?\"></a>Why Requery?</h3><ul>\n<li>Provide Benefit of ORM<ul>\n<li>Entity Mapping</li>\n<li>Schema Generation</li>\n<li>Compile Time Error Detecting</li>\n</ul>\n</li>\n</ul>\n<p>Bulk Operation은 JPA에 비해서 거의 100배 가량 빠르다고 한다. REST API 호출에서 퍼포먼스 Checking을 했을 때는 약 10배 가량 JPA를 사용했을때보다 빠르다고 한다. Upsert 기능이 제공되고 레이지한 로드(프록시를 사용한 접근이 아닌 특정 컬럼만 일부 Fetch하고 추후에 필요한 데이터를 가져오는 방식)도 가능하다.</p>\n<h3 id=\"Define-Entity-Java-Kotlin\"><a href=\"#Define-Entity-Java-Kotlin\" class=\"headerlink\" title=\"Define Entity - Java, Kotlin\"></a>Define Entity - Java, Kotlin</h3><p>JPA와 Hibernate보다는 간결한 기능을 제공하고 있다. 간결한 기능을 제공한다는 것은 JPA와 Hibernate보다는 기능적인 가지 수가 좀 적을 수 있다는 이야기이다. </p>\n<h3 id=\"EntityDataStore\"><a href=\"#EntityDataStore\" class=\"headerlink\" title=\"EntityDataStore\"></a>EntityDataStore</h3><ul>\n<li>FindByKey</li>\n<li>select/insert/update/upsert/delete</li>\n<li>where/eq,lte,lt,gt,gte,like,in,not</li>\n<li>groupBy / having / limit / offset</li>\n<li>support SQL Functions<ul>\n<li>count, sum, avg, upper, lower …</li>\n</ul>\n</li>\n<li>raw query</li>\n</ul>\n<h3 id=\"CoroutineEntityDataStore\"><a href=\"#CoroutineEntityDataStore\" class=\"headerlink\" title=\"CoroutineEntityDataStore\"></a>CoroutineEntityDataStore</h3><ul>\n<li>코틀린에서는 코루틴을 통하여 비동기 프로그래밍이 가능하다. JDBC가 블록킹 구간이 존재하지만 엔티티를 ResultSet으로부터 인스턴싱하는 과정을 비동기로하면 CPU를 좀 더 효율적으로 사용할 수 있다.</li>\n<li>requery는 자바의 CompletableFuture를 사용</li>\n</ul>\n<h3 id=\"spring-data-requery\"><a href=\"#spring-data-requery\" class=\"headerlink\" title=\"spring-data-requery\"></a>spring-data-requery</h3><ul>\n<li>운영 시스템은 아니더라도 개인 프로젝트에 적용해본다면 별 문제 없겠지만, 운영시스템에 이걸 적용한다면 ….. 상황을 겪을 수 있다. 그래서 만든 것이 spring-data-requery 프로젝트라고 한다.</li>\n<li>RequeryOperations</li>\n<li>RequeryTransactionManager for TransactionManager<ul>\n<li>Support Spring @Transactional</li>\n</ul>\n</li>\n<li>Better performance than spring-data-jpa<ul>\n<li>exists, paging할때, 매번 연관된 엔티티를 모두 조회하지 않는다.</li>\n</ul>\n</li>\n<li>Repository build in SQL</li>\n<li>ByPropertyName Auto Generation Methods</li>\n<li>@Query, Native SQL Query</li>\n<li>Query By Example</li>\n<li>Not Support<ul>\n<li>조인에 대해서는 개발자가 명시를 해줘야 한다. Annotation Path에 대한 자동으로 Query를 만들어 주지는 않는다.</li>\n<li>Named Parameter의 경우 현재 지원하지 않지만, 추후 지원이 가능 할거라고 한다.<h3 id=\"Query-By-Example\"><a href=\"#Query-By-Example\" class=\"headerlink\" title=\"Query By Example\"></a>Query By Example</h3></li>\n</ul>\n</li>\n<li>검색 조건에 대한 Predicate를 작성하는 거랑 비슷함<h3 id=\"Query-By-Property\"><a href=\"#Query-By-Property\" class=\"headerlink\" title=\"Query By Property\"></a>Query By Property</h3></li>\n<li>JPA의 가장 강력한 부분인데, 이에 대한 지원은 하고 있는데, Association에 대한 지원은 위에서 말한대로 현재 없다고 한다.</li>\n<li>JPA의 findXXX 매소드 시그니처를 사용 하듯이 사용하면 된다.</li>\n</ul>\n<h3 id=\"Exists\"><a href=\"#Exists\" class=\"headerlink\" title=\"Exists\"></a>Exists</h3><ul>\n<li>현재 JPA에서는 ExistExecution에서 모든 조회 결과를 가져오고 이에대한 존재 유무를 체크하게 된다고 한다.</li>\n<li>spring-data-requery에서는 ExistExecution 처리 시, 조회 결과를 단건만 가져와서 조회 조건에 대한 존재 유무를 체크한다고 한다.</li>\n</ul>\n<h3 id=\"Delete-in-JPA\"><a href=\"#Delete-in-JPA\" class=\"headerlink\" title=\"Delete in JPA\"></a>Delete in JPA</h3><ul>\n<li>연관 관계가 어떻게 되는지 모두 파악 후 Delete에 대한 실행이 진행된다.</li>\n<li>연관 관계에 대한 모든 파악을 진행 후 진행해야 하기 때문에 결국 <code>Read</code> 작업이 선행될 수 밖에 없다.</li>\n<li>Bulk Operation의 경우, 성능상 손실이 많이 발생한다.</li>\n<li>Bulk Operation의 원래 의도는 Set 방식으로 바로 지우는 것을 원하게 되는데, 이렇게 Read 액션이 먼저 발생하게 되면 성능적으로 느려질 수 밖에 없는 상황이다. Set 방식으로 움직여야 하는 것은 Direct로 SQL 구문을 사용하여 처리 할 수 있도록 가이드를 해주는 것이 중요하다. 깊게 이해하여 사용하는 것이 너무 중요하다.</li>\n<li>작게는 3배 많게는 100배 가량 퍼포먼스 차이가 발생할 수 있다고 한다.</li>\n</ul>\n<h3 id=\"Future-Works\"><a href=\"#Future-Works\" class=\"headerlink\" title=\"Future Works\"></a>Future Works</h3><ul>\n<li>Named Parameter</li>\n<li><code>@Param</code> in Spring Data</li>\n<li>Complicated Aggregation Operations</li>\n<li>Requery for Apache Phoenix(Hbase)</li>\n<li>CoroutineEntityStore </li>\n</ul>\n<h2 id=\"QnA\"><a href=\"#QnA\" class=\"headerlink\" title=\"QnA\"></a>QnA</h2><ul>\n<li>MySQL에서 넘어가는 이유가 뭔가요?<ul>\n<li>Money!!</li>\n<li>AWS RDS Aurora가 비용이 너무 비쌈…ㅠㅠ</li>\n<li>벤치마크 했을 때, 포스트그래가 생각보다 성능이 좋았다.</li>\n<li>JPA를 쓴 것이 성능이 느려서 고생을 했었는데, DB 벤더를 바꿈으로서 얻게 되는 이점이 생각보다 많이 있을 거라고 생각하여 변경을 하게 됐다.</li>\n</ul>\n</li>\n</ul>\n"},{"title":"JPA Insert 성능 올려보기","date":"2020-08-11T15:00:00.000Z","_content":"\n# JPA Insert 성능 올려보기\nJPA를 사용하다보면, 불필요하게 발생하는 쿼리를 종종 볼수 있다. 물론 도메인 상황이 select 쿼리가 반드시 필요한 상황이라면 문제가 되지 않겠지만, 경우에 따라서 insert 쿼리만 발생하도록 하는 것이 최선일 경우도 있다. 실제 업무에서 불필요하게 발생하는 select 쿼리로 인해 DBA분들에게 문의를 받기로 해서 이에 관련된 부분을 해결(?)하고자 이것저것 찾아본 내용을 정리하려고 한다.\n\n### Persistable 인터페이스 구현\nData JPA 문서를 살펴보면 `Persistable`이라는 인터페이스를 언급한 부분이 있다. 인터페이스 코드를 살펴보면 간단하게 엔티티의 상태를 표현할 수 있으며, 이에 따라 실제 JpaRepository의 구현 클래스인 `SimpleJpaRepository`에서 isNew 상태를 판단하여 불필요한 Select를 줄이고 바로 Insert문을 실행할 수 있게 된다. 간단한 엔티티 구현 코드를 아래와 같다.\n\n```kotlin\npackage me.daniel.enhancedperformancejpainsert.user_access_log\n\nimport org.hibernate.annotations.CreationTimestamp\nimport org.hibernate.annotations.UpdateTimestamp\nimport org.springframework.data.domain.Persistable\nimport java.time.LocalDateTime\nimport java.util.*\nimport javax.persistence.*\n\n@Entity\n@Table(name = \"USER_ACCESS_LOGS\")\nclass UserAccessLog protected constructor() : Persistable<String> {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    val id = 0L\n\n    var userId: String = \"\"\n\n    @CreationTimestamp\n    lateinit var createdAt: LocalDateTime\n\n    @UpdateTimestamp\n    lateinit var updatedAt: LocalDateTime\n\n    companion object {\n        fun create(userId: String) = UserAccessLog().apply {\n            this.userId = userId\n        }\n    }\n\n    @Transient\n    private var isNew = true\n\n    override fun isNew() = isNew\n\n    @PrePersist\n    @PostLoad\n    internal fun markNewState() {\n        this.isNew = false\n    }\n\n    override fun getId(): String? {\n        TODO(\"Not yet implemented\")\n    }\n}\n```\n\n`isNew`의 상태는 `@Transient` 어노테이션을 사용하여 영속화 대상에서 배제했으며, 실제 JPA의 영속화 관련 이벤트를 잡아 @PrePersist와 @PostLoad 단계에서 상태를 다시 false로 바꾸도록 했다. 이렇게 되면 `repository.save()`를 하는 시점에는 엔티티의 isNew상태가 true일 경우 바로 insert 쿼리만 발생하게 된다. 물론 update를 처리하는 경우도 있을 수 있으니 이에 대한 처리를 위해 @PostLoad를 붙여서 해당 케이스를 피했다.\n\n### Batch Insert 구현 추가해보기\n사용자들의 로그를 만약 RDBMS를 통하여 적재하는 경우를 생각해보자. 로그는 대부분 수정성격의 트랜잭션이 아닌 단순 적재만 하는 케이스일 경우가 농후하다. Persistable 인터페이스를 구현하여 insert만 발생하도록 하는 것도 차선책이 될수는 있지만, 이런 작업에 매번 트랜잭션을 발생시켜 커넥션을 낭비하는 건 매우 비효율적이므로 이에 대한 처리를 해줄 수 있는 코드를 추가해보도록 하겠다. 여러 사용자들의 로그를 집계하여 저장해야하기 때문에 기존 SimpleJpaRepository의 saveAll 구현이 아닌 별도의 커스텀 쿼리 메소드를 만들어서 처리할 것이다.\n\n```kotlin\n// (1)\n@SpringBootApplication\n@EnableJpaRepositories(\n    repositoryBaseClass = BatchRepositoryImpl::class \n)\nclass EnhancedPerformanceJpaInsertApplication\n\n// (2)\n@NoRepositoryBean \ninterface BatchRepository<T, ID> : JpaRepository<T, ID> {\n    fun <S : T> saveInBatch(entities: Iterable<S>)\n}\n\n// (3)\n@Transactional(propagation = Propagation.REQUIRES_NEW)\nclass BatchRepositoryImpl<T, ID : Serializable?>(\n        private val entityInformation: JpaEntityInformation<T, ID>,\n        private val entityManager: EntityManager\n) : SimpleJpaRepository<T, ID>(entityInformation, entityManager), BatchRepository<T, ID> {\n\n    @Value(\"\\${spring.jpa.properties.hibernate.jdbc.batch_size}\")\n    private var batchSize: Int? = 30\n\n    private val logger = LoggerFactory.getLogger(BatchRepository::class.java)\n\n    override fun <S : T> saveInBatch(entities: Iterable<S>) {\n        val entityTransaction = entityManager\n                .entityManagerFactory\n                .createEntityManager()\n                .transaction\n        try {\n            entityTransaction.begin()\n            for ((i, entity) in entities.withIndex()) {\n                if (i % (batchSize ?: 30) == 0 && i > 0) {\n                    logger.info(\"Flushing the EntityManager containing $batchSize entities ...\")\n                    entityTransaction.commit()\n                    entityTransaction.begin()\n                    entityManager.clear()\n                }\n                entityManager.persist(entity)\n            }\n            logger.info(\"Flushing the remaining entities ...\")\n            entityTransaction.commit()\n        } catch (e: RuntimeException) {\n            if (entityTransaction.isActive) {\n                entityTransaction.rollback()\n            }\n            throw e\n        } finally {\n            entityManager.close()\n        }\n    }\n}\n\n```\n\n(1) `@EnableJpaRepositories`을 선언하고 repositoryBaseClass에 확장하려는 인터페이스 클래스를 지정해준다.\n(2) 확장하려는 인터페이스 스펙을 지정해준다\n(3) 확장하려는 인터페이스 구현을 추가해준다. \n\n신규로 확장하는 레파지토리에는 saveInBatch에 대한 구현이 포함되어 있다. saveAll을 사용해도 되겠지만, saveAll의 경우 SimpleJpaRepository의 기본 구현을 따르기 때문에 다량의 insert가 발생할 경우 이에 대한 청크를 지정해주기 곤란하고, 트랜잭션에 대한 플러쉬/커밋 시점에 대한 지정이 어렵다. batchSize는 프로퍼티를 통하여 참조하고 해당 길이 기준으로 청크 처리하여 영속성 컨텍스트를 플러시/커밋 처리한다.\n\n### 로그 처리 프로세서 추가해보기\n불특정 다수의 사용자들의 로그를 수집하고 이를 batchSize만큼 모아서 데이터베이스에 플러시해야 하는 요구사항을 처리하기 위해 리액티브 스트림`Reactor`을 사용하려고 한다. 처리 프로세서는 스프링 빈(@Component)로 선언할것이며, 코드는 아래와 같다.\n\n```kotlin\n@Component\nclass UserAccessLogProcessor(\n    private val repository: UserAccessLogRepository\n) {\n    private val logger = LoggerFactory.getLogger(this.javaClass)\n    private val emitterProcessor = EmitterProcessor.create<UserAccessLog>()\n    private val flusSink = emitterProcessor.sink()\n    private lateinit var disposable: Disposable\n\n    fun send(item: UserAccessLog) {\n        flusSink.next(item)\n    }\n\n    @PostConstruct\n    protected fun init() {\n        disposable = emitterProcessor\n                .bufferTimeout(30, Duration.ofSeconds(5))\n                .delaySequence(Duration.ofMillis(100))\n                .limitRate(2)\n                .parallel(32)\n                .runOn(Schedulers.parallel())\n                .doOnNext {\n                    logger.info(\"items = {}\", it)\n                }\n                .flatMap {\n                    Mono.fromCallable { repository.saveInBatch(it) }\n                            .subscribeOn(Schedulers.boundedElastic())\n                }\n                .doOnError {\n                    logger.error(\"Error\", it)\n                }\n                .subscribe()\n    }\n\n    @PreDestroy\n    protected fun destroy() {\n        disposable.dispose()\n    }\n\n}\n```\n\n- EmitterProcessor를 활용하여 불특정 다수(멀티 스레드)에서 들어오는 이벤트를 수집하여 처리\n- 이벤트에 대한 구독은 스프링 빈의 이벤트 라이프사이클을 활용했다.\n- 배치 처리를 해야 하므로 이를 위해 bufferTimeout을 지정하여 개수를 배치 사이즈만큼 모아서 이벤트를 방출\n- 만약 다량의 이벤트가 동시에 들어올 경우, 이를 처리하는 다운스트림의 연산자에서 문제가 생길 수 있기 때문에 이에 대한 적절한 배압 처리를 위해 limitRate와 delaySequence를 지정해줬다.(필요하다면 배압 정책을 지정해줘도 괜찮다)\n- 데이터베이스에 대한 Blocking 연산을 회피하기 위해 데이터베이스 트랜잭션 부분은 별도의 스레드에서 처리하도록 분리\n  * 적절한 배압 정책이나 딜레이 정책이 없다면 디비 커넥션 고갈이나 스레드 고갈 문제를 겪을 수 밖에 없다. 논블록킹 연산을 지원하는 데이터베이스라면 모르겠지만, 지금은 JDBC 베이스의 JPA를 사용하기 때문에 이에 대한 스레드 분리는 필수적이다.\n\n\n#### 고려헤야 할 부분 & 개선해야 할 부분은?\n- 결국 메모리에 이벤트 스트림을 모아서 처리하는 로직이기 때문에, 유실에 대한 부분은 반드시 고려해야 된다. 백업 전략으로는 디스크를 통하여 이벤트 데이터를 저장하는 방법이 있을 수도 있고 아니면 별도의 구현체(큐 혹은 NoSQL)를 사용하는 방법이 있을 수 있다.","source":"_posts/Persistence/JPA_ENHANCE_INSERT.md","raw":"---\ntitle: 'JPA Insert 성능 올려보기'\ndate: 2020/8/12 00:00:00\ncategories:\n- Persistence\n---\n\n# JPA Insert 성능 올려보기\nJPA를 사용하다보면, 불필요하게 발생하는 쿼리를 종종 볼수 있다. 물론 도메인 상황이 select 쿼리가 반드시 필요한 상황이라면 문제가 되지 않겠지만, 경우에 따라서 insert 쿼리만 발생하도록 하는 것이 최선일 경우도 있다. 실제 업무에서 불필요하게 발생하는 select 쿼리로 인해 DBA분들에게 문의를 받기로 해서 이에 관련된 부분을 해결(?)하고자 이것저것 찾아본 내용을 정리하려고 한다.\n\n### Persistable 인터페이스 구현\nData JPA 문서를 살펴보면 `Persistable`이라는 인터페이스를 언급한 부분이 있다. 인터페이스 코드를 살펴보면 간단하게 엔티티의 상태를 표현할 수 있으며, 이에 따라 실제 JpaRepository의 구현 클래스인 `SimpleJpaRepository`에서 isNew 상태를 판단하여 불필요한 Select를 줄이고 바로 Insert문을 실행할 수 있게 된다. 간단한 엔티티 구현 코드를 아래와 같다.\n\n```kotlin\npackage me.daniel.enhancedperformancejpainsert.user_access_log\n\nimport org.hibernate.annotations.CreationTimestamp\nimport org.hibernate.annotations.UpdateTimestamp\nimport org.springframework.data.domain.Persistable\nimport java.time.LocalDateTime\nimport java.util.*\nimport javax.persistence.*\n\n@Entity\n@Table(name = \"USER_ACCESS_LOGS\")\nclass UserAccessLog protected constructor() : Persistable<String> {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    val id = 0L\n\n    var userId: String = \"\"\n\n    @CreationTimestamp\n    lateinit var createdAt: LocalDateTime\n\n    @UpdateTimestamp\n    lateinit var updatedAt: LocalDateTime\n\n    companion object {\n        fun create(userId: String) = UserAccessLog().apply {\n            this.userId = userId\n        }\n    }\n\n    @Transient\n    private var isNew = true\n\n    override fun isNew() = isNew\n\n    @PrePersist\n    @PostLoad\n    internal fun markNewState() {\n        this.isNew = false\n    }\n\n    override fun getId(): String? {\n        TODO(\"Not yet implemented\")\n    }\n}\n```\n\n`isNew`의 상태는 `@Transient` 어노테이션을 사용하여 영속화 대상에서 배제했으며, 실제 JPA의 영속화 관련 이벤트를 잡아 @PrePersist와 @PostLoad 단계에서 상태를 다시 false로 바꾸도록 했다. 이렇게 되면 `repository.save()`를 하는 시점에는 엔티티의 isNew상태가 true일 경우 바로 insert 쿼리만 발생하게 된다. 물론 update를 처리하는 경우도 있을 수 있으니 이에 대한 처리를 위해 @PostLoad를 붙여서 해당 케이스를 피했다.\n\n### Batch Insert 구현 추가해보기\n사용자들의 로그를 만약 RDBMS를 통하여 적재하는 경우를 생각해보자. 로그는 대부분 수정성격의 트랜잭션이 아닌 단순 적재만 하는 케이스일 경우가 농후하다. Persistable 인터페이스를 구현하여 insert만 발생하도록 하는 것도 차선책이 될수는 있지만, 이런 작업에 매번 트랜잭션을 발생시켜 커넥션을 낭비하는 건 매우 비효율적이므로 이에 대한 처리를 해줄 수 있는 코드를 추가해보도록 하겠다. 여러 사용자들의 로그를 집계하여 저장해야하기 때문에 기존 SimpleJpaRepository의 saveAll 구현이 아닌 별도의 커스텀 쿼리 메소드를 만들어서 처리할 것이다.\n\n```kotlin\n// (1)\n@SpringBootApplication\n@EnableJpaRepositories(\n    repositoryBaseClass = BatchRepositoryImpl::class \n)\nclass EnhancedPerformanceJpaInsertApplication\n\n// (2)\n@NoRepositoryBean \ninterface BatchRepository<T, ID> : JpaRepository<T, ID> {\n    fun <S : T> saveInBatch(entities: Iterable<S>)\n}\n\n// (3)\n@Transactional(propagation = Propagation.REQUIRES_NEW)\nclass BatchRepositoryImpl<T, ID : Serializable?>(\n        private val entityInformation: JpaEntityInformation<T, ID>,\n        private val entityManager: EntityManager\n) : SimpleJpaRepository<T, ID>(entityInformation, entityManager), BatchRepository<T, ID> {\n\n    @Value(\"\\${spring.jpa.properties.hibernate.jdbc.batch_size}\")\n    private var batchSize: Int? = 30\n\n    private val logger = LoggerFactory.getLogger(BatchRepository::class.java)\n\n    override fun <S : T> saveInBatch(entities: Iterable<S>) {\n        val entityTransaction = entityManager\n                .entityManagerFactory\n                .createEntityManager()\n                .transaction\n        try {\n            entityTransaction.begin()\n            for ((i, entity) in entities.withIndex()) {\n                if (i % (batchSize ?: 30) == 0 && i > 0) {\n                    logger.info(\"Flushing the EntityManager containing $batchSize entities ...\")\n                    entityTransaction.commit()\n                    entityTransaction.begin()\n                    entityManager.clear()\n                }\n                entityManager.persist(entity)\n            }\n            logger.info(\"Flushing the remaining entities ...\")\n            entityTransaction.commit()\n        } catch (e: RuntimeException) {\n            if (entityTransaction.isActive) {\n                entityTransaction.rollback()\n            }\n            throw e\n        } finally {\n            entityManager.close()\n        }\n    }\n}\n\n```\n\n(1) `@EnableJpaRepositories`을 선언하고 repositoryBaseClass에 확장하려는 인터페이스 클래스를 지정해준다.\n(2) 확장하려는 인터페이스 스펙을 지정해준다\n(3) 확장하려는 인터페이스 구현을 추가해준다. \n\n신규로 확장하는 레파지토리에는 saveInBatch에 대한 구현이 포함되어 있다. saveAll을 사용해도 되겠지만, saveAll의 경우 SimpleJpaRepository의 기본 구현을 따르기 때문에 다량의 insert가 발생할 경우 이에 대한 청크를 지정해주기 곤란하고, 트랜잭션에 대한 플러쉬/커밋 시점에 대한 지정이 어렵다. batchSize는 프로퍼티를 통하여 참조하고 해당 길이 기준으로 청크 처리하여 영속성 컨텍스트를 플러시/커밋 처리한다.\n\n### 로그 처리 프로세서 추가해보기\n불특정 다수의 사용자들의 로그를 수집하고 이를 batchSize만큼 모아서 데이터베이스에 플러시해야 하는 요구사항을 처리하기 위해 리액티브 스트림`Reactor`을 사용하려고 한다. 처리 프로세서는 스프링 빈(@Component)로 선언할것이며, 코드는 아래와 같다.\n\n```kotlin\n@Component\nclass UserAccessLogProcessor(\n    private val repository: UserAccessLogRepository\n) {\n    private val logger = LoggerFactory.getLogger(this.javaClass)\n    private val emitterProcessor = EmitterProcessor.create<UserAccessLog>()\n    private val flusSink = emitterProcessor.sink()\n    private lateinit var disposable: Disposable\n\n    fun send(item: UserAccessLog) {\n        flusSink.next(item)\n    }\n\n    @PostConstruct\n    protected fun init() {\n        disposable = emitterProcessor\n                .bufferTimeout(30, Duration.ofSeconds(5))\n                .delaySequence(Duration.ofMillis(100))\n                .limitRate(2)\n                .parallel(32)\n                .runOn(Schedulers.parallel())\n                .doOnNext {\n                    logger.info(\"items = {}\", it)\n                }\n                .flatMap {\n                    Mono.fromCallable { repository.saveInBatch(it) }\n                            .subscribeOn(Schedulers.boundedElastic())\n                }\n                .doOnError {\n                    logger.error(\"Error\", it)\n                }\n                .subscribe()\n    }\n\n    @PreDestroy\n    protected fun destroy() {\n        disposable.dispose()\n    }\n\n}\n```\n\n- EmitterProcessor를 활용하여 불특정 다수(멀티 스레드)에서 들어오는 이벤트를 수집하여 처리\n- 이벤트에 대한 구독은 스프링 빈의 이벤트 라이프사이클을 활용했다.\n- 배치 처리를 해야 하므로 이를 위해 bufferTimeout을 지정하여 개수를 배치 사이즈만큼 모아서 이벤트를 방출\n- 만약 다량의 이벤트가 동시에 들어올 경우, 이를 처리하는 다운스트림의 연산자에서 문제가 생길 수 있기 때문에 이에 대한 적절한 배압 처리를 위해 limitRate와 delaySequence를 지정해줬다.(필요하다면 배압 정책을 지정해줘도 괜찮다)\n- 데이터베이스에 대한 Blocking 연산을 회피하기 위해 데이터베이스 트랜잭션 부분은 별도의 스레드에서 처리하도록 분리\n  * 적절한 배압 정책이나 딜레이 정책이 없다면 디비 커넥션 고갈이나 스레드 고갈 문제를 겪을 수 밖에 없다. 논블록킹 연산을 지원하는 데이터베이스라면 모르겠지만, 지금은 JDBC 베이스의 JPA를 사용하기 때문에 이에 대한 스레드 분리는 필수적이다.\n\n\n#### 고려헤야 할 부분 & 개선해야 할 부분은?\n- 결국 메모리에 이벤트 스트림을 모아서 처리하는 로직이기 때문에, 유실에 대한 부분은 반드시 고려해야 된다. 백업 전략으로는 디스크를 통하여 이벤트 데이터를 저장하는 방법이 있을 수도 있고 아니면 별도의 구현체(큐 혹은 NoSQL)를 사용하는 방법이 있을 수 있다.","slug":"Persistence/JPA_ENHANCE_INSERT","published":1,"updated":"2021-08-02T12:29:52.327Z","_id":"ckrsup50r001ktjhvg8132iud","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"JPA-Insert-성능-올려보기\"><a href=\"#JPA-Insert-성능-올려보기\" class=\"headerlink\" title=\"JPA Insert 성능 올려보기\"></a>JPA Insert 성능 올려보기</h1><p>JPA를 사용하다보면, 불필요하게 발생하는 쿼리를 종종 볼수 있다. 물론 도메인 상황이 select 쿼리가 반드시 필요한 상황이라면 문제가 되지 않겠지만, 경우에 따라서 insert 쿼리만 발생하도록 하는 것이 최선일 경우도 있다. 실제 업무에서 불필요하게 발생하는 select 쿼리로 인해 DBA분들에게 문의를 받기로 해서 이에 관련된 부분을 해결(?)하고자 이것저것 찾아본 내용을 정리하려고 한다.</p>\n<h3 id=\"Persistable-인터페이스-구현\"><a href=\"#Persistable-인터페이스-구현\" class=\"headerlink\" title=\"Persistable 인터페이스 구현\"></a>Persistable 인터페이스 구현</h3><p>Data JPA 문서를 살펴보면 <code>Persistable</code>이라는 인터페이스를 언급한 부분이 있다. 인터페이스 코드를 살펴보면 간단하게 엔티티의 상태를 표현할 수 있으며, 이에 따라 실제 JpaRepository의 구현 클래스인 <code>SimpleJpaRepository</code>에서 isNew 상태를 판단하여 불필요한 Select를 줄이고 바로 Insert문을 실행할 수 있게 된다. 간단한 엔티티 구현 코드를 아래와 같다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> me.daniel.enhancedperformancejpainsert.user_access_log</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.hibernate.annotations.CreationTimestamp</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.hibernate.annotations.UpdateTimestamp</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.<span class=\"keyword\">data</span>.domain.Persistable</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.time.LocalDateTime</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.persistence.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table(name = <span class=\"meta-string\">&quot;USER_ACCESS_LOGS&quot;</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAccessLog</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">constructor</span></span>() : Persistable&lt;String&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> id = <span class=\"number\">0L</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> userId: String = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@CreationTimestamp</span></span><br><span class=\"line\">    <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> createdAt: LocalDateTime</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UpdateTimestamp</span></span><br><span class=\"line\">    <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> updatedAt: LocalDateTime</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">create</span><span class=\"params\">(userId: <span class=\"type\">String</span>)</span></span> = UserAccessLog().apply &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.userId = userId</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Transient</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> isNew = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isNew</span><span class=\"params\">()</span></span> = isNew</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PrePersist</span></span><br><span class=\"line\">    <span class=\"meta\">@PostLoad</span></span><br><span class=\"line\">    <span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">markNewState</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.isNew = <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getId</span><span class=\"params\">()</span></span>: String? &#123;</span><br><span class=\"line\">        TODO(<span class=\"string\">&quot;Not yet implemented&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>isNew</code>의 상태는 <code>@Transient</code> 어노테이션을 사용하여 영속화 대상에서 배제했으며, 실제 JPA의 영속화 관련 이벤트를 잡아 @PrePersist와 @PostLoad 단계에서 상태를 다시 false로 바꾸도록 했다. 이렇게 되면 <code>repository.save()</code>를 하는 시점에는 엔티티의 isNew상태가 true일 경우 바로 insert 쿼리만 발생하게 된다. 물론 update를 처리하는 경우도 있을 수 있으니 이에 대한 처리를 위해 @PostLoad를 붙여서 해당 케이스를 피했다.</p>\n<h3 id=\"Batch-Insert-구현-추가해보기\"><a href=\"#Batch-Insert-구현-추가해보기\" class=\"headerlink\" title=\"Batch Insert 구현 추가해보기\"></a>Batch Insert 구현 추가해보기</h3><p>사용자들의 로그를 만약 RDBMS를 통하여 적재하는 경우를 생각해보자. 로그는 대부분 수정성격의 트랜잭션이 아닌 단순 적재만 하는 케이스일 경우가 농후하다. Persistable 인터페이스를 구현하여 insert만 발생하도록 하는 것도 차선책이 될수는 있지만, 이런 작업에 매번 트랜잭션을 발생시켜 커넥션을 낭비하는 건 매우 비효율적이므로 이에 대한 처리를 해줄 수 있는 코드를 추가해보도록 하겠다. 여러 사용자들의 로그를 집계하여 저장해야하기 때문에 기존 SimpleJpaRepository의 saveAll 구현이 아닌 별도의 커스텀 쿼리 메소드를 만들어서 처리할 것이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1)</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableJpaRepositories(</span></span><br><span class=\"line\"><span class=\"meta\">    repositoryBaseClass = BatchRepositoryImpl::class </span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EnhancedPerformanceJpaInsertApplication</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (2)</span></span><br><span class=\"line\"><span class=\"meta\">@NoRepositoryBean</span> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BatchRepository</span>&lt;<span class=\"type\">T, ID</span>&gt; : <span class=\"type\">JpaRepository</span>&lt;<span class=\"type\">T, ID</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;S : T&gt;</span> <span class=\"title\">saveInBatch</span><span class=\"params\">(entities: <span class=\"type\">Iterable</span>&lt;<span class=\"type\">S</span>&gt;)</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (3)</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BatchRepositoryImpl</span>&lt;<span class=\"type\">T, ID : Serializable?</span>&gt;</span>(</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> entityInformation: JpaEntityInformation&lt;T, ID&gt;,</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> entityManager: EntityManager</span><br><span class=\"line\">) : SimpleJpaRepository&lt;T, ID&gt;(entityInformation, entityManager), BatchRepository&lt;T, ID&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value(<span class=\"meta-string\">&quot;\\$&#123;spring.jpa.properties.hibernate.jdbc.batch_size&#125;&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> batchSize: <span class=\"built_in\">Int</span>? = <span class=\"number\">30</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> logger = LoggerFactory.getLogger(BatchRepository::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;S : T&gt;</span> <span class=\"title\">saveInBatch</span><span class=\"params\">(entities: <span class=\"type\">Iterable</span>&lt;<span class=\"type\">S</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> entityTransaction = entityManager</span><br><span class=\"line\">                .entityManagerFactory</span><br><span class=\"line\">                .createEntityManager()</span><br><span class=\"line\">                .transaction</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            entityTransaction.begin()</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ((i, entity) <span class=\"keyword\">in</span> entities.withIndex()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i % (batchSize ?: <span class=\"number\">30</span>) == <span class=\"number\">0</span> &amp;&amp; i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    logger.info(<span class=\"string\">&quot;Flushing the EntityManager containing <span class=\"variable\">$batchSize</span> entities ...&quot;</span>)</span><br><span class=\"line\">                    entityTransaction.commit()</span><br><span class=\"line\">                    entityTransaction.begin()</span><br><span class=\"line\">                    entityManager.clear()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                entityManager.persist(entity)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            logger.info(<span class=\"string\">&quot;Flushing the remaining entities ...&quot;</span>)</span><br><span class=\"line\">            entityTransaction.commit()</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e: RuntimeException) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entityTransaction.isActive) &#123;</span><br><span class=\"line\">                entityTransaction.rollback()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            entityManager.close()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>(1) <code>@EnableJpaRepositories</code>을 선언하고 repositoryBaseClass에 확장하려는 인터페이스 클래스를 지정해준다.<br>(2) 확장하려는 인터페이스 스펙을 지정해준다<br>(3) 확장하려는 인터페이스 구현을 추가해준다. </p>\n<p>신규로 확장하는 레파지토리에는 saveInBatch에 대한 구현이 포함되어 있다. saveAll을 사용해도 되겠지만, saveAll의 경우 SimpleJpaRepository의 기본 구현을 따르기 때문에 다량의 insert가 발생할 경우 이에 대한 청크를 지정해주기 곤란하고, 트랜잭션에 대한 플러쉬/커밋 시점에 대한 지정이 어렵다. batchSize는 프로퍼티를 통하여 참조하고 해당 길이 기준으로 청크 처리하여 영속성 컨텍스트를 플러시/커밋 처리한다.</p>\n<h3 id=\"로그-처리-프로세서-추가해보기\"><a href=\"#로그-처리-프로세서-추가해보기\" class=\"headerlink\" title=\"로그 처리 프로세서 추가해보기\"></a>로그 처리 프로세서 추가해보기</h3><p>불특정 다수의 사용자들의 로그를 수집하고 이를 batchSize만큼 모아서 데이터베이스에 플러시해야 하는 요구사항을 처리하기 위해 리액티브 스트림<code>Reactor</code>을 사용하려고 한다. 처리 프로세서는 스프링 빈(@Component)로 선언할것이며, 코드는 아래와 같다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAccessLogProcessor</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> repository: UserAccessLogRepository</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> logger = LoggerFactory.getLogger(<span class=\"keyword\">this</span>.javaClass)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> emitterProcessor = EmitterProcessor.create&lt;UserAccessLog&gt;()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> flusSink = emitterProcessor.sink()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> disposable: Disposable</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">send</span><span class=\"params\">(item: <span class=\"type\">UserAccessLog</span>)</span></span> &#123;</span><br><span class=\"line\">        flusSink.next(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        disposable = emitterProcessor</span><br><span class=\"line\">                .bufferTimeout(<span class=\"number\">30</span>, Duration.ofSeconds(<span class=\"number\">5</span>))</span><br><span class=\"line\">                .delaySequence(Duration.ofMillis(<span class=\"number\">100</span>))</span><br><span class=\"line\">                .limitRate(<span class=\"number\">2</span>)</span><br><span class=\"line\">                .parallel(<span class=\"number\">32</span>)</span><br><span class=\"line\">                .runOn(Schedulers.parallel())</span><br><span class=\"line\">                .doOnNext &#123;</span><br><span class=\"line\">                    logger.info(<span class=\"string\">&quot;items = &#123;&#125;&quot;</span>, it)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                .flatMap &#123;</span><br><span class=\"line\">                    Mono.fromCallable &#123; repository.saveInBatch(it) &#125;</span><br><span class=\"line\">                            .subscribeOn(Schedulers.boundedElastic())</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                .doOnError &#123;</span><br><span class=\"line\">                    logger.error(<span class=\"string\">&quot;Error&quot;</span>, it)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                .subscribe()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        disposable.dispose()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>EmitterProcessor를 활용하여 불특정 다수(멀티 스레드)에서 들어오는 이벤트를 수집하여 처리</li>\n<li>이벤트에 대한 구독은 스프링 빈의 이벤트 라이프사이클을 활용했다.</li>\n<li>배치 처리를 해야 하므로 이를 위해 bufferTimeout을 지정하여 개수를 배치 사이즈만큼 모아서 이벤트를 방출</li>\n<li>만약 다량의 이벤트가 동시에 들어올 경우, 이를 처리하는 다운스트림의 연산자에서 문제가 생길 수 있기 때문에 이에 대한 적절한 배압 처리를 위해 limitRate와 delaySequence를 지정해줬다.(필요하다면 배압 정책을 지정해줘도 괜찮다)</li>\n<li>데이터베이스에 대한 Blocking 연산을 회피하기 위해 데이터베이스 트랜잭션 부분은 별도의 스레드에서 처리하도록 분리<ul>\n<li>적절한 배압 정책이나 딜레이 정책이 없다면 디비 커넥션 고갈이나 스레드 고갈 문제를 겪을 수 밖에 없다. 논블록킹 연산을 지원하는 데이터베이스라면 모르겠지만, 지금은 JDBC 베이스의 JPA를 사용하기 때문에 이에 대한 스레드 분리는 필수적이다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"고려헤야-할-부분-amp-개선해야-할-부분은\"><a href=\"#고려헤야-할-부분-amp-개선해야-할-부분은\" class=\"headerlink\" title=\"고려헤야 할 부분 &amp; 개선해야 할 부분은?\"></a>고려헤야 할 부분 &amp; 개선해야 할 부분은?</h4><ul>\n<li>결국 메모리에 이벤트 스트림을 모아서 처리하는 로직이기 때문에, 유실에 대한 부분은 반드시 고려해야 된다. 백업 전략으로는 디스크를 통하여 이벤트 데이터를 저장하는 방법이 있을 수도 있고 아니면 별도의 구현체(큐 혹은 NoSQL)를 사용하는 방법이 있을 수 있다.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JPA-Insert-성능-올려보기\"><a href=\"#JPA-Insert-성능-올려보기\" class=\"headerlink\" title=\"JPA Insert 성능 올려보기\"></a>JPA Insert 성능 올려보기</h1><p>JPA를 사용하다보면, 불필요하게 발생하는 쿼리를 종종 볼수 있다. 물론 도메인 상황이 select 쿼리가 반드시 필요한 상황이라면 문제가 되지 않겠지만, 경우에 따라서 insert 쿼리만 발생하도록 하는 것이 최선일 경우도 있다. 실제 업무에서 불필요하게 발생하는 select 쿼리로 인해 DBA분들에게 문의를 받기로 해서 이에 관련된 부분을 해결(?)하고자 이것저것 찾아본 내용을 정리하려고 한다.</p>\n<h3 id=\"Persistable-인터페이스-구현\"><a href=\"#Persistable-인터페이스-구현\" class=\"headerlink\" title=\"Persistable 인터페이스 구현\"></a>Persistable 인터페이스 구현</h3><p>Data JPA 문서를 살펴보면 <code>Persistable</code>이라는 인터페이스를 언급한 부분이 있다. 인터페이스 코드를 살펴보면 간단하게 엔티티의 상태를 표현할 수 있으며, 이에 따라 실제 JpaRepository의 구현 클래스인 <code>SimpleJpaRepository</code>에서 isNew 상태를 판단하여 불필요한 Select를 줄이고 바로 Insert문을 실행할 수 있게 된다. 간단한 엔티티 구현 코드를 아래와 같다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> me.daniel.enhancedperformancejpainsert.user_access_log</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.hibernate.annotations.CreationTimestamp</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.hibernate.annotations.UpdateTimestamp</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.<span class=\"keyword\">data</span>.domain.Persistable</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.time.LocalDateTime</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.persistence.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table(name = <span class=\"meta-string\">&quot;USER_ACCESS_LOGS&quot;</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAccessLog</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">constructor</span></span>() : Persistable&lt;String&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> id = <span class=\"number\">0L</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> userId: String = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@CreationTimestamp</span></span><br><span class=\"line\">    <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> createdAt: LocalDateTime</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UpdateTimestamp</span></span><br><span class=\"line\">    <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> updatedAt: LocalDateTime</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">create</span><span class=\"params\">(userId: <span class=\"type\">String</span>)</span></span> = UserAccessLog().apply &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.userId = userId</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Transient</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> isNew = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isNew</span><span class=\"params\">()</span></span> = isNew</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PrePersist</span></span><br><span class=\"line\">    <span class=\"meta\">@PostLoad</span></span><br><span class=\"line\">    <span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">markNewState</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.isNew = <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getId</span><span class=\"params\">()</span></span>: String? &#123;</span><br><span class=\"line\">        TODO(<span class=\"string\">&quot;Not yet implemented&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>isNew</code>의 상태는 <code>@Transient</code> 어노테이션을 사용하여 영속화 대상에서 배제했으며, 실제 JPA의 영속화 관련 이벤트를 잡아 @PrePersist와 @PostLoad 단계에서 상태를 다시 false로 바꾸도록 했다. 이렇게 되면 <code>repository.save()</code>를 하는 시점에는 엔티티의 isNew상태가 true일 경우 바로 insert 쿼리만 발생하게 된다. 물론 update를 처리하는 경우도 있을 수 있으니 이에 대한 처리를 위해 @PostLoad를 붙여서 해당 케이스를 피했다.</p>\n<h3 id=\"Batch-Insert-구현-추가해보기\"><a href=\"#Batch-Insert-구현-추가해보기\" class=\"headerlink\" title=\"Batch Insert 구현 추가해보기\"></a>Batch Insert 구현 추가해보기</h3><p>사용자들의 로그를 만약 RDBMS를 통하여 적재하는 경우를 생각해보자. 로그는 대부분 수정성격의 트랜잭션이 아닌 단순 적재만 하는 케이스일 경우가 농후하다. Persistable 인터페이스를 구현하여 insert만 발생하도록 하는 것도 차선책이 될수는 있지만, 이런 작업에 매번 트랜잭션을 발생시켜 커넥션을 낭비하는 건 매우 비효율적이므로 이에 대한 처리를 해줄 수 있는 코드를 추가해보도록 하겠다. 여러 사용자들의 로그를 집계하여 저장해야하기 때문에 기존 SimpleJpaRepository의 saveAll 구현이 아닌 별도의 커스텀 쿼리 메소드를 만들어서 처리할 것이다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1)</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableJpaRepositories(</span></span><br><span class=\"line\"><span class=\"meta\">    repositoryBaseClass = BatchRepositoryImpl::class </span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EnhancedPerformanceJpaInsertApplication</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (2)</span></span><br><span class=\"line\"><span class=\"meta\">@NoRepositoryBean</span> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BatchRepository</span>&lt;<span class=\"type\">T, ID</span>&gt; : <span class=\"type\">JpaRepository</span>&lt;<span class=\"type\">T, ID</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;S : T&gt;</span> <span class=\"title\">saveInBatch</span><span class=\"params\">(entities: <span class=\"type\">Iterable</span>&lt;<span class=\"type\">S</span>&gt;)</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (3)</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BatchRepositoryImpl</span>&lt;<span class=\"type\">T, ID : Serializable?</span>&gt;</span>(</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> entityInformation: JpaEntityInformation&lt;T, ID&gt;,</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> entityManager: EntityManager</span><br><span class=\"line\">) : SimpleJpaRepository&lt;T, ID&gt;(entityInformation, entityManager), BatchRepository&lt;T, ID&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value(<span class=\"meta-string\">&quot;\\$&#123;spring.jpa.properties.hibernate.jdbc.batch_size&#125;&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> batchSize: <span class=\"built_in\">Int</span>? = <span class=\"number\">30</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> logger = LoggerFactory.getLogger(BatchRepository::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;S : T&gt;</span> <span class=\"title\">saveInBatch</span><span class=\"params\">(entities: <span class=\"type\">Iterable</span>&lt;<span class=\"type\">S</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> entityTransaction = entityManager</span><br><span class=\"line\">                .entityManagerFactory</span><br><span class=\"line\">                .createEntityManager()</span><br><span class=\"line\">                .transaction</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            entityTransaction.begin()</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ((i, entity) <span class=\"keyword\">in</span> entities.withIndex()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i % (batchSize ?: <span class=\"number\">30</span>) == <span class=\"number\">0</span> &amp;&amp; i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    logger.info(<span class=\"string\">&quot;Flushing the EntityManager containing <span class=\"variable\">$batchSize</span> entities ...&quot;</span>)</span><br><span class=\"line\">                    entityTransaction.commit()</span><br><span class=\"line\">                    entityTransaction.begin()</span><br><span class=\"line\">                    entityManager.clear()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                entityManager.persist(entity)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            logger.info(<span class=\"string\">&quot;Flushing the remaining entities ...&quot;</span>)</span><br><span class=\"line\">            entityTransaction.commit()</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e: RuntimeException) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entityTransaction.isActive) &#123;</span><br><span class=\"line\">                entityTransaction.rollback()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            entityManager.close()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>(1) <code>@EnableJpaRepositories</code>을 선언하고 repositoryBaseClass에 확장하려는 인터페이스 클래스를 지정해준다.<br>(2) 확장하려는 인터페이스 스펙을 지정해준다<br>(3) 확장하려는 인터페이스 구현을 추가해준다. </p>\n<p>신규로 확장하는 레파지토리에는 saveInBatch에 대한 구현이 포함되어 있다. saveAll을 사용해도 되겠지만, saveAll의 경우 SimpleJpaRepository의 기본 구현을 따르기 때문에 다량의 insert가 발생할 경우 이에 대한 청크를 지정해주기 곤란하고, 트랜잭션에 대한 플러쉬/커밋 시점에 대한 지정이 어렵다. batchSize는 프로퍼티를 통하여 참조하고 해당 길이 기준으로 청크 처리하여 영속성 컨텍스트를 플러시/커밋 처리한다.</p>\n<h3 id=\"로그-처리-프로세서-추가해보기\"><a href=\"#로그-처리-프로세서-추가해보기\" class=\"headerlink\" title=\"로그 처리 프로세서 추가해보기\"></a>로그 처리 프로세서 추가해보기</h3><p>불특정 다수의 사용자들의 로그를 수집하고 이를 batchSize만큼 모아서 데이터베이스에 플러시해야 하는 요구사항을 처리하기 위해 리액티브 스트림<code>Reactor</code>을 사용하려고 한다. 처리 프로세서는 스프링 빈(@Component)로 선언할것이며, 코드는 아래와 같다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAccessLogProcessor</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> repository: UserAccessLogRepository</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> logger = LoggerFactory.getLogger(<span class=\"keyword\">this</span>.javaClass)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> emitterProcessor = EmitterProcessor.create&lt;UserAccessLog&gt;()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> flusSink = emitterProcessor.sink()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> disposable: Disposable</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">send</span><span class=\"params\">(item: <span class=\"type\">UserAccessLog</span>)</span></span> &#123;</span><br><span class=\"line\">        flusSink.next(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        disposable = emitterProcessor</span><br><span class=\"line\">                .bufferTimeout(<span class=\"number\">30</span>, Duration.ofSeconds(<span class=\"number\">5</span>))</span><br><span class=\"line\">                .delaySequence(Duration.ofMillis(<span class=\"number\">100</span>))</span><br><span class=\"line\">                .limitRate(<span class=\"number\">2</span>)</span><br><span class=\"line\">                .parallel(<span class=\"number\">32</span>)</span><br><span class=\"line\">                .runOn(Schedulers.parallel())</span><br><span class=\"line\">                .doOnNext &#123;</span><br><span class=\"line\">                    logger.info(<span class=\"string\">&quot;items = &#123;&#125;&quot;</span>, it)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                .flatMap &#123;</span><br><span class=\"line\">                    Mono.fromCallable &#123; repository.saveInBatch(it) &#125;</span><br><span class=\"line\">                            .subscribeOn(Schedulers.boundedElastic())</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                .doOnError &#123;</span><br><span class=\"line\">                    logger.error(<span class=\"string\">&quot;Error&quot;</span>, it)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                .subscribe()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        disposable.dispose()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>EmitterProcessor를 활용하여 불특정 다수(멀티 스레드)에서 들어오는 이벤트를 수집하여 처리</li>\n<li>이벤트에 대한 구독은 스프링 빈의 이벤트 라이프사이클을 활용했다.</li>\n<li>배치 처리를 해야 하므로 이를 위해 bufferTimeout을 지정하여 개수를 배치 사이즈만큼 모아서 이벤트를 방출</li>\n<li>만약 다량의 이벤트가 동시에 들어올 경우, 이를 처리하는 다운스트림의 연산자에서 문제가 생길 수 있기 때문에 이에 대한 적절한 배압 처리를 위해 limitRate와 delaySequence를 지정해줬다.(필요하다면 배압 정책을 지정해줘도 괜찮다)</li>\n<li>데이터베이스에 대한 Blocking 연산을 회피하기 위해 데이터베이스 트랜잭션 부분은 별도의 스레드에서 처리하도록 분리<ul>\n<li>적절한 배압 정책이나 딜레이 정책이 없다면 디비 커넥션 고갈이나 스레드 고갈 문제를 겪을 수 밖에 없다. 논블록킹 연산을 지원하는 데이터베이스라면 모르겠지만, 지금은 JDBC 베이스의 JPA를 사용하기 때문에 이에 대한 스레드 분리는 필수적이다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"고려헤야-할-부분-amp-개선해야-할-부분은\"><a href=\"#고려헤야-할-부분-amp-개선해야-할-부분은\" class=\"headerlink\" title=\"고려헤야 할 부분 &amp; 개선해야 할 부분은?\"></a>고려헤야 할 부분 &amp; 개선해야 할 부분은?</h4><ul>\n<li>결국 메모리에 이벤트 스트림을 모아서 처리하는 로직이기 때문에, 유실에 대한 부분은 반드시 고려해야 된다. 백업 전략으로는 디스크를 통하여 이벤트 데이터를 저장하는 방법이 있을 수도 있고 아니면 별도의 구현체(큐 혹은 NoSQL)를 사용하는 방법이 있을 수 있다.</li>\n</ul>\n"},{"title":"JPA @Access","date":"2021-04-21T15:00:00.000Z","_content":"\n# JPA @Access\n```java\n@Target( { TYPE, METHOD, FIELD })\n@Retention(RUNTIME)\npublic @interface Access {\n    AccessType value();\n}\n```\n- @Access 어노테이션은 엔터티 클래스, 매핑된 수퍼 클래스 또는 포함 가능한 클래스 또는 엔터티 맴버의 액세스 방법을 지정하는 데 사용.\n- Method, Class, Field에 매핑 가능\n- `AccessType`\n  - Field: 리플렉션 기반으로 필드/멤버에 액세스\n  - Property: Getter/Setter 기반으로 필드/멤버에 액세스\n- 기본적으로 `AccessType`은 `@Id`을 넣은 위치로 정의. \n  - 필드/멤버에 넣으면 `AccessType.FIELD`\n  - `getter`에 넣으면 `AccessType.PROPERTY`","source":"_posts/Persistence/JPA_ACCESS.md","raw":"---\ntitle: 'JPA @Access'\ndate: 2021/4/22 00:00:00\ncategories:\n- Persistence\n---\n\n# JPA @Access\n```java\n@Target( { TYPE, METHOD, FIELD })\n@Retention(RUNTIME)\npublic @interface Access {\n    AccessType value();\n}\n```\n- @Access 어노테이션은 엔터티 클래스, 매핑된 수퍼 클래스 또는 포함 가능한 클래스 또는 엔터티 맴버의 액세스 방법을 지정하는 데 사용.\n- Method, Class, Field에 매핑 가능\n- `AccessType`\n  - Field: 리플렉션 기반으로 필드/멤버에 액세스\n  - Property: Getter/Setter 기반으로 필드/멤버에 액세스\n- 기본적으로 `AccessType`은 `@Id`을 넣은 위치로 정의. \n  - 필드/멤버에 넣으면 `AccessType.FIELD`\n  - `getter`에 넣으면 `AccessType.PROPERTY`","slug":"Persistence/JPA_ACCESS","published":1,"updated":"2021-08-02T12:29:33.850Z","_id":"ckrsup50s001ltjhv8oasftqy","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"JPA-Access\"><a href=\"#JPA-Access\" class=\"headerlink\" title=\"JPA @Access\"></a>JPA @Access</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target( &#123; TYPE, METHOD, FIELD &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Access &#123;</span><br><span class=\"line\">    <span class=\"function\">AccessType <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>@Access 어노테이션은 엔터티 클래스, 매핑된 수퍼 클래스 또는 포함 가능한 클래스 또는 엔터티 맴버의 액세스 방법을 지정하는 데 사용.</li>\n<li>Method, Class, Field에 매핑 가능</li>\n<li><code>AccessType</code><ul>\n<li>Field: 리플렉션 기반으로 필드/멤버에 액세스</li>\n<li>Property: Getter/Setter 기반으로 필드/멤버에 액세스</li>\n</ul>\n</li>\n<li>기본적으로 <code>AccessType</code>은 <code>@Id</code>을 넣은 위치로 정의. <ul>\n<li>필드/멤버에 넣으면 <code>AccessType.FIELD</code></li>\n<li><code>getter</code>에 넣으면 <code>AccessType.PROPERTY</code></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JPA-Access\"><a href=\"#JPA-Access\" class=\"headerlink\" title=\"JPA @Access\"></a>JPA @Access</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target( &#123; TYPE, METHOD, FIELD &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Access &#123;</span><br><span class=\"line\">    <span class=\"function\">AccessType <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>@Access 어노테이션은 엔터티 클래스, 매핑된 수퍼 클래스 또는 포함 가능한 클래스 또는 엔터티 맴버의 액세스 방법을 지정하는 데 사용.</li>\n<li>Method, Class, Field에 매핑 가능</li>\n<li><code>AccessType</code><ul>\n<li>Field: 리플렉션 기반으로 필드/멤버에 액세스</li>\n<li>Property: Getter/Setter 기반으로 필드/멤버에 액세스</li>\n</ul>\n</li>\n<li>기본적으로 <code>AccessType</code>은 <code>@Id</code>을 넣은 위치로 정의. <ul>\n<li>필드/멤버에 넣으면 <code>AccessType.FIELD</code></li>\n<li><code>getter</code>에 넣으면 <code>AccessType.PROPERTY</code></li>\n</ul>\n</li>\n</ul>\n"},{"title":"Spring & JPA EntityManager & 동시성","date":"2019-08-30T15:00:00.000Z","_content":"\n# Spring & JPA EntityManager & 동시성\nJPA에서 영속성 컨텍스트에 접근하는 방법은 EntityManagerFactory를 통하여 만들어진 EntityManager를 통한 접근 방법이다. JPA 서적에서는 EntityManager는 Thread-Safe함을 보장하지 않기 때문에 공유 상태를 만들어서 사용하면 안된다고 적혀저 있는데, [하이버네이트 문서](https://docs.jboss.org/hibernate/core/4.0/hem/en-US/html/transactions.html)을 보면 몇가지 동시성과 관련된 주의점에 대해 책에서의 이야기처럼 `Application-Level EntityManager`, `User-Session-Level EntityManager`의 사용을 안티패턴이라고 규정하고 있다. \n\n의문이 들었던 부분은 Spring과 같은 컨테이너를 사용할 때, EntityManager를 주입 받아 사용하는 경우에 이에 대한 Thread-Safe를 어떻게 보장하는지가 궁금한 지점이었다.\n\nEntityManager는 `Container-managed EntityManager`이고 나머지는 코드에서 직접 핸들링하는 `Application-managed EntityManager`","source":"_posts/Persistence/JPA_EntityManager.md","raw":"---\ntitle: 'Spring & JPA EntityManager & 동시성'\ndate: 2019/8/31 00:00:00\ncategories:\n- Persistence\n---\n\n# Spring & JPA EntityManager & 동시성\nJPA에서 영속성 컨텍스트에 접근하는 방법은 EntityManagerFactory를 통하여 만들어진 EntityManager를 통한 접근 방법이다. JPA 서적에서는 EntityManager는 Thread-Safe함을 보장하지 않기 때문에 공유 상태를 만들어서 사용하면 안된다고 적혀저 있는데, [하이버네이트 문서](https://docs.jboss.org/hibernate/core/4.0/hem/en-US/html/transactions.html)을 보면 몇가지 동시성과 관련된 주의점에 대해 책에서의 이야기처럼 `Application-Level EntityManager`, `User-Session-Level EntityManager`의 사용을 안티패턴이라고 규정하고 있다. \n\n의문이 들었던 부분은 Spring과 같은 컨테이너를 사용할 때, EntityManager를 주입 받아 사용하는 경우에 이에 대한 Thread-Safe를 어떻게 보장하는지가 궁금한 지점이었다.\n\nEntityManager는 `Container-managed EntityManager`이고 나머지는 코드에서 직접 핸들링하는 `Application-managed EntityManager`","slug":"Persistence/JPA_EntityManager","published":1,"updated":"2021-08-02T12:30:08.001Z","_id":"ckrsup50s001mtjhvelt5hw87","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Spring-amp-JPA-EntityManager-amp-동시성\"><a href=\"#Spring-amp-JPA-EntityManager-amp-동시성\" class=\"headerlink\" title=\"Spring &amp; JPA EntityManager &amp; 동시성\"></a>Spring &amp; JPA EntityManager &amp; 동시성</h1><p>JPA에서 영속성 컨텍스트에 접근하는 방법은 EntityManagerFactory를 통하여 만들어진 EntityManager를 통한 접근 방법이다. JPA 서적에서는 EntityManager는 Thread-Safe함을 보장하지 않기 때문에 공유 상태를 만들어서 사용하면 안된다고 적혀저 있는데, <a href=\"https://docs.jboss.org/hibernate/core/4.0/hem/en-US/html/transactions.html\">하이버네이트 문서</a>을 보면 몇가지 동시성과 관련된 주의점에 대해 책에서의 이야기처럼 <code>Application-Level EntityManager</code>, <code>User-Session-Level EntityManager</code>의 사용을 안티패턴이라고 규정하고 있다. </p>\n<p>의문이 들었던 부분은 Spring과 같은 컨테이너를 사용할 때, EntityManager를 주입 받아 사용하는 경우에 이에 대한 Thread-Safe를 어떻게 보장하는지가 궁금한 지점이었다.</p>\n<p>EntityManager는 <code>Container-managed EntityManager</code>이고 나머지는 코드에서 직접 핸들링하는 <code>Application-managed EntityManager</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Spring-amp-JPA-EntityManager-amp-동시성\"><a href=\"#Spring-amp-JPA-EntityManager-amp-동시성\" class=\"headerlink\" title=\"Spring &amp; JPA EntityManager &amp; 동시성\"></a>Spring &amp; JPA EntityManager &amp; 동시성</h1><p>JPA에서 영속성 컨텍스트에 접근하는 방법은 EntityManagerFactory를 통하여 만들어진 EntityManager를 통한 접근 방법이다. JPA 서적에서는 EntityManager는 Thread-Safe함을 보장하지 않기 때문에 공유 상태를 만들어서 사용하면 안된다고 적혀저 있는데, <a href=\"https://docs.jboss.org/hibernate/core/4.0/hem/en-US/html/transactions.html\">하이버네이트 문서</a>을 보면 몇가지 동시성과 관련된 주의점에 대해 책에서의 이야기처럼 <code>Application-Level EntityManager</code>, <code>User-Session-Level EntityManager</code>의 사용을 안티패턴이라고 규정하고 있다. </p>\n<p>의문이 들었던 부분은 Spring과 같은 컨테이너를 사용할 때, EntityManager를 주입 받아 사용하는 경우에 이에 대한 Thread-Safe를 어떻게 보장하는지가 궁금한 지점이었다.</p>\n<p>EntityManager는 <code>Container-managed EntityManager</code>이고 나머지는 코드에서 직접 핸들링하는 <code>Application-managed EntityManager</code></p>\n"},{"title":"JPA 관련 링크","date":"2019-07-11T15:00:00.000Z","_content":"\n# JPA 관련 링크\n\n- One to One 매핑 시 PrimaryKey 기반의 매핑 방법 관련\n  - http://kwonnam.pe.kr/wiki/java/jpa/one-to-one\n  - http://whiteship.tistory.com/1459\n- Jpa N+1\n  - https://www.slideshare.net/nimbae/jpa-n1\n- How to do an UPSERT with Hibernate and MySQL and avoid throwing “Duplicate entry for key” issues\n  - https://discourse.hibernate.org/t/how-to-do-an-upsert-with-hibernate-and-mysql-and-avoid-throwing-duplicate-entry-for-key-issues/2349\n- Hierarchy For Package org.springframework.dao\n  - https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/dao/package-tree.html\n- 예외 전환\n- https://davidpark20.tistory.com/37","source":"_posts/Persistence/JPA_Reference.md","raw":"---\ntitle: 'JPA 관련 링크'\ndate: 2019/7/12 00:00:00\ncategories:\n- Persistence\n---\n\n# JPA 관련 링크\n\n- One to One 매핑 시 PrimaryKey 기반의 매핑 방법 관련\n  - http://kwonnam.pe.kr/wiki/java/jpa/one-to-one\n  - http://whiteship.tistory.com/1459\n- Jpa N+1\n  - https://www.slideshare.net/nimbae/jpa-n1\n- How to do an UPSERT with Hibernate and MySQL and avoid throwing “Duplicate entry for key” issues\n  - https://discourse.hibernate.org/t/how-to-do-an-upsert-with-hibernate-and-mysql-and-avoid-throwing-duplicate-entry-for-key-issues/2349\n- Hierarchy For Package org.springframework.dao\n  - https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/dao/package-tree.html\n- 예외 전환\n- https://davidpark20.tistory.com/37","slug":"Persistence/JPA_Reference","published":1,"updated":"2021-08-02T12:30:51.107Z","_id":"ckrsup50t001ntjhvf82bdmpe","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"JPA-관련-링크\"><a href=\"#JPA-관련-링크\" class=\"headerlink\" title=\"JPA 관련 링크\"></a>JPA 관련 링크</h1><ul>\n<li>One to One 매핑 시 PrimaryKey 기반의 매핑 방법 관련<ul>\n<li><a href=\"http://kwonnam.pe.kr/wiki/java/jpa/one-to-one\">http://kwonnam.pe.kr/wiki/java/jpa/one-to-one</a></li>\n<li><a href=\"http://whiteship.tistory.com/1459\">http://whiteship.tistory.com/1459</a></li>\n</ul>\n</li>\n<li>Jpa N+1<ul>\n<li><a href=\"https://www.slideshare.net/nimbae/jpa-n1\">https://www.slideshare.net/nimbae/jpa-n1</a></li>\n</ul>\n</li>\n<li>How to do an UPSERT with Hibernate and MySQL and avoid throwing “Duplicate entry for key” issues<ul>\n<li><a href=\"https://discourse.hibernate.org/t/how-to-do-an-upsert-with-hibernate-and-mysql-and-avoid-throwing-duplicate-entry-for-key-issues/2349\">https://discourse.hibernate.org/t/how-to-do-an-upsert-with-hibernate-and-mysql-and-avoid-throwing-duplicate-entry-for-key-issues/2349</a></li>\n</ul>\n</li>\n<li>Hierarchy For Package org.springframework.dao<ul>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/dao/package-tree.html\">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/dao/package-tree.html</a></li>\n</ul>\n</li>\n<li>예외 전환</li>\n<li><a href=\"https://davidpark20.tistory.com/37\">https://davidpark20.tistory.com/37</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JPA-관련-링크\"><a href=\"#JPA-관련-링크\" class=\"headerlink\" title=\"JPA 관련 링크\"></a>JPA 관련 링크</h1><ul>\n<li>One to One 매핑 시 PrimaryKey 기반의 매핑 방법 관련<ul>\n<li><a href=\"http://kwonnam.pe.kr/wiki/java/jpa/one-to-one\">http://kwonnam.pe.kr/wiki/java/jpa/one-to-one</a></li>\n<li><a href=\"http://whiteship.tistory.com/1459\">http://whiteship.tistory.com/1459</a></li>\n</ul>\n</li>\n<li>Jpa N+1<ul>\n<li><a href=\"https://www.slideshare.net/nimbae/jpa-n1\">https://www.slideshare.net/nimbae/jpa-n1</a></li>\n</ul>\n</li>\n<li>How to do an UPSERT with Hibernate and MySQL and avoid throwing “Duplicate entry for key” issues<ul>\n<li><a href=\"https://discourse.hibernate.org/t/how-to-do-an-upsert-with-hibernate-and-mysql-and-avoid-throwing-duplicate-entry-for-key-issues/2349\">https://discourse.hibernate.org/t/how-to-do-an-upsert-with-hibernate-and-mysql-and-avoid-throwing-duplicate-entry-for-key-issues/2349</a></li>\n</ul>\n</li>\n<li>Hierarchy For Package org.springframework.dao<ul>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/dao/package-tree.html\">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/dao/package-tree.html</a></li>\n</ul>\n</li>\n<li>예외 전환</li>\n<li><a href=\"https://davidpark20.tistory.com/37\">https://davidpark20.tistory.com/37</a></li>\n</ul>\n"},{"title":"JPA 컬렉션 & 리스너","date":"2019-08-31T11:09:00.000Z","_content":"\n# JPA 컬렉션 & 리스너\n\n> 자바 ORM 표준 JPA 프로그래밍 14장 내용을 정리\n\n## 컬렉션\n- JPA에서는 Collection, List, Set, Map과 같은 컬렉션 구현체에 대한 매핑을 제공\n  * Collection: 중복을 허용하고, 순서를 보장하지 않음\n  * List: 중복을 허용하고, 순서를 보장\n  * Set: 중복을 허용하지 않으나 순서를 보장하지 않음\n  * Map: K,V 구조의 구현체\n- @OneToMany, @ManyToMany와 같은 다수의 데이터를 매핑할 때 사용\n- @ElementCollection을 사용한 다중의 값 타입 매핑\n- 가장 많이 사용하는 JPA 구현체인 하이버네이트의 경우, 컬렉션 필드를 하이버네이트의 래퍼 클래스로 감싸서 관리함. 사용하는 래퍼 클래스는 아래 예제 코드를 참고하자\n```java\n// org.hibernate.collection.internal.PersistentBag\n@OneToMany\nCollection<Member> collection = new ArrayList<Member>();\n\n// org.hibernate.collection.internal.PersistentBag\n@OneToMany\nList<Member> list = new ArrayList<Member>();\n\n// org.hibernate.collection.internal.PersistentSet\n@OneToMany\nSet<Member> set = new HashSet<Member>();\n\n// org.hibernate.collection.internal.PersistentList\n@OneToMany\n@OrderColumn\nList<Member> orderColumnList = new ArrayList<Member>();\n```\n\n| Collection-Interface  | Hibernate-Collection  | 중복허용  | 순서 보관  |\n|----------------------|---|---|---|\n| Collection, List     | PersistenceBag   | O | X |\n| Set                  | PersistenceSet   | X | X |\n| List + @OrderColumn  | PersistenceList  | O | O |\n\n\n> 래퍼 클래스를 통하여 원본 콜렉션을 감싸는 이유에 대해서 좀 더 상세하게 풀어보자면, 하이버네이트 매뉴얼에서는 이를 래퍼 타입을 통하여 지연로딩, 상태변경 그리고 캐싱에 대한 기능 지원을 위해서라고 한다. \n> 실제 PersistentBag과 같은 구현체 내부를 보면, 하이버네이트에서 기능지원을 위해 사용하는 AbstractPersistentCollection 클래스를 상속하고 있고 또한 List 인터페이스를 그대로 구현하고 있는 것을 확인할 수 있다. 그러므로, 매핑 시 반드시 자바 콜렉션 프레임워크의 표준 인터페이스를 사용하여 매핑을 해야 한다.\n\n- Collection, List의 경우 중복을 허용하기 때문에, 지연로딩을 사용하는 경우라도 해당 콜렉션을 초기화하지 않는다. 반면, Set의 경우 중복에 대한 체크가 필요하기 때문에 지연로딩을 사용할 경우 해당 컬렉션을 초기화하는 작업을 거치게 된다.\n\n```java\npublic class Board {\n\t...\n\n\t@OneToMany(mappedBy = \"board\")\n\t@OrderColumn(name = \"POSITION\")\n\tprivate List<Comment> comments = new ArrayList<Comment>();\n}\n```\n- 위 코드와 같이 `List + @OrderColumn`을 조합하여 사용하는 경우, 순서를 판단할 수 있는 별도의 컬럼을 매핑하는 것이 가능하다. 해당 컬럼에 순서에 대한 시퀀스 벨류가 저장된다. \n- 하지만, 위 코드에서도 볼수 있듯이 실제 엔티티에 해당 컬럼이 매핑되는 것이 아닌 엔티티를 사용하는 측에 해당 컬럼을 명시하기 때문에 실 엔티티에서는 위와 같은 정보를 알수 없다. 또한, **실제 영속화하는 과정에서 별도의 update 구문이 한번 더 실행되며 콜렉션 내부의 삭제가 발생할 경우 순서를 조정하기 위한 연속적인 update 구문이 실행된다. 성능상에도 그리 좋은편은 아니라고 할 수 있다.**\n\n```java\npublic class Board {\n\t...\n\n\t@OneToMany(mappedBy = \"board\")\n\t@OrderBy(\"username desc, id asc\")\n\tprivate List<Comment> comments = new ArrayList<Comment>();\n}\n```\n- 별도의 순서를 저장하는 컬럼을 사용하는 것보다 `@OrderBy`를 사용하여 실제 사용하는 컬럼에서 순서를 지정하는 방법이 `@OrderColumn`을 사용하는 것보다 나을 수 있다.\n\n## 컨버터\n- 엔티티의 데이터를 영속화 할때, 데이터의 변환이 필요한 경우 컨버터 관련 구현을 해두면 데이터베이스와 JPA 사이에서의 변환 작업을 편리하게 진행할 수 있다. 아래 예제 코드를 살펴보자\n```kotlin\n@Entity\n@Table(name = \"boards\")\n@Convert(converter = TagConverter::class, attributeName = \"tags\")\nclass Board protected constructor(){\n\t...\n\t@Convert(converter = SecretConverter::class)\n\tvar secret: Boolean = false\n\t\tprotected set\n\n\t@Column(name = \"tags\", columnDefinition = \"text\", nullable = false)\n\tvar tags: MutableList<String> = mutableListOf()\n\t...\n}\n```\n\n- 컨버터는 `AttributeConverter` 인터페이스를 구현해야하며, 프로퍼티/멤버 레벨 및 클래스 레벨에서 지정이 가능하다. 클래스 레벨에서 지정하는 경우 `attributeName`에 변환이 필요한 프로퍼티/멤버를 명시하면 된다.\n- 전역으로 설정하고 싶은 경우 `autoApply`의 값을 `true`로 지정하면 제네릭에 명시되어 있는 타입에서의 변환에 대하여 전역 레벨에서 변환 작업을 하게 된다. \n\n```kotlin\n@Converter(autoApply = false)\nclass SecretConverter : AttributeConverter<Boolean, String>{\n\t// \n\toverride fun convertToDatabaseColumn(attribute: Boolean): String {\n\t\treturn if (attribute) \"Y\" else \"N\"\n\t}\n\n\toverride fun convertToEntityAttribute(dbData: String): Boolean {\n\t\treturn dbData == \"Y\"\n\t}\n}\n```\n- [링크](https://docs.oracle.com/javaee/7/api/javax/persistence/Convert.html)를 참고하면 좀 더 세부적인 컨버터 구현에 대한 내용 확인이 가능하다.\n\n## 리스너\n![JPA_엔티티_리스너_시점](https://i.imgur.com/kdrVtQ8.png)\n- 엔티티의 생명주기에 따른 이벤트를 처리할 수 있으며, 생명주기에 따른 특징은 아래를 참고하자\n  1. `PostLoad`\n     - 영속성 컨텍스트 조회 직후 호출\n     - 2차 캐시에 저장되어 있어도 호출됨\n  2. `PrePersist`\n     - persist() 호출 전 시점에 호출\n     - 식별자 생성 전략을 사용했을 경우 아직 식별자는 존재 하지 않음\n  3. `PreUpdate`\n     - `flush`, `commit` 호출하여 엔티티를 수정하기 직전에 호출\n  4. `PreRemove`\n     - `remove`를 호출하여 엔티티를 영속성 컨텍스트에서 삭제하기 전에 호출\n     - 영속성 전이가 일어나도 호출되며 orphanRemoval에 대하여 `flush`, `commit` 시에 호출됨\n  5. `PostPersist`\n     - `flush`, `commit` 호출하여 엔티티를 DB에 저장한 후 호출\n     - 데이터베이스 저장 후 호출되기 때문에, 식별자가 존재\n  6. `PostUpdate`\n     - `flush`, `commit` 호출하여 엔티티를 수정하여 DB에 반영한 이후에 호출\n  7. `PostRemove`\n     - `remove`를 호출하여 엔티티를 DB에서 삭제한 이후에 호출\n- 리스너 등록은 `엔티티에 직접 적용`, `별도 리스너 등록`이 있다.\n  - 엔티티에 직접 적용\n\t```kotlin\n\tclass Board {\n\t\t...\n\t\t@PrePersist\n\t\tfun prePersist() {\n\t\t\tlogger.info(\"PrePersist(), {}\", this)\n\t\t}\n\n\t\t@PostPersist\n\t\tfun postPersist() {\n\t\t\tlogger.info(\"postPersist(), {}\", this)\n\t\t}\n\t}\n\t```\n  - 별도 리스너 클래스 사용\n\t```kotlin\n\n\t@Entity\n\t@Table(name = \"boards\")\n\t@EntityListeners(value = [BoardListener::class])\n\tclass Board {\n\t\t...\n\t}\n\n\tclass BoardListener {\n\t\tval logger = LoggerFactory.getLogger(this::class.java)\n\n\t\t@PostLoad\n\t\tfun postLoad(obj: Any) {\n\t\t\tlogger.info(\"postLoad()\")\n\t\t}\n\n\t\t@PrePersist\n\t\tfun prePersist(obj: Any) {\n\t\t\tlogger.info(\"PrePersist()\")\n\t\t}\n\n\t\t@PostPersist\n\t\tfun postPersist(obj: Any) {\n\t\t\tlogger.info(\"postPersist()\")\n\t\t}\n\t}\n\t```\n- 리스너와 비슷하게 사용할 수 있는 `Audit` 기능도 존재한다.\n- 리스너가 중첩된 구조로 등록되어 있는 경우, 아래와 같은 순서대로 리스너가 실행된다.\n  1. 기본 리스너\n  2. 부모 클래스 리스너(@MappedSuperClass 등으로 매핑한 슈퍼 클래스)\n  3. 별도 리스너\n  4. 엔티티\n- 슈퍼 클래스 엔티티에서 지정한 리스너와 기본 리스너를 무시하고 싶다면 아래와 같이 설정하는 것이 가능하다.\n```kotlin\n@Entity\n@Table(name = \"boards\")\n@EntityListeners(value = [BoardListener::class])\n@ExcludeDefaultListeners\n@ExcludeSuperclassListeners\nclass Board protected constructor(){\n}\n```","source":"_posts/Persistence/JPA_컬렉션_리스너.md","raw":"---\ntitle: 'JPA 컬렉션 & 리스너'\ndate: 2019.8.31. 20:09\ncategories:\n- Persistence\n---\n\n# JPA 컬렉션 & 리스너\n\n> 자바 ORM 표준 JPA 프로그래밍 14장 내용을 정리\n\n## 컬렉션\n- JPA에서는 Collection, List, Set, Map과 같은 컬렉션 구현체에 대한 매핑을 제공\n  * Collection: 중복을 허용하고, 순서를 보장하지 않음\n  * List: 중복을 허용하고, 순서를 보장\n  * Set: 중복을 허용하지 않으나 순서를 보장하지 않음\n  * Map: K,V 구조의 구현체\n- @OneToMany, @ManyToMany와 같은 다수의 데이터를 매핑할 때 사용\n- @ElementCollection을 사용한 다중의 값 타입 매핑\n- 가장 많이 사용하는 JPA 구현체인 하이버네이트의 경우, 컬렉션 필드를 하이버네이트의 래퍼 클래스로 감싸서 관리함. 사용하는 래퍼 클래스는 아래 예제 코드를 참고하자\n```java\n// org.hibernate.collection.internal.PersistentBag\n@OneToMany\nCollection<Member> collection = new ArrayList<Member>();\n\n// org.hibernate.collection.internal.PersistentBag\n@OneToMany\nList<Member> list = new ArrayList<Member>();\n\n// org.hibernate.collection.internal.PersistentSet\n@OneToMany\nSet<Member> set = new HashSet<Member>();\n\n// org.hibernate.collection.internal.PersistentList\n@OneToMany\n@OrderColumn\nList<Member> orderColumnList = new ArrayList<Member>();\n```\n\n| Collection-Interface  | Hibernate-Collection  | 중복허용  | 순서 보관  |\n|----------------------|---|---|---|\n| Collection, List     | PersistenceBag   | O | X |\n| Set                  | PersistenceSet   | X | X |\n| List + @OrderColumn  | PersistenceList  | O | O |\n\n\n> 래퍼 클래스를 통하여 원본 콜렉션을 감싸는 이유에 대해서 좀 더 상세하게 풀어보자면, 하이버네이트 매뉴얼에서는 이를 래퍼 타입을 통하여 지연로딩, 상태변경 그리고 캐싱에 대한 기능 지원을 위해서라고 한다. \n> 실제 PersistentBag과 같은 구현체 내부를 보면, 하이버네이트에서 기능지원을 위해 사용하는 AbstractPersistentCollection 클래스를 상속하고 있고 또한 List 인터페이스를 그대로 구현하고 있는 것을 확인할 수 있다. 그러므로, 매핑 시 반드시 자바 콜렉션 프레임워크의 표준 인터페이스를 사용하여 매핑을 해야 한다.\n\n- Collection, List의 경우 중복을 허용하기 때문에, 지연로딩을 사용하는 경우라도 해당 콜렉션을 초기화하지 않는다. 반면, Set의 경우 중복에 대한 체크가 필요하기 때문에 지연로딩을 사용할 경우 해당 컬렉션을 초기화하는 작업을 거치게 된다.\n\n```java\npublic class Board {\n\t...\n\n\t@OneToMany(mappedBy = \"board\")\n\t@OrderColumn(name = \"POSITION\")\n\tprivate List<Comment> comments = new ArrayList<Comment>();\n}\n```\n- 위 코드와 같이 `List + @OrderColumn`을 조합하여 사용하는 경우, 순서를 판단할 수 있는 별도의 컬럼을 매핑하는 것이 가능하다. 해당 컬럼에 순서에 대한 시퀀스 벨류가 저장된다. \n- 하지만, 위 코드에서도 볼수 있듯이 실제 엔티티에 해당 컬럼이 매핑되는 것이 아닌 엔티티를 사용하는 측에 해당 컬럼을 명시하기 때문에 실 엔티티에서는 위와 같은 정보를 알수 없다. 또한, **실제 영속화하는 과정에서 별도의 update 구문이 한번 더 실행되며 콜렉션 내부의 삭제가 발생할 경우 순서를 조정하기 위한 연속적인 update 구문이 실행된다. 성능상에도 그리 좋은편은 아니라고 할 수 있다.**\n\n```java\npublic class Board {\n\t...\n\n\t@OneToMany(mappedBy = \"board\")\n\t@OrderBy(\"username desc, id asc\")\n\tprivate List<Comment> comments = new ArrayList<Comment>();\n}\n```\n- 별도의 순서를 저장하는 컬럼을 사용하는 것보다 `@OrderBy`를 사용하여 실제 사용하는 컬럼에서 순서를 지정하는 방법이 `@OrderColumn`을 사용하는 것보다 나을 수 있다.\n\n## 컨버터\n- 엔티티의 데이터를 영속화 할때, 데이터의 변환이 필요한 경우 컨버터 관련 구현을 해두면 데이터베이스와 JPA 사이에서의 변환 작업을 편리하게 진행할 수 있다. 아래 예제 코드를 살펴보자\n```kotlin\n@Entity\n@Table(name = \"boards\")\n@Convert(converter = TagConverter::class, attributeName = \"tags\")\nclass Board protected constructor(){\n\t...\n\t@Convert(converter = SecretConverter::class)\n\tvar secret: Boolean = false\n\t\tprotected set\n\n\t@Column(name = \"tags\", columnDefinition = \"text\", nullable = false)\n\tvar tags: MutableList<String> = mutableListOf()\n\t...\n}\n```\n\n- 컨버터는 `AttributeConverter` 인터페이스를 구현해야하며, 프로퍼티/멤버 레벨 및 클래스 레벨에서 지정이 가능하다. 클래스 레벨에서 지정하는 경우 `attributeName`에 변환이 필요한 프로퍼티/멤버를 명시하면 된다.\n- 전역으로 설정하고 싶은 경우 `autoApply`의 값을 `true`로 지정하면 제네릭에 명시되어 있는 타입에서의 변환에 대하여 전역 레벨에서 변환 작업을 하게 된다. \n\n```kotlin\n@Converter(autoApply = false)\nclass SecretConverter : AttributeConverter<Boolean, String>{\n\t// \n\toverride fun convertToDatabaseColumn(attribute: Boolean): String {\n\t\treturn if (attribute) \"Y\" else \"N\"\n\t}\n\n\toverride fun convertToEntityAttribute(dbData: String): Boolean {\n\t\treturn dbData == \"Y\"\n\t}\n}\n```\n- [링크](https://docs.oracle.com/javaee/7/api/javax/persistence/Convert.html)를 참고하면 좀 더 세부적인 컨버터 구현에 대한 내용 확인이 가능하다.\n\n## 리스너\n![JPA_엔티티_리스너_시점](https://i.imgur.com/kdrVtQ8.png)\n- 엔티티의 생명주기에 따른 이벤트를 처리할 수 있으며, 생명주기에 따른 특징은 아래를 참고하자\n  1. `PostLoad`\n     - 영속성 컨텍스트 조회 직후 호출\n     - 2차 캐시에 저장되어 있어도 호출됨\n  2. `PrePersist`\n     - persist() 호출 전 시점에 호출\n     - 식별자 생성 전략을 사용했을 경우 아직 식별자는 존재 하지 않음\n  3. `PreUpdate`\n     - `flush`, `commit` 호출하여 엔티티를 수정하기 직전에 호출\n  4. `PreRemove`\n     - `remove`를 호출하여 엔티티를 영속성 컨텍스트에서 삭제하기 전에 호출\n     - 영속성 전이가 일어나도 호출되며 orphanRemoval에 대하여 `flush`, `commit` 시에 호출됨\n  5. `PostPersist`\n     - `flush`, `commit` 호출하여 엔티티를 DB에 저장한 후 호출\n     - 데이터베이스 저장 후 호출되기 때문에, 식별자가 존재\n  6. `PostUpdate`\n     - `flush`, `commit` 호출하여 엔티티를 수정하여 DB에 반영한 이후에 호출\n  7. `PostRemove`\n     - `remove`를 호출하여 엔티티를 DB에서 삭제한 이후에 호출\n- 리스너 등록은 `엔티티에 직접 적용`, `별도 리스너 등록`이 있다.\n  - 엔티티에 직접 적용\n\t```kotlin\n\tclass Board {\n\t\t...\n\t\t@PrePersist\n\t\tfun prePersist() {\n\t\t\tlogger.info(\"PrePersist(), {}\", this)\n\t\t}\n\n\t\t@PostPersist\n\t\tfun postPersist() {\n\t\t\tlogger.info(\"postPersist(), {}\", this)\n\t\t}\n\t}\n\t```\n  - 별도 리스너 클래스 사용\n\t```kotlin\n\n\t@Entity\n\t@Table(name = \"boards\")\n\t@EntityListeners(value = [BoardListener::class])\n\tclass Board {\n\t\t...\n\t}\n\n\tclass BoardListener {\n\t\tval logger = LoggerFactory.getLogger(this::class.java)\n\n\t\t@PostLoad\n\t\tfun postLoad(obj: Any) {\n\t\t\tlogger.info(\"postLoad()\")\n\t\t}\n\n\t\t@PrePersist\n\t\tfun prePersist(obj: Any) {\n\t\t\tlogger.info(\"PrePersist()\")\n\t\t}\n\n\t\t@PostPersist\n\t\tfun postPersist(obj: Any) {\n\t\t\tlogger.info(\"postPersist()\")\n\t\t}\n\t}\n\t```\n- 리스너와 비슷하게 사용할 수 있는 `Audit` 기능도 존재한다.\n- 리스너가 중첩된 구조로 등록되어 있는 경우, 아래와 같은 순서대로 리스너가 실행된다.\n  1. 기본 리스너\n  2. 부모 클래스 리스너(@MappedSuperClass 등으로 매핑한 슈퍼 클래스)\n  3. 별도 리스너\n  4. 엔티티\n- 슈퍼 클래스 엔티티에서 지정한 리스너와 기본 리스너를 무시하고 싶다면 아래와 같이 설정하는 것이 가능하다.\n```kotlin\n@Entity\n@Table(name = \"boards\")\n@EntityListeners(value = [BoardListener::class])\n@ExcludeDefaultListeners\n@ExcludeSuperclassListeners\nclass Board protected constructor(){\n}\n```","slug":"Persistence/JPA_컬렉션_리스너","published":1,"updated":"2021-08-02T12:29:17.962Z","_id":"ckrsup50t001otjhv18qv1tgm","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"JPA-컬렉션-amp-리스너\"><a href=\"#JPA-컬렉션-amp-리스너\" class=\"headerlink\" title=\"JPA 컬렉션 &amp; 리스너\"></a>JPA 컬렉션 &amp; 리스너</h1><blockquote>\n<p>자바 ORM 표준 JPA 프로그래밍 14장 내용을 정리</p>\n</blockquote>\n<h2 id=\"컬렉션\"><a href=\"#컬렉션\" class=\"headerlink\" title=\"컬렉션\"></a>컬렉션</h2><ul>\n<li>JPA에서는 Collection, List, Set, Map과 같은 컬렉션 구현체에 대한 매핑을 제공<ul>\n<li>Collection: 중복을 허용하고, 순서를 보장하지 않음</li>\n<li>List: 중복을 허용하고, 순서를 보장</li>\n<li>Set: 중복을 허용하지 않으나 순서를 보장하지 않음</li>\n<li>Map: K,V 구조의 구현체</li>\n</ul>\n</li>\n<li>@OneToMany, @ManyToMany와 같은 다수의 데이터를 매핑할 때 사용</li>\n<li>@ElementCollection을 사용한 다중의 값 타입 매핑</li>\n<li>가장 많이 사용하는 JPA 구현체인 하이버네이트의 경우, 컬렉션 필드를 하이버네이트의 래퍼 클래스로 감싸서 관리함. 사용하는 래퍼 클래스는 아래 예제 코드를 참고하자<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// org.hibernate.collection.internal.PersistentBag</span></span><br><span class=\"line\"><span class=\"meta\">@OneToMany</span></span><br><span class=\"line\">Collection&lt;Member&gt; collection = <span class=\"keyword\">new</span> ArrayList&lt;Member&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// org.hibernate.collection.internal.PersistentBag</span></span><br><span class=\"line\"><span class=\"meta\">@OneToMany</span></span><br><span class=\"line\">List&lt;Member&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Member&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// org.hibernate.collection.internal.PersistentSet</span></span><br><span class=\"line\"><span class=\"meta\">@OneToMany</span></span><br><span class=\"line\">Set&lt;Member&gt; set = <span class=\"keyword\">new</span> HashSet&lt;Member&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// org.hibernate.collection.internal.PersistentList</span></span><br><span class=\"line\"><span class=\"meta\">@OneToMany</span></span><br><span class=\"line\"><span class=\"meta\">@OrderColumn</span></span><br><span class=\"line\">List&lt;Member&gt; orderColumnList = <span class=\"keyword\">new</span> ArrayList&lt;Member&gt;();</span><br></pre></td></tr></table></figure></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Collection-Interface</th>\n<th>Hibernate-Collection</th>\n<th>중복허용</th>\n<th>순서 보관</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Collection, List</td>\n<td>PersistenceBag</td>\n<td>O</td>\n<td>X</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>PersistenceSet</td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr>\n<td>List + @OrderColumn</td>\n<td>PersistenceList</td>\n<td>O</td>\n<td>O</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>래퍼 클래스를 통하여 원본 콜렉션을 감싸는 이유에 대해서 좀 더 상세하게 풀어보자면, 하이버네이트 매뉴얼에서는 이를 래퍼 타입을 통하여 지연로딩, 상태변경 그리고 캐싱에 대한 기능 지원을 위해서라고 한다.<br>실제 PersistentBag과 같은 구현체 내부를 보면, 하이버네이트에서 기능지원을 위해 사용하는 AbstractPersistentCollection 클래스를 상속하고 있고 또한 List 인터페이스를 그대로 구현하고 있는 것을 확인할 수 있다. 그러므로, 매핑 시 반드시 자바 콜렉션 프레임워크의 표준 인터페이스를 사용하여 매핑을 해야 한다.</p>\n</blockquote>\n<ul>\n<li>Collection, List의 경우 중복을 허용하기 때문에, 지연로딩을 사용하는 경우라도 해당 콜렉션을 초기화하지 않는다. 반면, Set의 경우 중복에 대한 체크가 필요하기 때문에 지연로딩을 사용할 경우 해당 컬렉션을 초기화하는 작업을 거치게 된다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Board</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@OneToMany(mappedBy = &quot;board&quot;)</span></span><br><span class=\"line\">\t<span class=\"meta\">@OrderColumn(name = &quot;POSITION&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> List&lt;Comment&gt; comments = <span class=\"keyword\">new</span> ArrayList&lt;Comment&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>위 코드와 같이 <code>List + @OrderColumn</code>을 조합하여 사용하는 경우, 순서를 판단할 수 있는 별도의 컬럼을 매핑하는 것이 가능하다. 해당 컬럼에 순서에 대한 시퀀스 벨류가 저장된다. </li>\n<li>하지만, 위 코드에서도 볼수 있듯이 실제 엔티티에 해당 컬럼이 매핑되는 것이 아닌 엔티티를 사용하는 측에 해당 컬럼을 명시하기 때문에 실 엔티티에서는 위와 같은 정보를 알수 없다. 또한, <strong>실제 영속화하는 과정에서 별도의 update 구문이 한번 더 실행되며 콜렉션 내부의 삭제가 발생할 경우 순서를 조정하기 위한 연속적인 update 구문이 실행된다. 성능상에도 그리 좋은편은 아니라고 할 수 있다.</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Board</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@OneToMany(mappedBy = &quot;board&quot;)</span></span><br><span class=\"line\">\t<span class=\"meta\">@OrderBy(&quot;username desc, id asc&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> List&lt;Comment&gt; comments = <span class=\"keyword\">new</span> ArrayList&lt;Comment&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>별도의 순서를 저장하는 컬럼을 사용하는 것보다 <code>@OrderBy</code>를 사용하여 실제 사용하는 컬럼에서 순서를 지정하는 방법이 <code>@OrderColumn</code>을 사용하는 것보다 나을 수 있다.</li>\n</ul>\n<h2 id=\"컨버터\"><a href=\"#컨버터\" class=\"headerlink\" title=\"컨버터\"></a>컨버터</h2><ul>\n<li><p>엔티티의 데이터를 영속화 할때, 데이터의 변환이 필요한 경우 컨버터 관련 구현을 해두면 데이터베이스와 JPA 사이에서의 변환 작업을 편리하게 진행할 수 있다. 아래 예제 코드를 살펴보자</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table(name = <span class=\"meta-string\">&quot;boards&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">@Convert(converter = TagConverter::class, attributeName = <span class=\"meta-string\">&quot;tags&quot;</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Board</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">constructor</span></span>()&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"meta\">@Convert(converter = SecretConverter::class)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> secret: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Column(name = <span class=\"meta-string\">&quot;tags&quot;</span>, columnDefinition = <span class=\"meta-string\">&quot;text&quot;</span>, nullable = false)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> tags: MutableList&lt;String&gt; = mutableListOf()</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>컨버터는 <code>AttributeConverter</code> 인터페이스를 구현해야하며, 프로퍼티/멤버 레벨 및 클래스 레벨에서 지정이 가능하다. 클래스 레벨에서 지정하는 경우 <code>attributeName</code>에 변환이 필요한 프로퍼티/멤버를 명시하면 된다.</p>\n</li>\n<li><p>전역으로 설정하고 싶은 경우 <code>autoApply</code>의 값을 <code>true</code>로 지정하면 제네릭에 명시되어 있는 타입에서의 변환에 대하여 전역 레벨에서 변환 작업을 하게 된다. </p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Converter(autoApply = false)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecretConverter</span> : <span class=\"type\">AttributeConverter</span>&lt;<span class=\"type\">Boolean, String</span>&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t<span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">convertToDatabaseColumn</span><span class=\"params\">(attribute: <span class=\"type\">Boolean</span>)</span></span>: String &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">if</span> (attribute) <span class=\"string\">&quot;Y&quot;</span> <span class=\"keyword\">else</span> <span class=\"string\">&quot;N&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">convertToEntityAttribute</span><span class=\"params\">(dbData: <span class=\"type\">String</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> dbData == <span class=\"string\">&quot;Y&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"https://docs.oracle.com/javaee/7/api/javax/persistence/Convert.html\">링크</a>를 참고하면 좀 더 세부적인 컨버터 구현에 대한 내용 확인이 가능하다.</li>\n</ul>\n<h2 id=\"리스너\"><a href=\"#리스너\" class=\"headerlink\" title=\"리스너\"></a>리스너</h2><p><img src=\"https://i.imgur.com/kdrVtQ8.png\" alt=\"JPA_엔티티_리스너_시점\"></p>\n<ul>\n<li>엔티티의 생명주기에 따른 이벤트를 처리할 수 있으며, 생명주기에 따른 특징은 아래를 참고하자<ol>\n<li><code>PostLoad</code><ul>\n<li>영속성 컨텍스트 조회 직후 호출</li>\n<li>2차 캐시에 저장되어 있어도 호출됨</li>\n</ul>\n</li>\n<li><code>PrePersist</code><ul>\n<li>persist() 호출 전 시점에 호출</li>\n<li>식별자 생성 전략을 사용했을 경우 아직 식별자는 존재 하지 않음</li>\n</ul>\n</li>\n<li><code>PreUpdate</code><ul>\n<li><code>flush</code>, <code>commit</code> 호출하여 엔티티를 수정하기 직전에 호출</li>\n</ul>\n</li>\n<li><code>PreRemove</code><ul>\n<li><code>remove</code>를 호출하여 엔티티를 영속성 컨텍스트에서 삭제하기 전에 호출</li>\n<li>영속성 전이가 일어나도 호출되며 orphanRemoval에 대하여 <code>flush</code>, <code>commit</code> 시에 호출됨</li>\n</ul>\n</li>\n<li><code>PostPersist</code><ul>\n<li><code>flush</code>, <code>commit</code> 호출하여 엔티티를 DB에 저장한 후 호출</li>\n<li>데이터베이스 저장 후 호출되기 때문에, 식별자가 존재</li>\n</ul>\n</li>\n<li><code>PostUpdate</code><ul>\n<li><code>flush</code>, <code>commit</code> 호출하여 엔티티를 수정하여 DB에 반영한 이후에 호출</li>\n</ul>\n</li>\n<li><code>PostRemove</code><ul>\n<li><code>remove</code>를 호출하여 엔티티를 DB에서 삭제한 이후에 호출</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>리스너 등록은 <code>엔티티에 직접 적용</code>, <code>별도 리스너 등록</code>이 있다.<ul>\n<li>엔티티에 직접 적용<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Board</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"meta\">@PrePersist</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">prePersist</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tlogger.info(<span class=\"string\">&quot;PrePersist(), &#123;&#125;&quot;</span>, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@PostPersist</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">postPersist</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tlogger.info(<span class=\"string\">&quot;postPersist(), &#123;&#125;&quot;</span>, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>별도 리스너 클래스 사용<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table(name = <span class=\"meta-string\">&quot;boards&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">@EntityListeners(value = [BoardListener::class])</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Board</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoardListener</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> logger = LoggerFactory.getLogger(<span class=\"keyword\">this</span>::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@PostLoad</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">postLoad</span><span class=\"params\">(obj: <span class=\"type\">Any</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tlogger.info(<span class=\"string\">&quot;postLoad()&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@PrePersist</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">prePersist</span><span class=\"params\">(obj: <span class=\"type\">Any</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tlogger.info(<span class=\"string\">&quot;PrePersist()&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@PostPersist</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">postPersist</span><span class=\"params\">(obj: <span class=\"type\">Any</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tlogger.info(<span class=\"string\">&quot;postPersist()&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>리스너와 비슷하게 사용할 수 있는 <code>Audit</code> 기능도 존재한다.</li>\n<li>리스너가 중첩된 구조로 등록되어 있는 경우, 아래와 같은 순서대로 리스너가 실행된다.<ol>\n<li>기본 리스너</li>\n<li>부모 클래스 리스너(@MappedSuperClass 등으로 매핑한 슈퍼 클래스)</li>\n<li>별도 리스너</li>\n<li>엔티티</li>\n</ol>\n</li>\n<li>슈퍼 클래스 엔티티에서 지정한 리스너와 기본 리스너를 무시하고 싶다면 아래와 같이 설정하는 것이 가능하다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table(name = <span class=\"meta-string\">&quot;boards&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">@EntityListeners(value = [BoardListener::class])</span></span><br><span class=\"line\"><span class=\"meta\">@ExcludeDefaultListeners</span></span><br><span class=\"line\"><span class=\"meta\">@ExcludeSuperclassListeners</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Board</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">constructor</span></span>()&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JPA-컬렉션-amp-리스너\"><a href=\"#JPA-컬렉션-amp-리스너\" class=\"headerlink\" title=\"JPA 컬렉션 &amp; 리스너\"></a>JPA 컬렉션 &amp; 리스너</h1><blockquote>\n<p>자바 ORM 표준 JPA 프로그래밍 14장 내용을 정리</p>\n</blockquote>\n<h2 id=\"컬렉션\"><a href=\"#컬렉션\" class=\"headerlink\" title=\"컬렉션\"></a>컬렉션</h2><ul>\n<li>JPA에서는 Collection, List, Set, Map과 같은 컬렉션 구현체에 대한 매핑을 제공<ul>\n<li>Collection: 중복을 허용하고, 순서를 보장하지 않음</li>\n<li>List: 중복을 허용하고, 순서를 보장</li>\n<li>Set: 중복을 허용하지 않으나 순서를 보장하지 않음</li>\n<li>Map: K,V 구조의 구현체</li>\n</ul>\n</li>\n<li>@OneToMany, @ManyToMany와 같은 다수의 데이터를 매핑할 때 사용</li>\n<li>@ElementCollection을 사용한 다중의 값 타입 매핑</li>\n<li>가장 많이 사용하는 JPA 구현체인 하이버네이트의 경우, 컬렉션 필드를 하이버네이트의 래퍼 클래스로 감싸서 관리함. 사용하는 래퍼 클래스는 아래 예제 코드를 참고하자<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// org.hibernate.collection.internal.PersistentBag</span></span><br><span class=\"line\"><span class=\"meta\">@OneToMany</span></span><br><span class=\"line\">Collection&lt;Member&gt; collection = <span class=\"keyword\">new</span> ArrayList&lt;Member&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// org.hibernate.collection.internal.PersistentBag</span></span><br><span class=\"line\"><span class=\"meta\">@OneToMany</span></span><br><span class=\"line\">List&lt;Member&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Member&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// org.hibernate.collection.internal.PersistentSet</span></span><br><span class=\"line\"><span class=\"meta\">@OneToMany</span></span><br><span class=\"line\">Set&lt;Member&gt; set = <span class=\"keyword\">new</span> HashSet&lt;Member&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// org.hibernate.collection.internal.PersistentList</span></span><br><span class=\"line\"><span class=\"meta\">@OneToMany</span></span><br><span class=\"line\"><span class=\"meta\">@OrderColumn</span></span><br><span class=\"line\">List&lt;Member&gt; orderColumnList = <span class=\"keyword\">new</span> ArrayList&lt;Member&gt;();</span><br></pre></td></tr></table></figure></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Collection-Interface</th>\n<th>Hibernate-Collection</th>\n<th>중복허용</th>\n<th>순서 보관</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Collection, List</td>\n<td>PersistenceBag</td>\n<td>O</td>\n<td>X</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>PersistenceSet</td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr>\n<td>List + @OrderColumn</td>\n<td>PersistenceList</td>\n<td>O</td>\n<td>O</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>래퍼 클래스를 통하여 원본 콜렉션을 감싸는 이유에 대해서 좀 더 상세하게 풀어보자면, 하이버네이트 매뉴얼에서는 이를 래퍼 타입을 통하여 지연로딩, 상태변경 그리고 캐싱에 대한 기능 지원을 위해서라고 한다.<br>실제 PersistentBag과 같은 구현체 내부를 보면, 하이버네이트에서 기능지원을 위해 사용하는 AbstractPersistentCollection 클래스를 상속하고 있고 또한 List 인터페이스를 그대로 구현하고 있는 것을 확인할 수 있다. 그러므로, 매핑 시 반드시 자바 콜렉션 프레임워크의 표준 인터페이스를 사용하여 매핑을 해야 한다.</p>\n</blockquote>\n<ul>\n<li>Collection, List의 경우 중복을 허용하기 때문에, 지연로딩을 사용하는 경우라도 해당 콜렉션을 초기화하지 않는다. 반면, Set의 경우 중복에 대한 체크가 필요하기 때문에 지연로딩을 사용할 경우 해당 컬렉션을 초기화하는 작업을 거치게 된다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Board</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@OneToMany(mappedBy = &quot;board&quot;)</span></span><br><span class=\"line\">\t<span class=\"meta\">@OrderColumn(name = &quot;POSITION&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> List&lt;Comment&gt; comments = <span class=\"keyword\">new</span> ArrayList&lt;Comment&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>위 코드와 같이 <code>List + @OrderColumn</code>을 조합하여 사용하는 경우, 순서를 판단할 수 있는 별도의 컬럼을 매핑하는 것이 가능하다. 해당 컬럼에 순서에 대한 시퀀스 벨류가 저장된다. </li>\n<li>하지만, 위 코드에서도 볼수 있듯이 실제 엔티티에 해당 컬럼이 매핑되는 것이 아닌 엔티티를 사용하는 측에 해당 컬럼을 명시하기 때문에 실 엔티티에서는 위와 같은 정보를 알수 없다. 또한, <strong>실제 영속화하는 과정에서 별도의 update 구문이 한번 더 실행되며 콜렉션 내부의 삭제가 발생할 경우 순서를 조정하기 위한 연속적인 update 구문이 실행된다. 성능상에도 그리 좋은편은 아니라고 할 수 있다.</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Board</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@OneToMany(mappedBy = &quot;board&quot;)</span></span><br><span class=\"line\">\t<span class=\"meta\">@OrderBy(&quot;username desc, id asc&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> List&lt;Comment&gt; comments = <span class=\"keyword\">new</span> ArrayList&lt;Comment&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>별도의 순서를 저장하는 컬럼을 사용하는 것보다 <code>@OrderBy</code>를 사용하여 실제 사용하는 컬럼에서 순서를 지정하는 방법이 <code>@OrderColumn</code>을 사용하는 것보다 나을 수 있다.</li>\n</ul>\n<h2 id=\"컨버터\"><a href=\"#컨버터\" class=\"headerlink\" title=\"컨버터\"></a>컨버터</h2><ul>\n<li><p>엔티티의 데이터를 영속화 할때, 데이터의 변환이 필요한 경우 컨버터 관련 구현을 해두면 데이터베이스와 JPA 사이에서의 변환 작업을 편리하게 진행할 수 있다. 아래 예제 코드를 살펴보자</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table(name = <span class=\"meta-string\">&quot;boards&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">@Convert(converter = TagConverter::class, attributeName = <span class=\"meta-string\">&quot;tags&quot;</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Board</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">constructor</span></span>()&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"meta\">@Convert(converter = SecretConverter::class)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> secret: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Column(name = <span class=\"meta-string\">&quot;tags&quot;</span>, columnDefinition = <span class=\"meta-string\">&quot;text&quot;</span>, nullable = false)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> tags: MutableList&lt;String&gt; = mutableListOf()</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>컨버터는 <code>AttributeConverter</code> 인터페이스를 구현해야하며, 프로퍼티/멤버 레벨 및 클래스 레벨에서 지정이 가능하다. 클래스 레벨에서 지정하는 경우 <code>attributeName</code>에 변환이 필요한 프로퍼티/멤버를 명시하면 된다.</p>\n</li>\n<li><p>전역으로 설정하고 싶은 경우 <code>autoApply</code>의 값을 <code>true</code>로 지정하면 제네릭에 명시되어 있는 타입에서의 변환에 대하여 전역 레벨에서 변환 작업을 하게 된다. </p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Converter(autoApply = false)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecretConverter</span> : <span class=\"type\">AttributeConverter</span>&lt;<span class=\"type\">Boolean, String</span>&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t<span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">convertToDatabaseColumn</span><span class=\"params\">(attribute: <span class=\"type\">Boolean</span>)</span></span>: String &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">if</span> (attribute) <span class=\"string\">&quot;Y&quot;</span> <span class=\"keyword\">else</span> <span class=\"string\">&quot;N&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">convertToEntityAttribute</span><span class=\"params\">(dbData: <span class=\"type\">String</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> dbData == <span class=\"string\">&quot;Y&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"https://docs.oracle.com/javaee/7/api/javax/persistence/Convert.html\">링크</a>를 참고하면 좀 더 세부적인 컨버터 구현에 대한 내용 확인이 가능하다.</li>\n</ul>\n<h2 id=\"리스너\"><a href=\"#리스너\" class=\"headerlink\" title=\"리스너\"></a>리스너</h2><p><img src=\"https://i.imgur.com/kdrVtQ8.png\" alt=\"JPA_엔티티_리스너_시점\"></p>\n<ul>\n<li>엔티티의 생명주기에 따른 이벤트를 처리할 수 있으며, 생명주기에 따른 특징은 아래를 참고하자<ol>\n<li><code>PostLoad</code><ul>\n<li>영속성 컨텍스트 조회 직후 호출</li>\n<li>2차 캐시에 저장되어 있어도 호출됨</li>\n</ul>\n</li>\n<li><code>PrePersist</code><ul>\n<li>persist() 호출 전 시점에 호출</li>\n<li>식별자 생성 전략을 사용했을 경우 아직 식별자는 존재 하지 않음</li>\n</ul>\n</li>\n<li><code>PreUpdate</code><ul>\n<li><code>flush</code>, <code>commit</code> 호출하여 엔티티를 수정하기 직전에 호출</li>\n</ul>\n</li>\n<li><code>PreRemove</code><ul>\n<li><code>remove</code>를 호출하여 엔티티를 영속성 컨텍스트에서 삭제하기 전에 호출</li>\n<li>영속성 전이가 일어나도 호출되며 orphanRemoval에 대하여 <code>flush</code>, <code>commit</code> 시에 호출됨</li>\n</ul>\n</li>\n<li><code>PostPersist</code><ul>\n<li><code>flush</code>, <code>commit</code> 호출하여 엔티티를 DB에 저장한 후 호출</li>\n<li>데이터베이스 저장 후 호출되기 때문에, 식별자가 존재</li>\n</ul>\n</li>\n<li><code>PostUpdate</code><ul>\n<li><code>flush</code>, <code>commit</code> 호출하여 엔티티를 수정하여 DB에 반영한 이후에 호출</li>\n</ul>\n</li>\n<li><code>PostRemove</code><ul>\n<li><code>remove</code>를 호출하여 엔티티를 DB에서 삭제한 이후에 호출</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>리스너 등록은 <code>엔티티에 직접 적용</code>, <code>별도 리스너 등록</code>이 있다.<ul>\n<li>엔티티에 직접 적용<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Board</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"meta\">@PrePersist</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">prePersist</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tlogger.info(<span class=\"string\">&quot;PrePersist(), &#123;&#125;&quot;</span>, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@PostPersist</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">postPersist</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tlogger.info(<span class=\"string\">&quot;postPersist(), &#123;&#125;&quot;</span>, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>별도 리스너 클래스 사용<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table(name = <span class=\"meta-string\">&quot;boards&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">@EntityListeners(value = [BoardListener::class])</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Board</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoardListener</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> logger = LoggerFactory.getLogger(<span class=\"keyword\">this</span>::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@PostLoad</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">postLoad</span><span class=\"params\">(obj: <span class=\"type\">Any</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tlogger.info(<span class=\"string\">&quot;postLoad()&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@PrePersist</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">prePersist</span><span class=\"params\">(obj: <span class=\"type\">Any</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tlogger.info(<span class=\"string\">&quot;PrePersist()&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@PostPersist</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">postPersist</span><span class=\"params\">(obj: <span class=\"type\">Any</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tlogger.info(<span class=\"string\">&quot;postPersist()&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>리스너와 비슷하게 사용할 수 있는 <code>Audit</code> 기능도 존재한다.</li>\n<li>리스너가 중첩된 구조로 등록되어 있는 경우, 아래와 같은 순서대로 리스너가 실행된다.<ol>\n<li>기본 리스너</li>\n<li>부모 클래스 리스너(@MappedSuperClass 등으로 매핑한 슈퍼 클래스)</li>\n<li>별도 리스너</li>\n<li>엔티티</li>\n</ol>\n</li>\n<li>슈퍼 클래스 엔티티에서 지정한 리스너와 기본 리스너를 무시하고 싶다면 아래와 같이 설정하는 것이 가능하다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table(name = <span class=\"meta-string\">&quot;boards&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">@EntityListeners(value = [BoardListener::class])</span></span><br><span class=\"line\"><span class=\"meta\">@ExcludeDefaultListeners</span></span><br><span class=\"line\"><span class=\"meta\">@ExcludeSuperclassListeners</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Board</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">constructor</span></span>()&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"JOOQ CodeGen 관련 문서","date":"2019-07-11T15:00:00.000Z","_content":"\n# JOOQ CodeGen 관련 문서\n- https://gist.github.com/kwon37xi/c0919d79d8af49d9113f5b46bd5c0fcf\n- [gradle-jooq-plugin](https://github.com/etiennestuder/gradle-jooq-plugin)\n- https://www.2ndquadrant.com/en/blog/using-java-object-oriented-querying-jooq-with-postgresql/\n","source":"_posts/Persistence/jooq.md","raw":"---\ntitle: 'JOOQ CodeGen 관련 문서'\ndate: 2019/7/12 00:00:00\ncategories:\n- Persistence\n---\n\n# JOOQ CodeGen 관련 문서\n- https://gist.github.com/kwon37xi/c0919d79d8af49d9113f5b46bd5c0fcf\n- [gradle-jooq-plugin](https://github.com/etiennestuder/gradle-jooq-plugin)\n- https://www.2ndquadrant.com/en/blog/using-java-object-oriented-querying-jooq-with-postgresql/\n","slug":"Persistence/jooq","published":1,"updated":"2021-08-02T12:30:54.410Z","_id":"ckrsup50u001ptjhvgi7mecys","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"JOOQ-CodeGen-관련-문서\"><a href=\"#JOOQ-CodeGen-관련-문서\" class=\"headerlink\" title=\"JOOQ CodeGen 관련 문서\"></a>JOOQ CodeGen 관련 문서</h1><ul>\n<li><a href=\"https://gist.github.com/kwon37xi/c0919d79d8af49d9113f5b46bd5c0fcf\">https://gist.github.com/kwon37xi/c0919d79d8af49d9113f5b46bd5c0fcf</a></li>\n<li><a href=\"https://github.com/etiennestuder/gradle-jooq-plugin\">gradle-jooq-plugin</a></li>\n<li><a href=\"https://www.2ndquadrant.com/en/blog/using-java-object-oriented-querying-jooq-with-postgresql/\">https://www.2ndquadrant.com/en/blog/using-java-object-oriented-querying-jooq-with-postgresql/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JOOQ-CodeGen-관련-문서\"><a href=\"#JOOQ-CodeGen-관련-문서\" class=\"headerlink\" title=\"JOOQ CodeGen 관련 문서\"></a>JOOQ CodeGen 관련 문서</h1><ul>\n<li><a href=\"https://gist.github.com/kwon37xi/c0919d79d8af49d9113f5b46bd5c0fcf\">https://gist.github.com/kwon37xi/c0919d79d8af49d9113f5b46bd5c0fcf</a></li>\n<li><a href=\"https://github.com/etiennestuder/gradle-jooq-plugin\">gradle-jooq-plugin</a></li>\n<li><a href=\"https://www.2ndquadrant.com/en/blog/using-java-object-oriented-querying-jooq-with-postgresql/\">https://www.2ndquadrant.com/en/blog/using-java-object-oriented-querying-jooq-with-postgresql/</a></li>\n</ul>\n"},{"title":"Redis 관련 링크","date":"2020-08-12T15:00:00.000Z","_content":"\n# Redis 관련 링크\n\n- https://redis.io/topics/distlock\n- https://bae-unidev.github.io/2015/12/20/redlock-trans/\n- redisson: https://devyounji.tistory.com/34","source":"_posts/REDIS/redlock.md","raw":"---\ntitle: 'Redis 관련 링크'\ndate: 2020/8/13 00:00:00\ncategories:\n- Redis\n---\n\n# Redis 관련 링크\n\n- https://redis.io/topics/distlock\n- https://bae-unidev.github.io/2015/12/20/redlock-trans/\n- redisson: https://devyounji.tistory.com/34","slug":"REDIS/redlock","published":1,"updated":"2021-08-02T12:22:09.945Z","_id":"ckrsup50v001qtjhv8jyw78uc","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Redis-관련-링크\"><a href=\"#Redis-관련-링크\" class=\"headerlink\" title=\"Redis 관련 링크\"></a>Redis 관련 링크</h1><ul>\n<li><a href=\"https://redis.io/topics/distlock\">https://redis.io/topics/distlock</a></li>\n<li><a href=\"https://bae-unidev.github.io/2015/12/20/redlock-trans/\">https://bae-unidev.github.io/2015/12/20/redlock-trans/</a></li>\n<li>redisson: <a href=\"https://devyounji.tistory.com/34\">https://devyounji.tistory.com/34</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Redis-관련-링크\"><a href=\"#Redis-관련-링크\" class=\"headerlink\" title=\"Redis 관련 링크\"></a>Redis 관련 링크</h1><ul>\n<li><a href=\"https://redis.io/topics/distlock\">https://redis.io/topics/distlock</a></li>\n<li><a href=\"https://bae-unidev.github.io/2015/12/20/redlock-trans/\">https://bae-unidev.github.io/2015/12/20/redlock-trans/</a></li>\n<li>redisson: <a href=\"https://devyounji.tistory.com/34\">https://devyounji.tistory.com/34</a></li>\n</ul>\n"},{"title":"스프링 부트 배치 #1 - 개요/주요개념","date":"2018-12-31T15:27:00.000Z","_content":"\n# 스프링 부트 배치 #1 - 개요/주요개념\n## 개요\n* 백엔드의 배치 처리 기능을 구현하는 데 사용하는 프레임워크.\n* 부트 배치의 경우, 스프링 배치의 설정 요소들을 간편화시켜 스프링 배치를 빠르고 쉽게 사용할 수 있도록 구성.\n  * 배치란, 순차적으로 자료를 처리한다는 뜻으로 일괄 처리와 같은 뜻\n\n## Why Spring Batch?\n* 대용량 처리 최적화되어 있고, 고성능을 발휘\n* 로깅. 통계 처리, 트랜잭션 관리 등 필수 기능 지원\n* 예외 및 비정상 동작에 대한 방어 기능\n* 개발자는 Spring Batch 프로그래밍 모델을 사용하여 비즈니스 로직에 집중하고 프레임워크가 인프라를 관리하도록 함.\n\n## 주의사항\n* 복잡한 구조와 로직을 피해야 함\n* 데이터를 직접 다루는 코드가 많으므로, 무결성을 유지할 수 있는 방어적인 방법을 사용해야 함.\n* I/O 사용을 최소화 해야 한다. 잦은 I/O 발생은 배치 어플리케이션 성능에 영향을 줄 수 있기 때문이다.\n  * Minimize system resource use, especially I/O. Perform as many operations as possible in internal memory.\n* 스프링 부트 배치는 별도의 스캐줄링 기능을 제공하지 않는다. 이에 따라, 별도의 스케줄링 구현체를 사용해야 한다.\n  * 쿼츠, 스프링 스캐줄러 등을 사용해야 함.\n* 실제 환경과 비슷한 데이터 볼륨을 가지고 테스트를 함으로써, 처리 안정성을 높히는 것이 좋다.\n\n## 배치 처리 절차\n* 읽기: 데이터베이스, 파일 등에서 데이터를 읽는다. \n  * Reads a large number of records from a database, file, or queue.\n* 처리: 읽은 데이터를 처리/가공\n  * Processes the data in some fashion.\n* 쓰기: 처리/가공한 데이터를 별도의 저장소에 저장\n  * Writes back data in a modified form.\n\n![](https://docs.spring.io/spring-batch/4.1.x/reference/html/images/spring-batch-reference-model.png)\n\n* Job과 Step은 1:N의 관계로, 하나의 Job에 여러 개의 Step으로 처리하는 프로세스를 가진다. 각각 Step은 ItemReader, ItemProcessor, ItemWriter를 가지고 있으며, Step과는 1:1 관계를 가진다.\n\n### 1. Job\n* 처리 과정 하나를 가리키는 객체로 여러 개의 Step을 포함할 수 있다. Step들의 컨테이너 역할을 수행한다.\n* Job 객체를 만드는 빌더 클래스는 여러 개 있으며, 여러 빌더를 통합한 JobBuilderFactory를 통하여 원하는 Job을 쉽게 생성할 수 있음.\n```java\n@Bean\npublic Job footballJob() {\n\treturn this.jobBuilderFactory.get(\"footballJob\")\n\t\t\t\t.start(playerLoad())\n\t\t\t\t.next(gameLoad())\n\t\t\t\t.next(playerSummarization())\n\t\t\t\t.end()\n\t\t\t\t.build();\n}\n```\n* JobBuilderFactory.get()을 호출하게 되면, 새로운 JobBuilder 인스턴스를 반환함. JobBuilder를 생성하는 과정에서 JobRepository를 주입받게 되는데, JobBuilderFactory에서 생성되는 모든 JobBuilder가 동일한 JobRepository를 사용하게 된다.\n* **JobBuilerFactory에서 JobBuilder를 생성하며 생성한 빌더를 통하여 Job을 생성할 수 있다.**\n* **JobBuilder는 직접 Job을 생성하는 것이 아니라, 별도의 구체적인 JobBuilder를 통하여 Job을 생성하게 된다.** Job을 생성할 수 있는 여러 상황을 고려하여 이렇게 구현되어 있는듯 보이며, 매소드 체이닝을 통하여 원하는 내용을 명시하면 쉽게 처리 할 수 있다.\n\n```java\n@Autowired\nprivate JobBuilderFactory jobBuilderFactory;\n\n@Bean\npublic Job simpleJob() {\n\t\t// 1. simpleJob 이라는 이름을 가진 Job을 생성할 수 있는 JobBuilder 인스턴스 반환\n\treturn jobBuilderFactory.get(\"simpleJob\")\n\t\t// 2. Step을 주입, Step혹은 Flow를 파라메터로 받아서 구체적인 빌더를 생성할 수 있다.\n\t\t.start(simpleStep())\n\t\t// 3. build()를 호출하여 \"simpleJob\"의 이름을 가지는 Job을 생성\n\t\t.build();\n}\n```\n\n#### 1.1 JobInstance\n* 하나의 Job의 실행 단위, JobExecution을 여러개 가질 수 있음\n\n#### 1.2 JobExecution\n* JobInstance에 대한 한 번 실행을 나타내는 객체. Job 실행에 대한 정보를 담고 있는 도메인 객체로 JobInstance, 실행 상태, 시작 시간, 종료 시간, 실패 메세지 등 정보를 담고 있음.\n\n#### 1.3 JobParameter\n![](https://docs.spring.io/spring-batch/4.1.x/reference/html/images/job-stereotypes-parameters.png)\n* Job이 실행될 떄 필요한 인자를 Map 타입으로 저장하는 객체. JobInstance와 1:1 관계이며, 사용 할 수 있는 데이터 타입은 Long, String, Date, Double 등이 있다.\n* JobInstance를 구분하는 기준으로 사용될 수 있다.\n  * `JobInstance = Job + identifying JobParameters`\n\n\n\n### 2. Step\n* 실질적인 Job 처리를 담당. 필요한 정보를 담고 있는 도메인 객체이며 모든 Job은 여러 개의 Step을 가질 수 있다.\n#### 2.1 StepExecution\n* Job에 JobExecution이 있듯이, Step에도 이에 대응하는 StepExecution이 존재한다. 해당 Step의 실행 정보를 담고 있다.\n\n### 3. JobRepository\n* JobRepository는 배치 처리 정보를 담고 있는 객체로, Job의 실행 횟수 및 시간 정보 등의 메타 정보를 가지고 있다. Step의 실행정보를 담고 있는 StepExecution도 가지고 있으며, 전체 메타 데이터를 가지고 있는 객체라고 생각하면 된다.\n\n### 4. JobLauncher\n* Job, JobParameter와 함께 배치를 시작하는 인터페이스로 사용. 인터페이스의 매소드는 `run()`만 존재함.\n\n### 5. ItemReader\n* Step에서 데이터를 읽어오는 역할을 수행. FILE, DB, QUEUE 등에서 데이터를 읽어 올 수 있다.\n\n### 6. ItemProcessor\n* 읽어온 데이터를 처리하는 인터페이스. Input과 Output에 대한 타입 명시가 가능\n\n### 7. ItemWriter\n* 이전 단계에서 처리한 데이터를 저장하는 인터페이스. List 인터페이스를 통하여 지정한 타입의 데이터를 받아오며 CHUNK 단위로 데이터를 받아온다.\n\n## 참고자료\n* [처음 배우는 스프링 부트 2](https://book.naver.com/bookdb/book_detail.nhn?bid=14031681)\n* [Spring Batch - Reference Documentation](https://docs.spring.io/spring-batch/4.1.x/reference/html/index.html)\n\n","source":"_posts/Spring/BATCH_1.md","raw":"---\ntitle: '스프링 부트 배치 #1 - 개요/주요개념'\ndate: 2019.1.1. 00:27\ncategories:\n- Spring\n---\n\n# 스프링 부트 배치 #1 - 개요/주요개념\n## 개요\n* 백엔드의 배치 처리 기능을 구현하는 데 사용하는 프레임워크.\n* 부트 배치의 경우, 스프링 배치의 설정 요소들을 간편화시켜 스프링 배치를 빠르고 쉽게 사용할 수 있도록 구성.\n  * 배치란, 순차적으로 자료를 처리한다는 뜻으로 일괄 처리와 같은 뜻\n\n## Why Spring Batch?\n* 대용량 처리 최적화되어 있고, 고성능을 발휘\n* 로깅. 통계 처리, 트랜잭션 관리 등 필수 기능 지원\n* 예외 및 비정상 동작에 대한 방어 기능\n* 개발자는 Spring Batch 프로그래밍 모델을 사용하여 비즈니스 로직에 집중하고 프레임워크가 인프라를 관리하도록 함.\n\n## 주의사항\n* 복잡한 구조와 로직을 피해야 함\n* 데이터를 직접 다루는 코드가 많으므로, 무결성을 유지할 수 있는 방어적인 방법을 사용해야 함.\n* I/O 사용을 최소화 해야 한다. 잦은 I/O 발생은 배치 어플리케이션 성능에 영향을 줄 수 있기 때문이다.\n  * Minimize system resource use, especially I/O. Perform as many operations as possible in internal memory.\n* 스프링 부트 배치는 별도의 스캐줄링 기능을 제공하지 않는다. 이에 따라, 별도의 스케줄링 구현체를 사용해야 한다.\n  * 쿼츠, 스프링 스캐줄러 등을 사용해야 함.\n* 실제 환경과 비슷한 데이터 볼륨을 가지고 테스트를 함으로써, 처리 안정성을 높히는 것이 좋다.\n\n## 배치 처리 절차\n* 읽기: 데이터베이스, 파일 등에서 데이터를 읽는다. \n  * Reads a large number of records from a database, file, or queue.\n* 처리: 읽은 데이터를 처리/가공\n  * Processes the data in some fashion.\n* 쓰기: 처리/가공한 데이터를 별도의 저장소에 저장\n  * Writes back data in a modified form.\n\n![](https://docs.spring.io/spring-batch/4.1.x/reference/html/images/spring-batch-reference-model.png)\n\n* Job과 Step은 1:N의 관계로, 하나의 Job에 여러 개의 Step으로 처리하는 프로세스를 가진다. 각각 Step은 ItemReader, ItemProcessor, ItemWriter를 가지고 있으며, Step과는 1:1 관계를 가진다.\n\n### 1. Job\n* 처리 과정 하나를 가리키는 객체로 여러 개의 Step을 포함할 수 있다. Step들의 컨테이너 역할을 수행한다.\n* Job 객체를 만드는 빌더 클래스는 여러 개 있으며, 여러 빌더를 통합한 JobBuilderFactory를 통하여 원하는 Job을 쉽게 생성할 수 있음.\n```java\n@Bean\npublic Job footballJob() {\n\treturn this.jobBuilderFactory.get(\"footballJob\")\n\t\t\t\t.start(playerLoad())\n\t\t\t\t.next(gameLoad())\n\t\t\t\t.next(playerSummarization())\n\t\t\t\t.end()\n\t\t\t\t.build();\n}\n```\n* JobBuilderFactory.get()을 호출하게 되면, 새로운 JobBuilder 인스턴스를 반환함. JobBuilder를 생성하는 과정에서 JobRepository를 주입받게 되는데, JobBuilderFactory에서 생성되는 모든 JobBuilder가 동일한 JobRepository를 사용하게 된다.\n* **JobBuilerFactory에서 JobBuilder를 생성하며 생성한 빌더를 통하여 Job을 생성할 수 있다.**\n* **JobBuilder는 직접 Job을 생성하는 것이 아니라, 별도의 구체적인 JobBuilder를 통하여 Job을 생성하게 된다.** Job을 생성할 수 있는 여러 상황을 고려하여 이렇게 구현되어 있는듯 보이며, 매소드 체이닝을 통하여 원하는 내용을 명시하면 쉽게 처리 할 수 있다.\n\n```java\n@Autowired\nprivate JobBuilderFactory jobBuilderFactory;\n\n@Bean\npublic Job simpleJob() {\n\t\t// 1. simpleJob 이라는 이름을 가진 Job을 생성할 수 있는 JobBuilder 인스턴스 반환\n\treturn jobBuilderFactory.get(\"simpleJob\")\n\t\t// 2. Step을 주입, Step혹은 Flow를 파라메터로 받아서 구체적인 빌더를 생성할 수 있다.\n\t\t.start(simpleStep())\n\t\t// 3. build()를 호출하여 \"simpleJob\"의 이름을 가지는 Job을 생성\n\t\t.build();\n}\n```\n\n#### 1.1 JobInstance\n* 하나의 Job의 실행 단위, JobExecution을 여러개 가질 수 있음\n\n#### 1.2 JobExecution\n* JobInstance에 대한 한 번 실행을 나타내는 객체. Job 실행에 대한 정보를 담고 있는 도메인 객체로 JobInstance, 실행 상태, 시작 시간, 종료 시간, 실패 메세지 등 정보를 담고 있음.\n\n#### 1.3 JobParameter\n![](https://docs.spring.io/spring-batch/4.1.x/reference/html/images/job-stereotypes-parameters.png)\n* Job이 실행될 떄 필요한 인자를 Map 타입으로 저장하는 객체. JobInstance와 1:1 관계이며, 사용 할 수 있는 데이터 타입은 Long, String, Date, Double 등이 있다.\n* JobInstance를 구분하는 기준으로 사용될 수 있다.\n  * `JobInstance = Job + identifying JobParameters`\n\n\n\n### 2. Step\n* 실질적인 Job 처리를 담당. 필요한 정보를 담고 있는 도메인 객체이며 모든 Job은 여러 개의 Step을 가질 수 있다.\n#### 2.1 StepExecution\n* Job에 JobExecution이 있듯이, Step에도 이에 대응하는 StepExecution이 존재한다. 해당 Step의 실행 정보를 담고 있다.\n\n### 3. JobRepository\n* JobRepository는 배치 처리 정보를 담고 있는 객체로, Job의 실행 횟수 및 시간 정보 등의 메타 정보를 가지고 있다. Step의 실행정보를 담고 있는 StepExecution도 가지고 있으며, 전체 메타 데이터를 가지고 있는 객체라고 생각하면 된다.\n\n### 4. JobLauncher\n* Job, JobParameter와 함께 배치를 시작하는 인터페이스로 사용. 인터페이스의 매소드는 `run()`만 존재함.\n\n### 5. ItemReader\n* Step에서 데이터를 읽어오는 역할을 수행. FILE, DB, QUEUE 등에서 데이터를 읽어 올 수 있다.\n\n### 6. ItemProcessor\n* 읽어온 데이터를 처리하는 인터페이스. Input과 Output에 대한 타입 명시가 가능\n\n### 7. ItemWriter\n* 이전 단계에서 처리한 데이터를 저장하는 인터페이스. List 인터페이스를 통하여 지정한 타입의 데이터를 받아오며 CHUNK 단위로 데이터를 받아온다.\n\n## 참고자료\n* [처음 배우는 스프링 부트 2](https://book.naver.com/bookdb/book_detail.nhn?bid=14031681)\n* [Spring Batch - Reference Documentation](https://docs.spring.io/spring-batch/4.1.x/reference/html/index.html)\n\n","slug":"Spring/BATCH_1","published":1,"updated":"2021-08-02T12:08:00.885Z","_id":"ckrsup50v001rtjhv8o3yhepq","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"스프링-부트-배치-1-개요-주요개념\"><a href=\"#스프링-부트-배치-1-개요-주요개념\" class=\"headerlink\" title=\"스프링 부트 배치 #1 - 개요/주요개념\"></a>스프링 부트 배치 #1 - 개요/주요개념</h1><h2 id=\"개요\"><a href=\"#개요\" class=\"headerlink\" title=\"개요\"></a>개요</h2><ul>\n<li>백엔드의 배치 처리 기능을 구현하는 데 사용하는 프레임워크.</li>\n<li>부트 배치의 경우, 스프링 배치의 설정 요소들을 간편화시켜 스프링 배치를 빠르고 쉽게 사용할 수 있도록 구성.<ul>\n<li>배치란, 순차적으로 자료를 처리한다는 뜻으로 일괄 처리와 같은 뜻</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Why-Spring-Batch\"><a href=\"#Why-Spring-Batch\" class=\"headerlink\" title=\"Why Spring Batch?\"></a>Why Spring Batch?</h2><ul>\n<li>대용량 처리 최적화되어 있고, 고성능을 발휘</li>\n<li>로깅. 통계 처리, 트랜잭션 관리 등 필수 기능 지원</li>\n<li>예외 및 비정상 동작에 대한 방어 기능</li>\n<li>개발자는 Spring Batch 프로그래밍 모델을 사용하여 비즈니스 로직에 집중하고 프레임워크가 인프라를 관리하도록 함.</li>\n</ul>\n<h2 id=\"주의사항\"><a href=\"#주의사항\" class=\"headerlink\" title=\"주의사항\"></a>주의사항</h2><ul>\n<li>복잡한 구조와 로직을 피해야 함</li>\n<li>데이터를 직접 다루는 코드가 많으므로, 무결성을 유지할 수 있는 방어적인 방법을 사용해야 함.</li>\n<li>I/O 사용을 최소화 해야 한다. 잦은 I/O 발생은 배치 어플리케이션 성능에 영향을 줄 수 있기 때문이다.<ul>\n<li>Minimize system resource use, especially I/O. Perform as many operations as possible in internal memory.</li>\n</ul>\n</li>\n<li>스프링 부트 배치는 별도의 스캐줄링 기능을 제공하지 않는다. 이에 따라, 별도의 스케줄링 구현체를 사용해야 한다.<ul>\n<li>쿼츠, 스프링 스캐줄러 등을 사용해야 함.</li>\n</ul>\n</li>\n<li>실제 환경과 비슷한 데이터 볼륨을 가지고 테스트를 함으로써, 처리 안정성을 높히는 것이 좋다.</li>\n</ul>\n<h2 id=\"배치-처리-절차\"><a href=\"#배치-처리-절차\" class=\"headerlink\" title=\"배치 처리 절차\"></a>배치 처리 절차</h2><ul>\n<li>읽기: 데이터베이스, 파일 등에서 데이터를 읽는다. <ul>\n<li>Reads a large number of records from a database, file, or queue.</li>\n</ul>\n</li>\n<li>처리: 읽은 데이터를 처리/가공<ul>\n<li>Processes the data in some fashion.</li>\n</ul>\n</li>\n<li>쓰기: 처리/가공한 데이터를 별도의 저장소에 저장<ul>\n<li>Writes back data in a modified form.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://docs.spring.io/spring-batch/4.1.x/reference/html/images/spring-batch-reference-model.png\"></p>\n<ul>\n<li>Job과 Step은 1:N의 관계로, 하나의 Job에 여러 개의 Step으로 처리하는 프로세스를 가진다. 각각 Step은 ItemReader, ItemProcessor, ItemWriter를 가지고 있으며, Step과는 1:1 관계를 가진다.</li>\n</ul>\n<h3 id=\"1-Job\"><a href=\"#1-Job\" class=\"headerlink\" title=\"1. Job\"></a>1. Job</h3><ul>\n<li>처리 과정 하나를 가리키는 객체로 여러 개의 Step을 포함할 수 있다. Step들의 컨테이너 역할을 수행한다.</li>\n<li>Job 객체를 만드는 빌더 클래스는 여러 개 있으며, 여러 빌더를 통합한 JobBuilderFactory를 통하여 원하는 Job을 쉽게 생성할 수 있음.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Job <span class=\"title\">footballJob</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.jobBuilderFactory.get(<span class=\"string\">&quot;footballJob&quot;</span>)</span><br><span class=\"line\">\t\t\t\t.start(playerLoad())</span><br><span class=\"line\">\t\t\t\t.next(gameLoad())</span><br><span class=\"line\">\t\t\t\t.next(playerSummarization())</span><br><span class=\"line\">\t\t\t\t.end()</span><br><span class=\"line\">\t\t\t\t.build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>JobBuilderFactory.get()을 호출하게 되면, 새로운 JobBuilder 인스턴스를 반환함. JobBuilder를 생성하는 과정에서 JobRepository를 주입받게 되는데, JobBuilderFactory에서 생성되는 모든 JobBuilder가 동일한 JobRepository를 사용하게 된다.</li>\n<li><strong>JobBuilerFactory에서 JobBuilder를 생성하며 생성한 빌더를 통하여 Job을 생성할 수 있다.</strong></li>\n<li><strong>JobBuilder는 직접 Job을 생성하는 것이 아니라, 별도의 구체적인 JobBuilder를 통하여 Job을 생성하게 된다.</strong> Job을 생성할 수 있는 여러 상황을 고려하여 이렇게 구현되어 있는듯 보이며, 매소드 체이닝을 통하여 원하는 내용을 명시하면 쉽게 처리 할 수 있다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> JobBuilderFactory jobBuilderFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Job <span class=\"title\">simpleJob</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 1. simpleJob 이라는 이름을 가진 Job을 생성할 수 있는 JobBuilder 인스턴스 반환</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> jobBuilderFactory.get(<span class=\"string\">&quot;simpleJob&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 2. Step을 주입, Step혹은 Flow를 파라메터로 받아서 구체적인 빌더를 생성할 수 있다.</span></span><br><span class=\"line\">\t\t.start(simpleStep())</span><br><span class=\"line\">\t\t<span class=\"comment\">// 3. build()를 호출하여 &quot;simpleJob&quot;의 이름을 가지는 Job을 생성</span></span><br><span class=\"line\">\t\t.build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-1-JobInstance\"><a href=\"#1-1-JobInstance\" class=\"headerlink\" title=\"1.1 JobInstance\"></a>1.1 JobInstance</h4><ul>\n<li>하나의 Job의 실행 단위, JobExecution을 여러개 가질 수 있음</li>\n</ul>\n<h4 id=\"1-2-JobExecution\"><a href=\"#1-2-JobExecution\" class=\"headerlink\" title=\"1.2 JobExecution\"></a>1.2 JobExecution</h4><ul>\n<li>JobInstance에 대한 한 번 실행을 나타내는 객체. Job 실행에 대한 정보를 담고 있는 도메인 객체로 JobInstance, 실행 상태, 시작 시간, 종료 시간, 실패 메세지 등 정보를 담고 있음.</li>\n</ul>\n<h4 id=\"1-3-JobParameter\"><a href=\"#1-3-JobParameter\" class=\"headerlink\" title=\"1.3 JobParameter\"></a>1.3 JobParameter</h4><p><img src=\"https://docs.spring.io/spring-batch/4.1.x/reference/html/images/job-stereotypes-parameters.png\"></p>\n<ul>\n<li>Job이 실행될 떄 필요한 인자를 Map 타입으로 저장하는 객체. JobInstance와 1:1 관계이며, 사용 할 수 있는 데이터 타입은 Long, String, Date, Double 등이 있다.</li>\n<li>JobInstance를 구분하는 기준으로 사용될 수 있다.<ul>\n<li><code>JobInstance = Job + identifying JobParameters</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-Step\"><a href=\"#2-Step\" class=\"headerlink\" title=\"2. Step\"></a>2. Step</h3><ul>\n<li>실질적인 Job 처리를 담당. 필요한 정보를 담고 있는 도메인 객체이며 모든 Job은 여러 개의 Step을 가질 수 있다.<h4 id=\"2-1-StepExecution\"><a href=\"#2-1-StepExecution\" class=\"headerlink\" title=\"2.1 StepExecution\"></a>2.1 StepExecution</h4></li>\n<li>Job에 JobExecution이 있듯이, Step에도 이에 대응하는 StepExecution이 존재한다. 해당 Step의 실행 정보를 담고 있다.</li>\n</ul>\n<h3 id=\"3-JobRepository\"><a href=\"#3-JobRepository\" class=\"headerlink\" title=\"3. JobRepository\"></a>3. JobRepository</h3><ul>\n<li>JobRepository는 배치 처리 정보를 담고 있는 객체로, Job의 실행 횟수 및 시간 정보 등의 메타 정보를 가지고 있다. Step의 실행정보를 담고 있는 StepExecution도 가지고 있으며, 전체 메타 데이터를 가지고 있는 객체라고 생각하면 된다.</li>\n</ul>\n<h3 id=\"4-JobLauncher\"><a href=\"#4-JobLauncher\" class=\"headerlink\" title=\"4. JobLauncher\"></a>4. JobLauncher</h3><ul>\n<li>Job, JobParameter와 함께 배치를 시작하는 인터페이스로 사용. 인터페이스의 매소드는 <code>run()</code>만 존재함.</li>\n</ul>\n<h3 id=\"5-ItemReader\"><a href=\"#5-ItemReader\" class=\"headerlink\" title=\"5. ItemReader\"></a>5. ItemReader</h3><ul>\n<li>Step에서 데이터를 읽어오는 역할을 수행. FILE, DB, QUEUE 등에서 데이터를 읽어 올 수 있다.</li>\n</ul>\n<h3 id=\"6-ItemProcessor\"><a href=\"#6-ItemProcessor\" class=\"headerlink\" title=\"6. ItemProcessor\"></a>6. ItemProcessor</h3><ul>\n<li>읽어온 데이터를 처리하는 인터페이스. Input과 Output에 대한 타입 명시가 가능</li>\n</ul>\n<h3 id=\"7-ItemWriter\"><a href=\"#7-ItemWriter\" class=\"headerlink\" title=\"7. ItemWriter\"></a>7. ItemWriter</h3><ul>\n<li>이전 단계에서 처리한 데이터를 저장하는 인터페이스. List 인터페이스를 통하여 지정한 타입의 데이터를 받아오며 CHUNK 단위로 데이터를 받아온다.</li>\n</ul>\n<h2 id=\"참고자료\"><a href=\"#참고자료\" class=\"headerlink\" title=\"참고자료\"></a>참고자료</h2><ul>\n<li><a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=14031681\">처음 배우는 스프링 부트 2</a></li>\n<li><a href=\"https://docs.spring.io/spring-batch/4.1.x/reference/html/index.html\">Spring Batch - Reference Documentation</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"스프링-부트-배치-1-개요-주요개념\"><a href=\"#스프링-부트-배치-1-개요-주요개념\" class=\"headerlink\" title=\"스프링 부트 배치 #1 - 개요/주요개념\"></a>스프링 부트 배치 #1 - 개요/주요개념</h1><h2 id=\"개요\"><a href=\"#개요\" class=\"headerlink\" title=\"개요\"></a>개요</h2><ul>\n<li>백엔드의 배치 처리 기능을 구현하는 데 사용하는 프레임워크.</li>\n<li>부트 배치의 경우, 스프링 배치의 설정 요소들을 간편화시켜 스프링 배치를 빠르고 쉽게 사용할 수 있도록 구성.<ul>\n<li>배치란, 순차적으로 자료를 처리한다는 뜻으로 일괄 처리와 같은 뜻</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Why-Spring-Batch\"><a href=\"#Why-Spring-Batch\" class=\"headerlink\" title=\"Why Spring Batch?\"></a>Why Spring Batch?</h2><ul>\n<li>대용량 처리 최적화되어 있고, 고성능을 발휘</li>\n<li>로깅. 통계 처리, 트랜잭션 관리 등 필수 기능 지원</li>\n<li>예외 및 비정상 동작에 대한 방어 기능</li>\n<li>개발자는 Spring Batch 프로그래밍 모델을 사용하여 비즈니스 로직에 집중하고 프레임워크가 인프라를 관리하도록 함.</li>\n</ul>\n<h2 id=\"주의사항\"><a href=\"#주의사항\" class=\"headerlink\" title=\"주의사항\"></a>주의사항</h2><ul>\n<li>복잡한 구조와 로직을 피해야 함</li>\n<li>데이터를 직접 다루는 코드가 많으므로, 무결성을 유지할 수 있는 방어적인 방법을 사용해야 함.</li>\n<li>I/O 사용을 최소화 해야 한다. 잦은 I/O 발생은 배치 어플리케이션 성능에 영향을 줄 수 있기 때문이다.<ul>\n<li>Minimize system resource use, especially I/O. Perform as many operations as possible in internal memory.</li>\n</ul>\n</li>\n<li>스프링 부트 배치는 별도의 스캐줄링 기능을 제공하지 않는다. 이에 따라, 별도의 스케줄링 구현체를 사용해야 한다.<ul>\n<li>쿼츠, 스프링 스캐줄러 등을 사용해야 함.</li>\n</ul>\n</li>\n<li>실제 환경과 비슷한 데이터 볼륨을 가지고 테스트를 함으로써, 처리 안정성을 높히는 것이 좋다.</li>\n</ul>\n<h2 id=\"배치-처리-절차\"><a href=\"#배치-처리-절차\" class=\"headerlink\" title=\"배치 처리 절차\"></a>배치 처리 절차</h2><ul>\n<li>읽기: 데이터베이스, 파일 등에서 데이터를 읽는다. <ul>\n<li>Reads a large number of records from a database, file, or queue.</li>\n</ul>\n</li>\n<li>처리: 읽은 데이터를 처리/가공<ul>\n<li>Processes the data in some fashion.</li>\n</ul>\n</li>\n<li>쓰기: 처리/가공한 데이터를 별도의 저장소에 저장<ul>\n<li>Writes back data in a modified form.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://docs.spring.io/spring-batch/4.1.x/reference/html/images/spring-batch-reference-model.png\"></p>\n<ul>\n<li>Job과 Step은 1:N의 관계로, 하나의 Job에 여러 개의 Step으로 처리하는 프로세스를 가진다. 각각 Step은 ItemReader, ItemProcessor, ItemWriter를 가지고 있으며, Step과는 1:1 관계를 가진다.</li>\n</ul>\n<h3 id=\"1-Job\"><a href=\"#1-Job\" class=\"headerlink\" title=\"1. Job\"></a>1. Job</h3><ul>\n<li>처리 과정 하나를 가리키는 객체로 여러 개의 Step을 포함할 수 있다. Step들의 컨테이너 역할을 수행한다.</li>\n<li>Job 객체를 만드는 빌더 클래스는 여러 개 있으며, 여러 빌더를 통합한 JobBuilderFactory를 통하여 원하는 Job을 쉽게 생성할 수 있음.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Job <span class=\"title\">footballJob</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.jobBuilderFactory.get(<span class=\"string\">&quot;footballJob&quot;</span>)</span><br><span class=\"line\">\t\t\t\t.start(playerLoad())</span><br><span class=\"line\">\t\t\t\t.next(gameLoad())</span><br><span class=\"line\">\t\t\t\t.next(playerSummarization())</span><br><span class=\"line\">\t\t\t\t.end()</span><br><span class=\"line\">\t\t\t\t.build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>JobBuilderFactory.get()을 호출하게 되면, 새로운 JobBuilder 인스턴스를 반환함. JobBuilder를 생성하는 과정에서 JobRepository를 주입받게 되는데, JobBuilderFactory에서 생성되는 모든 JobBuilder가 동일한 JobRepository를 사용하게 된다.</li>\n<li><strong>JobBuilerFactory에서 JobBuilder를 생성하며 생성한 빌더를 통하여 Job을 생성할 수 있다.</strong></li>\n<li><strong>JobBuilder는 직접 Job을 생성하는 것이 아니라, 별도의 구체적인 JobBuilder를 통하여 Job을 생성하게 된다.</strong> Job을 생성할 수 있는 여러 상황을 고려하여 이렇게 구현되어 있는듯 보이며, 매소드 체이닝을 통하여 원하는 내용을 명시하면 쉽게 처리 할 수 있다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> JobBuilderFactory jobBuilderFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Job <span class=\"title\">simpleJob</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 1. simpleJob 이라는 이름을 가진 Job을 생성할 수 있는 JobBuilder 인스턴스 반환</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> jobBuilderFactory.get(<span class=\"string\">&quot;simpleJob&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 2. Step을 주입, Step혹은 Flow를 파라메터로 받아서 구체적인 빌더를 생성할 수 있다.</span></span><br><span class=\"line\">\t\t.start(simpleStep())</span><br><span class=\"line\">\t\t<span class=\"comment\">// 3. build()를 호출하여 &quot;simpleJob&quot;의 이름을 가지는 Job을 생성</span></span><br><span class=\"line\">\t\t.build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-1-JobInstance\"><a href=\"#1-1-JobInstance\" class=\"headerlink\" title=\"1.1 JobInstance\"></a>1.1 JobInstance</h4><ul>\n<li>하나의 Job의 실행 단위, JobExecution을 여러개 가질 수 있음</li>\n</ul>\n<h4 id=\"1-2-JobExecution\"><a href=\"#1-2-JobExecution\" class=\"headerlink\" title=\"1.2 JobExecution\"></a>1.2 JobExecution</h4><ul>\n<li>JobInstance에 대한 한 번 실행을 나타내는 객체. Job 실행에 대한 정보를 담고 있는 도메인 객체로 JobInstance, 실행 상태, 시작 시간, 종료 시간, 실패 메세지 등 정보를 담고 있음.</li>\n</ul>\n<h4 id=\"1-3-JobParameter\"><a href=\"#1-3-JobParameter\" class=\"headerlink\" title=\"1.3 JobParameter\"></a>1.3 JobParameter</h4><p><img src=\"https://docs.spring.io/spring-batch/4.1.x/reference/html/images/job-stereotypes-parameters.png\"></p>\n<ul>\n<li>Job이 실행될 떄 필요한 인자를 Map 타입으로 저장하는 객체. JobInstance와 1:1 관계이며, 사용 할 수 있는 데이터 타입은 Long, String, Date, Double 등이 있다.</li>\n<li>JobInstance를 구분하는 기준으로 사용될 수 있다.<ul>\n<li><code>JobInstance = Job + identifying JobParameters</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-Step\"><a href=\"#2-Step\" class=\"headerlink\" title=\"2. Step\"></a>2. Step</h3><ul>\n<li>실질적인 Job 처리를 담당. 필요한 정보를 담고 있는 도메인 객체이며 모든 Job은 여러 개의 Step을 가질 수 있다.<h4 id=\"2-1-StepExecution\"><a href=\"#2-1-StepExecution\" class=\"headerlink\" title=\"2.1 StepExecution\"></a>2.1 StepExecution</h4></li>\n<li>Job에 JobExecution이 있듯이, Step에도 이에 대응하는 StepExecution이 존재한다. 해당 Step의 실행 정보를 담고 있다.</li>\n</ul>\n<h3 id=\"3-JobRepository\"><a href=\"#3-JobRepository\" class=\"headerlink\" title=\"3. JobRepository\"></a>3. JobRepository</h3><ul>\n<li>JobRepository는 배치 처리 정보를 담고 있는 객체로, Job의 실행 횟수 및 시간 정보 등의 메타 정보를 가지고 있다. Step의 실행정보를 담고 있는 StepExecution도 가지고 있으며, 전체 메타 데이터를 가지고 있는 객체라고 생각하면 된다.</li>\n</ul>\n<h3 id=\"4-JobLauncher\"><a href=\"#4-JobLauncher\" class=\"headerlink\" title=\"4. JobLauncher\"></a>4. JobLauncher</h3><ul>\n<li>Job, JobParameter와 함께 배치를 시작하는 인터페이스로 사용. 인터페이스의 매소드는 <code>run()</code>만 존재함.</li>\n</ul>\n<h3 id=\"5-ItemReader\"><a href=\"#5-ItemReader\" class=\"headerlink\" title=\"5. ItemReader\"></a>5. ItemReader</h3><ul>\n<li>Step에서 데이터를 읽어오는 역할을 수행. FILE, DB, QUEUE 등에서 데이터를 읽어 올 수 있다.</li>\n</ul>\n<h3 id=\"6-ItemProcessor\"><a href=\"#6-ItemProcessor\" class=\"headerlink\" title=\"6. ItemProcessor\"></a>6. ItemProcessor</h3><ul>\n<li>읽어온 데이터를 처리하는 인터페이스. Input과 Output에 대한 타입 명시가 가능</li>\n</ul>\n<h3 id=\"7-ItemWriter\"><a href=\"#7-ItemWriter\" class=\"headerlink\" title=\"7. ItemWriter\"></a>7. ItemWriter</h3><ul>\n<li>이전 단계에서 처리한 데이터를 저장하는 인터페이스. List 인터페이스를 통하여 지정한 타입의 데이터를 받아오며 CHUNK 단위로 데이터를 받아온다.</li>\n</ul>\n<h2 id=\"참고자료\"><a href=\"#참고자료\" class=\"headerlink\" title=\"참고자료\"></a>참고자료</h2><ul>\n<li><a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=14031681\">처음 배우는 스프링 부트 2</a></li>\n<li><a href=\"https://docs.spring.io/spring-batch/4.1.x/reference/html/index.html\">Spring Batch - Reference Documentation</a></li>\n</ul>\n"},{"title":"스프링 부트 배치 #3","date":"2019-01-03T15:27:00.000Z","_content":"\n# 스프링 부트 배치 #3\n\n## Chunk-Oriented-Processing\n* 트랜잭션 경계 내에서 청크 단위로 데이터를 읽고 생성하는 기법. \n* **읽은 데이터 수 == 청크 단위 수 => 쓰기 수행 및 트랜잭션 커밋**\n* Spring Batch는 가장 일반적인 구현 내에서 `Chunk Oriented Processing` 스타일을 사용\n![](https://docs.spring.io/spring-batch/trunk/reference/html/images/chunk-oriented-processing.png)\n\n    > 대량의 데이터에 대해 배치 로직이 실행된다고 했을 때, 청크 단위로 나누지 않고 실행하면 1개만 실패해도 나머지 처리건이 롤백되는데, \n    > 이를 청크 단위로 나눠서 처리하면, 실패한 배치 처리건이 존재해도 나머지 청크에 영향을 주지 않음\n\n* 하나의 Step에서 ItemReader -> ItemProcessor -> ItemWriter의 순서대로 처리하는 방식도 존재하지만, \n**스프링 배치에서는 `TaskletStep` 처리 시나리오도 제공하고 있다.**\n\n## Tasklet\n* `Chunk Oriented Processing` 전체 로직을 다루는 것을 `Tasklet`이라 생각하면 쉽다.\n* `Tasklet`은 `RepeatStatus.FINISHED`를 반환하거나 예외를 throw 할 때까지 `TaskletStep`에 의해 반복적으로 호출\n* `Tasklet` 인터페이스는 `execute` 매소드 하나만 존재하며 작업 끝나면 `RepeatStatus.FINISHED`를 반환하며, 작업이 계속되면 `RepeatStatus.CONTINUABLE`을 반환한다.\n    ```java\n    public interface Tasklet {\n        RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception;\n    }\n\n    ```\n    ```java\n    @Component\n    @AllArgsConstructor\n    public class InactiveItemTasklet implements Tasklet {\n\n        private UserRepository userRepository;\n\n\n        @Override\n        public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n            Date date = (Date) chunkContext.getStepContext().getJobParameters().get(\"nowDate\");\n            LocalDateTime now = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());\n            List<User> inactiveUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(\n                now.minusYears(1), UserStatus.ACTIVE\n            ).stream().map(User::setInactive).collect(Collectors.toList());\n            userRepository.saveAll(inactiveUsers);\n            return RepeatStatus.FINISHED;\n        }\n    }\n    ```\n* 파일 처리 Tasklet 예제\n    ```java\n    @Bean\n    public Job taskletJob() {\n            return this.jobBuilderFactory.get(\"taskletJob\")\n                                    .start(deleteFilesInDir())\n                                    .build();\n    }\n\n    @Bean\n    public Step deleteFilesInDir() {\n            return this.stepBuilderFactory.get(\"deleteFilesInDir\")\n                                    .tasklet(fileDeletingTasklet())\n                                    .build();\n    }\n\n    @Bean\n    public FileDeletingTasklet fileDeletingTasklet() {\n            FileDeletingTasklet tasklet = new FileDeletingTasklet();\n            tasklet.setDirectoryResource(new FileSystemResource(\"target/test-outputs/test-dir\"));\n            return tasklet;\n    }\n    ```\n\n\n## Listner\n* 배치 처리 흐름에서 전후처리에 해당하는 구간에 Listener를 설정 할 수 있다.\n* Job의 전후, Step의 전후, 각 청크 단위에서의 전후 등 세세한 과정 실행 시 특정 로직을 할당 할 수 있다.\n* 인터페이스 구현하는 방법과 어노테이션을 할당하여 구현하는 방법이 있다.\n\n| 인터페이스               | 어노테이션                                               | 설명  |\n|-----------------------|-------------------------------------------------------|------|\n| JobExecutionListener  | `@BeforeJob`, `@AfterJob`                             | Job 실행 전후 처리        |\n| ChunkListener         | `@BeforeChunk`,`@AfterChunk`, `@AfterChunkError`      | Chunk 실행 전후, 에러 처리 |\n| ItemReadListener      | `@BeforeRead`, `@AfterRead`, `@OnReadError`           | Read 실행 전후, 에러 처리  |\n| ItemProcessListener   | `@BeforeProcess`, `@AfterProcess`, `@OnProcessError`  | Process 실행 전후, 에러 처리     |\n| ItemWriteListener     | `@BeforeWrite`, `@AfterWrite`, `@OnWriteError`        | Write 실행 전후, 에러 처리     |\n| StepExecutionListener | `@BeforeStep`, `@AfterStep`                           | Step 실행 전후 처리     |\n| SkipListener          | `@OnSkipInRead`, `@OnSkipInWrite`, `@OnSkipInProcess` | Skip 발생 시 처리     |\n\n```java\n// 1. Interace 구현\n@Component\npublic class InactiveJobListener implements JobExecutionListener {\n    @Override\n    public void beforeJob(JobExecution jobExecution) {\n        log.info(\"Before JOB\");\n    }\n\n    @Override\n    public void afterJob(JobExecution jobExecution) {\n        log.info(\"After JOB\");\n    }\n}\n\n\n// 2. Annotation 구현\n@Component\npublic class StepListener {\n\n    @BeforeStep\n    public void beforeStep(StepExecution stepExecution) {\n        log.info(\"Before Step\");\n    }\n\n    @AfterStep\n    public void afterStep(StepExecution stepExecution) {\n        log.info(\"After Step\");\n    }\n\n}\n```\n\n## Flow, 흐름제어\n`Job` 실행에서 `Step`의 실패가 반드시 `Job`이 실패해야 한다는 것을 의미하지 않는다. 또한, 다음 `Step`에서 어떤 단계가 실행되어야 하는지를 흐름 제어가 필요한 상황도 충분히 생길 수 있다. 스프링 배치에서는 이러한 순차 처리 케이스와 조건 처리 케이스에 대해 구현체를 제공하고 있다.\n\n### Sequential Flow\n![](https://docs.spring.io/spring-batch/4.1.x/reference/html/images/sequential-flow.png)\n* `Step`들을 처리하는 가장 일반적인 시나리오로 모든 `Step`들이 연속적으로 실행되는 Flow.\n* 다시 말해, `Step A`가 완벽하게 수행되면 `Step B`가 실행되고 그 이후에 `Step C`까지 실행되는 구조이다. 만약 `Step A`가 실패하게 될 경우 이후 `Step`들은 실행되지 않으므로 해당 `Job`은 실패하게 된다. 위와 같은 플로우를 실행하는 `Job`은 아래와 같이 생성하면 된다.\n    ```java\n    @Bean\n    public Job job() {\n            return this.jobBuilderFactory.get(\"job\")\n                                    .start(stepA())\n                                    .next(stepB())\n                                    .next(stepC())\n                                    .build();\n    }\n    ```\n\n### Conditional Flow\n![](http://www.egovframe.go.kr/wiki/lib/exe/fetch.php?media=egovframework:rte2:brte:batch_core:conditional-flow.png)\n* 대부분의 경우, Sequential Flow를 통하여 해결이 되겠지만, 흐름 제어가 필요한 상황이 있을 수 있다. 예를 들어, `Step A`의 성공 유무를 체크하여 분기가 필요하다면 아래 코드이 `Job` 설정이 가능하다.\n    ```java\n    @Bean\n    public Job job() {\n            return this.jobBuilderFactory.get(\"job\")\n                                    .start(stepA())\n                                    .on(\"*\").to(stepB())\n                                    .from(stepA()).on(\"FAILED\").to(stepC())\n                                    .end()\n                                    .build();\n    }\n    ```\n* `on` 메소드는 간단한 패턴 일치를 사용하여 Step의 실행결과 `ExitStatus`를 일치시킴\n  * `*`은 0 개 이상의 문자와 일치.\n  * `?`은 정확히 한 문자 일치\n  > 예를 들어, \"c*t\"은 \"cat\" 및 \"count\"에 매칭 될 수 있다. 반면에, \"c?t\"은 \"cat\"에 매칭될 수 있지만, \"count\"에는 매칭 될 수 없다.\n\n\n* `ExitStatus`와 `BatchStatus`의 값을 구분하는 것이 중요\n\n    #### ExitStatus\n    ```java\n    .from(stepA()).on(\"FAILED\").to(stepB())\n    ```\n    위와 같은 Job코드가 있다고 가정할 때, 여기에서 표현하는 상태 값은 `Step`에서의 ExitStatus의 FAILED 상태 값을 나타낸다. 다시 말해, `Step`의 처리 상태를 표현하며, 상태값은 `UNKNOWN`, `EXECUTING`, `COMPLETED`, `NOOP`, `FAILED`, `STOPPED`이 존재한다. \n\n    #### BatchStatus\n    `JobExecution`와 `StepExecution` 양쪽에서 사용하는 열거형 값으로 프레임워크에서 `Job`과 `Step`의 상태를 기록하는 용도로 사용한다. 상태 값으로는 COMPLETED, STARTING, STARTED, STOPPING, STOPPED, FAILED, ABANDONED, or UNKNOWN이 존재한다.\n\n\n* 만약, ExitStatus의 값이 FAILED라고 하면, Job의 BatchStatus값 역시 FAILED로 처리된다. 이밖의 경우는 BatchStatus와 ExitStatus 모두 COMPLETE 상태로 처리된다.","source":"_posts/Spring/BATCH_3.md","raw":"---\ntitle: '스프링 부트 배치 #3'\ndate: 2019.1.4. 00:27\ncategories:\n- Spring\n---\n\n# 스프링 부트 배치 #3\n\n## Chunk-Oriented-Processing\n* 트랜잭션 경계 내에서 청크 단위로 데이터를 읽고 생성하는 기법. \n* **읽은 데이터 수 == 청크 단위 수 => 쓰기 수행 및 트랜잭션 커밋**\n* Spring Batch는 가장 일반적인 구현 내에서 `Chunk Oriented Processing` 스타일을 사용\n![](https://docs.spring.io/spring-batch/trunk/reference/html/images/chunk-oriented-processing.png)\n\n    > 대량의 데이터에 대해 배치 로직이 실행된다고 했을 때, 청크 단위로 나누지 않고 실행하면 1개만 실패해도 나머지 처리건이 롤백되는데, \n    > 이를 청크 단위로 나눠서 처리하면, 실패한 배치 처리건이 존재해도 나머지 청크에 영향을 주지 않음\n\n* 하나의 Step에서 ItemReader -> ItemProcessor -> ItemWriter의 순서대로 처리하는 방식도 존재하지만, \n**스프링 배치에서는 `TaskletStep` 처리 시나리오도 제공하고 있다.**\n\n## Tasklet\n* `Chunk Oriented Processing` 전체 로직을 다루는 것을 `Tasklet`이라 생각하면 쉽다.\n* `Tasklet`은 `RepeatStatus.FINISHED`를 반환하거나 예외를 throw 할 때까지 `TaskletStep`에 의해 반복적으로 호출\n* `Tasklet` 인터페이스는 `execute` 매소드 하나만 존재하며 작업 끝나면 `RepeatStatus.FINISHED`를 반환하며, 작업이 계속되면 `RepeatStatus.CONTINUABLE`을 반환한다.\n    ```java\n    public interface Tasklet {\n        RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception;\n    }\n\n    ```\n    ```java\n    @Component\n    @AllArgsConstructor\n    public class InactiveItemTasklet implements Tasklet {\n\n        private UserRepository userRepository;\n\n\n        @Override\n        public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n            Date date = (Date) chunkContext.getStepContext().getJobParameters().get(\"nowDate\");\n            LocalDateTime now = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());\n            List<User> inactiveUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(\n                now.minusYears(1), UserStatus.ACTIVE\n            ).stream().map(User::setInactive).collect(Collectors.toList());\n            userRepository.saveAll(inactiveUsers);\n            return RepeatStatus.FINISHED;\n        }\n    }\n    ```\n* 파일 처리 Tasklet 예제\n    ```java\n    @Bean\n    public Job taskletJob() {\n            return this.jobBuilderFactory.get(\"taskletJob\")\n                                    .start(deleteFilesInDir())\n                                    .build();\n    }\n\n    @Bean\n    public Step deleteFilesInDir() {\n            return this.stepBuilderFactory.get(\"deleteFilesInDir\")\n                                    .tasklet(fileDeletingTasklet())\n                                    .build();\n    }\n\n    @Bean\n    public FileDeletingTasklet fileDeletingTasklet() {\n            FileDeletingTasklet tasklet = new FileDeletingTasklet();\n            tasklet.setDirectoryResource(new FileSystemResource(\"target/test-outputs/test-dir\"));\n            return tasklet;\n    }\n    ```\n\n\n## Listner\n* 배치 처리 흐름에서 전후처리에 해당하는 구간에 Listener를 설정 할 수 있다.\n* Job의 전후, Step의 전후, 각 청크 단위에서의 전후 등 세세한 과정 실행 시 특정 로직을 할당 할 수 있다.\n* 인터페이스 구현하는 방법과 어노테이션을 할당하여 구현하는 방법이 있다.\n\n| 인터페이스               | 어노테이션                                               | 설명  |\n|-----------------------|-------------------------------------------------------|------|\n| JobExecutionListener  | `@BeforeJob`, `@AfterJob`                             | Job 실행 전후 처리        |\n| ChunkListener         | `@BeforeChunk`,`@AfterChunk`, `@AfterChunkError`      | Chunk 실행 전후, 에러 처리 |\n| ItemReadListener      | `@BeforeRead`, `@AfterRead`, `@OnReadError`           | Read 실행 전후, 에러 처리  |\n| ItemProcessListener   | `@BeforeProcess`, `@AfterProcess`, `@OnProcessError`  | Process 실행 전후, 에러 처리     |\n| ItemWriteListener     | `@BeforeWrite`, `@AfterWrite`, `@OnWriteError`        | Write 실행 전후, 에러 처리     |\n| StepExecutionListener | `@BeforeStep`, `@AfterStep`                           | Step 실행 전후 처리     |\n| SkipListener          | `@OnSkipInRead`, `@OnSkipInWrite`, `@OnSkipInProcess` | Skip 발생 시 처리     |\n\n```java\n// 1. Interace 구현\n@Component\npublic class InactiveJobListener implements JobExecutionListener {\n    @Override\n    public void beforeJob(JobExecution jobExecution) {\n        log.info(\"Before JOB\");\n    }\n\n    @Override\n    public void afterJob(JobExecution jobExecution) {\n        log.info(\"After JOB\");\n    }\n}\n\n\n// 2. Annotation 구현\n@Component\npublic class StepListener {\n\n    @BeforeStep\n    public void beforeStep(StepExecution stepExecution) {\n        log.info(\"Before Step\");\n    }\n\n    @AfterStep\n    public void afterStep(StepExecution stepExecution) {\n        log.info(\"After Step\");\n    }\n\n}\n```\n\n## Flow, 흐름제어\n`Job` 실행에서 `Step`의 실패가 반드시 `Job`이 실패해야 한다는 것을 의미하지 않는다. 또한, 다음 `Step`에서 어떤 단계가 실행되어야 하는지를 흐름 제어가 필요한 상황도 충분히 생길 수 있다. 스프링 배치에서는 이러한 순차 처리 케이스와 조건 처리 케이스에 대해 구현체를 제공하고 있다.\n\n### Sequential Flow\n![](https://docs.spring.io/spring-batch/4.1.x/reference/html/images/sequential-flow.png)\n* `Step`들을 처리하는 가장 일반적인 시나리오로 모든 `Step`들이 연속적으로 실행되는 Flow.\n* 다시 말해, `Step A`가 완벽하게 수행되면 `Step B`가 실행되고 그 이후에 `Step C`까지 실행되는 구조이다. 만약 `Step A`가 실패하게 될 경우 이후 `Step`들은 실행되지 않으므로 해당 `Job`은 실패하게 된다. 위와 같은 플로우를 실행하는 `Job`은 아래와 같이 생성하면 된다.\n    ```java\n    @Bean\n    public Job job() {\n            return this.jobBuilderFactory.get(\"job\")\n                                    .start(stepA())\n                                    .next(stepB())\n                                    .next(stepC())\n                                    .build();\n    }\n    ```\n\n### Conditional Flow\n![](http://www.egovframe.go.kr/wiki/lib/exe/fetch.php?media=egovframework:rte2:brte:batch_core:conditional-flow.png)\n* 대부분의 경우, Sequential Flow를 통하여 해결이 되겠지만, 흐름 제어가 필요한 상황이 있을 수 있다. 예를 들어, `Step A`의 성공 유무를 체크하여 분기가 필요하다면 아래 코드이 `Job` 설정이 가능하다.\n    ```java\n    @Bean\n    public Job job() {\n            return this.jobBuilderFactory.get(\"job\")\n                                    .start(stepA())\n                                    .on(\"*\").to(stepB())\n                                    .from(stepA()).on(\"FAILED\").to(stepC())\n                                    .end()\n                                    .build();\n    }\n    ```\n* `on` 메소드는 간단한 패턴 일치를 사용하여 Step의 실행결과 `ExitStatus`를 일치시킴\n  * `*`은 0 개 이상의 문자와 일치.\n  * `?`은 정확히 한 문자 일치\n  > 예를 들어, \"c*t\"은 \"cat\" 및 \"count\"에 매칭 될 수 있다. 반면에, \"c?t\"은 \"cat\"에 매칭될 수 있지만, \"count\"에는 매칭 될 수 없다.\n\n\n* `ExitStatus`와 `BatchStatus`의 값을 구분하는 것이 중요\n\n    #### ExitStatus\n    ```java\n    .from(stepA()).on(\"FAILED\").to(stepB())\n    ```\n    위와 같은 Job코드가 있다고 가정할 때, 여기에서 표현하는 상태 값은 `Step`에서의 ExitStatus의 FAILED 상태 값을 나타낸다. 다시 말해, `Step`의 처리 상태를 표현하며, 상태값은 `UNKNOWN`, `EXECUTING`, `COMPLETED`, `NOOP`, `FAILED`, `STOPPED`이 존재한다. \n\n    #### BatchStatus\n    `JobExecution`와 `StepExecution` 양쪽에서 사용하는 열거형 값으로 프레임워크에서 `Job`과 `Step`의 상태를 기록하는 용도로 사용한다. 상태 값으로는 COMPLETED, STARTING, STARTED, STOPPING, STOPPED, FAILED, ABANDONED, or UNKNOWN이 존재한다.\n\n\n* 만약, ExitStatus의 값이 FAILED라고 하면, Job의 BatchStatus값 역시 FAILED로 처리된다. 이밖의 경우는 BatchStatus와 ExitStatus 모두 COMPLETE 상태로 처리된다.","slug":"Spring/BATCH_3","published":1,"updated":"2021-08-02T12:08:13.207Z","_id":"ckrsup50w001stjhvartzd3il","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"스프링-부트-배치-3\"><a href=\"#스프링-부트-배치-3\" class=\"headerlink\" title=\"스프링 부트 배치 #3\"></a>스프링 부트 배치 #3</h1><h2 id=\"Chunk-Oriented-Processing\"><a href=\"#Chunk-Oriented-Processing\" class=\"headerlink\" title=\"Chunk-Oriented-Processing\"></a>Chunk-Oriented-Processing</h2><ul>\n<li><p>트랜잭션 경계 내에서 청크 단위로 데이터를 읽고 생성하는 기법. </p>\n</li>\n<li><p><strong>읽은 데이터 수 == 청크 단위 수 =&gt; 쓰기 수행 및 트랜잭션 커밋</strong></p>\n</li>\n<li><p>Spring Batch는 가장 일반적인 구현 내에서 <code>Chunk Oriented Processing</code> 스타일을 사용<br><img src=\"https://docs.spring.io/spring-batch/trunk/reference/html/images/chunk-oriented-processing.png\"></p>\n<blockquote>\n<p>대량의 데이터에 대해 배치 로직이 실행된다고 했을 때, 청크 단위로 나누지 않고 실행하면 1개만 실패해도 나머지 처리건이 롤백되는데,<br>이를 청크 단위로 나눠서 처리하면, 실패한 배치 처리건이 존재해도 나머지 청크에 영향을 주지 않음</p>\n</blockquote>\n</li>\n<li><p>하나의 Step에서 ItemReader -&gt; ItemProcessor -&gt; ItemWriter의 순서대로 처리하는 방식도 존재하지만, </p>\n</li>\n<li><p><em>스프링 배치에서는 <code>TaskletStep</code> 처리 시나리오도 제공하고 있다.</em>*</p>\n</li>\n</ul>\n<h2 id=\"Tasklet\"><a href=\"#Tasklet\" class=\"headerlink\" title=\"Tasklet\"></a>Tasklet</h2><ul>\n<li><code>Chunk Oriented Processing</code> 전체 로직을 다루는 것을 <code>Tasklet</code>이라 생각하면 쉽다.</li>\n<li><code>Tasklet</code>은 <code>RepeatStatus.FINISHED</code>를 반환하거나 예외를 throw 할 때까지 <code>TaskletStep</code>에 의해 반복적으로 호출</li>\n<li><code>Tasklet</code> 인터페이스는 <code>execute</code> 매소드 하나만 존재하며 작업 끝나면 <code>RepeatStatus.FINISHED</code>를 반환하며, 작업이 계속되면 <code>RepeatStatus.CONTINUABLE</code>을 반환한다.  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Tasklet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">RepeatStatus <span class=\"title\">execute</span><span class=\"params\">(StepContribution contribution, ChunkContext chunkContext)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InactiveItemTasklet</span> <span class=\"keyword\">implements</span> <span class=\"title\">Tasklet</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RepeatStatus <span class=\"title\">execute</span><span class=\"params\">(StepContribution contribution, ChunkContext chunkContext)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Date date = (Date) chunkContext.getStepContext().getJobParameters().get(<span class=\"string\">&quot;nowDate&quot;</span>);</span><br><span class=\"line\">        LocalDateTime now = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());</span><br><span class=\"line\">        List&lt;User&gt; inactiveUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(</span><br><span class=\"line\">            now.minusYears(<span class=\"number\">1</span>), UserStatus.ACTIVE</span><br><span class=\"line\">        ).stream().map(User::setInactive).collect(Collectors.toList());</span><br><span class=\"line\">        userRepository.saveAll(inactiveUsers);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RepeatStatus.FINISHED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>파일 처리 Tasklet 예제  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Job <span class=\"title\">taskletJob</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.jobBuilderFactory.get(<span class=\"string\">&quot;taskletJob&quot;</span>)</span><br><span class=\"line\">                                .start(deleteFilesInDir())</span><br><span class=\"line\">                                .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Step <span class=\"title\">deleteFilesInDir</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.stepBuilderFactory.get(<span class=\"string\">&quot;deleteFilesInDir&quot;</span>)</span><br><span class=\"line\">                                .tasklet(fileDeletingTasklet())</span><br><span class=\"line\">                                .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FileDeletingTasklet <span class=\"title\">fileDeletingTasklet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FileDeletingTasklet tasklet = <span class=\"keyword\">new</span> FileDeletingTasklet();</span><br><span class=\"line\">        tasklet.setDirectoryResource(<span class=\"keyword\">new</span> FileSystemResource(<span class=\"string\">&quot;target/test-outputs/test-dir&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tasklet;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Listner\"><a href=\"#Listner\" class=\"headerlink\" title=\"Listner\"></a>Listner</h2><ul>\n<li>배치 처리 흐름에서 전후처리에 해당하는 구간에 Listener를 설정 할 수 있다.</li>\n<li>Job의 전후, Step의 전후, 각 청크 단위에서의 전후 등 세세한 과정 실행 시 특정 로직을 할당 할 수 있다.</li>\n<li>인터페이스 구현하는 방법과 어노테이션을 할당하여 구현하는 방법이 있다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>인터페이스</th>\n<th>어노테이션</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JobExecutionListener</td>\n<td><code>@BeforeJob</code>, <code>@AfterJob</code></td>\n<td>Job 실행 전후 처리</td>\n</tr>\n<tr>\n<td>ChunkListener</td>\n<td><code>@BeforeChunk</code>,<code>@AfterChunk</code>, <code>@AfterChunkError</code></td>\n<td>Chunk 실행 전후, 에러 처리</td>\n</tr>\n<tr>\n<td>ItemReadListener</td>\n<td><code>@BeforeRead</code>, <code>@AfterRead</code>, <code>@OnReadError</code></td>\n<td>Read 실행 전후, 에러 처리</td>\n</tr>\n<tr>\n<td>ItemProcessListener</td>\n<td><code>@BeforeProcess</code>, <code>@AfterProcess</code>, <code>@OnProcessError</code></td>\n<td>Process 실행 전후, 에러 처리</td>\n</tr>\n<tr>\n<td>ItemWriteListener</td>\n<td><code>@BeforeWrite</code>, <code>@AfterWrite</code>, <code>@OnWriteError</code></td>\n<td>Write 실행 전후, 에러 처리</td>\n</tr>\n<tr>\n<td>StepExecutionListener</td>\n<td><code>@BeforeStep</code>, <code>@AfterStep</code></td>\n<td>Step 실행 전후 처리</td>\n</tr>\n<tr>\n<td>SkipListener</td>\n<td><code>@OnSkipInRead</code>, <code>@OnSkipInWrite</code>, <code>@OnSkipInProcess</code></td>\n<td>Skip 발생 시 처리</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. Interace 구현</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InactiveJobListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">JobExecutionListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">beforeJob</span><span class=\"params\">(JobExecution jobExecution)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;Before JOB&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterJob</span><span class=\"params\">(JobExecution jobExecution)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;After JOB&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. Annotation 구현</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StepListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@BeforeStep</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">beforeStep</span><span class=\"params\">(StepExecution stepExecution)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;Before Step&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterStep</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterStep</span><span class=\"params\">(StepExecution stepExecution)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;After Step&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Flow-흐름제어\"><a href=\"#Flow-흐름제어\" class=\"headerlink\" title=\"Flow, 흐름제어\"></a>Flow, 흐름제어</h2><p><code>Job</code> 실행에서 <code>Step</code>의 실패가 반드시 <code>Job</code>이 실패해야 한다는 것을 의미하지 않는다. 또한, 다음 <code>Step</code>에서 어떤 단계가 실행되어야 하는지를 흐름 제어가 필요한 상황도 충분히 생길 수 있다. 스프링 배치에서는 이러한 순차 처리 케이스와 조건 처리 케이스에 대해 구현체를 제공하고 있다.</p>\n<h3 id=\"Sequential-Flow\"><a href=\"#Sequential-Flow\" class=\"headerlink\" title=\"Sequential Flow\"></a>Sequential Flow</h3><p><img src=\"https://docs.spring.io/spring-batch/4.1.x/reference/html/images/sequential-flow.png\"></p>\n<ul>\n<li><code>Step</code>들을 처리하는 가장 일반적인 시나리오로 모든 <code>Step</code>들이 연속적으로 실행되는 Flow.</li>\n<li>다시 말해, <code>Step A</code>가 완벽하게 수행되면 <code>Step B</code>가 실행되고 그 이후에 <code>Step C</code>까지 실행되는 구조이다. 만약 <code>Step A</code>가 실패하게 될 경우 이후 <code>Step</code>들은 실행되지 않으므로 해당 <code>Job</code>은 실패하게 된다. 위와 같은 플로우를 실행하는 <code>Job</code>은 아래와 같이 생성하면 된다.  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Job <span class=\"title\">job</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.jobBuilderFactory.get(<span class=\"string\">&quot;job&quot;</span>)</span><br><span class=\"line\">                                .start(stepA())</span><br><span class=\"line\">                                .next(stepB())</span><br><span class=\"line\">                                .next(stepC())</span><br><span class=\"line\">                                .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"Conditional-Flow\"><a href=\"#Conditional-Flow\" class=\"headerlink\" title=\"Conditional Flow\"></a>Conditional Flow</h3><p><img src=\"http://www.egovframe.go.kr/wiki/lib/exe/fetch.php?media=egovframework:rte2:brte:batch_core:conditional-flow.png\"></p>\n<ul>\n<li>대부분의 경우, Sequential Flow를 통하여 해결이 되겠지만, 흐름 제어가 필요한 상황이 있을 수 있다. 예를 들어, <code>Step A</code>의 성공 유무를 체크하여 분기가 필요하다면 아래 코드이 <code>Job</code> 설정이 가능하다.  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Job <span class=\"title\">job</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.jobBuilderFactory.get(<span class=\"string\">&quot;job&quot;</span>)</span><br><span class=\"line\">                                .start(stepA())</span><br><span class=\"line\">                                .on(<span class=\"string\">&quot;*&quot;</span>).to(stepB())</span><br><span class=\"line\">                                .from(stepA()).on(<span class=\"string\">&quot;FAILED&quot;</span>).to(stepC())</span><br><span class=\"line\">                                .end()</span><br><span class=\"line\">                                .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>on</code> 메소드는 간단한 패턴 일치를 사용하여 Step의 실행결과 <code>ExitStatus</code>를 일치시킴<ul>\n<li><code>*</code>은 0 개 이상의 문자와 일치.</li>\n<li><code>?</code>은 정확히 한 문자 일치<blockquote>\n<p>예를 들어, “c*t”은 “cat” 및 “count”에 매칭 될 수 있다. 반면에, “c?t”은 “cat”에 매칭될 수 있지만, “count”에는 매칭 될 수 없다.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><code>ExitStatus</code>와 <code>BatchStatus</code>의 값을 구분하는 것이 중요</p>\n<h4 id=\"ExitStatus\"><a href=\"#ExitStatus\" class=\"headerlink\" title=\"ExitStatus\"></a>ExitStatus</h4>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.from(stepA()).on(<span class=\"string\">&quot;FAILED&quot;</span>).to(stepB())</span><br></pre></td></tr></table></figure>\n<p>  위와 같은 Job코드가 있다고 가정할 때, 여기에서 표현하는 상태 값은 <code>Step</code>에서의 ExitStatus의 FAILED 상태 값을 나타낸다. 다시 말해, <code>Step</code>의 처리 상태를 표현하며, 상태값은 <code>UNKNOWN</code>, <code>EXECUTING</code>, <code>COMPLETED</code>, <code>NOOP</code>, <code>FAILED</code>, <code>STOPPED</code>이 존재한다. </p>\n<h4 id=\"BatchStatus\"><a href=\"#BatchStatus\" class=\"headerlink\" title=\"BatchStatus\"></a>BatchStatus</h4><p>  <code>JobExecution</code>와 <code>StepExecution</code> 양쪽에서 사용하는 열거형 값으로 프레임워크에서 <code>Job</code>과 <code>Step</code>의 상태를 기록하는 용도로 사용한다. 상태 값으로는 COMPLETED, STARTING, STARTED, STOPPING, STOPPED, FAILED, ABANDONED, or UNKNOWN이 존재한다.</p>\n</li>\n</ul>\n<ul>\n<li>만약, ExitStatus의 값이 FAILED라고 하면, Job의 BatchStatus값 역시 FAILED로 처리된다. 이밖의 경우는 BatchStatus와 ExitStatus 모두 COMPLETE 상태로 처리된다.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"스프링-부트-배치-3\"><a href=\"#스프링-부트-배치-3\" class=\"headerlink\" title=\"스프링 부트 배치 #3\"></a>스프링 부트 배치 #3</h1><h2 id=\"Chunk-Oriented-Processing\"><a href=\"#Chunk-Oriented-Processing\" class=\"headerlink\" title=\"Chunk-Oriented-Processing\"></a>Chunk-Oriented-Processing</h2><ul>\n<li><p>트랜잭션 경계 내에서 청크 단위로 데이터를 읽고 생성하는 기법. </p>\n</li>\n<li><p><strong>읽은 데이터 수 == 청크 단위 수 =&gt; 쓰기 수행 및 트랜잭션 커밋</strong></p>\n</li>\n<li><p>Spring Batch는 가장 일반적인 구현 내에서 <code>Chunk Oriented Processing</code> 스타일을 사용<br><img src=\"https://docs.spring.io/spring-batch/trunk/reference/html/images/chunk-oriented-processing.png\"></p>\n<blockquote>\n<p>대량의 데이터에 대해 배치 로직이 실행된다고 했을 때, 청크 단위로 나누지 않고 실행하면 1개만 실패해도 나머지 처리건이 롤백되는데,<br>이를 청크 단위로 나눠서 처리하면, 실패한 배치 처리건이 존재해도 나머지 청크에 영향을 주지 않음</p>\n</blockquote>\n</li>\n<li><p>하나의 Step에서 ItemReader -&gt; ItemProcessor -&gt; ItemWriter의 순서대로 처리하는 방식도 존재하지만, </p>\n</li>\n<li><p><em>스프링 배치에서는 <code>TaskletStep</code> 처리 시나리오도 제공하고 있다.</em>*</p>\n</li>\n</ul>\n<h2 id=\"Tasklet\"><a href=\"#Tasklet\" class=\"headerlink\" title=\"Tasklet\"></a>Tasklet</h2><ul>\n<li><code>Chunk Oriented Processing</code> 전체 로직을 다루는 것을 <code>Tasklet</code>이라 생각하면 쉽다.</li>\n<li><code>Tasklet</code>은 <code>RepeatStatus.FINISHED</code>를 반환하거나 예외를 throw 할 때까지 <code>TaskletStep</code>에 의해 반복적으로 호출</li>\n<li><code>Tasklet</code> 인터페이스는 <code>execute</code> 매소드 하나만 존재하며 작업 끝나면 <code>RepeatStatus.FINISHED</code>를 반환하며, 작업이 계속되면 <code>RepeatStatus.CONTINUABLE</code>을 반환한다.  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Tasklet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">RepeatStatus <span class=\"title\">execute</span><span class=\"params\">(StepContribution contribution, ChunkContext chunkContext)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InactiveItemTasklet</span> <span class=\"keyword\">implements</span> <span class=\"title\">Tasklet</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RepeatStatus <span class=\"title\">execute</span><span class=\"params\">(StepContribution contribution, ChunkContext chunkContext)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Date date = (Date) chunkContext.getStepContext().getJobParameters().get(<span class=\"string\">&quot;nowDate&quot;</span>);</span><br><span class=\"line\">        LocalDateTime now = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());</span><br><span class=\"line\">        List&lt;User&gt; inactiveUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(</span><br><span class=\"line\">            now.minusYears(<span class=\"number\">1</span>), UserStatus.ACTIVE</span><br><span class=\"line\">        ).stream().map(User::setInactive).collect(Collectors.toList());</span><br><span class=\"line\">        userRepository.saveAll(inactiveUsers);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RepeatStatus.FINISHED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>파일 처리 Tasklet 예제  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Job <span class=\"title\">taskletJob</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.jobBuilderFactory.get(<span class=\"string\">&quot;taskletJob&quot;</span>)</span><br><span class=\"line\">                                .start(deleteFilesInDir())</span><br><span class=\"line\">                                .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Step <span class=\"title\">deleteFilesInDir</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.stepBuilderFactory.get(<span class=\"string\">&quot;deleteFilesInDir&quot;</span>)</span><br><span class=\"line\">                                .tasklet(fileDeletingTasklet())</span><br><span class=\"line\">                                .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FileDeletingTasklet <span class=\"title\">fileDeletingTasklet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FileDeletingTasklet tasklet = <span class=\"keyword\">new</span> FileDeletingTasklet();</span><br><span class=\"line\">        tasklet.setDirectoryResource(<span class=\"keyword\">new</span> FileSystemResource(<span class=\"string\">&quot;target/test-outputs/test-dir&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tasklet;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Listner\"><a href=\"#Listner\" class=\"headerlink\" title=\"Listner\"></a>Listner</h2><ul>\n<li>배치 처리 흐름에서 전후처리에 해당하는 구간에 Listener를 설정 할 수 있다.</li>\n<li>Job의 전후, Step의 전후, 각 청크 단위에서의 전후 등 세세한 과정 실행 시 특정 로직을 할당 할 수 있다.</li>\n<li>인터페이스 구현하는 방법과 어노테이션을 할당하여 구현하는 방법이 있다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>인터페이스</th>\n<th>어노테이션</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JobExecutionListener</td>\n<td><code>@BeforeJob</code>, <code>@AfterJob</code></td>\n<td>Job 실행 전후 처리</td>\n</tr>\n<tr>\n<td>ChunkListener</td>\n<td><code>@BeforeChunk</code>,<code>@AfterChunk</code>, <code>@AfterChunkError</code></td>\n<td>Chunk 실행 전후, 에러 처리</td>\n</tr>\n<tr>\n<td>ItemReadListener</td>\n<td><code>@BeforeRead</code>, <code>@AfterRead</code>, <code>@OnReadError</code></td>\n<td>Read 실행 전후, 에러 처리</td>\n</tr>\n<tr>\n<td>ItemProcessListener</td>\n<td><code>@BeforeProcess</code>, <code>@AfterProcess</code>, <code>@OnProcessError</code></td>\n<td>Process 실행 전후, 에러 처리</td>\n</tr>\n<tr>\n<td>ItemWriteListener</td>\n<td><code>@BeforeWrite</code>, <code>@AfterWrite</code>, <code>@OnWriteError</code></td>\n<td>Write 실행 전후, 에러 처리</td>\n</tr>\n<tr>\n<td>StepExecutionListener</td>\n<td><code>@BeforeStep</code>, <code>@AfterStep</code></td>\n<td>Step 실행 전후 처리</td>\n</tr>\n<tr>\n<td>SkipListener</td>\n<td><code>@OnSkipInRead</code>, <code>@OnSkipInWrite</code>, <code>@OnSkipInProcess</code></td>\n<td>Skip 발생 시 처리</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. Interace 구현</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InactiveJobListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">JobExecutionListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">beforeJob</span><span class=\"params\">(JobExecution jobExecution)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;Before JOB&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterJob</span><span class=\"params\">(JobExecution jobExecution)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;After JOB&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. Annotation 구현</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StepListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@BeforeStep</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">beforeStep</span><span class=\"params\">(StepExecution stepExecution)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;Before Step&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterStep</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterStep</span><span class=\"params\">(StepExecution stepExecution)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;After Step&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Flow-흐름제어\"><a href=\"#Flow-흐름제어\" class=\"headerlink\" title=\"Flow, 흐름제어\"></a>Flow, 흐름제어</h2><p><code>Job</code> 실행에서 <code>Step</code>의 실패가 반드시 <code>Job</code>이 실패해야 한다는 것을 의미하지 않는다. 또한, 다음 <code>Step</code>에서 어떤 단계가 실행되어야 하는지를 흐름 제어가 필요한 상황도 충분히 생길 수 있다. 스프링 배치에서는 이러한 순차 처리 케이스와 조건 처리 케이스에 대해 구현체를 제공하고 있다.</p>\n<h3 id=\"Sequential-Flow\"><a href=\"#Sequential-Flow\" class=\"headerlink\" title=\"Sequential Flow\"></a>Sequential Flow</h3><p><img src=\"https://docs.spring.io/spring-batch/4.1.x/reference/html/images/sequential-flow.png\"></p>\n<ul>\n<li><code>Step</code>들을 처리하는 가장 일반적인 시나리오로 모든 <code>Step</code>들이 연속적으로 실행되는 Flow.</li>\n<li>다시 말해, <code>Step A</code>가 완벽하게 수행되면 <code>Step B</code>가 실행되고 그 이후에 <code>Step C</code>까지 실행되는 구조이다. 만약 <code>Step A</code>가 실패하게 될 경우 이후 <code>Step</code>들은 실행되지 않으므로 해당 <code>Job</code>은 실패하게 된다. 위와 같은 플로우를 실행하는 <code>Job</code>은 아래와 같이 생성하면 된다.  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Job <span class=\"title\">job</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.jobBuilderFactory.get(<span class=\"string\">&quot;job&quot;</span>)</span><br><span class=\"line\">                                .start(stepA())</span><br><span class=\"line\">                                .next(stepB())</span><br><span class=\"line\">                                .next(stepC())</span><br><span class=\"line\">                                .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"Conditional-Flow\"><a href=\"#Conditional-Flow\" class=\"headerlink\" title=\"Conditional Flow\"></a>Conditional Flow</h3><p><img src=\"http://www.egovframe.go.kr/wiki/lib/exe/fetch.php?media=egovframework:rte2:brte:batch_core:conditional-flow.png\"></p>\n<ul>\n<li>대부분의 경우, Sequential Flow를 통하여 해결이 되겠지만, 흐름 제어가 필요한 상황이 있을 수 있다. 예를 들어, <code>Step A</code>의 성공 유무를 체크하여 분기가 필요하다면 아래 코드이 <code>Job</code> 설정이 가능하다.  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Job <span class=\"title\">job</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.jobBuilderFactory.get(<span class=\"string\">&quot;job&quot;</span>)</span><br><span class=\"line\">                                .start(stepA())</span><br><span class=\"line\">                                .on(<span class=\"string\">&quot;*&quot;</span>).to(stepB())</span><br><span class=\"line\">                                .from(stepA()).on(<span class=\"string\">&quot;FAILED&quot;</span>).to(stepC())</span><br><span class=\"line\">                                .end()</span><br><span class=\"line\">                                .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>on</code> 메소드는 간단한 패턴 일치를 사용하여 Step의 실행결과 <code>ExitStatus</code>를 일치시킴<ul>\n<li><code>*</code>은 0 개 이상의 문자와 일치.</li>\n<li><code>?</code>은 정확히 한 문자 일치<blockquote>\n<p>예를 들어, “c*t”은 “cat” 및 “count”에 매칭 될 수 있다. 반면에, “c?t”은 “cat”에 매칭될 수 있지만, “count”에는 매칭 될 수 없다.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><code>ExitStatus</code>와 <code>BatchStatus</code>의 값을 구분하는 것이 중요</p>\n<h4 id=\"ExitStatus\"><a href=\"#ExitStatus\" class=\"headerlink\" title=\"ExitStatus\"></a>ExitStatus</h4>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.from(stepA()).on(<span class=\"string\">&quot;FAILED&quot;</span>).to(stepB())</span><br></pre></td></tr></table></figure>\n<p>  위와 같은 Job코드가 있다고 가정할 때, 여기에서 표현하는 상태 값은 <code>Step</code>에서의 ExitStatus의 FAILED 상태 값을 나타낸다. 다시 말해, <code>Step</code>의 처리 상태를 표현하며, 상태값은 <code>UNKNOWN</code>, <code>EXECUTING</code>, <code>COMPLETED</code>, <code>NOOP</code>, <code>FAILED</code>, <code>STOPPED</code>이 존재한다. </p>\n<h4 id=\"BatchStatus\"><a href=\"#BatchStatus\" class=\"headerlink\" title=\"BatchStatus\"></a>BatchStatus</h4><p>  <code>JobExecution</code>와 <code>StepExecution</code> 양쪽에서 사용하는 열거형 값으로 프레임워크에서 <code>Job</code>과 <code>Step</code>의 상태를 기록하는 용도로 사용한다. 상태 값으로는 COMPLETED, STARTING, STARTED, STOPPING, STOPPED, FAILED, ABANDONED, or UNKNOWN이 존재한다.</p>\n</li>\n</ul>\n<ul>\n<li>만약, ExitStatus의 값이 FAILED라고 하면, Job의 BatchStatus값 역시 FAILED로 처리된다. 이밖의 경우는 BatchStatus와 ExitStatus 모두 COMPLETE 상태로 처리된다.</li>\n</ul>\n"},{"title":"스프링 부트 배치 #2 - ItemReader","date":"2019-01-03T15:27:00.000Z","_content":"\n# 스프링 부트 배치 #2 - ItemReader\n\n## 2.1 ItemReader\n* 스프링 배치에서는 상황에 맞는 `ItemReader` 구현체를 제공\n* `ItemReader`는 쓰레드 세이프하지 않기 때문에(Non-Thread-Safe) 쓰레드 간 경합이 발생하지 않도록 주의해야 한다.\n  * 스프링 배치에서는 이를 보완하기 위해, `SynchronizedItemStreamReader` 구현체를 제공하며, 이를 생성할 수 있는 빌더 구현체인 `SynchronizedItemStreamReaderBuilder` 또한 제공한다.\n* Flat-File, Message-Queue(AMQP), Database(RDBMS, Mongodb) 등의 ItemReader 구현체들이 존재하며, 스프링 배치에서 제공하고 있는 구현체들은 [링크](https://docs.spring.io/spring-batch/4.0.x/reference/html/appendix.html#listOfReadersAndWriters)를 통해 확인 가능하다.\n* 스프링 배치에서 제공하지 않은, Custom ItemReader가 필요한 경우, ItemReader 인터페이스를 상속하게 ItemReader 구현체를 작성하면 된다.\n\n## 2.2 ListItemReader\n```java\n    @Bean\n    @StepScope\n    public ListItemReader<User> itemReader() {\n        List<User> oldUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(\n            LocalDateTime.now().minusYears(1), UserStatus.AVTIVE\n        );\n        return new ListItemReader<>(oldUsers);\n    }\n```\n* ListItemReader를 사용하면, 읽어온 리스트 데이터를 메모리에 올려두고 ItemReader.read()를 사용하여 하나씩 처리 작업을 수행한다. \n* 하지만, 전체 데이터를 메모리에 올려두고 사용하는 것은 비효율적이기 때문에, 이를 나눠서 처리 할 수 있는 `PagingItemReader` 구현체를 사용 할 수 있다.\n\n## 2.3 Database Readers\n데이터베이스를 기준으로 ItemReader의 구현체를 나눌 때, `Cursor Based ItemReader`과 `Paging Based ItemReader`으로 나눌 수 있다.\n\n### Cursor Based ItemReader\n![](https://docs.spring.io/spring-batch/4.0.x/reference/html/images/cursorExample.png)\n\n* 관계형 데이터베이스에서 데이터를 Streaming 해오는 전통적인 방법으로 `ResultSet`을 통하여 커서를 유지하여 row 단위로 데이터를 가져오게 하는 방법을 많이 사용한다.\n* Spring Batch에서 Cursor Based ItemReader 구현은 초기화 시 커서를 열고 모든 호출에 대해 커서를 한 행 앞으로 이동시킨다. 커서 이동은 read()를 호출하면서 일어난다.\n* Spring Batch에서는 `JdbcCursorItemReader` 구현체를 제공하며 `DataSource`로부터 얻은 연결을 통하여 SQL 문을 실행하고 이를 `ResultSet`을 이용하여 커서 기반으로 데이터를 가져온다. `JdbcCursorItemReader`은 `JdbcCursorItemReaderBuilder`을 통하여 생성 할 수 있으며 예제 코드는 아래와 같다.\n\n```java\n    @Bean\n    public JdbcCursorItemReader<CustomerCredit> itemReader() {\n            return new JdbcCursorItemReaderBuilder<CustomerCredit>()\n                            .dataSource(this.dataSource)\n                            .name(\"creditReader\")\n                            .sql(\"select ID, NAME, CREDIT from CUSTOMER\")\n                            .rowMapper(new CustomerCreditRowMapper())\n                            .build();\n\n    }\n```\n\n* 이 밖에도 아래와 같은 ItemReader 구현체도 스프링 배치에서 제공하고 있다. 상황에 맞게 구현하면 된다.\n  * [`HibernateCursorItemReader`](https://docs.spring.io/spring-batch/4.0.x/reference/html/readersAndWriters.html#HibernateCursorItemReader)\n  * [`StoredProcedureItemReader`](https://docs.spring.io/spring-batch/4.0.x/reference/html/readersAndWriters.html#StoredProcedureItemReader)\n\n\n### Paging Based ItemReader\n* Cursor 기반의 ItemReader의 경우, 데이터베이스 커넥션을 지속적으로 독점으로 사용하여 처리가 완료되는 시점까지 커넥션을 놓아주지 않기 때문에, 경우에 따라 성능상에 영향을 줄 수 있다. 처리 해야 할 데이터가 크다면 Cursor 기반이 아닌 Pagination 기반의 구현을 사용하는 것이 유리하다. \n* Pagination 기반의 ItemReader의 구현체는 `JdbcPagingItemReader`, `JpaPagingItemReader`이 있다.\n\n#### JdbcPagingItemReader\n* `JdbcPagingItemReader`을 사용할 때, SQL 쿼리를 제공 `PagingQueryProvider`가 필요\n* 데이터베이스마다 페이징을 처리하는 구문과 전략이 다르기 때문에 이를 지정해줘야 한다. 지원되는 각 데이터베이스 유형마다 다른 `PagingQueryProvider`를 사용해야합니다\n* 또한 사용중인 데이터베이스를 자동으로 검색하고 적절한 `PagingQueryProvider` 구현을 결정하는 `SqlPagingQueryProviderFactoryBean`이 있다. `SqlPagingQueryProviderFactoryBean`은 select절, from절 및 sortKey 구문을 반드시 지정해야하며, where절은 필수가 아닌 옵션으로 설정 할 수 있다.\n\n```java\n@Bean\npublic JdbcPagingItemReader itemReader(DataSource dataSource) {\n        Map<String, Object> parameterValues = new HashMap<>();\n        parameterValues.put(\"status\", \"NEW\");\n\n        return new JdbcPagingItemReaderBuilder<CustomerCredit>()\n                                           .name(\"creditReader\")\n                                           .dataSource(dataSource)\n                                           .queryProvider(queryProvider())\n                                           .parameterValues(parameterValues)\n                                           .rowMapper(customerCreditMapper())\n                                           .pageSize(1000)\n                                           .build();\n}\n\n@Bean\npublic SqlPagingQueryProviderFactoryBean queryProvider() {\n        SqlPagingQueryProviderFactoryBean provider = new SqlPagingQueryProviderFactoryBean();\n\n        provider.setSelectClause(\"select id, name, credit\");\n        provider.setFromClause(\"from customer\");\n        provider.setWhereClause(\"where status=:status\");\n        provider.setSortKey(\"id\");\n\n        return provider;\n}\n```\n\n#### JpaPagingItemReader\n\n* `JpaPagingItemReader`를 통하여 지정한 페이지 사이즈만큼 데이터를 가져와서 처리 가능하다.\n* 조회한 데이터는 JPA 영속성 컨텍스트상에서 `DETACH`상태이기 때문에, 영속성 컨텍스트의 관리 대상에서 벗어나게 된다.\n* `JpaPagingItemReaderBuilder`를 통하여 생성 가능하며, `JpaPagingItemReader`를 직접 생성하는 것도 가능하다.\n```java\n    // JpaPagingItemReaderBuilder를 통한 생성\n    @Bean\n    public JpaPagingItemReader itemReader() {\n            return new JpaPagingItemReaderBuilder<CustomerCredit>()\n                                            .name(\"creditReader\")\n                                            .entityManagerFactory(entityManagerFactory())\n                                            .queryString(\"select c from CustomerCredit c\")\n                                            .pageSize(1000)\n                                            .build();\n    }\n\n    // 직접 생성\n    @Bean(destroyMethod = \"\")\n    @StepScope\n    public JpaPagingItemReader<User> itemReader() {\n        JpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader<User>()\n        jpaPagingItemReader.setQueryString(\n            \"select u from User as u where u.updatedDate < :updatedDate and u.status = :status\"\n        );\n        HashMap<String, Object> map = new HashMap<>();\n        map.put(\"updatedDate\", LocalDateTime.now().minusYears(1));\n        map.put(\"status\", UserStatus.ACTIVE);\n        jpaPagingItemReader.setParameterValues(map);\n        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);\n        jpaPagingItemReader.setPageSize(CHUNK_SIZE);\n        return jpaPagingItemReader;\n    }\n```\n* `JpaPagingItemReader` 내부에서 `EntityManager`를 할당 받아서 사용한다. `EntityManagerFactory`를 통하여 생성한 `EntityManager`에서 지정한 크기대로 데이터를 가져오기 때문에 예를 들어 10개씩 `[읽기] -> [처리] -> [쓰기]`를 하는 Step이 있다고 했을 때, 처음 이후의 처리에 대해 데이터 건너뛰기가 발생 할 수 있다.\n\n```puml\n@startuml\nparticipant BATCH_APPLICATION\ndatabase DATABASE\n\n== 1. 첫 번째 Read ==\nBATCH_APPLICATION <-> DATABASE : [READ]: SELECT * FROM USER LIMIT 5\nBATCH_APPLICATION -> BATCH_APPLICATION : [PROCESS]: 데이터 가공/처리\nBATCH_APPLICATION -> DATABASE: [WRITE]: 데이터 입력/수정\n== 2. 두 번째 Read ==\nBATCH_APPLICATION <-> DATABASE : [READ]: SELECT * FROM USER OFFSET 5 LIMIT 5\nBATCH_APPLICATION -> BATCH_APPLICATION : [PROCESS]: 데이터 가공/처리\nBATCH_APPLICATION -> DATABASE: [WRITE]: 데이터 입력/수정\n@enduml\n```\n\n* 청크 단위로 데이터를 가져오도록 기본 구현이 되어 있기 때문에 5개의 아이템을 건너 뛰게 되는 상황이 생길 수 있다. 실제 두 번째 단계에서 올바른 데이터를 가져오기 위해서는 `OFFSET 5`을 빼놓고 SQL문을 질의해야 한다. \n* OFFSET 적용을 피하기 위해서는 아래와 같이 `JpaPagingItemReader`의 getPage를 오버라이드하여 매번 첫 번째 페이지만 참조할 수 있도록 변경하면 된다.\n\n```java\nJpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader<User>() {\n    @Override\n    public int getPage() {\n        return 0;\n    }\n};\n```\n\n#### RepositoryItemReader\n* `PagingAndSortingRepository`룰 활용한 ItemReader 구현체\n* `RepositoryItemReader`를 직접 생성하는 방법과 빌더 구현체인 `RepositoryItemReaderBuilder`를 통하여 `RepositoryItemReader` 인스턴스를 생성하는 방법이 있다.\n* 구현 시, 주의해야 할 점은 Repository에서 Pageable 타입 혹은 하위 타입을 반환해야 하는점과 매소드 마지막 인자에 Pageable 인자를 포함해야 하는 점이다. 아래 예제 코드를 참고하자.\n```java\npublic interface UserRepository extends JpaRepository<User, Long> {\n    // 1. Pageable 타입을 반환해야 하며, 인자 마지막에 Pageable 타입의 인스턴스를 포함해야 함.\n    Page<User> findByUpdatedDateBeforeAndStatusEquals(LocalDateTime localDateTime, UserStatus status, Pageable pageable);\n}\n\n@Bean\n@StepScope\npublic RepositoryItemReader<User> itemReader() {\n    return new RepositoryItemReaderBuilder()\n        .repository(userRepository)\n        .methodName(\"findByUpdatedDateBeforeAndStatusEquals\")\n        .pageSize(CHUNK_SIZE)\n        .maxItemCount(CHUNK_SIZE)\n        .arguments(Arrays.asList(LocalDateTime.now().minusYears(1), UserStatus.ACTIVE))\n        .sorts(Collections.singletonMap(\"idx\", Sort.Direction.ASC))\n        .name(\"repositoryItemReader\")\n        .build();\n}\n\n```\n* `RepositoryItemReader`도 마찬가지로 `JpaPagingItemReader`와 같이 지정해놓은 pageSize에 의거하여 건너뛰는 SQL 구문이 포함됨을 확인할 수 있었다. 이를 회피하기 위해서는 `doPageRead` 메소드를 오버라이드하여 첫 번째 페이지만 호출되도록 수정하면 된다. **아래 이미지의 주석 내용을 살펴보도록 하자**\n![RepositoryItemReader.doPageRead()](https://i.imgur.com/vnUQFi9.png)\n\n> 실무에서는 JPA를 원활하게 사용하기 위해, querydsl 혹은 Specification API를 사용하게 되는데, 이를 사용하기 위해서는 결국 Custom ItemReader를 구현해서 사용하는 방법밖에 없는거 같다.\n\n\n## 참고\n* [처음 배우는 스프링 부트 2](https://book.naver.com/bookdb/book_detail.nhn?bid=14031681)\n* [Spring Batch - Reference Documentation](https://docs.spring.io/spring-batch/4.1.x/reference/html/index.html)","source":"_posts/Spring/BATCH_2.md","raw":"---\ntitle: '스프링 부트 배치 #2 - ItemReader'\ndate: 2019.1.4. 00:27\ncategories:\n- Spring\n---\n\n# 스프링 부트 배치 #2 - ItemReader\n\n## 2.1 ItemReader\n* 스프링 배치에서는 상황에 맞는 `ItemReader` 구현체를 제공\n* `ItemReader`는 쓰레드 세이프하지 않기 때문에(Non-Thread-Safe) 쓰레드 간 경합이 발생하지 않도록 주의해야 한다.\n  * 스프링 배치에서는 이를 보완하기 위해, `SynchronizedItemStreamReader` 구현체를 제공하며, 이를 생성할 수 있는 빌더 구현체인 `SynchronizedItemStreamReaderBuilder` 또한 제공한다.\n* Flat-File, Message-Queue(AMQP), Database(RDBMS, Mongodb) 등의 ItemReader 구현체들이 존재하며, 스프링 배치에서 제공하고 있는 구현체들은 [링크](https://docs.spring.io/spring-batch/4.0.x/reference/html/appendix.html#listOfReadersAndWriters)를 통해 확인 가능하다.\n* 스프링 배치에서 제공하지 않은, Custom ItemReader가 필요한 경우, ItemReader 인터페이스를 상속하게 ItemReader 구현체를 작성하면 된다.\n\n## 2.2 ListItemReader\n```java\n    @Bean\n    @StepScope\n    public ListItemReader<User> itemReader() {\n        List<User> oldUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(\n            LocalDateTime.now().minusYears(1), UserStatus.AVTIVE\n        );\n        return new ListItemReader<>(oldUsers);\n    }\n```\n* ListItemReader를 사용하면, 읽어온 리스트 데이터를 메모리에 올려두고 ItemReader.read()를 사용하여 하나씩 처리 작업을 수행한다. \n* 하지만, 전체 데이터를 메모리에 올려두고 사용하는 것은 비효율적이기 때문에, 이를 나눠서 처리 할 수 있는 `PagingItemReader` 구현체를 사용 할 수 있다.\n\n## 2.3 Database Readers\n데이터베이스를 기준으로 ItemReader의 구현체를 나눌 때, `Cursor Based ItemReader`과 `Paging Based ItemReader`으로 나눌 수 있다.\n\n### Cursor Based ItemReader\n![](https://docs.spring.io/spring-batch/4.0.x/reference/html/images/cursorExample.png)\n\n* 관계형 데이터베이스에서 데이터를 Streaming 해오는 전통적인 방법으로 `ResultSet`을 통하여 커서를 유지하여 row 단위로 데이터를 가져오게 하는 방법을 많이 사용한다.\n* Spring Batch에서 Cursor Based ItemReader 구현은 초기화 시 커서를 열고 모든 호출에 대해 커서를 한 행 앞으로 이동시킨다. 커서 이동은 read()를 호출하면서 일어난다.\n* Spring Batch에서는 `JdbcCursorItemReader` 구현체를 제공하며 `DataSource`로부터 얻은 연결을 통하여 SQL 문을 실행하고 이를 `ResultSet`을 이용하여 커서 기반으로 데이터를 가져온다. `JdbcCursorItemReader`은 `JdbcCursorItemReaderBuilder`을 통하여 생성 할 수 있으며 예제 코드는 아래와 같다.\n\n```java\n    @Bean\n    public JdbcCursorItemReader<CustomerCredit> itemReader() {\n            return new JdbcCursorItemReaderBuilder<CustomerCredit>()\n                            .dataSource(this.dataSource)\n                            .name(\"creditReader\")\n                            .sql(\"select ID, NAME, CREDIT from CUSTOMER\")\n                            .rowMapper(new CustomerCreditRowMapper())\n                            .build();\n\n    }\n```\n\n* 이 밖에도 아래와 같은 ItemReader 구현체도 스프링 배치에서 제공하고 있다. 상황에 맞게 구현하면 된다.\n  * [`HibernateCursorItemReader`](https://docs.spring.io/spring-batch/4.0.x/reference/html/readersAndWriters.html#HibernateCursorItemReader)\n  * [`StoredProcedureItemReader`](https://docs.spring.io/spring-batch/4.0.x/reference/html/readersAndWriters.html#StoredProcedureItemReader)\n\n\n### Paging Based ItemReader\n* Cursor 기반의 ItemReader의 경우, 데이터베이스 커넥션을 지속적으로 독점으로 사용하여 처리가 완료되는 시점까지 커넥션을 놓아주지 않기 때문에, 경우에 따라 성능상에 영향을 줄 수 있다. 처리 해야 할 데이터가 크다면 Cursor 기반이 아닌 Pagination 기반의 구현을 사용하는 것이 유리하다. \n* Pagination 기반의 ItemReader의 구현체는 `JdbcPagingItemReader`, `JpaPagingItemReader`이 있다.\n\n#### JdbcPagingItemReader\n* `JdbcPagingItemReader`을 사용할 때, SQL 쿼리를 제공 `PagingQueryProvider`가 필요\n* 데이터베이스마다 페이징을 처리하는 구문과 전략이 다르기 때문에 이를 지정해줘야 한다. 지원되는 각 데이터베이스 유형마다 다른 `PagingQueryProvider`를 사용해야합니다\n* 또한 사용중인 데이터베이스를 자동으로 검색하고 적절한 `PagingQueryProvider` 구현을 결정하는 `SqlPagingQueryProviderFactoryBean`이 있다. `SqlPagingQueryProviderFactoryBean`은 select절, from절 및 sortKey 구문을 반드시 지정해야하며, where절은 필수가 아닌 옵션으로 설정 할 수 있다.\n\n```java\n@Bean\npublic JdbcPagingItemReader itemReader(DataSource dataSource) {\n        Map<String, Object> parameterValues = new HashMap<>();\n        parameterValues.put(\"status\", \"NEW\");\n\n        return new JdbcPagingItemReaderBuilder<CustomerCredit>()\n                                           .name(\"creditReader\")\n                                           .dataSource(dataSource)\n                                           .queryProvider(queryProvider())\n                                           .parameterValues(parameterValues)\n                                           .rowMapper(customerCreditMapper())\n                                           .pageSize(1000)\n                                           .build();\n}\n\n@Bean\npublic SqlPagingQueryProviderFactoryBean queryProvider() {\n        SqlPagingQueryProviderFactoryBean provider = new SqlPagingQueryProviderFactoryBean();\n\n        provider.setSelectClause(\"select id, name, credit\");\n        provider.setFromClause(\"from customer\");\n        provider.setWhereClause(\"where status=:status\");\n        provider.setSortKey(\"id\");\n\n        return provider;\n}\n```\n\n#### JpaPagingItemReader\n\n* `JpaPagingItemReader`를 통하여 지정한 페이지 사이즈만큼 데이터를 가져와서 처리 가능하다.\n* 조회한 데이터는 JPA 영속성 컨텍스트상에서 `DETACH`상태이기 때문에, 영속성 컨텍스트의 관리 대상에서 벗어나게 된다.\n* `JpaPagingItemReaderBuilder`를 통하여 생성 가능하며, `JpaPagingItemReader`를 직접 생성하는 것도 가능하다.\n```java\n    // JpaPagingItemReaderBuilder를 통한 생성\n    @Bean\n    public JpaPagingItemReader itemReader() {\n            return new JpaPagingItemReaderBuilder<CustomerCredit>()\n                                            .name(\"creditReader\")\n                                            .entityManagerFactory(entityManagerFactory())\n                                            .queryString(\"select c from CustomerCredit c\")\n                                            .pageSize(1000)\n                                            .build();\n    }\n\n    // 직접 생성\n    @Bean(destroyMethod = \"\")\n    @StepScope\n    public JpaPagingItemReader<User> itemReader() {\n        JpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader<User>()\n        jpaPagingItemReader.setQueryString(\n            \"select u from User as u where u.updatedDate < :updatedDate and u.status = :status\"\n        );\n        HashMap<String, Object> map = new HashMap<>();\n        map.put(\"updatedDate\", LocalDateTime.now().minusYears(1));\n        map.put(\"status\", UserStatus.ACTIVE);\n        jpaPagingItemReader.setParameterValues(map);\n        jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);\n        jpaPagingItemReader.setPageSize(CHUNK_SIZE);\n        return jpaPagingItemReader;\n    }\n```\n* `JpaPagingItemReader` 내부에서 `EntityManager`를 할당 받아서 사용한다. `EntityManagerFactory`를 통하여 생성한 `EntityManager`에서 지정한 크기대로 데이터를 가져오기 때문에 예를 들어 10개씩 `[읽기] -> [처리] -> [쓰기]`를 하는 Step이 있다고 했을 때, 처음 이후의 처리에 대해 데이터 건너뛰기가 발생 할 수 있다.\n\n```puml\n@startuml\nparticipant BATCH_APPLICATION\ndatabase DATABASE\n\n== 1. 첫 번째 Read ==\nBATCH_APPLICATION <-> DATABASE : [READ]: SELECT * FROM USER LIMIT 5\nBATCH_APPLICATION -> BATCH_APPLICATION : [PROCESS]: 데이터 가공/처리\nBATCH_APPLICATION -> DATABASE: [WRITE]: 데이터 입력/수정\n== 2. 두 번째 Read ==\nBATCH_APPLICATION <-> DATABASE : [READ]: SELECT * FROM USER OFFSET 5 LIMIT 5\nBATCH_APPLICATION -> BATCH_APPLICATION : [PROCESS]: 데이터 가공/처리\nBATCH_APPLICATION -> DATABASE: [WRITE]: 데이터 입력/수정\n@enduml\n```\n\n* 청크 단위로 데이터를 가져오도록 기본 구현이 되어 있기 때문에 5개의 아이템을 건너 뛰게 되는 상황이 생길 수 있다. 실제 두 번째 단계에서 올바른 데이터를 가져오기 위해서는 `OFFSET 5`을 빼놓고 SQL문을 질의해야 한다. \n* OFFSET 적용을 피하기 위해서는 아래와 같이 `JpaPagingItemReader`의 getPage를 오버라이드하여 매번 첫 번째 페이지만 참조할 수 있도록 변경하면 된다.\n\n```java\nJpaPagingItemReader<User> jpaPagingItemReader = new JpaPagingItemReader<User>() {\n    @Override\n    public int getPage() {\n        return 0;\n    }\n};\n```\n\n#### RepositoryItemReader\n* `PagingAndSortingRepository`룰 활용한 ItemReader 구현체\n* `RepositoryItemReader`를 직접 생성하는 방법과 빌더 구현체인 `RepositoryItemReaderBuilder`를 통하여 `RepositoryItemReader` 인스턴스를 생성하는 방법이 있다.\n* 구현 시, 주의해야 할 점은 Repository에서 Pageable 타입 혹은 하위 타입을 반환해야 하는점과 매소드 마지막 인자에 Pageable 인자를 포함해야 하는 점이다. 아래 예제 코드를 참고하자.\n```java\npublic interface UserRepository extends JpaRepository<User, Long> {\n    // 1. Pageable 타입을 반환해야 하며, 인자 마지막에 Pageable 타입의 인스턴스를 포함해야 함.\n    Page<User> findByUpdatedDateBeforeAndStatusEquals(LocalDateTime localDateTime, UserStatus status, Pageable pageable);\n}\n\n@Bean\n@StepScope\npublic RepositoryItemReader<User> itemReader() {\n    return new RepositoryItemReaderBuilder()\n        .repository(userRepository)\n        .methodName(\"findByUpdatedDateBeforeAndStatusEquals\")\n        .pageSize(CHUNK_SIZE)\n        .maxItemCount(CHUNK_SIZE)\n        .arguments(Arrays.asList(LocalDateTime.now().minusYears(1), UserStatus.ACTIVE))\n        .sorts(Collections.singletonMap(\"idx\", Sort.Direction.ASC))\n        .name(\"repositoryItemReader\")\n        .build();\n}\n\n```\n* `RepositoryItemReader`도 마찬가지로 `JpaPagingItemReader`와 같이 지정해놓은 pageSize에 의거하여 건너뛰는 SQL 구문이 포함됨을 확인할 수 있었다. 이를 회피하기 위해서는 `doPageRead` 메소드를 오버라이드하여 첫 번째 페이지만 호출되도록 수정하면 된다. **아래 이미지의 주석 내용을 살펴보도록 하자**\n![RepositoryItemReader.doPageRead()](https://i.imgur.com/vnUQFi9.png)\n\n> 실무에서는 JPA를 원활하게 사용하기 위해, querydsl 혹은 Specification API를 사용하게 되는데, 이를 사용하기 위해서는 결국 Custom ItemReader를 구현해서 사용하는 방법밖에 없는거 같다.\n\n\n## 참고\n* [처음 배우는 스프링 부트 2](https://book.naver.com/bookdb/book_detail.nhn?bid=14031681)\n* [Spring Batch - Reference Documentation](https://docs.spring.io/spring-batch/4.1.x/reference/html/index.html)","slug":"Spring/BATCH_2","published":1,"updated":"2021-08-02T12:08:07.731Z","_id":"ckrsup50w001ttjhv92dl56cm","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"스프링-부트-배치-2-ItemReader\"><a href=\"#스프링-부트-배치-2-ItemReader\" class=\"headerlink\" title=\"스프링 부트 배치 #2 - ItemReader\"></a>스프링 부트 배치 #2 - ItemReader</h1><h2 id=\"2-1-ItemReader\"><a href=\"#2-1-ItemReader\" class=\"headerlink\" title=\"2.1 ItemReader\"></a>2.1 ItemReader</h2><ul>\n<li>스프링 배치에서는 상황에 맞는 <code>ItemReader</code> 구현체를 제공</li>\n<li><code>ItemReader</code>는 쓰레드 세이프하지 않기 때문에(Non-Thread-Safe) 쓰레드 간 경합이 발생하지 않도록 주의해야 한다.<ul>\n<li>스프링 배치에서는 이를 보완하기 위해, <code>SynchronizedItemStreamReader</code> 구현체를 제공하며, 이를 생성할 수 있는 빌더 구현체인 <code>SynchronizedItemStreamReaderBuilder</code> 또한 제공한다.</li>\n</ul>\n</li>\n<li>Flat-File, Message-Queue(AMQP), Database(RDBMS, Mongodb) 등의 ItemReader 구현체들이 존재하며, 스프링 배치에서 제공하고 있는 구현체들은 <a href=\"https://docs.spring.io/spring-batch/4.0.x/reference/html/appendix.html#listOfReadersAndWriters\">링크</a>를 통해 확인 가능하다.</li>\n<li>스프링 배치에서 제공하지 않은, Custom ItemReader가 필요한 경우, ItemReader 인터페이스를 상속하게 ItemReader 구현체를 작성하면 된다.</li>\n</ul>\n<h2 id=\"2-2-ListItemReader\"><a href=\"#2-2-ListItemReader\" class=\"headerlink\" title=\"2.2 ListItemReader\"></a>2.2 ListItemReader</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@StepScope</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ListItemReader&lt;User&gt; <span class=\"title\">itemReader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;User&gt; oldUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(</span><br><span class=\"line\">        LocalDateTime.now().minusYears(<span class=\"number\">1</span>), UserStatus.AVTIVE</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListItemReader&lt;&gt;(oldUsers);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ListItemReader를 사용하면, 읽어온 리스트 데이터를 메모리에 올려두고 ItemReader.read()를 사용하여 하나씩 처리 작업을 수행한다. </li>\n<li>하지만, 전체 데이터를 메모리에 올려두고 사용하는 것은 비효율적이기 때문에, 이를 나눠서 처리 할 수 있는 <code>PagingItemReader</code> 구현체를 사용 할 수 있다.</li>\n</ul>\n<h2 id=\"2-3-Database-Readers\"><a href=\"#2-3-Database-Readers\" class=\"headerlink\" title=\"2.3 Database Readers\"></a>2.3 Database Readers</h2><p>데이터베이스를 기준으로 ItemReader의 구현체를 나눌 때, <code>Cursor Based ItemReader</code>과 <code>Paging Based ItemReader</code>으로 나눌 수 있다.</p>\n<h3 id=\"Cursor-Based-ItemReader\"><a href=\"#Cursor-Based-ItemReader\" class=\"headerlink\" title=\"Cursor Based ItemReader\"></a>Cursor Based ItemReader</h3><p><img src=\"https://docs.spring.io/spring-batch/4.0.x/reference/html/images/cursorExample.png\"></p>\n<ul>\n<li>관계형 데이터베이스에서 데이터를 Streaming 해오는 전통적인 방법으로 <code>ResultSet</code>을 통하여 커서를 유지하여 row 단위로 데이터를 가져오게 하는 방법을 많이 사용한다.</li>\n<li>Spring Batch에서 Cursor Based ItemReader 구현은 초기화 시 커서를 열고 모든 호출에 대해 커서를 한 행 앞으로 이동시킨다. 커서 이동은 read()를 호출하면서 일어난다.</li>\n<li>Spring Batch에서는 <code>JdbcCursorItemReader</code> 구현체를 제공하며 <code>DataSource</code>로부터 얻은 연결을 통하여 SQL 문을 실행하고 이를 <code>ResultSet</code>을 이용하여 커서 기반으로 데이터를 가져온다. <code>JdbcCursorItemReader</code>은 <code>JdbcCursorItemReaderBuilder</code>을 통하여 생성 할 수 있으며 예제 코드는 아래와 같다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> JdbcCursorItemReader&lt;CustomerCredit&gt; <span class=\"title\">itemReader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcCursorItemReaderBuilder&lt;CustomerCredit&gt;()</span><br><span class=\"line\">                        .dataSource(<span class=\"keyword\">this</span>.dataSource)</span><br><span class=\"line\">                        .name(<span class=\"string\">&quot;creditReader&quot;</span>)</span><br><span class=\"line\">                        .sql(<span class=\"string\">&quot;select ID, NAME, CREDIT from CUSTOMER&quot;</span>)</span><br><span class=\"line\">                        .rowMapper(<span class=\"keyword\">new</span> CustomerCreditRowMapper())</span><br><span class=\"line\">                        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>이 밖에도 아래와 같은 ItemReader 구현체도 스프링 배치에서 제공하고 있다. 상황에 맞게 구현하면 된다.<ul>\n<li><a href=\"https://docs.spring.io/spring-batch/4.0.x/reference/html/readersAndWriters.html#HibernateCursorItemReader\"><code>HibernateCursorItemReader</code></a></li>\n<li><a href=\"https://docs.spring.io/spring-batch/4.0.x/reference/html/readersAndWriters.html#StoredProcedureItemReader\"><code>StoredProcedureItemReader</code></a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Paging-Based-ItemReader\"><a href=\"#Paging-Based-ItemReader\" class=\"headerlink\" title=\"Paging Based ItemReader\"></a>Paging Based ItemReader</h3><ul>\n<li>Cursor 기반의 ItemReader의 경우, 데이터베이스 커넥션을 지속적으로 독점으로 사용하여 처리가 완료되는 시점까지 커넥션을 놓아주지 않기 때문에, 경우에 따라 성능상에 영향을 줄 수 있다. 처리 해야 할 데이터가 크다면 Cursor 기반이 아닌 Pagination 기반의 구현을 사용하는 것이 유리하다. </li>\n<li>Pagination 기반의 ItemReader의 구현체는 <code>JdbcPagingItemReader</code>, <code>JpaPagingItemReader</code>이 있다.</li>\n</ul>\n<h4 id=\"JdbcPagingItemReader\"><a href=\"#JdbcPagingItemReader\" class=\"headerlink\" title=\"JdbcPagingItemReader\"></a>JdbcPagingItemReader</h4><ul>\n<li><code>JdbcPagingItemReader</code>을 사용할 때, SQL 쿼리를 제공 <code>PagingQueryProvider</code>가 필요</li>\n<li>데이터베이스마다 페이징을 처리하는 구문과 전략이 다르기 때문에 이를 지정해줘야 한다. 지원되는 각 데이터베이스 유형마다 다른 <code>PagingQueryProvider</code>를 사용해야합니다</li>\n<li>또한 사용중인 데이터베이스를 자동으로 검색하고 적절한 <code>PagingQueryProvider</code> 구현을 결정하는 <code>SqlPagingQueryProviderFactoryBean</code>이 있다. <code>SqlPagingQueryProviderFactoryBean</code>은 select절, from절 및 sortKey 구문을 반드시 지정해야하며, where절은 필수가 아닌 옵션으로 설정 할 수 있다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> JdbcPagingItemReader <span class=\"title\">itemReader</span><span class=\"params\">(DataSource dataSource)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; parameterValues = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        parameterValues.put(<span class=\"string\">&quot;status&quot;</span>, <span class=\"string\">&quot;NEW&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcPagingItemReaderBuilder&lt;CustomerCredit&gt;()</span><br><span class=\"line\">                                           .name(<span class=\"string\">&quot;creditReader&quot;</span>)</span><br><span class=\"line\">                                           .dataSource(dataSource)</span><br><span class=\"line\">                                           .queryProvider(queryProvider())</span><br><span class=\"line\">                                           .parameterValues(parameterValues)</span><br><span class=\"line\">                                           .rowMapper(customerCreditMapper())</span><br><span class=\"line\">                                           .pageSize(<span class=\"number\">1000</span>)</span><br><span class=\"line\">                                           .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlPagingQueryProviderFactoryBean <span class=\"title\">queryProvider</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        SqlPagingQueryProviderFactoryBean provider = <span class=\"keyword\">new</span> SqlPagingQueryProviderFactoryBean();</span><br><span class=\"line\"></span><br><span class=\"line\">        provider.setSelectClause(<span class=\"string\">&quot;select id, name, credit&quot;</span>);</span><br><span class=\"line\">        provider.setFromClause(<span class=\"string\">&quot;from customer&quot;</span>);</span><br><span class=\"line\">        provider.setWhereClause(<span class=\"string\">&quot;where status=:status&quot;</span>);</span><br><span class=\"line\">        provider.setSortKey(<span class=\"string\">&quot;id&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> provider;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"JpaPagingItemReader\"><a href=\"#JpaPagingItemReader\" class=\"headerlink\" title=\"JpaPagingItemReader\"></a>JpaPagingItemReader</h4><ul>\n<li><code>JpaPagingItemReader</code>를 통하여 지정한 페이지 사이즈만큼 데이터를 가져와서 처리 가능하다.</li>\n<li>조회한 데이터는 JPA 영속성 컨텍스트상에서 <code>DETACH</code>상태이기 때문에, 영속성 컨텍스트의 관리 대상에서 벗어나게 된다.</li>\n<li><code>JpaPagingItemReaderBuilder</code>를 통하여 생성 가능하며, <code>JpaPagingItemReader</code>를 직접 생성하는 것도 가능하다.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JpaPagingItemReaderBuilder를 통한 생성</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> JpaPagingItemReader <span class=\"title\">itemReader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JpaPagingItemReaderBuilder&lt;CustomerCredit&gt;()</span><br><span class=\"line\">                                        .name(<span class=\"string\">&quot;creditReader&quot;</span>)</span><br><span class=\"line\">                                        .entityManagerFactory(entityManagerFactory())</span><br><span class=\"line\">                                        .queryString(<span class=\"string\">&quot;select c from CustomerCredit c&quot;</span>)</span><br><span class=\"line\">                                        .pageSize(<span class=\"number\">1000</span>)</span><br><span class=\"line\">                                        .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 직접 생성</span></span><br><span class=\"line\"><span class=\"meta\">@Bean(destroyMethod = &quot;&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@StepScope</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> JpaPagingItemReader&lt;User&gt; <span class=\"title\">itemReader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    JpaPagingItemReader&lt;User&gt; jpaPagingItemReader = <span class=\"keyword\">new</span> JpaPagingItemReader&lt;User&gt;()</span><br><span class=\"line\">    jpaPagingItemReader.setQueryString(</span><br><span class=\"line\">        <span class=\"string\">&quot;select u from User as u where u.updatedDate &lt; :updatedDate and u.status = :status&quot;</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">    HashMap&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    map.put(<span class=\"string\">&quot;updatedDate&quot;</span>, LocalDateTime.now().minusYears(<span class=\"number\">1</span>));</span><br><span class=\"line\">    map.put(<span class=\"string\">&quot;status&quot;</span>, UserStatus.ACTIVE);</span><br><span class=\"line\">    jpaPagingItemReader.setParameterValues(map);</span><br><span class=\"line\">    jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);</span><br><span class=\"line\">    jpaPagingItemReader.setPageSize(CHUNK_SIZE);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jpaPagingItemReader;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>JpaPagingItemReader</code> 내부에서 <code>EntityManager</code>를 할당 받아서 사용한다. <code>EntityManagerFactory</code>를 통하여 생성한 <code>EntityManager</code>에서 지정한 크기대로 데이터를 가져오기 때문에 예를 들어 10개씩 <code>[읽기] -&gt; [처리] -&gt; [쓰기]</code>를 하는 Step이 있다고 했을 때, 처음 이후의 처리에 대해 데이터 건너뛰기가 발생 할 수 있다.</li>\n</ul>\n<img src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U2NyaXB0VHlwZT0iYXBwbGljYXRpb24vZWNtYXNjcmlwdCIgY29udGVudFN0eWxlVHlwZT0idGV4dC9jc3MiIGhlaWdodD0iNDQycHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDo0NzBweDtoZWlnaHQ6NDQycHg7YmFja2dyb3VuZDojRkZGRkZGOyIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgNDcwIDQ0MiIgd2lkdGg9IjQ3MHB4IiB6b29tQW5kUGFuPSJtYWduaWZ5Ij48ZGVmcz48ZmlsdGVyIGhlaWdodD0iMzAwJSIgaWQ9ImY2dndmZGcybWc3azciIHdpZHRoPSIzMDAlIiB4PSItMSIgeT0iLTEiPjxmZUdhdXNzaWFuQmx1ciByZXN1bHQ9ImJsdXJPdXQiIHN0ZERldmlhdGlvbj0iMi4wIi8+PGZlQ29sb3JNYXRyaXggaW49ImJsdXJPdXQiIHJlc3VsdD0iYmx1ck91dDIiIHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAuNCAwIi8+PGZlT2Zmc2V0IGR4PSI0LjAiIGR5PSI0LjAiIGluPSJibHVyT3V0MiIgcmVzdWx0PSJibHVyT3V0MyIvPjxmZUJsZW5kIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9ImJsdXJPdXQzIiBtb2RlPSJub3JtYWwiLz48L2ZpbHRlcj48L2RlZnM+PGc+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9Ijg5IiB4Mj0iODkiIHkxPSI2Ny4yOTY5IiB5Mj0iMzc0LjM1OTQiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjUuMCw1LjA7IiB4MT0iNDE2IiB4Mj0iNDE2IiB5MT0iNjcuMjk2OSIgeTI9IjM3NC4zNTk0Ii8+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2Y2dndmZGcybWc3azcpIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjE2NCIgeD0iNSIgeT0iMzIiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNTAiIHg9IjEyIiB5PSI1MS45OTUxIj5CQVRDSF9BUFBMSUNBVElPTjwvdGV4dD48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjZ2d2ZkZzJtZzdrNykiIGhlaWdodD0iMzAuMjk2OSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTY0IiB4PSI1IiB5PSIzNzMuMzU5NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE1MCIgeD0iMTIiIHk9IjM5My4zNTQ1Ij5CQVRDSF9BUFBMSUNBVElPTjwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI3OCIgeD0iMzc0IiB5PSI2My45OTUxIj5EQVRBQkFTRTwvdGV4dD48cGF0aCBkPSJNMzk4LDE1IEMzOTgsNSA0MTYsNSA0MTYsNSBDNDE2LDUgNDM0LDUgNDM0LDE1IEw0MzQsNDEgQzQzNCw1MSA0MTYsNTEgNDE2LDUxIEM0MTYsNTEgMzk4LDUxIDM5OCw0MSBMMzk4LDE1ICIgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2Y2dndmZGcybWc3azcpIiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuNTsiLz48cGF0aCBkPSJNMzk4LDE1IEMzOTgsMjUgNDE2LDI1IDQxNiwyNSBDNDE2LDI1IDQzNCwyNSA0MzQsMTUgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuNTsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI3OCIgeD0iMzc0IiB5PSIzODYuMzU0NSI+REFUQUJBU0U8L3RleHQ+PHBhdGggZD0iTTM5OCwzOTkuNjU2MyBDMzk4LDM4OS42NTYzIDQxNiwzODkuNjU2MyA0MTYsMzg5LjY1NjMgQzQxNiwzODkuNjU2MyA0MzQsMzg5LjY1NjMgNDM0LDM5OS42NTYzIEw0MzQsNDI1LjY1NjMgQzQzNCw0MzUuNjU2MyA0MTYsNDM1LjY1NjMgNDE2LDQzNS42NTYzIEM0MTYsNDM1LjY1NjMgMzk4LDQzNS42NTYzIDM5OCw0MjUuNjU2MyBMMzk4LDM5OS42NTYzICIgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2Y2dndmZGcybWc3azcpIiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuNTsiLz48cGF0aCBkPSJNMzk4LDM5OS42NTYzIEMzOTgsNDA5LjY1NjMgNDE2LDQwOS42NTYzIDQxNiw0MDkuNjU2MyBDNDE2LDQwOS42NTYzIDQzNCw0MDkuNjU2MyA0MzQsMzk5LjY1NjMgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuNTsiLz48cmVjdCBmaWxsPSIjRUVFRUVFIiBmaWx0ZXI9InVybCgjZjZ2d2ZkZzJtZzdrNykiIGhlaWdodD0iMyIgc3R5bGU9InN0cm9rZTojRUVFRUVFO3N0cm9rZS13aWR0aDoxLjA7IiB3aWR0aD0iNDYzIiB4PSIwIiB5PSI5Ny44NjMzIi8+PGxpbmUgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMCIgeDI9IjQ2MyIgeTE9Ijk3Ljg2MzMiIHkyPSI5Ny44NjMzIi8+PGxpbmUgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMCIgeDI9IjQ2MyIgeTE9IjEwMC44NjMzIiB5Mj0iMTAwLjg2MzMiLz48cmVjdCBmaWxsPSIjRUVFRUVFIiBmaWx0ZXI9InVybCgjZjZ2d2ZkZzJtZzdrNykiIGhlaWdodD0iMjMuMTMyOCIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjA7IiB3aWR0aD0iMTI3IiB4PSIxNjgiIHk9Ijg3LjI5NjkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTA4IiB4PSIxNzQiIHk9IjEwMy4zNjM4Ij4xLiDssqsg67KI7Ke4IFJlYWQ8L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIxMDAsMTM3LjU2MjUsOTAsMTQxLjU2MjUsMTAwLDE0NS41NjI1LDk2LDE0MS41NjI1IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjQwNCwxMzcuNTYyNSw0MTQsMTQxLjU2MjUsNDA0LDE0NS41NjI1LDQwOCwxNDEuNTYyNSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iOTQiIHgyPSI0MTAiIHkxPSIxNDEuNTYyNSIgeTI9IjE0MS41NjI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjM5IiB4PSIxMDYiIHk9IjEzNi40OTY2Ij5bUkVBRF06IFNFTEVDVCAqIEZST00gVVNFUiBMSU1JVCA1PC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9Ijg5IiB4Mj0iMTMxIiB5MT0iMTcwLjY5NTMiIHkyPSIxNzAuNjk1MyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjEzMSIgeDI9IjEzMSIgeTE9IjE3MC42OTUzIiB5Mj0iMTgzLjY5NTMiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI5MCIgeDI9IjEzMSIgeTE9IjE4My42OTUzIiB5Mj0iMTgzLjY5NTMiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjEwMCwxNzkuNjk1Myw5MCwxODMuNjk1MywxMDAsMTg3LjY5NTMsOTYsMTgzLjY5NTMiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE3OCIgeD0iOTYiIHk9IjE2NS42Mjk0Ij5bUFJPQ0VTU106IOuNsOydtO2EsCDqsIDqs7Uv7LKY66asPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNDA0LDIwOC44MjgxLDQxNCwyMTIuODI4MSw0MDQsMjE2LjgyODEsNDA4LDIxMi44MjgxIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI4OSIgeDI9IjQxMCIgeTE9IjIxMi44MjgxIiB5Mj0iMjEyLjgyODEiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNTkiIHg9Ijk2IiB5PSIyMDcuNzYyMiI+W1dSSVRFXTog642w7J207YSwIOyeheugpS/siJjsoJU8L3RleHQ+PHJlY3QgZmlsbD0iI0VFRUVFRSIgZmlsdGVyPSJ1cmwoI2Y2dndmZGcybWc3azcpIiBoZWlnaHQ9IjMiIHN0eWxlPSJzdHJva2U6I0VFRUVFRTtzdHJva2Utd2lkdGg6MS4wOyIgd2lkdGg9IjQ2MyIgeD0iMCIgeT0iMjQxLjM5NDUiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIwIiB4Mj0iNDYzIiB5MT0iMjQxLjM5NDUiIHkyPSIyNDEuMzk0NSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjAiIHgyPSI0NjMiIHkxPSIyNDQuMzk0NSIgeTI9IjI0NC4zOTQ1Ii8+PHJlY3QgZmlsbD0iI0VFRUVFRSIgZmlsdGVyPSJ1cmwoI2Y2dndmZGcybWc3azcpIiBoZWlnaHQ9IjIzLjEzMjgiIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6Mi4wOyIgd2lkdGg9IjEyNyIgeD0iMTY4IiB5PSIyMzAuODI4MSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMDgiIHg9IjE3NCIgeT0iMjQ2Ljg5NSI+Mi4g65GQIOuyiOynuCBSZWFkPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMTAwLDI4MS4wOTM4LDkwLDI4NS4wOTM4LDEwMCwyODkuMDkzOCw5NiwyODUuMDkzOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSI0MDQsMjgxLjA5MzgsNDE0LDI4NS4wOTM4LDQwNCwyODkuMDkzOCw0MDgsMjg1LjA5MzgiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9Ijk0IiB4Mj0iNDEwIiB5MT0iMjg1LjA5MzgiIHkyPSIyODUuMDkzOCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjMwMyIgeD0iMTA2IiB5PSIyODAuMDI3OCI+W1JFQURdOiBTRUxFQ1QgKiBGUk9NIFVTRVIgT0ZGU0VUIDUgTElNSVQgNTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI4OSIgeDI9IjEzMSIgeTE9IjMxNC4yMjY2IiB5Mj0iMzE0LjIyNjYiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIxMzEiIHgyPSIxMzEiIHkxPSIzMTQuMjI2NiIgeTI9IjMyNy4yMjY2Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iOTAiIHgyPSIxMzEiIHkxPSIzMjcuMjI2NiIgeTI9IjMyNy4yMjY2Ii8+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIxMDAsMzIzLjIyNjYsOTAsMzI3LjIyNjYsMTAwLDMzMS4yMjY2LDk2LDMyNy4yMjY2IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNzgiIHg9Ijk2IiB5PSIzMDkuMTYwNiI+W1BST0NFU1NdOiDrjbDsnbTthLAg6rCA6rO1L+yymOumrDwvdGV4dD48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjQwNCwzNTIuMzU5NCw0MTQsMzU2LjM1OTQsNDA0LDM2MC4zNTk0LDQwOCwzNTYuMzU5NCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iODkiIHgyPSI0MTAiIHkxPSIzNTYuMzU5NCIgeTI9IjM1Ni4zNTk0Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTU5IiB4PSI5NiIgeT0iMzUxLjI5MzUiPltXUklURV06IOuNsOydtO2EsCDsnoXroKUv7IiY7KCVPC90ZXh0PjwhLS1NRDU9W2FhZTQwNzY3ZWM3ODc1NTNlYmJkYTAwMjhhNjQ0YmZjXQpAc3RhcnR1bWwNCnBhcnRpY2lwYW50IEJBVENIX0FQUExJQ0FUSU9ODQpkYXRhYmFzZSBEQVRBQkFTRQ0KDQo9PSAxLiDssqsg67KI7Ke4IFJlYWQgPT0NCkJBVENIX0FQUExJQ0FUSU9OIDwtPiBEQVRBQkFTRSA6IFtSRUFEXTogU0VMRUNUICogRlJPTSBVU0VSIExJTUlUIDUNCkJBVENIX0FQUExJQ0FUSU9OIC0+IEJBVENIX0FQUExJQ0FUSU9OIDogW1BST0NFU1NdOiDrjbDsnbTthLAg6rCA6rO1L+yymOumrA0KQkFUQ0hfQVBQTElDQVRJT04gLT4gREFUQUJBU0U6IFtXUklURV06IOuNsOydtO2EsCDsnoXroKUv7IiY7KCVDQo9PSAyLiDrkZAg67KI7Ke4IFJlYWQgPT0NCkJBVENIX0FQUExJQ0FUSU9OIDwtPiBEQVRBQkFTRSA6IFtSRUFEXTogU0VMRUNUICogRlJPTSBVU0VSIE9GRlNFVCA1IExJTUlUIDUNCkJBVENIX0FQUExJQ0FUSU9OIC0+IEJBVENIX0FQUExJQ0FUSU9OIDogW1BST0NFU1NdOiDrjbDsnbTthLAg6rCA6rO1L+yymOumrA0KQkFUQ0hfQVBQTElDQVRJT04gLT4gREFUQUJBU0U6IFtXUklURV06IOuNsOydtO2EsCDsnoXroKUv7IiY7KCVDQpAZW5kdW1sDQoKUGxhbnRVTUwgdmVyc2lvbiAxLjIwMjEuMTBiZXRhMihVbmtub3duIGNvbXBpbGUgdGltZSkKKEdQTCBzb3VyY2UgZGlzdHJpYnV0aW9uKQpKYXZhIFJ1bnRpbWU6IEphdmEoVE0pIFNFIFJ1bnRpbWUgRW52aXJvbm1lbnQKSlZNOiBKYXZhIEhvdFNwb3QoVE0pIDY0LUJpdCBTZXJ2ZXIgVk0KRGVmYXVsdCBFbmNvZGluZzogVVRGLTgKTGFuZ3VhZ2U6IGVuCkNvdW50cnk6IFVTCi0tPjwvZz48L3N2Zz4='>\n\n<ul>\n<li>청크 단위로 데이터를 가져오도록 기본 구현이 되어 있기 때문에 5개의 아이템을 건너 뛰게 되는 상황이 생길 수 있다. 실제 두 번째 단계에서 올바른 데이터를 가져오기 위해서는 <code>OFFSET 5</code>을 빼놓고 SQL문을 질의해야 한다. </li>\n<li>OFFSET 적용을 피하기 위해서는 아래와 같이 <code>JpaPagingItemReader</code>의 getPage를 오버라이드하여 매번 첫 번째 페이지만 참조할 수 있도록 변경하면 된다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JpaPagingItemReader&lt;User&gt; jpaPagingItemReader = <span class=\"keyword\">new</span> JpaPagingItemReader&lt;User&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getPage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RepositoryItemReader\"><a href=\"#RepositoryItemReader\" class=\"headerlink\" title=\"RepositoryItemReader\"></a>RepositoryItemReader</h4><ul>\n<li><code>PagingAndSortingRepository</code>룰 활용한 ItemReader 구현체</li>\n<li><code>RepositoryItemReader</code>를 직접 생성하는 방법과 빌더 구현체인 <code>RepositoryItemReaderBuilder</code>를 통하여 <code>RepositoryItemReader</code> 인스턴스를 생성하는 방법이 있다.</li>\n<li>구현 시, 주의해야 할 점은 Repository에서 Pageable 타입 혹은 하위 타입을 반환해야 하는점과 매소드 마지막 인자에 Pageable 인자를 포함해야 하는 점이다. 아래 예제 코드를 참고하자.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. Pageable 타입을 반환해야 하며, 인자 마지막에 Pageable 타입의 인스턴스를 포함해야 함.</span></span><br><span class=\"line\">    <span class=\"function\">Page&lt;User&gt; <span class=\"title\">findByUpdatedDateBeforeAndStatusEquals</span><span class=\"params\">(LocalDateTime localDateTime, UserStatus status, Pageable pageable)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@StepScope</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RepositoryItemReader&lt;User&gt; <span class=\"title\">itemReader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RepositoryItemReaderBuilder()</span><br><span class=\"line\">        .repository(userRepository)</span><br><span class=\"line\">        .methodName(<span class=\"string\">&quot;findByUpdatedDateBeforeAndStatusEquals&quot;</span>)</span><br><span class=\"line\">        .pageSize(CHUNK_SIZE)</span><br><span class=\"line\">        .maxItemCount(CHUNK_SIZE)</span><br><span class=\"line\">        .arguments(Arrays.asList(LocalDateTime.now().minusYears(<span class=\"number\">1</span>), UserStatus.ACTIVE))</span><br><span class=\"line\">        .sorts(Collections.singletonMap(<span class=\"string\">&quot;idx&quot;</span>, Sort.Direction.ASC))</span><br><span class=\"line\">        .name(<span class=\"string\">&quot;repositoryItemReader&quot;</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><code>RepositoryItemReader</code>도 마찬가지로 <code>JpaPagingItemReader</code>와 같이 지정해놓은 pageSize에 의거하여 건너뛰는 SQL 구문이 포함됨을 확인할 수 있었다. 이를 회피하기 위해서는 <code>doPageRead</code> 메소드를 오버라이드하여 첫 번째 페이지만 호출되도록 수정하면 된다. <strong>아래 이미지의 주석 내용을 살펴보도록 하자</strong><br><img src=\"https://i.imgur.com/vnUQFi9.png\" alt=\"RepositoryItemReader.doPageRead()\"></li>\n</ul>\n<blockquote>\n<p>실무에서는 JPA를 원활하게 사용하기 위해, querydsl 혹은 Specification API를 사용하게 되는데, 이를 사용하기 위해서는 결국 Custom ItemReader를 구현해서 사용하는 방법밖에 없는거 같다.</p>\n</blockquote>\n<h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><ul>\n<li><a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=14031681\">처음 배우는 스프링 부트 2</a></li>\n<li><a href=\"https://docs.spring.io/spring-batch/4.1.x/reference/html/index.html\">Spring Batch - Reference Documentation</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"스프링-부트-배치-2-ItemReader\"><a href=\"#스프링-부트-배치-2-ItemReader\" class=\"headerlink\" title=\"스프링 부트 배치 #2 - ItemReader\"></a>스프링 부트 배치 #2 - ItemReader</h1><h2 id=\"2-1-ItemReader\"><a href=\"#2-1-ItemReader\" class=\"headerlink\" title=\"2.1 ItemReader\"></a>2.1 ItemReader</h2><ul>\n<li>스프링 배치에서는 상황에 맞는 <code>ItemReader</code> 구현체를 제공</li>\n<li><code>ItemReader</code>는 쓰레드 세이프하지 않기 때문에(Non-Thread-Safe) 쓰레드 간 경합이 발생하지 않도록 주의해야 한다.<ul>\n<li>스프링 배치에서는 이를 보완하기 위해, <code>SynchronizedItemStreamReader</code> 구현체를 제공하며, 이를 생성할 수 있는 빌더 구현체인 <code>SynchronizedItemStreamReaderBuilder</code> 또한 제공한다.</li>\n</ul>\n</li>\n<li>Flat-File, Message-Queue(AMQP), Database(RDBMS, Mongodb) 등의 ItemReader 구현체들이 존재하며, 스프링 배치에서 제공하고 있는 구현체들은 <a href=\"https://docs.spring.io/spring-batch/4.0.x/reference/html/appendix.html#listOfReadersAndWriters\">링크</a>를 통해 확인 가능하다.</li>\n<li>스프링 배치에서 제공하지 않은, Custom ItemReader가 필요한 경우, ItemReader 인터페이스를 상속하게 ItemReader 구현체를 작성하면 된다.</li>\n</ul>\n<h2 id=\"2-2-ListItemReader\"><a href=\"#2-2-ListItemReader\" class=\"headerlink\" title=\"2.2 ListItemReader\"></a>2.2 ListItemReader</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@StepScope</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ListItemReader&lt;User&gt; <span class=\"title\">itemReader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;User&gt; oldUsers = userRepository.findByUpdatedDateBeforeAndStatusEquals(</span><br><span class=\"line\">        LocalDateTime.now().minusYears(<span class=\"number\">1</span>), UserStatus.AVTIVE</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListItemReader&lt;&gt;(oldUsers);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ListItemReader를 사용하면, 읽어온 리스트 데이터를 메모리에 올려두고 ItemReader.read()를 사용하여 하나씩 처리 작업을 수행한다. </li>\n<li>하지만, 전체 데이터를 메모리에 올려두고 사용하는 것은 비효율적이기 때문에, 이를 나눠서 처리 할 수 있는 <code>PagingItemReader</code> 구현체를 사용 할 수 있다.</li>\n</ul>\n<h2 id=\"2-3-Database-Readers\"><a href=\"#2-3-Database-Readers\" class=\"headerlink\" title=\"2.3 Database Readers\"></a>2.3 Database Readers</h2><p>데이터베이스를 기준으로 ItemReader의 구현체를 나눌 때, <code>Cursor Based ItemReader</code>과 <code>Paging Based ItemReader</code>으로 나눌 수 있다.</p>\n<h3 id=\"Cursor-Based-ItemReader\"><a href=\"#Cursor-Based-ItemReader\" class=\"headerlink\" title=\"Cursor Based ItemReader\"></a>Cursor Based ItemReader</h3><p><img src=\"https://docs.spring.io/spring-batch/4.0.x/reference/html/images/cursorExample.png\"></p>\n<ul>\n<li>관계형 데이터베이스에서 데이터를 Streaming 해오는 전통적인 방법으로 <code>ResultSet</code>을 통하여 커서를 유지하여 row 단위로 데이터를 가져오게 하는 방법을 많이 사용한다.</li>\n<li>Spring Batch에서 Cursor Based ItemReader 구현은 초기화 시 커서를 열고 모든 호출에 대해 커서를 한 행 앞으로 이동시킨다. 커서 이동은 read()를 호출하면서 일어난다.</li>\n<li>Spring Batch에서는 <code>JdbcCursorItemReader</code> 구현체를 제공하며 <code>DataSource</code>로부터 얻은 연결을 통하여 SQL 문을 실행하고 이를 <code>ResultSet</code>을 이용하여 커서 기반으로 데이터를 가져온다. <code>JdbcCursorItemReader</code>은 <code>JdbcCursorItemReaderBuilder</code>을 통하여 생성 할 수 있으며 예제 코드는 아래와 같다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> JdbcCursorItemReader&lt;CustomerCredit&gt; <span class=\"title\">itemReader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcCursorItemReaderBuilder&lt;CustomerCredit&gt;()</span><br><span class=\"line\">                        .dataSource(<span class=\"keyword\">this</span>.dataSource)</span><br><span class=\"line\">                        .name(<span class=\"string\">&quot;creditReader&quot;</span>)</span><br><span class=\"line\">                        .sql(<span class=\"string\">&quot;select ID, NAME, CREDIT from CUSTOMER&quot;</span>)</span><br><span class=\"line\">                        .rowMapper(<span class=\"keyword\">new</span> CustomerCreditRowMapper())</span><br><span class=\"line\">                        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>이 밖에도 아래와 같은 ItemReader 구현체도 스프링 배치에서 제공하고 있다. 상황에 맞게 구현하면 된다.<ul>\n<li><a href=\"https://docs.spring.io/spring-batch/4.0.x/reference/html/readersAndWriters.html#HibernateCursorItemReader\"><code>HibernateCursorItemReader</code></a></li>\n<li><a href=\"https://docs.spring.io/spring-batch/4.0.x/reference/html/readersAndWriters.html#StoredProcedureItemReader\"><code>StoredProcedureItemReader</code></a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Paging-Based-ItemReader\"><a href=\"#Paging-Based-ItemReader\" class=\"headerlink\" title=\"Paging Based ItemReader\"></a>Paging Based ItemReader</h3><ul>\n<li>Cursor 기반의 ItemReader의 경우, 데이터베이스 커넥션을 지속적으로 독점으로 사용하여 처리가 완료되는 시점까지 커넥션을 놓아주지 않기 때문에, 경우에 따라 성능상에 영향을 줄 수 있다. 처리 해야 할 데이터가 크다면 Cursor 기반이 아닌 Pagination 기반의 구현을 사용하는 것이 유리하다. </li>\n<li>Pagination 기반의 ItemReader의 구현체는 <code>JdbcPagingItemReader</code>, <code>JpaPagingItemReader</code>이 있다.</li>\n</ul>\n<h4 id=\"JdbcPagingItemReader\"><a href=\"#JdbcPagingItemReader\" class=\"headerlink\" title=\"JdbcPagingItemReader\"></a>JdbcPagingItemReader</h4><ul>\n<li><code>JdbcPagingItemReader</code>을 사용할 때, SQL 쿼리를 제공 <code>PagingQueryProvider</code>가 필요</li>\n<li>데이터베이스마다 페이징을 처리하는 구문과 전략이 다르기 때문에 이를 지정해줘야 한다. 지원되는 각 데이터베이스 유형마다 다른 <code>PagingQueryProvider</code>를 사용해야합니다</li>\n<li>또한 사용중인 데이터베이스를 자동으로 검색하고 적절한 <code>PagingQueryProvider</code> 구현을 결정하는 <code>SqlPagingQueryProviderFactoryBean</code>이 있다. <code>SqlPagingQueryProviderFactoryBean</code>은 select절, from절 및 sortKey 구문을 반드시 지정해야하며, where절은 필수가 아닌 옵션으로 설정 할 수 있다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> JdbcPagingItemReader <span class=\"title\">itemReader</span><span class=\"params\">(DataSource dataSource)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; parameterValues = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        parameterValues.put(<span class=\"string\">&quot;status&quot;</span>, <span class=\"string\">&quot;NEW&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcPagingItemReaderBuilder&lt;CustomerCredit&gt;()</span><br><span class=\"line\">                                           .name(<span class=\"string\">&quot;creditReader&quot;</span>)</span><br><span class=\"line\">                                           .dataSource(dataSource)</span><br><span class=\"line\">                                           .queryProvider(queryProvider())</span><br><span class=\"line\">                                           .parameterValues(parameterValues)</span><br><span class=\"line\">                                           .rowMapper(customerCreditMapper())</span><br><span class=\"line\">                                           .pageSize(<span class=\"number\">1000</span>)</span><br><span class=\"line\">                                           .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlPagingQueryProviderFactoryBean <span class=\"title\">queryProvider</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        SqlPagingQueryProviderFactoryBean provider = <span class=\"keyword\">new</span> SqlPagingQueryProviderFactoryBean();</span><br><span class=\"line\"></span><br><span class=\"line\">        provider.setSelectClause(<span class=\"string\">&quot;select id, name, credit&quot;</span>);</span><br><span class=\"line\">        provider.setFromClause(<span class=\"string\">&quot;from customer&quot;</span>);</span><br><span class=\"line\">        provider.setWhereClause(<span class=\"string\">&quot;where status=:status&quot;</span>);</span><br><span class=\"line\">        provider.setSortKey(<span class=\"string\">&quot;id&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> provider;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"JpaPagingItemReader\"><a href=\"#JpaPagingItemReader\" class=\"headerlink\" title=\"JpaPagingItemReader\"></a>JpaPagingItemReader</h4><ul>\n<li><code>JpaPagingItemReader</code>를 통하여 지정한 페이지 사이즈만큼 데이터를 가져와서 처리 가능하다.</li>\n<li>조회한 데이터는 JPA 영속성 컨텍스트상에서 <code>DETACH</code>상태이기 때문에, 영속성 컨텍스트의 관리 대상에서 벗어나게 된다.</li>\n<li><code>JpaPagingItemReaderBuilder</code>를 통하여 생성 가능하며, <code>JpaPagingItemReader</code>를 직접 생성하는 것도 가능하다.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JpaPagingItemReaderBuilder를 통한 생성</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> JpaPagingItemReader <span class=\"title\">itemReader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JpaPagingItemReaderBuilder&lt;CustomerCredit&gt;()</span><br><span class=\"line\">                                        .name(<span class=\"string\">&quot;creditReader&quot;</span>)</span><br><span class=\"line\">                                        .entityManagerFactory(entityManagerFactory())</span><br><span class=\"line\">                                        .queryString(<span class=\"string\">&quot;select c from CustomerCredit c&quot;</span>)</span><br><span class=\"line\">                                        .pageSize(<span class=\"number\">1000</span>)</span><br><span class=\"line\">                                        .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 직접 생성</span></span><br><span class=\"line\"><span class=\"meta\">@Bean(destroyMethod = &quot;&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@StepScope</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> JpaPagingItemReader&lt;User&gt; <span class=\"title\">itemReader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    JpaPagingItemReader&lt;User&gt; jpaPagingItemReader = <span class=\"keyword\">new</span> JpaPagingItemReader&lt;User&gt;()</span><br><span class=\"line\">    jpaPagingItemReader.setQueryString(</span><br><span class=\"line\">        <span class=\"string\">&quot;select u from User as u where u.updatedDate &lt; :updatedDate and u.status = :status&quot;</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">    HashMap&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    map.put(<span class=\"string\">&quot;updatedDate&quot;</span>, LocalDateTime.now().minusYears(<span class=\"number\">1</span>));</span><br><span class=\"line\">    map.put(<span class=\"string\">&quot;status&quot;</span>, UserStatus.ACTIVE);</span><br><span class=\"line\">    jpaPagingItemReader.setParameterValues(map);</span><br><span class=\"line\">    jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory);</span><br><span class=\"line\">    jpaPagingItemReader.setPageSize(CHUNK_SIZE);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jpaPagingItemReader;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>JpaPagingItemReader</code> 내부에서 <code>EntityManager</code>를 할당 받아서 사용한다. <code>EntityManagerFactory</code>를 통하여 생성한 <code>EntityManager</code>에서 지정한 크기대로 데이터를 가져오기 때문에 예를 들어 10개씩 <code>[읽기] -&gt; [처리] -&gt; [쓰기]</code>를 하는 Step이 있다고 했을 때, 처음 이후의 처리에 대해 데이터 건너뛰기가 발생 할 수 있다.</li>\n</ul>\n<img src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U2NyaXB0VHlwZT0iYXBwbGljYXRpb24vZWNtYXNjcmlwdCIgY29udGVudFN0eWxlVHlwZT0idGV4dC9jc3MiIGhlaWdodD0iNDQycHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDo0NzBweDtoZWlnaHQ6NDQycHg7YmFja2dyb3VuZDojRkZGRkZGOyIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgNDcwIDQ0MiIgd2lkdGg9IjQ3MHB4IiB6b29tQW5kUGFuPSJtYWduaWZ5Ij48ZGVmcz48ZmlsdGVyIGhlaWdodD0iMzAwJSIgaWQ9ImY2dndmZGcybWc3azciIHdpZHRoPSIzMDAlIiB4PSItMSIgeT0iLTEiPjxmZUdhdXNzaWFuQmx1ciByZXN1bHQ9ImJsdXJPdXQiIHN0ZERldmlhdGlvbj0iMi4wIi8+PGZlQ29sb3JNYXRyaXggaW49ImJsdXJPdXQiIHJlc3VsdD0iYmx1ck91dDIiIHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAuNCAwIi8+PGZlT2Zmc2V0IGR4PSI0LjAiIGR5PSI0LjAiIGluPSJibHVyT3V0MiIgcmVzdWx0PSJibHVyT3V0MyIvPjxmZUJsZW5kIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9ImJsdXJPdXQzIiBtb2RlPSJub3JtYWwiLz48L2ZpbHRlcj48L2RlZnM+PGc+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9Ijg5IiB4Mj0iODkiIHkxPSI2Ny4yOTY5IiB5Mj0iMzc0LjM1OTQiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjUuMCw1LjA7IiB4MT0iNDE2IiB4Mj0iNDE2IiB5MT0iNjcuMjk2OSIgeTI9IjM3NC4zNTk0Ii8+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2Y2dndmZGcybWc3azcpIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjE2NCIgeD0iNSIgeT0iMzIiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNTAiIHg9IjEyIiB5PSI1MS45OTUxIj5CQVRDSF9BUFBMSUNBVElPTjwvdGV4dD48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjZ2d2ZkZzJtZzdrNykiIGhlaWdodD0iMzAuMjk2OSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTY0IiB4PSI1IiB5PSIzNzMuMzU5NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE1MCIgeD0iMTIiIHk9IjM5My4zNTQ1Ij5CQVRDSF9BUFBMSUNBVElPTjwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI3OCIgeD0iMzc0IiB5PSI2My45OTUxIj5EQVRBQkFTRTwvdGV4dD48cGF0aCBkPSJNMzk4LDE1IEMzOTgsNSA0MTYsNSA0MTYsNSBDNDE2LDUgNDM0LDUgNDM0LDE1IEw0MzQsNDEgQzQzNCw1MSA0MTYsNTEgNDE2LDUxIEM0MTYsNTEgMzk4LDUxIDM5OCw0MSBMMzk4LDE1ICIgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2Y2dndmZGcybWc3azcpIiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuNTsiLz48cGF0aCBkPSJNMzk4LDE1IEMzOTgsMjUgNDE2LDI1IDQxNiwyNSBDNDE2LDI1IDQzNCwyNSA0MzQsMTUgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuNTsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI3OCIgeD0iMzc0IiB5PSIzODYuMzU0NSI+REFUQUJBU0U8L3RleHQ+PHBhdGggZD0iTTM5OCwzOTkuNjU2MyBDMzk4LDM4OS42NTYzIDQxNiwzODkuNjU2MyA0MTYsMzg5LjY1NjMgQzQxNiwzODkuNjU2MyA0MzQsMzg5LjY1NjMgNDM0LDM5OS42NTYzIEw0MzQsNDI1LjY1NjMgQzQzNCw0MzUuNjU2MyA0MTYsNDM1LjY1NjMgNDE2LDQzNS42NTYzIEM0MTYsNDM1LjY1NjMgMzk4LDQzNS42NTYzIDM5OCw0MjUuNjU2MyBMMzk4LDM5OS42NTYzICIgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2Y2dndmZGcybWc3azcpIiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuNTsiLz48cGF0aCBkPSJNMzk4LDM5OS42NTYzIEMzOTgsNDA5LjY1NjMgNDE2LDQwOS42NTYzIDQxNiw0MDkuNjU2MyBDNDE2LDQwOS42NTYzIDQzNCw0MDkuNjU2MyA0MzQsMzk5LjY1NjMgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuNTsiLz48cmVjdCBmaWxsPSIjRUVFRUVFIiBmaWx0ZXI9InVybCgjZjZ2d2ZkZzJtZzdrNykiIGhlaWdodD0iMyIgc3R5bGU9InN0cm9rZTojRUVFRUVFO3N0cm9rZS13aWR0aDoxLjA7IiB3aWR0aD0iNDYzIiB4PSIwIiB5PSI5Ny44NjMzIi8+PGxpbmUgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMCIgeDI9IjQ2MyIgeTE9Ijk3Ljg2MzMiIHkyPSI5Ny44NjMzIi8+PGxpbmUgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMCIgeDI9IjQ2MyIgeTE9IjEwMC44NjMzIiB5Mj0iMTAwLjg2MzMiLz48cmVjdCBmaWxsPSIjRUVFRUVFIiBmaWx0ZXI9InVybCgjZjZ2d2ZkZzJtZzdrNykiIGhlaWdodD0iMjMuMTMyOCIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjA7IiB3aWR0aD0iMTI3IiB4PSIxNjgiIHk9Ijg3LjI5NjkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTA4IiB4PSIxNzQiIHk9IjEwMy4zNjM4Ij4xLiDssqsg67KI7Ke4IFJlYWQ8L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIxMDAsMTM3LjU2MjUsOTAsMTQxLjU2MjUsMTAwLDE0NS41NjI1LDk2LDE0MS41NjI1IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjQwNCwxMzcuNTYyNSw0MTQsMTQxLjU2MjUsNDA0LDE0NS41NjI1LDQwOCwxNDEuNTYyNSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iOTQiIHgyPSI0MTAiIHkxPSIxNDEuNTYyNSIgeTI9IjE0MS41NjI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjM5IiB4PSIxMDYiIHk9IjEzNi40OTY2Ij5bUkVBRF06IFNFTEVDVCAqIEZST00gVVNFUiBMSU1JVCA1PC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9Ijg5IiB4Mj0iMTMxIiB5MT0iMTcwLjY5NTMiIHkyPSIxNzAuNjk1MyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjEzMSIgeDI9IjEzMSIgeTE9IjE3MC42OTUzIiB5Mj0iMTgzLjY5NTMiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI5MCIgeDI9IjEzMSIgeTE9IjE4My42OTUzIiB5Mj0iMTgzLjY5NTMiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjEwMCwxNzkuNjk1Myw5MCwxODMuNjk1MywxMDAsMTg3LjY5NTMsOTYsMTgzLjY5NTMiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE3OCIgeD0iOTYiIHk9IjE2NS42Mjk0Ij5bUFJPQ0VTU106IOuNsOydtO2EsCDqsIDqs7Uv7LKY66asPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNDA0LDIwOC44MjgxLDQxNCwyMTIuODI4MSw0MDQsMjE2LjgyODEsNDA4LDIxMi44MjgxIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI4OSIgeDI9IjQxMCIgeTE9IjIxMi44MjgxIiB5Mj0iMjEyLjgyODEiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNTkiIHg9Ijk2IiB5PSIyMDcuNzYyMiI+W1dSSVRFXTog642w7J207YSwIOyeheugpS/siJjsoJU8L3RleHQ+PHJlY3QgZmlsbD0iI0VFRUVFRSIgZmlsdGVyPSJ1cmwoI2Y2dndmZGcybWc3azcpIiBoZWlnaHQ9IjMiIHN0eWxlPSJzdHJva2U6I0VFRUVFRTtzdHJva2Utd2lkdGg6MS4wOyIgd2lkdGg9IjQ2MyIgeD0iMCIgeT0iMjQxLjM5NDUiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIwIiB4Mj0iNDYzIiB5MT0iMjQxLjM5NDUiIHkyPSIyNDEuMzk0NSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjAiIHgyPSI0NjMiIHkxPSIyNDQuMzk0NSIgeTI9IjI0NC4zOTQ1Ii8+PHJlY3QgZmlsbD0iI0VFRUVFRSIgZmlsdGVyPSJ1cmwoI2Y2dndmZGcybWc3azcpIiBoZWlnaHQ9IjIzLjEzMjgiIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6Mi4wOyIgd2lkdGg9IjEyNyIgeD0iMTY4IiB5PSIyMzAuODI4MSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMDgiIHg9IjE3NCIgeT0iMjQ2Ljg5NSI+Mi4g65GQIOuyiOynuCBSZWFkPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMTAwLDI4MS4wOTM4LDkwLDI4NS4wOTM4LDEwMCwyODkuMDkzOCw5NiwyODUuMDkzOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSI0MDQsMjgxLjA5MzgsNDE0LDI4NS4wOTM4LDQwNCwyODkuMDkzOCw0MDgsMjg1LjA5MzgiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9Ijk0IiB4Mj0iNDEwIiB5MT0iMjg1LjA5MzgiIHkyPSIyODUuMDkzOCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjMwMyIgeD0iMTA2IiB5PSIyODAuMDI3OCI+W1JFQURdOiBTRUxFQ1QgKiBGUk9NIFVTRVIgT0ZGU0VUIDUgTElNSVQgNTwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSI4OSIgeDI9IjEzMSIgeTE9IjMxNC4yMjY2IiB5Mj0iMzE0LjIyNjYiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIxMzEiIHgyPSIxMzEiIHkxPSIzMTQuMjI2NiIgeTI9IjMyNy4yMjY2Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iOTAiIHgyPSIxMzEiIHkxPSIzMjcuMjI2NiIgeTI9IjMyNy4yMjY2Ii8+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIxMDAsMzIzLjIyNjYsOTAsMzI3LjIyNjYsMTAwLDMzMS4yMjY2LDk2LDMyNy4yMjY2IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNzgiIHg9Ijk2IiB5PSIzMDkuMTYwNiI+W1BST0NFU1NdOiDrjbDsnbTthLAg6rCA6rO1L+yymOumrDwvdGV4dD48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjQwNCwzNTIuMzU5NCw0MTQsMzU2LjM1OTQsNDA0LDM2MC4zNTk0LDQwOCwzNTYuMzU5NCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iODkiIHgyPSI0MTAiIHkxPSIzNTYuMzU5NCIgeTI9IjM1Ni4zNTk0Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTU5IiB4PSI5NiIgeT0iMzUxLjI5MzUiPltXUklURV06IOuNsOydtO2EsCDsnoXroKUv7IiY7KCVPC90ZXh0PjwhLS1NRDU9W2FhZTQwNzY3ZWM3ODc1NTNlYmJkYTAwMjhhNjQ0YmZjXQpAc3RhcnR1bWwNCnBhcnRpY2lwYW50IEJBVENIX0FQUExJQ0FUSU9ODQpkYXRhYmFzZSBEQVRBQkFTRQ0KDQo9PSAxLiDssqsg67KI7Ke4IFJlYWQgPT0NCkJBVENIX0FQUExJQ0FUSU9OIDwtPiBEQVRBQkFTRSA6IFtSRUFEXTogU0VMRUNUICogRlJPTSBVU0VSIExJTUlUIDUNCkJBVENIX0FQUExJQ0FUSU9OIC0+IEJBVENIX0FQUExJQ0FUSU9OIDogW1BST0NFU1NdOiDrjbDsnbTthLAg6rCA6rO1L+yymOumrA0KQkFUQ0hfQVBQTElDQVRJT04gLT4gREFUQUJBU0U6IFtXUklURV06IOuNsOydtO2EsCDsnoXroKUv7IiY7KCVDQo9PSAyLiDrkZAg67KI7Ke4IFJlYWQgPT0NCkJBVENIX0FQUExJQ0FUSU9OIDwtPiBEQVRBQkFTRSA6IFtSRUFEXTogU0VMRUNUICogRlJPTSBVU0VSIE9GRlNFVCA1IExJTUlUIDUNCkJBVENIX0FQUExJQ0FUSU9OIC0+IEJBVENIX0FQUExJQ0FUSU9OIDogW1BST0NFU1NdOiDrjbDsnbTthLAg6rCA6rO1L+yymOumrA0KQkFUQ0hfQVBQTElDQVRJT04gLT4gREFUQUJBU0U6IFtXUklURV06IOuNsOydtO2EsCDsnoXroKUv7IiY7KCVDQpAZW5kdW1sDQoKUGxhbnRVTUwgdmVyc2lvbiAxLjIwMjEuMTBiZXRhMihVbmtub3duIGNvbXBpbGUgdGltZSkKKEdQTCBzb3VyY2UgZGlzdHJpYnV0aW9uKQpKYXZhIFJ1bnRpbWU6IEphdmEoVE0pIFNFIFJ1bnRpbWUgRW52aXJvbm1lbnQKSlZNOiBKYXZhIEhvdFNwb3QoVE0pIDY0LUJpdCBTZXJ2ZXIgVk0KRGVmYXVsdCBFbmNvZGluZzogVVRGLTgKTGFuZ3VhZ2U6IGVuCkNvdW50cnk6IFVTCi0tPjwvZz48L3N2Zz4='>\n\n<ul>\n<li>청크 단위로 데이터를 가져오도록 기본 구현이 되어 있기 때문에 5개의 아이템을 건너 뛰게 되는 상황이 생길 수 있다. 실제 두 번째 단계에서 올바른 데이터를 가져오기 위해서는 <code>OFFSET 5</code>을 빼놓고 SQL문을 질의해야 한다. </li>\n<li>OFFSET 적용을 피하기 위해서는 아래와 같이 <code>JpaPagingItemReader</code>의 getPage를 오버라이드하여 매번 첫 번째 페이지만 참조할 수 있도록 변경하면 된다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JpaPagingItemReader&lt;User&gt; jpaPagingItemReader = <span class=\"keyword\">new</span> JpaPagingItemReader&lt;User&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getPage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RepositoryItemReader\"><a href=\"#RepositoryItemReader\" class=\"headerlink\" title=\"RepositoryItemReader\"></a>RepositoryItemReader</h4><ul>\n<li><code>PagingAndSortingRepository</code>룰 활용한 ItemReader 구현체</li>\n<li><code>RepositoryItemReader</code>를 직접 생성하는 방법과 빌더 구현체인 <code>RepositoryItemReaderBuilder</code>를 통하여 <code>RepositoryItemReader</code> 인스턴스를 생성하는 방법이 있다.</li>\n<li>구현 시, 주의해야 할 점은 Repository에서 Pageable 타입 혹은 하위 타입을 반환해야 하는점과 매소드 마지막 인자에 Pageable 인자를 포함해야 하는 점이다. 아래 예제 코드를 참고하자.<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">User</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. Pageable 타입을 반환해야 하며, 인자 마지막에 Pageable 타입의 인스턴스를 포함해야 함.</span></span><br><span class=\"line\">    <span class=\"function\">Page&lt;User&gt; <span class=\"title\">findByUpdatedDateBeforeAndStatusEquals</span><span class=\"params\">(LocalDateTime localDateTime, UserStatus status, Pageable pageable)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@StepScope</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RepositoryItemReader&lt;User&gt; <span class=\"title\">itemReader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RepositoryItemReaderBuilder()</span><br><span class=\"line\">        .repository(userRepository)</span><br><span class=\"line\">        .methodName(<span class=\"string\">&quot;findByUpdatedDateBeforeAndStatusEquals&quot;</span>)</span><br><span class=\"line\">        .pageSize(CHUNK_SIZE)</span><br><span class=\"line\">        .maxItemCount(CHUNK_SIZE)</span><br><span class=\"line\">        .arguments(Arrays.asList(LocalDateTime.now().minusYears(<span class=\"number\">1</span>), UserStatus.ACTIVE))</span><br><span class=\"line\">        .sorts(Collections.singletonMap(<span class=\"string\">&quot;idx&quot;</span>, Sort.Direction.ASC))</span><br><span class=\"line\">        .name(<span class=\"string\">&quot;repositoryItemReader&quot;</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><code>RepositoryItemReader</code>도 마찬가지로 <code>JpaPagingItemReader</code>와 같이 지정해놓은 pageSize에 의거하여 건너뛰는 SQL 구문이 포함됨을 확인할 수 있었다. 이를 회피하기 위해서는 <code>doPageRead</code> 메소드를 오버라이드하여 첫 번째 페이지만 호출되도록 수정하면 된다. <strong>아래 이미지의 주석 내용을 살펴보도록 하자</strong><br><img src=\"https://i.imgur.com/vnUQFi9.png\" alt=\"RepositoryItemReader.doPageRead()\"></li>\n</ul>\n<blockquote>\n<p>실무에서는 JPA를 원활하게 사용하기 위해, querydsl 혹은 Specification API를 사용하게 되는데, 이를 사용하기 위해서는 결국 Custom ItemReader를 구현해서 사용하는 방법밖에 없는거 같다.</p>\n</blockquote>\n<h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><ul>\n<li><a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=14031681\">처음 배우는 스프링 부트 2</a></li>\n<li><a href=\"https://docs.spring.io/spring-batch/4.1.x/reference/html/index.html\">Spring Batch - Reference Documentation</a></li>\n</ul>\n"},{"title":"Logging","date":"2019-05-01T05:42:00.000Z","_content":"\n# Logging\n사내에서 최근 ELK 도입을 준비하고 있는 과정에서 로깅 포맷을 지정하고 사용해야 하는 Needs가 생겨서 이번 작업을 시작하게 되었다. 스프링 부트에서는 로깅 설정을 프로파일별로 다르게 지정 할 수 있으며, 또한 로깅 구현체에 대한 유연한 변경(log4j2 등)이 가능하므로 작업 자체의 난이도가 높지는 않다고 할 수 있다.\n\n## 다시 보는 로깅 레벨\n![](http://myblog.opendocs.co.kr/wp-content/uploads/2015/03/log4j-1024x453.png)\n- 출처: 구글 이미지 검색\n\n\n## Hibernate Logging 관련 이슈\n로깅 작업 중 Hibernate 관련 로깅이 slf4j에 제대로 적용이 안되는 이슈가 생겼었다. 이와 관련된 문서를 뒤져보다 [링크](https://medium.com/@scadge/how-to-enable-hibernate-logging-dc11545efd3d)를 통하여 해당 문제를 해결 할 수 있었다.\n\n링크의 내용을 요약하자면, 하이버네이트 로깅 설정이 초기화 되는 구간에서 실제 slf4j에서 사용하는 로거 설정이 적용되며 자바 프로세스 실행 시 `-Dorg.jboss.logging.provider=slf4j` 혹은 코드에서 `System.setProperty(\"org.jboss.logging.provider\", “slf4j\")` 명시적으로 slf4j를 사용하도록 설정을 해줘야지 hibernate에서 발생하는 쿼리 로깅이 slf4j를 사용하여 실행되는 것을 확인할 수 있었다.\n\n\n```java\n    // LoggerProviders.class\n    private static LoggerProvider findProvider() {\n        final ClassLoader cl = LoggerProviders.class.getClassLoader();\n        try {\n            // Check the system property\n            final String loggerProvider = AccessController.doPrivileged(new PrivilegedAction<String>() {\n                public String run() {\n                    return System.getProperty(LOGGING_PROVIDER_KEY);\n                }\n            });\n            if (loggerProvider != null) {\n                if (\"jboss\".equalsIgnoreCase(loggerProvider)) {\n                    return tryJBossLogManager(cl, \"system property\");\n                } else if (\"jdk\".equalsIgnoreCase(loggerProvider)) {\n                    return tryJDK(\"system property\");\n                } else if (\"log4j2\".equalsIgnoreCase(loggerProvider)) {\n                    return tryLog4j2(cl, \"system property\");\n                } else if (\"log4j\".equalsIgnoreCase(loggerProvider)) {\n                    return tryLog4j(cl, \"system property\");\n                } else if (\"slf4j\".equalsIgnoreCase(loggerProvider)) {\n                    return trySlf4j(\"system property\");\n                }\n            }\n        } catch (Throwable t) {\n            // nope...\n        }\n        // ... 이하 생략\n```\n\n\n```java\npublic void logStatement(String statement, Formatter formatter) {\n    if ( format ) {\n        if ( logToStdout || LOG.isDebugEnabled() ) {\n            statement = formatter.format( statement );\n        }\n    }\n    LOG.debug( statement );\n    if ( logToStdout ) {\n        System.out.println( \"Hibernate: \" + statement );\n    }\n}\n```\n\n\n### 기타 참고 링크\n- [Stackoverflow - Can't avoid hibernate logging SQL to console with Spring Boot and Logback](https://stackoverflow.com/questions/36496178/cant-avoid-hibernate-logging-sql-to-console-with-spring-boot-and-logback)\n- [Hibernate Log 남기기](http://kwonnam.pe.kr/wiki/java/hibernate/log)\n\n## 프로파일별 설정\n- [Profile-specific Configuration](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-logging.html#_profile_specific_configuration)\n\n스프링 부트에서는 프로파일별로 로깅 설정을 지정 할수 있도록 설정 할수 있다. 프로파일별로 달라지는 설정값은 `<springProperty>` 태그를 활용하여 분기 처리를 할 수 있다. 설정 값은 실행하는 프로파일의 `application.properties`의 값을 참조하게 된다.\n\n## [Logstash-logback-encoder](https://github.com/logstash/logstash-logback-encoder#async-appenders)\n로깅 포맷을 지정하는 과정에서, logback의 `JsonLayout`을 선 적용하여 설정을 했었는데, 어차피 ELK에서 사용하는 목적이 크기 때문에 포맷 자체를 ELK에서 Offical하게 사용하는 포맷을 사용하는 것이 더 나으리라 생각했다. 그래서 `Logstash-logback-encoder` 구현체를 사용하는 것으로 판단을 내렸고, 적용은 아래 내용을 참고하면 누구나 쉽게 할 수 있으리라 생각한다. 로컬 개발 환경에서는 굳이 해당 레이아웃을 적용할 필요가 없기 때문에, 스프링 부트에서 제공해주는 기본 로거 설정을 사용하도록 하였다.\n\n로그는 `logstash-logback-encoder`에서 제공해주는 TcpAppender를 사용하여 Logstash에 바로 보낼 수 있도록 설정하였으며, TCP를 사용하기 때문에 연결에 대한 reconnection, KeepAlive 설정을 추가로 적용했다. 일단 적용 후 추후 로그에 대한 유실 유무를 판단하여 FileBeat를 사용하는 등 개선점에 대해서는 모니터링 후 판단하기로 결정을 내렸다.\n\n로깅 프로퍼티의 경우, 현재 개발 환경에 Spring-Cloud-Sleuth를 사용하고 있어서 [해당 문서](https://cloud.spring.io/spring-cloud-sleuth/single/spring-cloud-sleuth.html#_json_logback_with_logstash)를 일정 부분 참고했다.\n\n- build.gradle\n```groovy\n    /**\n     * logstash-logback\n     */\n    compile('net.logstash.logback:logstash-logback-encoder:5.3')\n```\n\n- resources/logback-spring.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<configuration>\n\n    <!-- FILE Appender -->\n    <springProperty scope=\"context\" name=\"LOG_DIR\"        source=\"logging.path\"      defaultValue=\"/var/log/tomcat8\" />\n    <springProperty scope=\"context\" name=\"LOG_PATH_NAME\"  source=\"logging.file-name\" defaultValue=\"${LOG_DIR}/server-application.log\" />\n    <springProperty scope=\"context\" name=\"LOG_STASH_ADDR\" source=\"logging.log-stash\" defaultValue=\"{IP_ADDRESS}\" />\n    <springProperty scope=\"context\" name=\"APP_NAME\"       source=\"spring.zipkin.service.name\" defaultValue=\"DEFAULT_APP_NAME\" />\n\n    <appender name=\"file\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <file>${LOG_PATH_NAME}</file>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            <fileNamePattern>${LOG_PATH_NAME}.%d{yyyyMMdd}</fileNamePattern>\n            <maxHistory>60</maxHistory>\n        </rollingPolicy>\n\n        <encoder class=\"net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder\">\n            <providers>\n                <timestamp>\n                    <pattern>yyyy-MM-dd'T'HH:mm:ssZ</pattern>\n                    <timeZone>UTC</timeZone>\n                </timestamp>\n                <version/>\n                <logLevel/>\n                <threadName/>\n                <loggerName/>\n                <message />\n                <pattern>\n                    <pattern>\n                        {\n                        \"service\": \"${APP_NAME:-}\",\n                        \"traceId\": \"%X{X-B3-TraceId:-}\"\n                        }\n                    </pattern>\n                </pattern>\n            </providers>\n        </encoder>\n    </appender>\n\n    <!-- Logstash Appender -->\n    <appender name=\"stash\" class=\"net.logstash.logback.appender.LogstashTcpSocketAppender\">\n        <destination>${LOG_STASH_ADDR}</destination>\n        <keepAliveDuration>5 minutes</keepAliveDuration>\n        <reconnectionDelay>15 second</reconnectionDelay>\n\n        <encoder class=\"net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder\">\n            <providers>\n                <timestamp>\n                    <pattern>yyyy-MM-dd'T'HH:mm:ssZ</pattern>\n                    <timeZone>UTC</timeZone>\n                </timestamp>\n                <version/>\n                <logLevel/>\n                <threadName/>\n                <loggerName/>\n                <message />\n                <pattern>\n                    <pattern>\n                        {\n                        \"service\": \"${APP_NAME:-}\",\n                        \"traceId\": \"%X{X-B3-TraceId:-}\"\n                        }\n                    </pattern>\n                </pattern>\n\n            </providers>\n        </encoder>\n    </appender>\n    \n\n    <appender name=\"async-file\" class=\"ch.qos.logback.classic.AsyncAppender\">\n        <filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\">\n            <level>DEBUG</level>\n        </filter>\n        <!-- \n        발신자의 정보 (class명, 줄번호 등)가 추가되어 수집 서버로 전송여부를 결정합니다.\n        true 설정 시, 성능 저하를 일으킬 수 있습니다.        \n         -->\n        <param name=\"includeCallerData\" value=\"false\"/>\n        <!-- \n        - blocking queue의 최대 수용 갯수로 기본값은 256입니다.\n        - 대기열 용량의 20 % 미만이 남아있을 때 AsyncAppender는 WARN 및 ERROR 이벤트 만 유지하면서 TRACE, DEBUG 및 INFO 수준의 이벤트를 삭제합니다\n        -->        \n        <param name=\"queueSize\" value=\"2048\"/>\n        <!-- \n        false로 설정한 경우 큐가 가득찬 상황에서 appender는 메세지 유실을 방지하기 위해 application을 block 합니다. \n        true로 설정된 경우 application을 멈추지 않기 위해 메세지를 버립니다.\n        -->                \n        <param name=\"neverBlock\" value=\"true\"/>\n        <!-- \n        LoggerContext가 정지하면 AsyncAppender의 stop 메소드는 작업 스레드가 timeout 될때까지 대기합니다.\n        maxFlushTime를 사용하면, timeout 시간을 밀리초로 설정할 수 있습니다.\n        해당 시간안에 처리하지 못한 이벤트는 삭제됩니다.\n         -->\n        <param name=\"maxFlushTime\" value=\"60000\"/>\n        <appender-ref ref=\"file\" />\n    </appender>\n\n\n    <appender name=\"async-stash\" class=\"net.logstash.logback.appender.LoggingEventAsyncDisruptorAppender\">\n        <filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\">\n            <level>DEBUG</level>\n        </filter>\n        <waitStrategyType>sleeping</waitStrategyType>\n        <appender-ref ref=\"stash\" />\n    </appender>\n\n    <!-- Logger -->\n    <logger name=\"org.hibernate.SQL\" level=\"DEBUG\" />\n    <logger name=\"org.hibernate.tool.hbm2ddl\" level=\"DEBUG\"/>\n    <logger name=\"org.hibernate.stat\" level=\"DEBUG\" />\n    <logger name=\"org.hibernate.type.BasicTypeRegistry\" level=\"DEBUG\" />\n    <logger name=\"org.hibernate.type.descriptor.sql\" level=\"INFO\" />\n\n\n    <!-- Profile -->\n    <springProfile name=\"default | dev\">\n        <include resource=\"org/springframework/boot/logging/logback/base.xml\" />\n    </springProfile>\n\n    <springProfile name=\"stage\">\n        <root level=\"INFO\">\n            <appender-ref ref=\"async-stash\"/>\n            <appender-ref ref=\"async-file\"/>\n        </root>\n    </springProfile>\n\n    <springProfile name=\"live\">\n        <include resource=\"org/springframework/boot/logging/logback/base.xml\" />\n    </springProfile>\n\n</configuration>\n```\n\n## 참고\n- https://docs.toast.com/ko/Analytics/Log%20&%20Crash%20Search/ko/logback-sdk-guide/\n\n\n\n\n\n","source":"_posts/Spring/LOG.md","raw":"---\ntitle: 'Logging'\ndate: 2019.5.1. 14:42\ncategories:\n- Spring\n---\n\n# Logging\n사내에서 최근 ELK 도입을 준비하고 있는 과정에서 로깅 포맷을 지정하고 사용해야 하는 Needs가 생겨서 이번 작업을 시작하게 되었다. 스프링 부트에서는 로깅 설정을 프로파일별로 다르게 지정 할 수 있으며, 또한 로깅 구현체에 대한 유연한 변경(log4j2 등)이 가능하므로 작업 자체의 난이도가 높지는 않다고 할 수 있다.\n\n## 다시 보는 로깅 레벨\n![](http://myblog.opendocs.co.kr/wp-content/uploads/2015/03/log4j-1024x453.png)\n- 출처: 구글 이미지 검색\n\n\n## Hibernate Logging 관련 이슈\n로깅 작업 중 Hibernate 관련 로깅이 slf4j에 제대로 적용이 안되는 이슈가 생겼었다. 이와 관련된 문서를 뒤져보다 [링크](https://medium.com/@scadge/how-to-enable-hibernate-logging-dc11545efd3d)를 통하여 해당 문제를 해결 할 수 있었다.\n\n링크의 내용을 요약하자면, 하이버네이트 로깅 설정이 초기화 되는 구간에서 실제 slf4j에서 사용하는 로거 설정이 적용되며 자바 프로세스 실행 시 `-Dorg.jboss.logging.provider=slf4j` 혹은 코드에서 `System.setProperty(\"org.jboss.logging.provider\", “slf4j\")` 명시적으로 slf4j를 사용하도록 설정을 해줘야지 hibernate에서 발생하는 쿼리 로깅이 slf4j를 사용하여 실행되는 것을 확인할 수 있었다.\n\n\n```java\n    // LoggerProviders.class\n    private static LoggerProvider findProvider() {\n        final ClassLoader cl = LoggerProviders.class.getClassLoader();\n        try {\n            // Check the system property\n            final String loggerProvider = AccessController.doPrivileged(new PrivilegedAction<String>() {\n                public String run() {\n                    return System.getProperty(LOGGING_PROVIDER_KEY);\n                }\n            });\n            if (loggerProvider != null) {\n                if (\"jboss\".equalsIgnoreCase(loggerProvider)) {\n                    return tryJBossLogManager(cl, \"system property\");\n                } else if (\"jdk\".equalsIgnoreCase(loggerProvider)) {\n                    return tryJDK(\"system property\");\n                } else if (\"log4j2\".equalsIgnoreCase(loggerProvider)) {\n                    return tryLog4j2(cl, \"system property\");\n                } else if (\"log4j\".equalsIgnoreCase(loggerProvider)) {\n                    return tryLog4j(cl, \"system property\");\n                } else if (\"slf4j\".equalsIgnoreCase(loggerProvider)) {\n                    return trySlf4j(\"system property\");\n                }\n            }\n        } catch (Throwable t) {\n            // nope...\n        }\n        // ... 이하 생략\n```\n\n\n```java\npublic void logStatement(String statement, Formatter formatter) {\n    if ( format ) {\n        if ( logToStdout || LOG.isDebugEnabled() ) {\n            statement = formatter.format( statement );\n        }\n    }\n    LOG.debug( statement );\n    if ( logToStdout ) {\n        System.out.println( \"Hibernate: \" + statement );\n    }\n}\n```\n\n\n### 기타 참고 링크\n- [Stackoverflow - Can't avoid hibernate logging SQL to console with Spring Boot and Logback](https://stackoverflow.com/questions/36496178/cant-avoid-hibernate-logging-sql-to-console-with-spring-boot-and-logback)\n- [Hibernate Log 남기기](http://kwonnam.pe.kr/wiki/java/hibernate/log)\n\n## 프로파일별 설정\n- [Profile-specific Configuration](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-logging.html#_profile_specific_configuration)\n\n스프링 부트에서는 프로파일별로 로깅 설정을 지정 할수 있도록 설정 할수 있다. 프로파일별로 달라지는 설정값은 `<springProperty>` 태그를 활용하여 분기 처리를 할 수 있다. 설정 값은 실행하는 프로파일의 `application.properties`의 값을 참조하게 된다.\n\n## [Logstash-logback-encoder](https://github.com/logstash/logstash-logback-encoder#async-appenders)\n로깅 포맷을 지정하는 과정에서, logback의 `JsonLayout`을 선 적용하여 설정을 했었는데, 어차피 ELK에서 사용하는 목적이 크기 때문에 포맷 자체를 ELK에서 Offical하게 사용하는 포맷을 사용하는 것이 더 나으리라 생각했다. 그래서 `Logstash-logback-encoder` 구현체를 사용하는 것으로 판단을 내렸고, 적용은 아래 내용을 참고하면 누구나 쉽게 할 수 있으리라 생각한다. 로컬 개발 환경에서는 굳이 해당 레이아웃을 적용할 필요가 없기 때문에, 스프링 부트에서 제공해주는 기본 로거 설정을 사용하도록 하였다.\n\n로그는 `logstash-logback-encoder`에서 제공해주는 TcpAppender를 사용하여 Logstash에 바로 보낼 수 있도록 설정하였으며, TCP를 사용하기 때문에 연결에 대한 reconnection, KeepAlive 설정을 추가로 적용했다. 일단 적용 후 추후 로그에 대한 유실 유무를 판단하여 FileBeat를 사용하는 등 개선점에 대해서는 모니터링 후 판단하기로 결정을 내렸다.\n\n로깅 프로퍼티의 경우, 현재 개발 환경에 Spring-Cloud-Sleuth를 사용하고 있어서 [해당 문서](https://cloud.spring.io/spring-cloud-sleuth/single/spring-cloud-sleuth.html#_json_logback_with_logstash)를 일정 부분 참고했다.\n\n- build.gradle\n```groovy\n    /**\n     * logstash-logback\n     */\n    compile('net.logstash.logback:logstash-logback-encoder:5.3')\n```\n\n- resources/logback-spring.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<configuration>\n\n    <!-- FILE Appender -->\n    <springProperty scope=\"context\" name=\"LOG_DIR\"        source=\"logging.path\"      defaultValue=\"/var/log/tomcat8\" />\n    <springProperty scope=\"context\" name=\"LOG_PATH_NAME\"  source=\"logging.file-name\" defaultValue=\"${LOG_DIR}/server-application.log\" />\n    <springProperty scope=\"context\" name=\"LOG_STASH_ADDR\" source=\"logging.log-stash\" defaultValue=\"{IP_ADDRESS}\" />\n    <springProperty scope=\"context\" name=\"APP_NAME\"       source=\"spring.zipkin.service.name\" defaultValue=\"DEFAULT_APP_NAME\" />\n\n    <appender name=\"file\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <file>${LOG_PATH_NAME}</file>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            <fileNamePattern>${LOG_PATH_NAME}.%d{yyyyMMdd}</fileNamePattern>\n            <maxHistory>60</maxHistory>\n        </rollingPolicy>\n\n        <encoder class=\"net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder\">\n            <providers>\n                <timestamp>\n                    <pattern>yyyy-MM-dd'T'HH:mm:ssZ</pattern>\n                    <timeZone>UTC</timeZone>\n                </timestamp>\n                <version/>\n                <logLevel/>\n                <threadName/>\n                <loggerName/>\n                <message />\n                <pattern>\n                    <pattern>\n                        {\n                        \"service\": \"${APP_NAME:-}\",\n                        \"traceId\": \"%X{X-B3-TraceId:-}\"\n                        }\n                    </pattern>\n                </pattern>\n            </providers>\n        </encoder>\n    </appender>\n\n    <!-- Logstash Appender -->\n    <appender name=\"stash\" class=\"net.logstash.logback.appender.LogstashTcpSocketAppender\">\n        <destination>${LOG_STASH_ADDR}</destination>\n        <keepAliveDuration>5 minutes</keepAliveDuration>\n        <reconnectionDelay>15 second</reconnectionDelay>\n\n        <encoder class=\"net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder\">\n            <providers>\n                <timestamp>\n                    <pattern>yyyy-MM-dd'T'HH:mm:ssZ</pattern>\n                    <timeZone>UTC</timeZone>\n                </timestamp>\n                <version/>\n                <logLevel/>\n                <threadName/>\n                <loggerName/>\n                <message />\n                <pattern>\n                    <pattern>\n                        {\n                        \"service\": \"${APP_NAME:-}\",\n                        \"traceId\": \"%X{X-B3-TraceId:-}\"\n                        }\n                    </pattern>\n                </pattern>\n\n            </providers>\n        </encoder>\n    </appender>\n    \n\n    <appender name=\"async-file\" class=\"ch.qos.logback.classic.AsyncAppender\">\n        <filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\">\n            <level>DEBUG</level>\n        </filter>\n        <!-- \n        발신자의 정보 (class명, 줄번호 등)가 추가되어 수집 서버로 전송여부를 결정합니다.\n        true 설정 시, 성능 저하를 일으킬 수 있습니다.        \n         -->\n        <param name=\"includeCallerData\" value=\"false\"/>\n        <!-- \n        - blocking queue의 최대 수용 갯수로 기본값은 256입니다.\n        - 대기열 용량의 20 % 미만이 남아있을 때 AsyncAppender는 WARN 및 ERROR 이벤트 만 유지하면서 TRACE, DEBUG 및 INFO 수준의 이벤트를 삭제합니다\n        -->        \n        <param name=\"queueSize\" value=\"2048\"/>\n        <!-- \n        false로 설정한 경우 큐가 가득찬 상황에서 appender는 메세지 유실을 방지하기 위해 application을 block 합니다. \n        true로 설정된 경우 application을 멈추지 않기 위해 메세지를 버립니다.\n        -->                \n        <param name=\"neverBlock\" value=\"true\"/>\n        <!-- \n        LoggerContext가 정지하면 AsyncAppender의 stop 메소드는 작업 스레드가 timeout 될때까지 대기합니다.\n        maxFlushTime를 사용하면, timeout 시간을 밀리초로 설정할 수 있습니다.\n        해당 시간안에 처리하지 못한 이벤트는 삭제됩니다.\n         -->\n        <param name=\"maxFlushTime\" value=\"60000\"/>\n        <appender-ref ref=\"file\" />\n    </appender>\n\n\n    <appender name=\"async-stash\" class=\"net.logstash.logback.appender.LoggingEventAsyncDisruptorAppender\">\n        <filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\">\n            <level>DEBUG</level>\n        </filter>\n        <waitStrategyType>sleeping</waitStrategyType>\n        <appender-ref ref=\"stash\" />\n    </appender>\n\n    <!-- Logger -->\n    <logger name=\"org.hibernate.SQL\" level=\"DEBUG\" />\n    <logger name=\"org.hibernate.tool.hbm2ddl\" level=\"DEBUG\"/>\n    <logger name=\"org.hibernate.stat\" level=\"DEBUG\" />\n    <logger name=\"org.hibernate.type.BasicTypeRegistry\" level=\"DEBUG\" />\n    <logger name=\"org.hibernate.type.descriptor.sql\" level=\"INFO\" />\n\n\n    <!-- Profile -->\n    <springProfile name=\"default | dev\">\n        <include resource=\"org/springframework/boot/logging/logback/base.xml\" />\n    </springProfile>\n\n    <springProfile name=\"stage\">\n        <root level=\"INFO\">\n            <appender-ref ref=\"async-stash\"/>\n            <appender-ref ref=\"async-file\"/>\n        </root>\n    </springProfile>\n\n    <springProfile name=\"live\">\n        <include resource=\"org/springframework/boot/logging/logback/base.xml\" />\n    </springProfile>\n\n</configuration>\n```\n\n## 참고\n- https://docs.toast.com/ko/Analytics/Log%20&%20Crash%20Search/ko/logback-sdk-guide/\n\n\n\n\n\n","slug":"Spring/LOG","published":1,"updated":"2021-08-02T12:06:23.433Z","_id":"ckrsup50x001utjhv1rhjejh8","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Logging\"><a href=\"#Logging\" class=\"headerlink\" title=\"Logging\"></a>Logging</h1><p>사내에서 최근 ELK 도입을 준비하고 있는 과정에서 로깅 포맷을 지정하고 사용해야 하는 Needs가 생겨서 이번 작업을 시작하게 되었다. 스프링 부트에서는 로깅 설정을 프로파일별로 다르게 지정 할 수 있으며, 또한 로깅 구현체에 대한 유연한 변경(log4j2 등)이 가능하므로 작업 자체의 난이도가 높지는 않다고 할 수 있다.</p>\n<h2 id=\"다시-보는-로깅-레벨\"><a href=\"#다시-보는-로깅-레벨\" class=\"headerlink\" title=\"다시 보는 로깅 레벨\"></a>다시 보는 로깅 레벨</h2><p><img src=\"http://myblog.opendocs.co.kr/wp-content/uploads/2015/03/log4j-1024x453.png\"></p>\n<ul>\n<li>출처: 구글 이미지 검색</li>\n</ul>\n<h2 id=\"Hibernate-Logging-관련-이슈\"><a href=\"#Hibernate-Logging-관련-이슈\" class=\"headerlink\" title=\"Hibernate Logging 관련 이슈\"></a>Hibernate Logging 관련 이슈</h2><p>로깅 작업 중 Hibernate 관련 로깅이 slf4j에 제대로 적용이 안되는 이슈가 생겼었다. 이와 관련된 문서를 뒤져보다 <a href=\"https://medium.com/@scadge/how-to-enable-hibernate-logging-dc11545efd3d\">링크</a>를 통하여 해당 문제를 해결 할 수 있었다.</p>\n<p>링크의 내용을 요약하자면, 하이버네이트 로깅 설정이 초기화 되는 구간에서 실제 slf4j에서 사용하는 로거 설정이 적용되며 자바 프로세스 실행 시 <code>-Dorg.jboss.logging.provider=slf4j</code> 혹은 코드에서 <code>System.setProperty(&quot;org.jboss.logging.provider&quot;, “slf4j&quot;)</code> 명시적으로 slf4j를 사용하도록 설정을 해줘야지 hibernate에서 발생하는 쿼리 로깅이 slf4j를 사용하여 실행되는 것을 확인할 수 있었다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LoggerProviders.class</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LoggerProvider <span class=\"title\">findProvider</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ClassLoader cl = LoggerProviders.class.getClassLoader();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Check the system property</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> String loggerProvider = AccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> System.getProperty(LOGGING_PROVIDER_KEY);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loggerProvider != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"string\">&quot;jboss&quot;</span>.equalsIgnoreCase(loggerProvider)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> tryJBossLogManager(cl, <span class=\"string\">&quot;system property&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;jdk&quot;</span>.equalsIgnoreCase(loggerProvider)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> tryJDK(<span class=\"string\">&quot;system property&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;log4j2&quot;</span>.equalsIgnoreCase(loggerProvider)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> tryLog4j2(cl, <span class=\"string\">&quot;system property&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;log4j&quot;</span>.equalsIgnoreCase(loggerProvider)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> tryLog4j(cl, <span class=\"string\">&quot;system property&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;slf4j&quot;</span>.equalsIgnoreCase(loggerProvider)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> trySlf4j(<span class=\"string\">&quot;system property&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// nope...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ... 이하 생략</span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">logStatement</span><span class=\"params\">(String statement, Formatter formatter)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( format ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( logToStdout || LOG.isDebugEnabled() ) &#123;</span><br><span class=\"line\">            statement = formatter.format( statement );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LOG.debug( statement );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( logToStdout ) &#123;</span><br><span class=\"line\">        System.out.println( <span class=\"string\">&quot;Hibernate: &quot;</span> + statement );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"기타-참고-링크\"><a href=\"#기타-참고-링크\" class=\"headerlink\" title=\"기타 참고 링크\"></a>기타 참고 링크</h3><ul>\n<li><a href=\"https://stackoverflow.com/questions/36496178/cant-avoid-hibernate-logging-sql-to-console-with-spring-boot-and-logback\">Stackoverflow - Can’t avoid hibernate logging SQL to console with Spring Boot and Logback</a></li>\n<li><a href=\"http://kwonnam.pe.kr/wiki/java/hibernate/log\">Hibernate Log 남기기</a></li>\n</ul>\n<h2 id=\"프로파일별-설정\"><a href=\"#프로파일별-설정\" class=\"headerlink\" title=\"프로파일별 설정\"></a>프로파일별 설정</h2><ul>\n<li><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-logging.html#_profile_specific_configuration\">Profile-specific Configuration</a></li>\n</ul>\n<p>스프링 부트에서는 프로파일별로 로깅 설정을 지정 할수 있도록 설정 할수 있다. 프로파일별로 달라지는 설정값은 <code>&lt;springProperty&gt;</code> 태그를 활용하여 분기 처리를 할 수 있다. 설정 값은 실행하는 프로파일의 <code>application.properties</code>의 값을 참조하게 된다.</p>\n<h2 id=\"Logstash-logback-encoder\"><a href=\"#Logstash-logback-encoder\" class=\"headerlink\" title=\"Logstash-logback-encoder\"></a><a href=\"https://github.com/logstash/logstash-logback-encoder#async-appenders\">Logstash-logback-encoder</a></h2><p>로깅 포맷을 지정하는 과정에서, logback의 <code>JsonLayout</code>을 선 적용하여 설정을 했었는데, 어차피 ELK에서 사용하는 목적이 크기 때문에 포맷 자체를 ELK에서 Offical하게 사용하는 포맷을 사용하는 것이 더 나으리라 생각했다. 그래서 <code>Logstash-logback-encoder</code> 구현체를 사용하는 것으로 판단을 내렸고, 적용은 아래 내용을 참고하면 누구나 쉽게 할 수 있으리라 생각한다. 로컬 개발 환경에서는 굳이 해당 레이아웃을 적용할 필요가 없기 때문에, 스프링 부트에서 제공해주는 기본 로거 설정을 사용하도록 하였다.</p>\n<p>로그는 <code>logstash-logback-encoder</code>에서 제공해주는 TcpAppender를 사용하여 Logstash에 바로 보낼 수 있도록 설정하였으며, TCP를 사용하기 때문에 연결에 대한 reconnection, KeepAlive 설정을 추가로 적용했다. 일단 적용 후 추후 로그에 대한 유실 유무를 판단하여 FileBeat를 사용하는 등 개선점에 대해서는 모니터링 후 판단하기로 결정을 내렸다.</p>\n<p>로깅 프로퍼티의 경우, 현재 개발 환경에 Spring-Cloud-Sleuth를 사용하고 있어서 <a href=\"https://cloud.spring.io/spring-cloud-sleuth/single/spring-cloud-sleuth.html#_json_logback_with_logstash\">해당 문서</a>를 일정 부분 참고했다.</p>\n<ul>\n<li><p>build.gradle</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * logstash-logback</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">compile(<span class=\"string\">&#x27;net.logstash.logback:logstash-logback-encoder:5.3&#x27;</span>)</span><br></pre></td></tr></table></figure></li>\n<li><p>resources/logback-spring.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- FILE Appender --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">springProperty</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;context&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;LOG_DIR&quot;</span>        <span class=\"attr\">source</span>=<span class=\"string\">&quot;logging.path&quot;</span>      <span class=\"attr\">defaultValue</span>=<span class=\"string\">&quot;/var/log/tomcat8&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">springProperty</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;context&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;LOG_PATH_NAME&quot;</span>  <span class=\"attr\">source</span>=<span class=\"string\">&quot;logging.file-name&quot;</span> <span class=\"attr\">defaultValue</span>=<span class=\"string\">&quot;$&#123;LOG_DIR&#125;/server-application.log&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">springProperty</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;context&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;LOG_STASH_ADDR&quot;</span> <span class=\"attr\">source</span>=<span class=\"string\">&quot;logging.log-stash&quot;</span> <span class=\"attr\">defaultValue</span>=<span class=\"string\">&quot;&#123;IP_ADDRESS&#125;&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">springProperty</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;context&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;APP_NAME&quot;</span>       <span class=\"attr\">source</span>=<span class=\"string\">&quot;spring.zipkin.service.name&quot;</span> <span class=\"attr\">defaultValue</span>=<span class=\"string\">&quot;DEFAULT_APP_NAME&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;file&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>$&#123;LOG_PATH_NAME&#125;<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH_NAME&#125;.%d&#123;yyyyMMdd&#125;<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>60<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">providers</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">timestamp</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>yyyy-MM-dd&#x27;T&#x27;HH:mm:ssZ<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">timeZone</span>&gt;</span>UTC<span class=\"tag\">&lt;/<span class=\"name\">timeZone</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">timestamp</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">logLevel</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">threadName</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">loggerName</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">message</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                        &quot;service&quot;: &quot;$&#123;APP_NAME:-&#125;&quot;,</span><br><span class=\"line\">                        &quot;traceId&quot;: &quot;%X&#123;X-B3-TraceId:-&#125;&quot;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">providers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Logstash Appender --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;stash&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">destination</span>&gt;</span>$&#123;LOG_STASH_ADDR&#125;<span class=\"tag\">&lt;/<span class=\"name\">destination</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">keepAliveDuration</span>&gt;</span>5 minutes<span class=\"tag\">&lt;/<span class=\"name\">keepAliveDuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">reconnectionDelay</span>&gt;</span>15 second<span class=\"tag\">&lt;/<span class=\"name\">reconnectionDelay</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">providers</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">timestamp</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>yyyy-MM-dd&#x27;T&#x27;HH:mm:ssZ<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">timeZone</span>&gt;</span>UTC<span class=\"tag\">&lt;/<span class=\"name\">timeZone</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">timestamp</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">logLevel</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">threadName</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">loggerName</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">message</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                        &quot;service&quot;: &quot;$&#123;APP_NAME:-&#125;&quot;,</span><br><span class=\"line\">                        &quot;traceId&quot;: &quot;%X&#123;X-B3-TraceId:-&#125;&quot;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">providers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;async-file&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">level</span>&gt;</span>DEBUG<span class=\"tag\">&lt;/<span class=\"name\">level</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        발신자의 정보 (class명, 줄번호 등)가 추가되어 수집 서버로 전송여부를 결정합니다.</span></span><br><span class=\"line\"><span class=\"comment\">        true 설정 시, 성능 저하를 일으킬 수 있습니다.        </span></span><br><span class=\"line\"><span class=\"comment\">         --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;includeCallerData&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;false&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        - blocking queue의 최대 수용 갯수로 기본값은 256입니다.</span></span><br><span class=\"line\"><span class=\"comment\">        - 대기열 용량의 20 % 미만이 남아있을 때 AsyncAppender는 WARN 및 ERROR 이벤트 만 유지하면서 TRACE, DEBUG 및 INFO 수준의 이벤트를 삭제합니다</span></span><br><span class=\"line\"><span class=\"comment\">        --&gt;</span>        </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;queueSize&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;2048&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        false로 설정한 경우 큐가 가득찬 상황에서 appender는 메세지 유실을 방지하기 위해 application을 block 합니다. </span></span><br><span class=\"line\"><span class=\"comment\">        true로 설정된 경우 application을 멈추지 않기 위해 메세지를 버립니다.</span></span><br><span class=\"line\"><span class=\"comment\">        --&gt;</span>                </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;neverBlock&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        LoggerContext가 정지하면 AsyncAppender의 stop 메소드는 작업 스레드가 timeout 될때까지 대기합니다.</span></span><br><span class=\"line\"><span class=\"comment\">        maxFlushTime를 사용하면, timeout 시간을 밀리초로 설정할 수 있습니다.</span></span><br><span class=\"line\"><span class=\"comment\">        해당 시간안에 처리하지 못한 이벤트는 삭제됩니다.</span></span><br><span class=\"line\"><span class=\"comment\">         --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maxFlushTime&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;60000&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;file&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;async-stash&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;net.logstash.logback.appender.LoggingEventAsyncDisruptorAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">level</span>&gt;</span>DEBUG<span class=\"tag\">&lt;/<span class=\"name\">level</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">waitStrategyType</span>&gt;</span>sleeping<span class=\"tag\">&lt;/<span class=\"name\">waitStrategyType</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;stash&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Logger --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.SQL&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.tool.hbm2ddl&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.stat&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.type.BasicTypeRegistry&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.type.descriptor.sql&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;INFO&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Profile --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">springProfile</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;default | dev&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">include</span> <span class=\"attr\">resource</span>=<span class=\"string\">&quot;org/springframework/boot/logging/logback/base.xml&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">springProfile</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">springProfile</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;stage&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;INFO&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;async-stash&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;async-file&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">springProfile</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">springProfile</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;live&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">include</span> <span class=\"attr\">resource</span>=<span class=\"string\">&quot;org/springframework/boot/logging/logback/base.xml&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">springProfile</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><ul>\n<li><a href=\"https://docs.toast.com/ko/Analytics/Log%20&amp;%20Crash%20Search/ko/logback-sdk-guide/\">https://docs.toast.com/ko/Analytics/Log%20&amp;%20Crash%20Search/ko/logback-sdk-guide/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Logging\"><a href=\"#Logging\" class=\"headerlink\" title=\"Logging\"></a>Logging</h1><p>사내에서 최근 ELK 도입을 준비하고 있는 과정에서 로깅 포맷을 지정하고 사용해야 하는 Needs가 생겨서 이번 작업을 시작하게 되었다. 스프링 부트에서는 로깅 설정을 프로파일별로 다르게 지정 할 수 있으며, 또한 로깅 구현체에 대한 유연한 변경(log4j2 등)이 가능하므로 작업 자체의 난이도가 높지는 않다고 할 수 있다.</p>\n<h2 id=\"다시-보는-로깅-레벨\"><a href=\"#다시-보는-로깅-레벨\" class=\"headerlink\" title=\"다시 보는 로깅 레벨\"></a>다시 보는 로깅 레벨</h2><p><img src=\"http://myblog.opendocs.co.kr/wp-content/uploads/2015/03/log4j-1024x453.png\"></p>\n<ul>\n<li>출처: 구글 이미지 검색</li>\n</ul>\n<h2 id=\"Hibernate-Logging-관련-이슈\"><a href=\"#Hibernate-Logging-관련-이슈\" class=\"headerlink\" title=\"Hibernate Logging 관련 이슈\"></a>Hibernate Logging 관련 이슈</h2><p>로깅 작업 중 Hibernate 관련 로깅이 slf4j에 제대로 적용이 안되는 이슈가 생겼었다. 이와 관련된 문서를 뒤져보다 <a href=\"https://medium.com/@scadge/how-to-enable-hibernate-logging-dc11545efd3d\">링크</a>를 통하여 해당 문제를 해결 할 수 있었다.</p>\n<p>링크의 내용을 요약하자면, 하이버네이트 로깅 설정이 초기화 되는 구간에서 실제 slf4j에서 사용하는 로거 설정이 적용되며 자바 프로세스 실행 시 <code>-Dorg.jboss.logging.provider=slf4j</code> 혹은 코드에서 <code>System.setProperty(&quot;org.jboss.logging.provider&quot;, “slf4j&quot;)</code> 명시적으로 slf4j를 사용하도록 설정을 해줘야지 hibernate에서 발생하는 쿼리 로깅이 slf4j를 사용하여 실행되는 것을 확인할 수 있었다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LoggerProviders.class</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LoggerProvider <span class=\"title\">findProvider</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ClassLoader cl = LoggerProviders.class.getClassLoader();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Check the system property</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> String loggerProvider = AccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> System.getProperty(LOGGING_PROVIDER_KEY);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loggerProvider != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"string\">&quot;jboss&quot;</span>.equalsIgnoreCase(loggerProvider)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> tryJBossLogManager(cl, <span class=\"string\">&quot;system property&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;jdk&quot;</span>.equalsIgnoreCase(loggerProvider)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> tryJDK(<span class=\"string\">&quot;system property&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;log4j2&quot;</span>.equalsIgnoreCase(loggerProvider)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> tryLog4j2(cl, <span class=\"string\">&quot;system property&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;log4j&quot;</span>.equalsIgnoreCase(loggerProvider)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> tryLog4j(cl, <span class=\"string\">&quot;system property&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;slf4j&quot;</span>.equalsIgnoreCase(loggerProvider)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> trySlf4j(<span class=\"string\">&quot;system property&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// nope...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ... 이하 생략</span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">logStatement</span><span class=\"params\">(String statement, Formatter formatter)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( format ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( logToStdout || LOG.isDebugEnabled() ) &#123;</span><br><span class=\"line\">            statement = formatter.format( statement );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LOG.debug( statement );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( logToStdout ) &#123;</span><br><span class=\"line\">        System.out.println( <span class=\"string\">&quot;Hibernate: &quot;</span> + statement );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"기타-참고-링크\"><a href=\"#기타-참고-링크\" class=\"headerlink\" title=\"기타 참고 링크\"></a>기타 참고 링크</h3><ul>\n<li><a href=\"https://stackoverflow.com/questions/36496178/cant-avoid-hibernate-logging-sql-to-console-with-spring-boot-and-logback\">Stackoverflow - Can’t avoid hibernate logging SQL to console with Spring Boot and Logback</a></li>\n<li><a href=\"http://kwonnam.pe.kr/wiki/java/hibernate/log\">Hibernate Log 남기기</a></li>\n</ul>\n<h2 id=\"프로파일별-설정\"><a href=\"#프로파일별-설정\" class=\"headerlink\" title=\"프로파일별 설정\"></a>프로파일별 설정</h2><ul>\n<li><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-logging.html#_profile_specific_configuration\">Profile-specific Configuration</a></li>\n</ul>\n<p>스프링 부트에서는 프로파일별로 로깅 설정을 지정 할수 있도록 설정 할수 있다. 프로파일별로 달라지는 설정값은 <code>&lt;springProperty&gt;</code> 태그를 활용하여 분기 처리를 할 수 있다. 설정 값은 실행하는 프로파일의 <code>application.properties</code>의 값을 참조하게 된다.</p>\n<h2 id=\"Logstash-logback-encoder\"><a href=\"#Logstash-logback-encoder\" class=\"headerlink\" title=\"Logstash-logback-encoder\"></a><a href=\"https://github.com/logstash/logstash-logback-encoder#async-appenders\">Logstash-logback-encoder</a></h2><p>로깅 포맷을 지정하는 과정에서, logback의 <code>JsonLayout</code>을 선 적용하여 설정을 했었는데, 어차피 ELK에서 사용하는 목적이 크기 때문에 포맷 자체를 ELK에서 Offical하게 사용하는 포맷을 사용하는 것이 더 나으리라 생각했다. 그래서 <code>Logstash-logback-encoder</code> 구현체를 사용하는 것으로 판단을 내렸고, 적용은 아래 내용을 참고하면 누구나 쉽게 할 수 있으리라 생각한다. 로컬 개발 환경에서는 굳이 해당 레이아웃을 적용할 필요가 없기 때문에, 스프링 부트에서 제공해주는 기본 로거 설정을 사용하도록 하였다.</p>\n<p>로그는 <code>logstash-logback-encoder</code>에서 제공해주는 TcpAppender를 사용하여 Logstash에 바로 보낼 수 있도록 설정하였으며, TCP를 사용하기 때문에 연결에 대한 reconnection, KeepAlive 설정을 추가로 적용했다. 일단 적용 후 추후 로그에 대한 유실 유무를 판단하여 FileBeat를 사용하는 등 개선점에 대해서는 모니터링 후 판단하기로 결정을 내렸다.</p>\n<p>로깅 프로퍼티의 경우, 현재 개발 환경에 Spring-Cloud-Sleuth를 사용하고 있어서 <a href=\"https://cloud.spring.io/spring-cloud-sleuth/single/spring-cloud-sleuth.html#_json_logback_with_logstash\">해당 문서</a>를 일정 부분 참고했다.</p>\n<ul>\n<li><p>build.gradle</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * logstash-logback</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">compile(<span class=\"string\">&#x27;net.logstash.logback:logstash-logback-encoder:5.3&#x27;</span>)</span><br></pre></td></tr></table></figure></li>\n<li><p>resources/logback-spring.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- FILE Appender --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">springProperty</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;context&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;LOG_DIR&quot;</span>        <span class=\"attr\">source</span>=<span class=\"string\">&quot;logging.path&quot;</span>      <span class=\"attr\">defaultValue</span>=<span class=\"string\">&quot;/var/log/tomcat8&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">springProperty</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;context&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;LOG_PATH_NAME&quot;</span>  <span class=\"attr\">source</span>=<span class=\"string\">&quot;logging.file-name&quot;</span> <span class=\"attr\">defaultValue</span>=<span class=\"string\">&quot;$&#123;LOG_DIR&#125;/server-application.log&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">springProperty</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;context&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;LOG_STASH_ADDR&quot;</span> <span class=\"attr\">source</span>=<span class=\"string\">&quot;logging.log-stash&quot;</span> <span class=\"attr\">defaultValue</span>=<span class=\"string\">&quot;&#123;IP_ADDRESS&#125;&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">springProperty</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;context&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;APP_NAME&quot;</span>       <span class=\"attr\">source</span>=<span class=\"string\">&quot;spring.zipkin.service.name&quot;</span> <span class=\"attr\">defaultValue</span>=<span class=\"string\">&quot;DEFAULT_APP_NAME&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;file&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>$&#123;LOG_PATH_NAME&#125;<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH_NAME&#125;.%d&#123;yyyyMMdd&#125;<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>60<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">providers</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">timestamp</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>yyyy-MM-dd&#x27;T&#x27;HH:mm:ssZ<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">timeZone</span>&gt;</span>UTC<span class=\"tag\">&lt;/<span class=\"name\">timeZone</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">timestamp</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">logLevel</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">threadName</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">loggerName</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">message</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                        &quot;service&quot;: &quot;$&#123;APP_NAME:-&#125;&quot;,</span><br><span class=\"line\">                        &quot;traceId&quot;: &quot;%X&#123;X-B3-TraceId:-&#125;&quot;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">providers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Logstash Appender --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;stash&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">destination</span>&gt;</span>$&#123;LOG_STASH_ADDR&#125;<span class=\"tag\">&lt;/<span class=\"name\">destination</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">keepAliveDuration</span>&gt;</span>5 minutes<span class=\"tag\">&lt;/<span class=\"name\">keepAliveDuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">reconnectionDelay</span>&gt;</span>15 second<span class=\"tag\">&lt;/<span class=\"name\">reconnectionDelay</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">providers</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">timestamp</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>yyyy-MM-dd&#x27;T&#x27;HH:mm:ssZ<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">timeZone</span>&gt;</span>UTC<span class=\"tag\">&lt;/<span class=\"name\">timeZone</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">timestamp</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">logLevel</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">threadName</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">loggerName</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">message</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                        &quot;service&quot;: &quot;$&#123;APP_NAME:-&#125;&quot;,</span><br><span class=\"line\">                        &quot;traceId&quot;: &quot;%X&#123;X-B3-TraceId:-&#125;&quot;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">providers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;async-file&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">level</span>&gt;</span>DEBUG<span class=\"tag\">&lt;/<span class=\"name\">level</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        발신자의 정보 (class명, 줄번호 등)가 추가되어 수집 서버로 전송여부를 결정합니다.</span></span><br><span class=\"line\"><span class=\"comment\">        true 설정 시, 성능 저하를 일으킬 수 있습니다.        </span></span><br><span class=\"line\"><span class=\"comment\">         --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;includeCallerData&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;false&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        - blocking queue의 최대 수용 갯수로 기본값은 256입니다.</span></span><br><span class=\"line\"><span class=\"comment\">        - 대기열 용량의 20 % 미만이 남아있을 때 AsyncAppender는 WARN 및 ERROR 이벤트 만 유지하면서 TRACE, DEBUG 및 INFO 수준의 이벤트를 삭제합니다</span></span><br><span class=\"line\"><span class=\"comment\">        --&gt;</span>        </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;queueSize&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;2048&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        false로 설정한 경우 큐가 가득찬 상황에서 appender는 메세지 유실을 방지하기 위해 application을 block 합니다. </span></span><br><span class=\"line\"><span class=\"comment\">        true로 설정된 경우 application을 멈추지 않기 위해 메세지를 버립니다.</span></span><br><span class=\"line\"><span class=\"comment\">        --&gt;</span>                </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;neverBlock&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">        LoggerContext가 정지하면 AsyncAppender의 stop 메소드는 작업 스레드가 timeout 될때까지 대기합니다.</span></span><br><span class=\"line\"><span class=\"comment\">        maxFlushTime를 사용하면, timeout 시간을 밀리초로 설정할 수 있습니다.</span></span><br><span class=\"line\"><span class=\"comment\">        해당 시간안에 처리하지 못한 이벤트는 삭제됩니다.</span></span><br><span class=\"line\"><span class=\"comment\">         --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maxFlushTime&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;60000&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;file&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;async-stash&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;net.logstash.logback.appender.LoggingEventAsyncDisruptorAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">level</span>&gt;</span>DEBUG<span class=\"tag\">&lt;/<span class=\"name\">level</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">waitStrategyType</span>&gt;</span>sleeping<span class=\"tag\">&lt;/<span class=\"name\">waitStrategyType</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;stash&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Logger --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.SQL&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.tool.hbm2ddl&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.stat&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.type.BasicTypeRegistry&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.type.descriptor.sql&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;INFO&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Profile --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">springProfile</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;default | dev&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">include</span> <span class=\"attr\">resource</span>=<span class=\"string\">&quot;org/springframework/boot/logging/logback/base.xml&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">springProfile</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">springProfile</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;stage&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;INFO&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;async-stash&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;async-file&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">springProfile</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">springProfile</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;live&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">include</span> <span class=\"attr\">resource</span>=<span class=\"string\">&quot;org/springframework/boot/logging/logback/base.xml&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">springProfile</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><ul>\n<li><a href=\"https://docs.toast.com/ko/Analytics/Log%20&amp;%20Crash%20Search/ko/logback-sdk-guide/\">https://docs.toast.com/ko/Analytics/Log%20&amp;%20Crash%20Search/ko/logback-sdk-guide/</a></li>\n</ul>\n"},{"title":"@JsonView와 @JsonFilter를 사용하여 Partial response 구현하기","date":"2019-05-27T00:33:00.000Z","_content":"\n# @JsonView와 @JsonFilter를 사용하여 Partial response 구현하기\n## 개요\nJSON HTTP API를 구현할 때, 페이징만 구현하는 경우를 쉽게 볼 수 있는데, 여기서 한 걸음 더 나아가 조금 더 나은 퍼포먼스를 위하여 클라이언트가 필요한 필드만 골라서 받을 수 있도록 구현하는 것이 필요할 수 있다. 예를 들어 아래와 같은 상황을 예를 들어 볼 수 있다.\n\n- HTTP Reqeust\n```\nHTTP/1.1 GET /books/1?fields=isbn,title\n```\n\n- HTTP Response\n```javascript\n{\n    \"isbn\": \"978-3-16-148410-0\",\n    \"title\": \"Book Title\"\n}\n```\n\n책 데이터를 조회하는 JSON API가 있다고 했을 때, 헤당 API에서 제공하는 정보 중 일부 정보만을 클라이언트에서 필요한 경우에 fields 쿼리스트링에 필요한 키 값을 콤마 베이스로 나열하여 요청하는 예시이다. 클라이언트가 필요한 응답만을 제공하는 동시에 조금 더 나은 네트워크 레벨에서의 퍼포먼스를 가져갈 수 있다. 이런 부분적인 응답 값을 반환하는 것을 `Partial Response`라고 부르며 REST와 관련된 문서에서 심심찮게 발견할 수 있는 내용이다.\n\n- [GOOGLE-REST-Improve performance](https://developers.google.com/drive/api/v3/performance)\n- [조대협님 블로그, REST API 디자인 가이드](https://bcho.tistory.com/914)\n- [MS, API 디자인](https://docs.microsoft.com/ko-kr/azure/architecture/best-practices/api-design)\n\n\n구현하는 언어와 환경에 따라 이를 구현하는 방법에는 차이가 존재하는데, 일반적으로 Spring Framework, Boot 환경에서는 JSON 데이터에 대한 처리를 GSON 혹은 Jackson 라이브러리가 담당하게 되는데 그 중에서도 Jackson을 사용하는 환경에서 간단하게 partial response를 구현하는 예제를 작성해보려고 한다.\n\n## 개발 환경\n- Kotlin 1.3.31\n- Spring Boot 2.1.5 RELEASE\n  - WEB\n\n\n## 1. @JsonView를 사용한 예제\n@JsonView 어노테이션을 활용하면 계층적인 부분 렌더링이 가능하다. @JsonView에 대한 계층 정의 예와 유저에 대한 예제 엔티티는 아래와 같다.\n\n```kotlin\ninterface Views {\n    interface List\n    interface Get: List\n}\n\nclass User(\n    @JsonView(Views.List::class)\n    val id: UUID = UUID.randomUUID(),\n    @JsonView(Views.List::class)\n    val email: String,\n    @JsonView(Views.List::class)\n    val name: String,\n    @JsonView(Views.Get::class)\n    val createdAt: LocalDateTime = LocalDateTime.now(),\n    @JsonView(Views.Get::class)\n    val updatedAt: LocalDateTime = LocalDateTime.now()\n)\n```\n\n위와 같이 선언할 경우, `@JsonView(Dto.Views.List::class)`로 데이터를 처리하게 되면 모든 데이터를 유저 엔티티에서 `id`, `email`, `name`만을 Jackson 라이브러리가 serialize하게 된다. 반대로, `@JsonView(Dto.Views.Get::class)`으로 지정해놓게 되면 유저 엔티티의 모든 데이터가 serialize된다.\n\nSpring Mvc에서는 요청 컨트롤러 매핑 메서드에 @JsonView를 명시해주면 해당 뷰로 Serailize 할 수 있도록 지원하고 있다.\n\n```kotlin\n@RestController\n@RequestMapping\nclass BookController {\n    private companion object {\n        val user = Dto.User(\n            name = \"Park\",\n            email = \"park@gmail.com\"\n        )\n    }\n\n    @GetMapping(\"/get\")\n    @JsonView(Dto.Views.Get::class)\n    fun jsonViewGet() = user\n\n    @GetMapping(\"/list\")\n    @JsonView(Dto.Views.List::class)\n    fun jsonViewList() = listOf(user)\n}\n```\n\n@JsonView를 통하여 제대로 결과가 반환되는지 테스트 코드를 간단하게 작성해보면 아래와 같다. 테스트코드는 스프링 부트의 통합테스트 환경을 그대로 사용했으며, jsonPath 라이브러리를 사용하여 해당 키 값이 제대로 존재하는지 그리고 타입이 정확한지 유무까지 테스트를 해봤다.\n\n### 테스트코드\n```kotlin\n@RunWith(SpringRunner::class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@AutoConfigureMockMvc\nclass MvcJacksonviewApplicationTests {\n\n    @Autowired\n    private lateinit var mockMvc: MockMvc\n\n    @Test\n    fun `JsonView_Get_Test`() {\n        mockMvc.perform(\n            get(\"/get\")\n        )\n        .andDo(print())\n        .andExpect(status().isOk)\n        .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))\n        .andExpect(jsonPath(\"id\").exists())\n        .andExpect(jsonPath(\"id\").isString)\n        .andExpect(jsonPath(\"email\").exists())\n        .andExpect(jsonPath(\"email\").isString)\n        .andExpect(jsonPath(\"name\").exists())\n        .andExpect(jsonPath(\"name\").isString)\n        .andExpect(jsonPath(\"createdAt\").exists())\n        .andExpect(jsonPath(\"createdAt\").isString)\n        .andExpect(jsonPath(\"updatedAt\").exists())\n        .andExpect(jsonPath(\"updatedAt\").isString)\n    }\n\n    @Test\n    fun `JsonView_List_Test`() {\n        mockMvc.perform(\n            get(\"/list\")\n        )\n            .andDo(print())\n            .andExpect(status().isOk)\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))\n            .andExpect(jsonPath(\"[0].id\").exists())\n            .andExpect(jsonPath(\"[0].id\").isString)\n            .andExpect(jsonPath(\"[0].email\").exists())\n            .andExpect(jsonPath(\"[0].email\").isString)\n            .andExpect(jsonPath(\"[0].name\").exists())\n            .andExpect(jsonPath(\"[0].name\").isString)\n            .andExpect(jsonPath(\"[0].createdAt\").doesNotExist())\n            .andExpect(jsonPath(\"[0].updatedAt\").doesNotExist())\n    }\n\n    @Test\n    fun `JsonFilter_single`() {\n        mockMvc.perform(\n            get(\"/json-filter\")\n                .param(\"fields\", \"isbn\")\n        )\n            .andDo(print())\n            .andExpect(status().isOk)\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))\n            .andExpect(jsonPath(\"isbn\").exists())\n            .andExpect(jsonPath(\"isbn\").isString)\n            .andExpect(jsonPath(\"title\").doesNotExist())\n            .andExpect(jsonPath(\"content\").doesNotExist())\n            .andExpect(jsonPath(\"createdAt\").doesNotExist())\n            .andExpect(jsonPath(\"updatedAt\").doesNotExist())\n    }\n}\n```\n\n## 2. @JsonFilter를 사용하는 예제\n위에서 본 @JsonView의 경우, 딱 지정해놓은 계층 구조 혹은 뷰가 아닐 경우 필드에 대한 선택 자체가 불가능하다. 결국 서버 어플리케이션에서 정해놓은 구조로만 부분 뷰를 응답 받을 수 있는 구조인데, 실제 요청에 부합하는 응답 값만 전달하기 위해서는 Jackson의 @JsonFilter 어노테이션과 Spring MVC의 MappingJacksonValue를 활용하면 해당 구현이 가능하다.\n\n```kotlin\n@JsonFilter(\"bookFilter\")\nclass Book (\n    val isbn: String,\n    val title: String,\n    val content: String,\n    val createdAt: LocalDateTime = LocalDateTime.now(),\n    val updatedAt: LocalDateTime = LocalDateTime.now()\n)\n\nclass GetReq {\n    var fields: List<String> = emptyList()\n}\n```\n\n```kotlin\n@RestController\n@RequestMapping\nclass BookController {\n    private companion object {\n        val book: Dto.Book = Dto.Book(\n            isbn = UUID.randomUUID().toString(),\n            title = \"Title\",\n            content = \"Content\"\n        )\n    }\n\n    @GetMapping(\"/json-filter\")\n    fun jsonFilter(reqDto: GetReq) = MappingJacksonValue(book).apply {\n        filters = SimpleFilterProvider().also {\n            it.addFilter(\"bookFilter\",\n                if (reqDto.fields.isNotEmpty()) SimpleBeanPropertyFilter.filterOutAllExcept(reqDto.fields.toSet())\n                else SimpleBeanPropertyFilter.serializeAll()\n            )\n        }\n    }\n}\n```\n\n### 테스트코드\n```kotlin\n@RunWith(SpringRunner::class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@AutoConfigureMockMvc\nclass MvcJacksonviewApplicationTests {\n\n    @Autowired\n    private lateinit var mockMvc: MockMvc\n\n    @Test\n    fun `JsonFilter_single`() {\n        mockMvc.perform(\n            get(\"/json-filter\")\n                .param(\"fields\", \"isbn\")\n        )\n            .andDo(print())\n            .andExpect(status().isOk)\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))\n            .andExpect(jsonPath(\"isbn\").exists())\n            .andExpect(jsonPath(\"isbn\").isString)\n            .andExpect(jsonPath(\"title\").doesNotExist())\n            .andExpect(jsonPath(\"content\").doesNotExist())\n            .andExpect(jsonPath(\"createdAt\").doesNotExist())\n            .andExpect(jsonPath(\"updatedAt\").doesNotExist())\n    }\n\n    @Test\n    fun `JsonFilter_comma_separator`() {\n        mockMvc.perform(\n            get(\"/json-filter\")\n                .param(\"fields\", \"isbn,title\")\n        )\n            .andDo(print())\n            .andExpect(status().isOk)\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))\n            .andExpect(jsonPath(\"isbn\").exists())\n            .andExpect(jsonPath(\"isbn\").isString)\n            .andExpect(jsonPath(\"title\").exists())\n            .andExpect(jsonPath(\"title\").isString)\n            .andExpect(jsonPath(\"content\").doesNotExist())\n            .andExpect(jsonPath(\"createdAt\").doesNotExist())\n            .andExpect(jsonPath(\"updatedAt\").doesNotExist())\n    }\n}\n```\n\n간단하게 @JsonView와 @JsonFilter를 사용하여 partial response에 대한 구현을 해볼 수 있었는데, 여기서 \b조금 더 나아가 복잡한 조건이나 구조에서의 구현이 필요할 경우 [Squiggly Filter ](https://github.com/bohnman/squiggly-java)와 같은 구현체를 사용하는 것도 좋은 선택이 될 수 있을거 같다.\n\n> 예제는 [링크](https://github.com/thefeeling/spring-code/tree/develop/spring-mvc-jacksonview)를 통하여 확인 가능합니다.\n\n## 참고\n- [spring-mvc – Spring MVC 컨트롤러에서 JsonView의 동적 선택](https://codeday.me/ko/qa/20190512/527260.html)\n- [Jackson JSON Views](https://www.baeldung.com/jackson-json-view-annotation)","source":"_posts/Spring/MVC_PartialReseponse.md","raw":"---\ntitle: '@JsonView와 @JsonFilter를 사용하여 Partial response 구현하기'\ndate: 2019.5.27. 09:33:00\ncategories:\n- Spring\n---\n\n# @JsonView와 @JsonFilter를 사용하여 Partial response 구현하기\n## 개요\nJSON HTTP API를 구현할 때, 페이징만 구현하는 경우를 쉽게 볼 수 있는데, 여기서 한 걸음 더 나아가 조금 더 나은 퍼포먼스를 위하여 클라이언트가 필요한 필드만 골라서 받을 수 있도록 구현하는 것이 필요할 수 있다. 예를 들어 아래와 같은 상황을 예를 들어 볼 수 있다.\n\n- HTTP Reqeust\n```\nHTTP/1.1 GET /books/1?fields=isbn,title\n```\n\n- HTTP Response\n```javascript\n{\n    \"isbn\": \"978-3-16-148410-0\",\n    \"title\": \"Book Title\"\n}\n```\n\n책 데이터를 조회하는 JSON API가 있다고 했을 때, 헤당 API에서 제공하는 정보 중 일부 정보만을 클라이언트에서 필요한 경우에 fields 쿼리스트링에 필요한 키 값을 콤마 베이스로 나열하여 요청하는 예시이다. 클라이언트가 필요한 응답만을 제공하는 동시에 조금 더 나은 네트워크 레벨에서의 퍼포먼스를 가져갈 수 있다. 이런 부분적인 응답 값을 반환하는 것을 `Partial Response`라고 부르며 REST와 관련된 문서에서 심심찮게 발견할 수 있는 내용이다.\n\n- [GOOGLE-REST-Improve performance](https://developers.google.com/drive/api/v3/performance)\n- [조대협님 블로그, REST API 디자인 가이드](https://bcho.tistory.com/914)\n- [MS, API 디자인](https://docs.microsoft.com/ko-kr/azure/architecture/best-practices/api-design)\n\n\n구현하는 언어와 환경에 따라 이를 구현하는 방법에는 차이가 존재하는데, 일반적으로 Spring Framework, Boot 환경에서는 JSON 데이터에 대한 처리를 GSON 혹은 Jackson 라이브러리가 담당하게 되는데 그 중에서도 Jackson을 사용하는 환경에서 간단하게 partial response를 구현하는 예제를 작성해보려고 한다.\n\n## 개발 환경\n- Kotlin 1.3.31\n- Spring Boot 2.1.5 RELEASE\n  - WEB\n\n\n## 1. @JsonView를 사용한 예제\n@JsonView 어노테이션을 활용하면 계층적인 부분 렌더링이 가능하다. @JsonView에 대한 계층 정의 예와 유저에 대한 예제 엔티티는 아래와 같다.\n\n```kotlin\ninterface Views {\n    interface List\n    interface Get: List\n}\n\nclass User(\n    @JsonView(Views.List::class)\n    val id: UUID = UUID.randomUUID(),\n    @JsonView(Views.List::class)\n    val email: String,\n    @JsonView(Views.List::class)\n    val name: String,\n    @JsonView(Views.Get::class)\n    val createdAt: LocalDateTime = LocalDateTime.now(),\n    @JsonView(Views.Get::class)\n    val updatedAt: LocalDateTime = LocalDateTime.now()\n)\n```\n\n위와 같이 선언할 경우, `@JsonView(Dto.Views.List::class)`로 데이터를 처리하게 되면 모든 데이터를 유저 엔티티에서 `id`, `email`, `name`만을 Jackson 라이브러리가 serialize하게 된다. 반대로, `@JsonView(Dto.Views.Get::class)`으로 지정해놓게 되면 유저 엔티티의 모든 데이터가 serialize된다.\n\nSpring Mvc에서는 요청 컨트롤러 매핑 메서드에 @JsonView를 명시해주면 해당 뷰로 Serailize 할 수 있도록 지원하고 있다.\n\n```kotlin\n@RestController\n@RequestMapping\nclass BookController {\n    private companion object {\n        val user = Dto.User(\n            name = \"Park\",\n            email = \"park@gmail.com\"\n        )\n    }\n\n    @GetMapping(\"/get\")\n    @JsonView(Dto.Views.Get::class)\n    fun jsonViewGet() = user\n\n    @GetMapping(\"/list\")\n    @JsonView(Dto.Views.List::class)\n    fun jsonViewList() = listOf(user)\n}\n```\n\n@JsonView를 통하여 제대로 결과가 반환되는지 테스트 코드를 간단하게 작성해보면 아래와 같다. 테스트코드는 스프링 부트의 통합테스트 환경을 그대로 사용했으며, jsonPath 라이브러리를 사용하여 해당 키 값이 제대로 존재하는지 그리고 타입이 정확한지 유무까지 테스트를 해봤다.\n\n### 테스트코드\n```kotlin\n@RunWith(SpringRunner::class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@AutoConfigureMockMvc\nclass MvcJacksonviewApplicationTests {\n\n    @Autowired\n    private lateinit var mockMvc: MockMvc\n\n    @Test\n    fun `JsonView_Get_Test`() {\n        mockMvc.perform(\n            get(\"/get\")\n        )\n        .andDo(print())\n        .andExpect(status().isOk)\n        .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))\n        .andExpect(jsonPath(\"id\").exists())\n        .andExpect(jsonPath(\"id\").isString)\n        .andExpect(jsonPath(\"email\").exists())\n        .andExpect(jsonPath(\"email\").isString)\n        .andExpect(jsonPath(\"name\").exists())\n        .andExpect(jsonPath(\"name\").isString)\n        .andExpect(jsonPath(\"createdAt\").exists())\n        .andExpect(jsonPath(\"createdAt\").isString)\n        .andExpect(jsonPath(\"updatedAt\").exists())\n        .andExpect(jsonPath(\"updatedAt\").isString)\n    }\n\n    @Test\n    fun `JsonView_List_Test`() {\n        mockMvc.perform(\n            get(\"/list\")\n        )\n            .andDo(print())\n            .andExpect(status().isOk)\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))\n            .andExpect(jsonPath(\"[0].id\").exists())\n            .andExpect(jsonPath(\"[0].id\").isString)\n            .andExpect(jsonPath(\"[0].email\").exists())\n            .andExpect(jsonPath(\"[0].email\").isString)\n            .andExpect(jsonPath(\"[0].name\").exists())\n            .andExpect(jsonPath(\"[0].name\").isString)\n            .andExpect(jsonPath(\"[0].createdAt\").doesNotExist())\n            .andExpect(jsonPath(\"[0].updatedAt\").doesNotExist())\n    }\n\n    @Test\n    fun `JsonFilter_single`() {\n        mockMvc.perform(\n            get(\"/json-filter\")\n                .param(\"fields\", \"isbn\")\n        )\n            .andDo(print())\n            .andExpect(status().isOk)\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))\n            .andExpect(jsonPath(\"isbn\").exists())\n            .andExpect(jsonPath(\"isbn\").isString)\n            .andExpect(jsonPath(\"title\").doesNotExist())\n            .andExpect(jsonPath(\"content\").doesNotExist())\n            .andExpect(jsonPath(\"createdAt\").doesNotExist())\n            .andExpect(jsonPath(\"updatedAt\").doesNotExist())\n    }\n}\n```\n\n## 2. @JsonFilter를 사용하는 예제\n위에서 본 @JsonView의 경우, 딱 지정해놓은 계층 구조 혹은 뷰가 아닐 경우 필드에 대한 선택 자체가 불가능하다. 결국 서버 어플리케이션에서 정해놓은 구조로만 부분 뷰를 응답 받을 수 있는 구조인데, 실제 요청에 부합하는 응답 값만 전달하기 위해서는 Jackson의 @JsonFilter 어노테이션과 Spring MVC의 MappingJacksonValue를 활용하면 해당 구현이 가능하다.\n\n```kotlin\n@JsonFilter(\"bookFilter\")\nclass Book (\n    val isbn: String,\n    val title: String,\n    val content: String,\n    val createdAt: LocalDateTime = LocalDateTime.now(),\n    val updatedAt: LocalDateTime = LocalDateTime.now()\n)\n\nclass GetReq {\n    var fields: List<String> = emptyList()\n}\n```\n\n```kotlin\n@RestController\n@RequestMapping\nclass BookController {\n    private companion object {\n        val book: Dto.Book = Dto.Book(\n            isbn = UUID.randomUUID().toString(),\n            title = \"Title\",\n            content = \"Content\"\n        )\n    }\n\n    @GetMapping(\"/json-filter\")\n    fun jsonFilter(reqDto: GetReq) = MappingJacksonValue(book).apply {\n        filters = SimpleFilterProvider().also {\n            it.addFilter(\"bookFilter\",\n                if (reqDto.fields.isNotEmpty()) SimpleBeanPropertyFilter.filterOutAllExcept(reqDto.fields.toSet())\n                else SimpleBeanPropertyFilter.serializeAll()\n            )\n        }\n    }\n}\n```\n\n### 테스트코드\n```kotlin\n@RunWith(SpringRunner::class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@AutoConfigureMockMvc\nclass MvcJacksonviewApplicationTests {\n\n    @Autowired\n    private lateinit var mockMvc: MockMvc\n\n    @Test\n    fun `JsonFilter_single`() {\n        mockMvc.perform(\n            get(\"/json-filter\")\n                .param(\"fields\", \"isbn\")\n        )\n            .andDo(print())\n            .andExpect(status().isOk)\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))\n            .andExpect(jsonPath(\"isbn\").exists())\n            .andExpect(jsonPath(\"isbn\").isString)\n            .andExpect(jsonPath(\"title\").doesNotExist())\n            .andExpect(jsonPath(\"content\").doesNotExist())\n            .andExpect(jsonPath(\"createdAt\").doesNotExist())\n            .andExpect(jsonPath(\"updatedAt\").doesNotExist())\n    }\n\n    @Test\n    fun `JsonFilter_comma_separator`() {\n        mockMvc.perform(\n            get(\"/json-filter\")\n                .param(\"fields\", \"isbn,title\")\n        )\n            .andDo(print())\n            .andExpect(status().isOk)\n            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))\n            .andExpect(jsonPath(\"isbn\").exists())\n            .andExpect(jsonPath(\"isbn\").isString)\n            .andExpect(jsonPath(\"title\").exists())\n            .andExpect(jsonPath(\"title\").isString)\n            .andExpect(jsonPath(\"content\").doesNotExist())\n            .andExpect(jsonPath(\"createdAt\").doesNotExist())\n            .andExpect(jsonPath(\"updatedAt\").doesNotExist())\n    }\n}\n```\n\n간단하게 @JsonView와 @JsonFilter를 사용하여 partial response에 대한 구현을 해볼 수 있었는데, 여기서 \b조금 더 나아가 복잡한 조건이나 구조에서의 구현이 필요할 경우 [Squiggly Filter ](https://github.com/bohnman/squiggly-java)와 같은 구현체를 사용하는 것도 좋은 선택이 될 수 있을거 같다.\n\n> 예제는 [링크](https://github.com/thefeeling/spring-code/tree/develop/spring-mvc-jacksonview)를 통하여 확인 가능합니다.\n\n## 참고\n- [spring-mvc – Spring MVC 컨트롤러에서 JsonView의 동적 선택](https://codeday.me/ko/qa/20190512/527260.html)\n- [Jackson JSON Views](https://www.baeldung.com/jackson-json-view-annotation)","slug":"Spring/MVC_PartialReseponse","published":1,"updated":"2021-08-02T12:05:06.006Z","_id":"ckrsup50x001vtjhv08qz3cn4","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"JsonView와-JsonFilter를-사용하여-Partial-response-구현하기\"><a href=\"#JsonView와-JsonFilter를-사용하여-Partial-response-구현하기\" class=\"headerlink\" title=\"@JsonView와 @JsonFilter를 사용하여 Partial response 구현하기\"></a>@JsonView와 @JsonFilter를 사용하여 Partial response 구현하기</h1><h2 id=\"개요\"><a href=\"#개요\" class=\"headerlink\" title=\"개요\"></a>개요</h2><p>JSON HTTP API를 구현할 때, 페이징만 구현하는 경우를 쉽게 볼 수 있는데, 여기서 한 걸음 더 나아가 조금 더 나은 퍼포먼스를 위하여 클라이언트가 필요한 필드만 골라서 받을 수 있도록 구현하는 것이 필요할 수 있다. 예를 들어 아래와 같은 상황을 예를 들어 볼 수 있다.</p>\n<ul>\n<li><p>HTTP Reqeust</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 GET /books/1?fields=isbn,title</span><br></pre></td></tr></table></figure></li>\n<li><p>HTTP Response</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;isbn&quot;</span>: <span class=\"string\">&quot;978-3-16-148410-0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;title&quot;</span>: <span class=\"string\">&quot;Book Title&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>책 데이터를 조회하는 JSON API가 있다고 했을 때, 헤당 API에서 제공하는 정보 중 일부 정보만을 클라이언트에서 필요한 경우에 fields 쿼리스트링에 필요한 키 값을 콤마 베이스로 나열하여 요청하는 예시이다. 클라이언트가 필요한 응답만을 제공하는 동시에 조금 더 나은 네트워크 레벨에서의 퍼포먼스를 가져갈 수 있다. 이런 부분적인 응답 값을 반환하는 것을 <code>Partial Response</code>라고 부르며 REST와 관련된 문서에서 심심찮게 발견할 수 있는 내용이다.</p>\n<ul>\n<li><a href=\"https://developers.google.com/drive/api/v3/performance\">GOOGLE-REST-Improve performance</a></li>\n<li><a href=\"https://bcho.tistory.com/914\">조대협님 블로그, REST API 디자인 가이드</a></li>\n<li><a href=\"https://docs.microsoft.com/ko-kr/azure/architecture/best-practices/api-design\">MS, API 디자인</a></li>\n</ul>\n<p>구현하는 언어와 환경에 따라 이를 구현하는 방법에는 차이가 존재하는데, 일반적으로 Spring Framework, Boot 환경에서는 JSON 데이터에 대한 처리를 GSON 혹은 Jackson 라이브러리가 담당하게 되는데 그 중에서도 Jackson을 사용하는 환경에서 간단하게 partial response를 구현하는 예제를 작성해보려고 한다.</p>\n<h2 id=\"개발-환경\"><a href=\"#개발-환경\" class=\"headerlink\" title=\"개발 환경\"></a>개발 환경</h2><ul>\n<li>Kotlin 1.3.31</li>\n<li>Spring Boot 2.1.5 RELEASE<ul>\n<li>WEB</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-JsonView를-사용한-예제\"><a href=\"#1-JsonView를-사용한-예제\" class=\"headerlink\" title=\"1. @JsonView를 사용한 예제\"></a>1. @JsonView를 사용한 예제</h2><p>@JsonView 어노테이션을 활용하면 계층적인 부분 렌더링이 가능하다. @JsonView에 대한 계층 정의 예와 유저에 대한 예제 엔티티는 아래와 같다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Views</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">List</span></span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Get</span>: <span class=\"type\">List</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>(</span><br><span class=\"line\">    <span class=\"meta\">@JsonView(Views.List::class)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> id: UUID = UUID.randomUUID(),</span><br><span class=\"line\">    <span class=\"meta\">@JsonView(Views.List::class)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> email: String,</span><br><span class=\"line\">    <span class=\"meta\">@JsonView(Views.List::class)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> name: String,</span><br><span class=\"line\">    <span class=\"meta\">@JsonView(Views.Get::class)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> createdAt: LocalDateTime = LocalDateTime.now(),</span><br><span class=\"line\">    <span class=\"meta\">@JsonView(Views.Get::class)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> updatedAt: LocalDateTime = LocalDateTime.now()</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>위와 같이 선언할 경우, <code>@JsonView(Dto.Views.List::class)</code>로 데이터를 처리하게 되면 모든 데이터를 유저 엔티티에서 <code>id</code>, <code>email</code>, <code>name</code>만을 Jackson 라이브러리가 serialize하게 된다. 반대로, <code>@JsonView(Dto.Views.Get::class)</code>으로 지정해놓게 되면 유저 엔티티의 모든 데이터가 serialize된다.</p>\n<p>Spring Mvc에서는 요청 컨트롤러 매핑 메서드에 @JsonView를 명시해주면 해당 뷰로 Serailize 할 수 있도록 지원하고 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> user = Dto.User(</span><br><span class=\"line\">            name = <span class=\"string\">&quot;Park&quot;</span>,</span><br><span class=\"line\">            email = <span class=\"string\">&quot;park@gmail.com&quot;</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(<span class=\"meta-string\">&quot;/get&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"meta\">@JsonView(Dto.Views.Get::class)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">jsonViewGet</span><span class=\"params\">()</span></span> = user</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(<span class=\"meta-string\">&quot;/list&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"meta\">@JsonView(Dto.Views.List::class)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">jsonViewList</span><span class=\"params\">()</span></span> = listOf(user)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>@JsonView를 통하여 제대로 결과가 반환되는지 테스트 코드를 간단하게 작성해보면 아래와 같다. 테스트코드는 스프링 부트의 통합테스트 환경을 그대로 사용했으며, jsonPath 라이브러리를 사용하여 해당 키 값이 제대로 존재하는지 그리고 타입이 정확한지 유무까지 테스트를 해봤다.</p>\n<h3 id=\"테스트코드\"><a href=\"#테스트코드\" class=\"headerlink\" title=\"테스트코드\"></a>테스트코드</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringRunner::class)</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigureMockMvc</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MvcJacksonviewApplicationTests</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> mockMvc: MockMvc</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> `JsonView_Get_Test`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        mockMvc.perform(</span><br><span class=\"line\">            <span class=\"keyword\">get</span>(<span class=\"string\">&quot;/get&quot;</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\">        .andDo(print())</span><br><span class=\"line\">        .andExpect(status().isOk)</span><br><span class=\"line\">        .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;id&quot;</span>).exists())</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;id&quot;</span>).isString)</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;email&quot;</span>).exists())</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;email&quot;</span>).isString)</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;name&quot;</span>).exists())</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;name&quot;</span>).isString)</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;createdAt&quot;</span>).exists())</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;createdAt&quot;</span>).isString)</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;updatedAt&quot;</span>).exists())</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;updatedAt&quot;</span>).isString)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> `JsonView_List_Test`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        mockMvc.perform(</span><br><span class=\"line\">            <span class=\"keyword\">get</span>(<span class=\"string\">&quot;/list&quot;</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\">            .andDo(print())</span><br><span class=\"line\">            .andExpect(status().isOk)</span><br><span class=\"line\">            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;[0].id&quot;</span>).exists())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;[0].id&quot;</span>).isString)</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;[0].email&quot;</span>).exists())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;[0].email&quot;</span>).isString)</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;[0].name&quot;</span>).exists())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;[0].name&quot;</span>).isString)</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;[0].createdAt&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;[0].updatedAt&quot;</span>).doesNotExist())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> `JsonFilter_single`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        mockMvc.perform(</span><br><span class=\"line\">            <span class=\"keyword\">get</span>(<span class=\"string\">&quot;/json-filter&quot;</span>)</span><br><span class=\"line\">                .param(<span class=\"string\">&quot;fields&quot;</span>, <span class=\"string\">&quot;isbn&quot;</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\">            .andDo(print())</span><br><span class=\"line\">            .andExpect(status().isOk)</span><br><span class=\"line\">            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;isbn&quot;</span>).exists())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;isbn&quot;</span>).isString)</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;title&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;content&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;createdAt&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;updatedAt&quot;</span>).doesNotExist())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-JsonFilter를-사용하는-예제\"><a href=\"#2-JsonFilter를-사용하는-예제\" class=\"headerlink\" title=\"2. @JsonFilter를 사용하는 예제\"></a>2. @JsonFilter를 사용하는 예제</h2><p>위에서 본 @JsonView의 경우, 딱 지정해놓은 계층 구조 혹은 뷰가 아닐 경우 필드에 대한 선택 자체가 불가능하다. 결국 서버 어플리케이션에서 정해놓은 구조로만 부분 뷰를 응답 받을 수 있는 구조인데, 실제 요청에 부합하는 응답 값만 전달하기 위해서는 Jackson의 @JsonFilter 어노테이션과 Spring MVC의 MappingJacksonValue를 활용하면 해당 구현이 가능하다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@JsonFilter(<span class=\"meta-string\">&quot;bookFilter&quot;</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span> </span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> isbn: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> title: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> content: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> createdAt: LocalDateTime = LocalDateTime.now(),</span><br><span class=\"line\">    <span class=\"keyword\">val</span> updatedAt: LocalDateTime = LocalDateTime.now()</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GetReq</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fields: List&lt;String&gt; = emptyList()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> book: Dto.Book = Dto.Book(</span><br><span class=\"line\">            isbn = UUID.randomUUID().toString(),</span><br><span class=\"line\">            title = <span class=\"string\">&quot;Title&quot;</span>,</span><br><span class=\"line\">            content = <span class=\"string\">&quot;Content&quot;</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(<span class=\"meta-string\">&quot;/json-filter&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">jsonFilter</span><span class=\"params\">(reqDto: <span class=\"type\">GetReq</span>)</span></span> = MappingJacksonValue(book).apply &#123;</span><br><span class=\"line\">        filters = SimpleFilterProvider().also &#123;</span><br><span class=\"line\">            it.addFilter(<span class=\"string\">&quot;bookFilter&quot;</span>,</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (reqDto.fields.isNotEmpty()) SimpleBeanPropertyFilter.filterOutAllExcept(reqDto.fields.toSet())</span><br><span class=\"line\">                <span class=\"keyword\">else</span> SimpleBeanPropertyFilter.serializeAll()</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"테스트코드-1\"><a href=\"#테스트코드-1\" class=\"headerlink\" title=\"테스트코드\"></a>테스트코드</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringRunner::class)</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigureMockMvc</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MvcJacksonviewApplicationTests</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> mockMvc: MockMvc</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> `JsonFilter_single`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        mockMvc.perform(</span><br><span class=\"line\">            <span class=\"keyword\">get</span>(<span class=\"string\">&quot;/json-filter&quot;</span>)</span><br><span class=\"line\">                .param(<span class=\"string\">&quot;fields&quot;</span>, <span class=\"string\">&quot;isbn&quot;</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\">            .andDo(print())</span><br><span class=\"line\">            .andExpect(status().isOk)</span><br><span class=\"line\">            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;isbn&quot;</span>).exists())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;isbn&quot;</span>).isString)</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;title&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;content&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;createdAt&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;updatedAt&quot;</span>).doesNotExist())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> `JsonFilter_comma_separator`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        mockMvc.perform(</span><br><span class=\"line\">            <span class=\"keyword\">get</span>(<span class=\"string\">&quot;/json-filter&quot;</span>)</span><br><span class=\"line\">                .param(<span class=\"string\">&quot;fields&quot;</span>, <span class=\"string\">&quot;isbn,title&quot;</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\">            .andDo(print())</span><br><span class=\"line\">            .andExpect(status().isOk)</span><br><span class=\"line\">            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;isbn&quot;</span>).exists())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;isbn&quot;</span>).isString)</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;title&quot;</span>).exists())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;title&quot;</span>).isString)</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;content&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;createdAt&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;updatedAt&quot;</span>).doesNotExist())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>간단하게 @JsonView와 @JsonFilter를 사용하여 partial response에 대한 구현을 해볼 수 있었는데, 여기서 \b조금 더 나아가 복잡한 조건이나 구조에서의 구현이 필요할 경우 <a href=\"https://github.com/bohnman/squiggly-java\">Squiggly Filter </a>와 같은 구현체를 사용하는 것도 좋은 선택이 될 수 있을거 같다.</p>\n<blockquote>\n<p>예제는 <a href=\"https://github.com/thefeeling/spring-code/tree/develop/spring-mvc-jacksonview\">링크</a>를 통하여 확인 가능합니다.</p>\n</blockquote>\n<h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><ul>\n<li><a href=\"https://codeday.me/ko/qa/20190512/527260.html\">spring-mvc – Spring MVC 컨트롤러에서 JsonView의 동적 선택</a></li>\n<li><a href=\"https://www.baeldung.com/jackson-json-view-annotation\">Jackson JSON Views</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JsonView와-JsonFilter를-사용하여-Partial-response-구현하기\"><a href=\"#JsonView와-JsonFilter를-사용하여-Partial-response-구현하기\" class=\"headerlink\" title=\"@JsonView와 @JsonFilter를 사용하여 Partial response 구현하기\"></a>@JsonView와 @JsonFilter를 사용하여 Partial response 구현하기</h1><h2 id=\"개요\"><a href=\"#개요\" class=\"headerlink\" title=\"개요\"></a>개요</h2><p>JSON HTTP API를 구현할 때, 페이징만 구현하는 경우를 쉽게 볼 수 있는데, 여기서 한 걸음 더 나아가 조금 더 나은 퍼포먼스를 위하여 클라이언트가 필요한 필드만 골라서 받을 수 있도록 구현하는 것이 필요할 수 있다. 예를 들어 아래와 같은 상황을 예를 들어 볼 수 있다.</p>\n<ul>\n<li><p>HTTP Reqeust</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 GET /books/1?fields=isbn,title</span><br></pre></td></tr></table></figure></li>\n<li><p>HTTP Response</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;isbn&quot;</span>: <span class=\"string\">&quot;978-3-16-148410-0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;title&quot;</span>: <span class=\"string\">&quot;Book Title&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>책 데이터를 조회하는 JSON API가 있다고 했을 때, 헤당 API에서 제공하는 정보 중 일부 정보만을 클라이언트에서 필요한 경우에 fields 쿼리스트링에 필요한 키 값을 콤마 베이스로 나열하여 요청하는 예시이다. 클라이언트가 필요한 응답만을 제공하는 동시에 조금 더 나은 네트워크 레벨에서의 퍼포먼스를 가져갈 수 있다. 이런 부분적인 응답 값을 반환하는 것을 <code>Partial Response</code>라고 부르며 REST와 관련된 문서에서 심심찮게 발견할 수 있는 내용이다.</p>\n<ul>\n<li><a href=\"https://developers.google.com/drive/api/v3/performance\">GOOGLE-REST-Improve performance</a></li>\n<li><a href=\"https://bcho.tistory.com/914\">조대협님 블로그, REST API 디자인 가이드</a></li>\n<li><a href=\"https://docs.microsoft.com/ko-kr/azure/architecture/best-practices/api-design\">MS, API 디자인</a></li>\n</ul>\n<p>구현하는 언어와 환경에 따라 이를 구현하는 방법에는 차이가 존재하는데, 일반적으로 Spring Framework, Boot 환경에서는 JSON 데이터에 대한 처리를 GSON 혹은 Jackson 라이브러리가 담당하게 되는데 그 중에서도 Jackson을 사용하는 환경에서 간단하게 partial response를 구현하는 예제를 작성해보려고 한다.</p>\n<h2 id=\"개발-환경\"><a href=\"#개발-환경\" class=\"headerlink\" title=\"개발 환경\"></a>개발 환경</h2><ul>\n<li>Kotlin 1.3.31</li>\n<li>Spring Boot 2.1.5 RELEASE<ul>\n<li>WEB</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-JsonView를-사용한-예제\"><a href=\"#1-JsonView를-사용한-예제\" class=\"headerlink\" title=\"1. @JsonView를 사용한 예제\"></a>1. @JsonView를 사용한 예제</h2><p>@JsonView 어노테이션을 활용하면 계층적인 부분 렌더링이 가능하다. @JsonView에 대한 계층 정의 예와 유저에 대한 예제 엔티티는 아래와 같다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Views</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">List</span></span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Get</span>: <span class=\"type\">List</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>(</span><br><span class=\"line\">    <span class=\"meta\">@JsonView(Views.List::class)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> id: UUID = UUID.randomUUID(),</span><br><span class=\"line\">    <span class=\"meta\">@JsonView(Views.List::class)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> email: String,</span><br><span class=\"line\">    <span class=\"meta\">@JsonView(Views.List::class)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> name: String,</span><br><span class=\"line\">    <span class=\"meta\">@JsonView(Views.Get::class)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> createdAt: LocalDateTime = LocalDateTime.now(),</span><br><span class=\"line\">    <span class=\"meta\">@JsonView(Views.Get::class)</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> updatedAt: LocalDateTime = LocalDateTime.now()</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>위와 같이 선언할 경우, <code>@JsonView(Dto.Views.List::class)</code>로 데이터를 처리하게 되면 모든 데이터를 유저 엔티티에서 <code>id</code>, <code>email</code>, <code>name</code>만을 Jackson 라이브러리가 serialize하게 된다. 반대로, <code>@JsonView(Dto.Views.Get::class)</code>으로 지정해놓게 되면 유저 엔티티의 모든 데이터가 serialize된다.</p>\n<p>Spring Mvc에서는 요청 컨트롤러 매핑 메서드에 @JsonView를 명시해주면 해당 뷰로 Serailize 할 수 있도록 지원하고 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> user = Dto.User(</span><br><span class=\"line\">            name = <span class=\"string\">&quot;Park&quot;</span>,</span><br><span class=\"line\">            email = <span class=\"string\">&quot;park@gmail.com&quot;</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(<span class=\"meta-string\">&quot;/get&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"meta\">@JsonView(Dto.Views.Get::class)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">jsonViewGet</span><span class=\"params\">()</span></span> = user</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(<span class=\"meta-string\">&quot;/list&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"meta\">@JsonView(Dto.Views.List::class)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">jsonViewList</span><span class=\"params\">()</span></span> = listOf(user)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>@JsonView를 통하여 제대로 결과가 반환되는지 테스트 코드를 간단하게 작성해보면 아래와 같다. 테스트코드는 스프링 부트의 통합테스트 환경을 그대로 사용했으며, jsonPath 라이브러리를 사용하여 해당 키 값이 제대로 존재하는지 그리고 타입이 정확한지 유무까지 테스트를 해봤다.</p>\n<h3 id=\"테스트코드\"><a href=\"#테스트코드\" class=\"headerlink\" title=\"테스트코드\"></a>테스트코드</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringRunner::class)</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigureMockMvc</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MvcJacksonviewApplicationTests</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> mockMvc: MockMvc</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> `JsonView_Get_Test`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        mockMvc.perform(</span><br><span class=\"line\">            <span class=\"keyword\">get</span>(<span class=\"string\">&quot;/get&quot;</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\">        .andDo(print())</span><br><span class=\"line\">        .andExpect(status().isOk)</span><br><span class=\"line\">        .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;id&quot;</span>).exists())</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;id&quot;</span>).isString)</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;email&quot;</span>).exists())</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;email&quot;</span>).isString)</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;name&quot;</span>).exists())</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;name&quot;</span>).isString)</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;createdAt&quot;</span>).exists())</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;createdAt&quot;</span>).isString)</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;updatedAt&quot;</span>).exists())</span><br><span class=\"line\">        .andExpect(jsonPath(<span class=\"string\">&quot;updatedAt&quot;</span>).isString)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> `JsonView_List_Test`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        mockMvc.perform(</span><br><span class=\"line\">            <span class=\"keyword\">get</span>(<span class=\"string\">&quot;/list&quot;</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\">            .andDo(print())</span><br><span class=\"line\">            .andExpect(status().isOk)</span><br><span class=\"line\">            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;[0].id&quot;</span>).exists())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;[0].id&quot;</span>).isString)</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;[0].email&quot;</span>).exists())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;[0].email&quot;</span>).isString)</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;[0].name&quot;</span>).exists())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;[0].name&quot;</span>).isString)</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;[0].createdAt&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;[0].updatedAt&quot;</span>).doesNotExist())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> `JsonFilter_single`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        mockMvc.perform(</span><br><span class=\"line\">            <span class=\"keyword\">get</span>(<span class=\"string\">&quot;/json-filter&quot;</span>)</span><br><span class=\"line\">                .param(<span class=\"string\">&quot;fields&quot;</span>, <span class=\"string\">&quot;isbn&quot;</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\">            .andDo(print())</span><br><span class=\"line\">            .andExpect(status().isOk)</span><br><span class=\"line\">            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;isbn&quot;</span>).exists())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;isbn&quot;</span>).isString)</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;title&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;content&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;createdAt&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;updatedAt&quot;</span>).doesNotExist())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-JsonFilter를-사용하는-예제\"><a href=\"#2-JsonFilter를-사용하는-예제\" class=\"headerlink\" title=\"2. @JsonFilter를 사용하는 예제\"></a>2. @JsonFilter를 사용하는 예제</h2><p>위에서 본 @JsonView의 경우, 딱 지정해놓은 계층 구조 혹은 뷰가 아닐 경우 필드에 대한 선택 자체가 불가능하다. 결국 서버 어플리케이션에서 정해놓은 구조로만 부분 뷰를 응답 받을 수 있는 구조인데, 실제 요청에 부합하는 응답 값만 전달하기 위해서는 Jackson의 @JsonFilter 어노테이션과 Spring MVC의 MappingJacksonValue를 활용하면 해당 구현이 가능하다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@JsonFilter(<span class=\"meta-string\">&quot;bookFilter&quot;</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span> </span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> isbn: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> title: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> content: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> createdAt: LocalDateTime = LocalDateTime.now(),</span><br><span class=\"line\">    <span class=\"keyword\">val</span> updatedAt: LocalDateTime = LocalDateTime.now()</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GetReq</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fields: List&lt;String&gt; = emptyList()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> book: Dto.Book = Dto.Book(</span><br><span class=\"line\">            isbn = UUID.randomUUID().toString(),</span><br><span class=\"line\">            title = <span class=\"string\">&quot;Title&quot;</span>,</span><br><span class=\"line\">            content = <span class=\"string\">&quot;Content&quot;</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(<span class=\"meta-string\">&quot;/json-filter&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">jsonFilter</span><span class=\"params\">(reqDto: <span class=\"type\">GetReq</span>)</span></span> = MappingJacksonValue(book).apply &#123;</span><br><span class=\"line\">        filters = SimpleFilterProvider().also &#123;</span><br><span class=\"line\">            it.addFilter(<span class=\"string\">&quot;bookFilter&quot;</span>,</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (reqDto.fields.isNotEmpty()) SimpleBeanPropertyFilter.filterOutAllExcept(reqDto.fields.toSet())</span><br><span class=\"line\">                <span class=\"keyword\">else</span> SimpleBeanPropertyFilter.serializeAll()</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"테스트코드-1\"><a href=\"#테스트코드-1\" class=\"headerlink\" title=\"테스트코드\"></a>테스트코드</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringRunner::class)</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigureMockMvc</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MvcJacksonviewApplicationTests</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> mockMvc: MockMvc</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> `JsonFilter_single`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        mockMvc.perform(</span><br><span class=\"line\">            <span class=\"keyword\">get</span>(<span class=\"string\">&quot;/json-filter&quot;</span>)</span><br><span class=\"line\">                .param(<span class=\"string\">&quot;fields&quot;</span>, <span class=\"string\">&quot;isbn&quot;</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\">            .andDo(print())</span><br><span class=\"line\">            .andExpect(status().isOk)</span><br><span class=\"line\">            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;isbn&quot;</span>).exists())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;isbn&quot;</span>).isString)</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;title&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;content&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;createdAt&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;updatedAt&quot;</span>).doesNotExist())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> `JsonFilter_comma_separator`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        mockMvc.perform(</span><br><span class=\"line\">            <span class=\"keyword\">get</span>(<span class=\"string\">&quot;/json-filter&quot;</span>)</span><br><span class=\"line\">                .param(<span class=\"string\">&quot;fields&quot;</span>, <span class=\"string\">&quot;isbn,title&quot;</span>)</span><br><span class=\"line\">        )</span><br><span class=\"line\">            .andDo(print())</span><br><span class=\"line\">            .andExpect(status().isOk)</span><br><span class=\"line\">            .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;isbn&quot;</span>).exists())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;isbn&quot;</span>).isString)</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;title&quot;</span>).exists())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;title&quot;</span>).isString)</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;content&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;createdAt&quot;</span>).doesNotExist())</span><br><span class=\"line\">            .andExpect(jsonPath(<span class=\"string\">&quot;updatedAt&quot;</span>).doesNotExist())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>간단하게 @JsonView와 @JsonFilter를 사용하여 partial response에 대한 구현을 해볼 수 있었는데, 여기서 \b조금 더 나아가 복잡한 조건이나 구조에서의 구현이 필요할 경우 <a href=\"https://github.com/bohnman/squiggly-java\">Squiggly Filter </a>와 같은 구현체를 사용하는 것도 좋은 선택이 될 수 있을거 같다.</p>\n<blockquote>\n<p>예제는 <a href=\"https://github.com/thefeeling/spring-code/tree/develop/spring-mvc-jacksonview\">링크</a>를 통하여 확인 가능합니다.</p>\n</blockquote>\n<h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><ul>\n<li><a href=\"https://codeday.me/ko/qa/20190512/527260.html\">spring-mvc – Spring MVC 컨트롤러에서 JsonView의 동적 선택</a></li>\n<li><a href=\"https://www.baeldung.com/jackson-json-view-annotation\">Jackson JSON Views</a></li>\n</ul>\n"},{"title":"MVC와 WebFlux에서의 @ReqeustParam","date":"2021-07-27T10:50:00.000Z","_content":"\n# MVC와 WebFlux에서의 @ReqeustParam\n\n## Spring MVC\n- Spring MVC에서는 기본적으로 `querystring`, `form-data`, `multipart` 요청에 대해 `@ReqeustParam`으로 매핑이 가능하다.\n- 이는 서블릿 API에서 `querystring`, `form-data(requestBody)`를 parameters map에 같이 바인딩하기 때문이다. \n\n> [RequestParamMethodArgumentResolver.resolveName](https://github.com/spring-projects/spring-framework/blob/f0f450a18dec7639ce8b967ed26c78cf777d4f7e/spring-web/src/main/java/org/springframework/web/method/annotation/RequestParamMethodArgumentResolver.java#L162)을 살펴보면 간단하게 로직 확인이 가능하다.\n\n## Spring Webflux\n- 웹플럭스에서는 querystring에서 대해서만 바인딩을 지원한다.\n\n> [RequestParamMethodArgumentResolver.resolveNamedValue](https://github.com/spring-projects/spring-framework/blob/f0f450a18dec7639ce8b967ed26c78cf777d4f7e/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/RequestParamMethodArgumentResolver.java#L101)을 살펴보면 간단하게 로직 확인이 가능하다.\n\n- MVC에서처럼 querystring, form-data, multipart 모두 값을 받으려면 `@ModelAttribute`를 이용해야 한다.\n\n## 참고\n- [RequestParam (Spring Framework 5.3.7 API)](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestParam.html)","source":"_posts/Spring/MVC_RequestParam.md","raw":"---\ntitle: 'MVC와 WebFlux에서의 @ReqeustParam'\ndate: 2021.7.27. 19:50\ncategories:\n- Spring\n---\n\n# MVC와 WebFlux에서의 @ReqeustParam\n\n## Spring MVC\n- Spring MVC에서는 기본적으로 `querystring`, `form-data`, `multipart` 요청에 대해 `@ReqeustParam`으로 매핑이 가능하다.\n- 이는 서블릿 API에서 `querystring`, `form-data(requestBody)`를 parameters map에 같이 바인딩하기 때문이다. \n\n> [RequestParamMethodArgumentResolver.resolveName](https://github.com/spring-projects/spring-framework/blob/f0f450a18dec7639ce8b967ed26c78cf777d4f7e/spring-web/src/main/java/org/springframework/web/method/annotation/RequestParamMethodArgumentResolver.java#L162)을 살펴보면 간단하게 로직 확인이 가능하다.\n\n## Spring Webflux\n- 웹플럭스에서는 querystring에서 대해서만 바인딩을 지원한다.\n\n> [RequestParamMethodArgumentResolver.resolveNamedValue](https://github.com/spring-projects/spring-framework/blob/f0f450a18dec7639ce8b967ed26c78cf777d4f7e/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/RequestParamMethodArgumentResolver.java#L101)을 살펴보면 간단하게 로직 확인이 가능하다.\n\n- MVC에서처럼 querystring, form-data, multipart 모두 값을 받으려면 `@ModelAttribute`를 이용해야 한다.\n\n## 참고\n- [RequestParam (Spring Framework 5.3.7 API)](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestParam.html)","slug":"Spring/MVC_RequestParam","published":1,"updated":"2021-08-02T11:59:03.459Z","_id":"ckrsup50y001wtjhv4yan8swi","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"MVC와-WebFlux에서의-ReqeustParam\"><a href=\"#MVC와-WebFlux에서의-ReqeustParam\" class=\"headerlink\" title=\"MVC와 WebFlux에서의 @ReqeustParam\"></a>MVC와 WebFlux에서의 @ReqeustParam</h1><h2 id=\"Spring-MVC\"><a href=\"#Spring-MVC\" class=\"headerlink\" title=\"Spring MVC\"></a>Spring MVC</h2><ul>\n<li>Spring MVC에서는 기본적으로 <code>querystring</code>, <code>form-data</code>, <code>multipart</code> 요청에 대해 <code>@ReqeustParam</code>으로 매핑이 가능하다.</li>\n<li>이는 서블릿 API에서 <code>querystring</code>, <code>form-data(requestBody)</code>를 parameters map에 같이 바인딩하기 때문이다. </li>\n</ul>\n<blockquote>\n<p><a href=\"https://github.com/spring-projects/spring-framework/blob/f0f450a18dec7639ce8b967ed26c78cf777d4f7e/spring-web/src/main/java/org/springframework/web/method/annotation/RequestParamMethodArgumentResolver.java#L162\">RequestParamMethodArgumentResolver.resolveName</a>을 살펴보면 간단하게 로직 확인이 가능하다.</p>\n</blockquote>\n<h2 id=\"Spring-Webflux\"><a href=\"#Spring-Webflux\" class=\"headerlink\" title=\"Spring Webflux\"></a>Spring Webflux</h2><ul>\n<li>웹플럭스에서는 querystring에서 대해서만 바인딩을 지원한다.</li>\n</ul>\n<blockquote>\n<p><a href=\"https://github.com/spring-projects/spring-framework/blob/f0f450a18dec7639ce8b967ed26c78cf777d4f7e/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/RequestParamMethodArgumentResolver.java#L101\">RequestParamMethodArgumentResolver.resolveNamedValue</a>을 살펴보면 간단하게 로직 확인이 가능하다.</p>\n</blockquote>\n<ul>\n<li>MVC에서처럼 querystring, form-data, multipart 모두 값을 받으려면 <code>@ModelAttribute</code>를 이용해야 한다.</li>\n</ul>\n<h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><ul>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestParam.html\">RequestParam (Spring Framework 5.3.7 API)</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MVC와-WebFlux에서의-ReqeustParam\"><a href=\"#MVC와-WebFlux에서의-ReqeustParam\" class=\"headerlink\" title=\"MVC와 WebFlux에서의 @ReqeustParam\"></a>MVC와 WebFlux에서의 @ReqeustParam</h1><h2 id=\"Spring-MVC\"><a href=\"#Spring-MVC\" class=\"headerlink\" title=\"Spring MVC\"></a>Spring MVC</h2><ul>\n<li>Spring MVC에서는 기본적으로 <code>querystring</code>, <code>form-data</code>, <code>multipart</code> 요청에 대해 <code>@ReqeustParam</code>으로 매핑이 가능하다.</li>\n<li>이는 서블릿 API에서 <code>querystring</code>, <code>form-data(requestBody)</code>를 parameters map에 같이 바인딩하기 때문이다. </li>\n</ul>\n<blockquote>\n<p><a href=\"https://github.com/spring-projects/spring-framework/blob/f0f450a18dec7639ce8b967ed26c78cf777d4f7e/spring-web/src/main/java/org/springframework/web/method/annotation/RequestParamMethodArgumentResolver.java#L162\">RequestParamMethodArgumentResolver.resolveName</a>을 살펴보면 간단하게 로직 확인이 가능하다.</p>\n</blockquote>\n<h2 id=\"Spring-Webflux\"><a href=\"#Spring-Webflux\" class=\"headerlink\" title=\"Spring Webflux\"></a>Spring Webflux</h2><ul>\n<li>웹플럭스에서는 querystring에서 대해서만 바인딩을 지원한다.</li>\n</ul>\n<blockquote>\n<p><a href=\"https://github.com/spring-projects/spring-framework/blob/f0f450a18dec7639ce8b967ed26c78cf777d4f7e/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/RequestParamMethodArgumentResolver.java#L101\">RequestParamMethodArgumentResolver.resolveNamedValue</a>을 살펴보면 간단하게 로직 확인이 가능하다.</p>\n</blockquote>\n<ul>\n<li>MVC에서처럼 querystring, form-data, multipart 모두 값을 받으려면 <code>@ModelAttribute</code>를 이용해야 한다.</li>\n</ul>\n<h2 id=\"참고\"><a href=\"#참고\" class=\"headerlink\" title=\"참고\"></a>참고</h2><ul>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestParam.html\">RequestParam (Spring Framework 5.3.7 API)</a></li>\n</ul>\n"},{"title":"RestTemplate","date":"2019-07-11T15:00:00.000Z","_content":"\n## ClientHttpRequestInterceptor 구현 관련\nClientHttpRequestInterceptor를 구현하여 request 와 response를 핸들하는 경우.\nrequest를 조회하는것은 문제가 없지만 response의 경우 인터셉터의 프로세스를 수행 후 인풋스트림이 닫히기 때문에 getBody() 에서 얻어올 컨텐츠 타입이 null포인터 익셉션이 발생한다.\n\nRestTemplate에 생성자로 BufferingClientHttpRequestFactory타입의 클래스를 넘겨주어야만 위와 같은 현상을 피할 수 있다. BufferingClientHttpRequestFactory 는  HttpComponentsClientHttpRequestFactory 를 주입받는다\n\n\n## Link\n[Reqeust, Reponse Logging](http://lng1982.tistory.com/238)\n","source":"_posts/Spring/RestTemplate.md","raw":"---\ntitle: 'RestTemplate'\ndate: 2019/7/12 00:00:00\ncategories:\n- Spring\n---\n\n## ClientHttpRequestInterceptor 구현 관련\nClientHttpRequestInterceptor를 구현하여 request 와 response를 핸들하는 경우.\nrequest를 조회하는것은 문제가 없지만 response의 경우 인터셉터의 프로세스를 수행 후 인풋스트림이 닫히기 때문에 getBody() 에서 얻어올 컨텐츠 타입이 null포인터 익셉션이 발생한다.\n\nRestTemplate에 생성자로 BufferingClientHttpRequestFactory타입의 클래스를 넘겨주어야만 위와 같은 현상을 피할 수 있다. BufferingClientHttpRequestFactory 는  HttpComponentsClientHttpRequestFactory 를 주입받는다\n\n\n## Link\n[Reqeust, Reponse Logging](http://lng1982.tistory.com/238)\n","slug":"Spring/RestTemplate","published":1,"updated":"2021-08-02T12:33:52.079Z","_id":"ckrsup50y001xtjhvgz1m56mx","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"ClientHttpRequestInterceptor-구현-관련\"><a href=\"#ClientHttpRequestInterceptor-구현-관련\" class=\"headerlink\" title=\"ClientHttpRequestInterceptor 구현 관련\"></a>ClientHttpRequestInterceptor 구현 관련</h2><p>ClientHttpRequestInterceptor를 구현하여 request 와 response를 핸들하는 경우.<br>request를 조회하는것은 문제가 없지만 response의 경우 인터셉터의 프로세스를 수행 후 인풋스트림이 닫히기 때문에 getBody() 에서 얻어올 컨텐츠 타입이 null포인터 익셉션이 발생한다.</p>\n<p>RestTemplate에 생성자로 BufferingClientHttpRequestFactory타입의 클래스를 넘겨주어야만 위와 같은 현상을 피할 수 있다. BufferingClientHttpRequestFactory 는  HttpComponentsClientHttpRequestFactory 를 주입받는다</p>\n<h2 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h2><p><a href=\"http://lng1982.tistory.com/238\">Reqeust, Reponse Logging</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ClientHttpRequestInterceptor-구현-관련\"><a href=\"#ClientHttpRequestInterceptor-구현-관련\" class=\"headerlink\" title=\"ClientHttpRequestInterceptor 구현 관련\"></a>ClientHttpRequestInterceptor 구현 관련</h2><p>ClientHttpRequestInterceptor를 구현하여 request 와 response를 핸들하는 경우.<br>request를 조회하는것은 문제가 없지만 response의 경우 인터셉터의 프로세스를 수행 후 인풋스트림이 닫히기 때문에 getBody() 에서 얻어올 컨텐츠 타입이 null포인터 익셉션이 발생한다.</p>\n<p>RestTemplate에 생성자로 BufferingClientHttpRequestFactory타입의 클래스를 넘겨주어야만 위와 같은 현상을 피할 수 있다. BufferingClientHttpRequestFactory 는  HttpComponentsClientHttpRequestFactory 를 주입받는다</p>\n<h2 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h2><p><a href=\"http://lng1982.tistory.com/238\">Reqeust, Reponse Logging</a></p>\n"},{"title":"Spring Test","date":"2019-07-11T15:00:00.000Z","_content":"\n# Spring Test\n---------\n\n1. Spring Boot 테스트 기능 소개\n    - [Spring Boot Test by ToastMeetup](http://meetup.toast.com/posts/124)\n\n2. Spring Boot 테스트 관련 Use-Case\n    - [test-driven-spring-boot](https://github.com/xpinjection/test-driven-spring-boot/tree/master/src/test)\n\n3. Spring Boot EmbeddedDatabase 설정 시 빈 등록 샘플 코드\n    - API Reference : https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/datasource/embedded/EmbeddedDatabaseBuilder.html\n    ```java\n    private DataSource dataSource() {\n        EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();\n        EmbeddedDatabase db = builder\n            .setType(EmbeddedDatabaseType.H2)\n            .setName(\"testdb;DATABASE_TO_UPPER=false;MODE=Oracle\")\n            .addScript(\"schema.sql\")\n            .addScript(\"data.sql\")\n            .build();\n        return db;\n    }\n    ```\n\n\n4. `@DataJpaTest`을 사용한 DataJpa 테스트 예제 코드\n    - [@DataJPATest with Spring Boot](http://javasampleapproach.com/testing/datajpatest-with-spring-boot)\n5. `JpaVendorAdapter` 인터페이스를 구현 객체를 @Bean으로 동록하여 EntityManagerFactoryBean 등록 예제 코드\n    - 테스트 내장 디비 설정 시 사용.\n    - 링크 : https://stackoverflow.com/questions/21968965/disable-table-recreation-in-spring-boot-application\n    ```java\n    @ComponentScan\n    @EnableAutoConfiguration\n    @EnableHypermediaSupport\n    @EnableSpringDataWebSupport\n    public class ApplicationConfig {\n\n        @Bean\n        public DataSource dataSource() {\n            DriverManagerDataSource datasource = new DriverManagerDataSource();\n            datasource.setDriverClassName(\"org.postgresql.Driver\");\n            datasource.setUrl(\"jdbc:postgresql://localhost/mydatabase\");\n            datasource.setUsername(\"myusername\");\n            datasource.setPassword(\"mypassword\");\n            return datasource;\n        }\n\n        @Bean\n        public LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource, JpaVendorAdapter jpaVendorAdapter) {\n            LocalContainerEntityManagerFactoryBean lef = new LocalContainerEntityManagerFactoryBean();\n            lef.setDataSource(dataSource);\n            lef.setJpaVendorAdapter(jpaVendorAdapter);\n            lef.setPackagesToScan(\"my.domain.package\");\n            Properties jpaProperties = new Properties();\n            jpaProperties.setProperty(\"hibernate.hbm2ddl.auto\", \"update\");\n            lef.setJpaProperties(jpaProperties);\n            return lef;\n        }\n\n        @Bean\n        public JpaVendorAdapter jpaVendorAdapter() {\n            HibernateJpaVendorAdapter hibernateJpaVendorAdapter = new HibernateJpaVendorAdapter();\n            hibernateJpaVendorAdapter.setShowSql(false);\n            hibernateJpaVendorAdapter.setGenerateDdl(true);\n            hibernateJpaVendorAdapter.setDatabase(Database.POSTGRESQL);\n            return hibernateJpaVendorAdapter;\n        }\n\n        @Bean\n        public PlatformTransactionManager transactionManager() {\n            return new JpaTransactionManager();\n        }\n\n        public static void main(String[] args) {\n            SpringApplication.run(ApplicationConfig.class, args);\n        }\n    }\n    ```","source":"_posts/Spring/TEST.md","raw":"---\ntitle: 'Spring Test'\ndate: 2019/7/12 00:00:00\ncategories:\n- Spring\n---\n\n# Spring Test\n---------\n\n1. Spring Boot 테스트 기능 소개\n    - [Spring Boot Test by ToastMeetup](http://meetup.toast.com/posts/124)\n\n2. Spring Boot 테스트 관련 Use-Case\n    - [test-driven-spring-boot](https://github.com/xpinjection/test-driven-spring-boot/tree/master/src/test)\n\n3. Spring Boot EmbeddedDatabase 설정 시 빈 등록 샘플 코드\n    - API Reference : https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/datasource/embedded/EmbeddedDatabaseBuilder.html\n    ```java\n    private DataSource dataSource() {\n        EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();\n        EmbeddedDatabase db = builder\n            .setType(EmbeddedDatabaseType.H2)\n            .setName(\"testdb;DATABASE_TO_UPPER=false;MODE=Oracle\")\n            .addScript(\"schema.sql\")\n            .addScript(\"data.sql\")\n            .build();\n        return db;\n    }\n    ```\n\n\n4. `@DataJpaTest`을 사용한 DataJpa 테스트 예제 코드\n    - [@DataJPATest with Spring Boot](http://javasampleapproach.com/testing/datajpatest-with-spring-boot)\n5. `JpaVendorAdapter` 인터페이스를 구현 객체를 @Bean으로 동록하여 EntityManagerFactoryBean 등록 예제 코드\n    - 테스트 내장 디비 설정 시 사용.\n    - 링크 : https://stackoverflow.com/questions/21968965/disable-table-recreation-in-spring-boot-application\n    ```java\n    @ComponentScan\n    @EnableAutoConfiguration\n    @EnableHypermediaSupport\n    @EnableSpringDataWebSupport\n    public class ApplicationConfig {\n\n        @Bean\n        public DataSource dataSource() {\n            DriverManagerDataSource datasource = new DriverManagerDataSource();\n            datasource.setDriverClassName(\"org.postgresql.Driver\");\n            datasource.setUrl(\"jdbc:postgresql://localhost/mydatabase\");\n            datasource.setUsername(\"myusername\");\n            datasource.setPassword(\"mypassword\");\n            return datasource;\n        }\n\n        @Bean\n        public LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource, JpaVendorAdapter jpaVendorAdapter) {\n            LocalContainerEntityManagerFactoryBean lef = new LocalContainerEntityManagerFactoryBean();\n            lef.setDataSource(dataSource);\n            lef.setJpaVendorAdapter(jpaVendorAdapter);\n            lef.setPackagesToScan(\"my.domain.package\");\n            Properties jpaProperties = new Properties();\n            jpaProperties.setProperty(\"hibernate.hbm2ddl.auto\", \"update\");\n            lef.setJpaProperties(jpaProperties);\n            return lef;\n        }\n\n        @Bean\n        public JpaVendorAdapter jpaVendorAdapter() {\n            HibernateJpaVendorAdapter hibernateJpaVendorAdapter = new HibernateJpaVendorAdapter();\n            hibernateJpaVendorAdapter.setShowSql(false);\n            hibernateJpaVendorAdapter.setGenerateDdl(true);\n            hibernateJpaVendorAdapter.setDatabase(Database.POSTGRESQL);\n            return hibernateJpaVendorAdapter;\n        }\n\n        @Bean\n        public PlatformTransactionManager transactionManager() {\n            return new JpaTransactionManager();\n        }\n\n        public static void main(String[] args) {\n            SpringApplication.run(ApplicationConfig.class, args);\n        }\n    }\n    ```","slug":"Spring/TEST","published":1,"updated":"2021-08-02T12:33:33.206Z","_id":"ckrsup50z001ytjhvcfya62up","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Spring-Test\"><a href=\"#Spring-Test\" class=\"headerlink\" title=\"Spring Test\"></a>Spring Test</h1><hr>\n<ol>\n<li><p>Spring Boot 테스트 기능 소개</p>\n<ul>\n<li><a href=\"http://meetup.toast.com/posts/124\">Spring Boot Test by ToastMeetup</a></li>\n</ul>\n</li>\n<li><p>Spring Boot 테스트 관련 Use-Case</p>\n<ul>\n<li><a href=\"https://github.com/xpinjection/test-driven-spring-boot/tree/master/src/test\">test-driven-spring-boot</a></li>\n</ul>\n</li>\n<li><p>Spring Boot EmbeddedDatabase 설정 시 빈 등록 샘플 코드</p>\n<ul>\n<li>API Reference : <a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/datasource/embedded/EmbeddedDatabaseBuilder.html\">https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/datasource/embedded/EmbeddedDatabaseBuilder.html</a><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    EmbeddedDatabaseBuilder builder = <span class=\"keyword\">new</span> EmbeddedDatabaseBuilder();</span><br><span class=\"line\">    EmbeddedDatabase db = builder</span><br><span class=\"line\">        .setType(EmbeddedDatabaseType.H2)</span><br><span class=\"line\">        .setName(<span class=\"string\">&quot;testdb;DATABASE_TO_UPPER=false;MODE=Oracle&quot;</span>)</span><br><span class=\"line\">        .addScript(<span class=\"string\">&quot;schema.sql&quot;</span>)</span><br><span class=\"line\">        .addScript(<span class=\"string\">&quot;data.sql&quot;</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> db;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li><code>@DataJpaTest</code>을 사용한 DataJpa 테스트 예제 코드<ul>\n<li><a href=\"http://javasampleapproach.com/testing/datajpatest-with-spring-boot\">@DataJPATest with Spring Boot</a></li>\n</ul>\n</li>\n<li><code>JpaVendorAdapter</code> 인터페이스를 구현 객체를 @Bean으로 동록하여 EntityManagerFactoryBean 등록 예제 코드<ul>\n<li>테스트 내장 디비 설정 시 사용.</li>\n<li>링크 : <a href=\"https://stackoverflow.com/questions/21968965/disable-table-recreation-in-spring-boot-application\">https://stackoverflow.com/questions/21968965/disable-table-recreation-in-spring-boot-application</a><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHypermediaSupport</span></span><br><span class=\"line\"><span class=\"meta\">@EnableSpringDataWebSupport</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        DriverManagerDataSource datasource = <span class=\"keyword\">new</span> DriverManagerDataSource();</span><br><span class=\"line\">        datasource.setDriverClassName(<span class=\"string\">&quot;org.postgresql.Driver&quot;</span>);</span><br><span class=\"line\">        datasource.setUrl(<span class=\"string\">&quot;jdbc:postgresql://localhost/mydatabase&quot;</span>);</span><br><span class=\"line\">        datasource.setUsername(<span class=\"string\">&quot;myusername&quot;</span>);</span><br><span class=\"line\">        datasource.setPassword(<span class=\"string\">&quot;mypassword&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> datasource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LocalContainerEntityManagerFactoryBean <span class=\"title\">entityManagerFactory</span><span class=\"params\">(DataSource dataSource, JpaVendorAdapter jpaVendorAdapter)</span> </span>&#123;</span><br><span class=\"line\">        LocalContainerEntityManagerFactoryBean lef = <span class=\"keyword\">new</span> LocalContainerEntityManagerFactoryBean();</span><br><span class=\"line\">        lef.setDataSource(dataSource);</span><br><span class=\"line\">        lef.setJpaVendorAdapter(jpaVendorAdapter);</span><br><span class=\"line\">        lef.setPackagesToScan(<span class=\"string\">&quot;my.domain.package&quot;</span>);</span><br><span class=\"line\">        Properties jpaProperties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">        jpaProperties.setProperty(<span class=\"string\">&quot;hibernate.hbm2ddl.auto&quot;</span>, <span class=\"string\">&quot;update&quot;</span>);</span><br><span class=\"line\">        lef.setJpaProperties(jpaProperties);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lef;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> JpaVendorAdapter <span class=\"title\">jpaVendorAdapter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        HibernateJpaVendorAdapter hibernateJpaVendorAdapter = <span class=\"keyword\">new</span> HibernateJpaVendorAdapter();</span><br><span class=\"line\">        hibernateJpaVendorAdapter.setShowSql(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        hibernateJpaVendorAdapter.setGenerateDdl(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        hibernateJpaVendorAdapter.setDatabase(Database.POSTGRESQL);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hibernateJpaVendorAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PlatformTransactionManager <span class=\"title\">transactionManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JpaTransactionManager();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(ApplicationConfig.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Spring-Test\"><a href=\"#Spring-Test\" class=\"headerlink\" title=\"Spring Test\"></a>Spring Test</h1><hr>\n<ol>\n<li><p>Spring Boot 테스트 기능 소개</p>\n<ul>\n<li><a href=\"http://meetup.toast.com/posts/124\">Spring Boot Test by ToastMeetup</a></li>\n</ul>\n</li>\n<li><p>Spring Boot 테스트 관련 Use-Case</p>\n<ul>\n<li><a href=\"https://github.com/xpinjection/test-driven-spring-boot/tree/master/src/test\">test-driven-spring-boot</a></li>\n</ul>\n</li>\n<li><p>Spring Boot EmbeddedDatabase 설정 시 빈 등록 샘플 코드</p>\n<ul>\n<li>API Reference : <a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/datasource/embedded/EmbeddedDatabaseBuilder.html\">https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/datasource/embedded/EmbeddedDatabaseBuilder.html</a><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    EmbeddedDatabaseBuilder builder = <span class=\"keyword\">new</span> EmbeddedDatabaseBuilder();</span><br><span class=\"line\">    EmbeddedDatabase db = builder</span><br><span class=\"line\">        .setType(EmbeddedDatabaseType.H2)</span><br><span class=\"line\">        .setName(<span class=\"string\">&quot;testdb;DATABASE_TO_UPPER=false;MODE=Oracle&quot;</span>)</span><br><span class=\"line\">        .addScript(<span class=\"string\">&quot;schema.sql&quot;</span>)</span><br><span class=\"line\">        .addScript(<span class=\"string\">&quot;data.sql&quot;</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> db;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li><code>@DataJpaTest</code>을 사용한 DataJpa 테스트 예제 코드<ul>\n<li><a href=\"http://javasampleapproach.com/testing/datajpatest-with-spring-boot\">@DataJPATest with Spring Boot</a></li>\n</ul>\n</li>\n<li><code>JpaVendorAdapter</code> 인터페이스를 구현 객체를 @Bean으로 동록하여 EntityManagerFactoryBean 등록 예제 코드<ul>\n<li>테스트 내장 디비 설정 시 사용.</li>\n<li>링크 : <a href=\"https://stackoverflow.com/questions/21968965/disable-table-recreation-in-spring-boot-application\">https://stackoverflow.com/questions/21968965/disable-table-recreation-in-spring-boot-application</a><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHypermediaSupport</span></span><br><span class=\"line\"><span class=\"meta\">@EnableSpringDataWebSupport</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        DriverManagerDataSource datasource = <span class=\"keyword\">new</span> DriverManagerDataSource();</span><br><span class=\"line\">        datasource.setDriverClassName(<span class=\"string\">&quot;org.postgresql.Driver&quot;</span>);</span><br><span class=\"line\">        datasource.setUrl(<span class=\"string\">&quot;jdbc:postgresql://localhost/mydatabase&quot;</span>);</span><br><span class=\"line\">        datasource.setUsername(<span class=\"string\">&quot;myusername&quot;</span>);</span><br><span class=\"line\">        datasource.setPassword(<span class=\"string\">&quot;mypassword&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> datasource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LocalContainerEntityManagerFactoryBean <span class=\"title\">entityManagerFactory</span><span class=\"params\">(DataSource dataSource, JpaVendorAdapter jpaVendorAdapter)</span> </span>&#123;</span><br><span class=\"line\">        LocalContainerEntityManagerFactoryBean lef = <span class=\"keyword\">new</span> LocalContainerEntityManagerFactoryBean();</span><br><span class=\"line\">        lef.setDataSource(dataSource);</span><br><span class=\"line\">        lef.setJpaVendorAdapter(jpaVendorAdapter);</span><br><span class=\"line\">        lef.setPackagesToScan(<span class=\"string\">&quot;my.domain.package&quot;</span>);</span><br><span class=\"line\">        Properties jpaProperties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">        jpaProperties.setProperty(<span class=\"string\">&quot;hibernate.hbm2ddl.auto&quot;</span>, <span class=\"string\">&quot;update&quot;</span>);</span><br><span class=\"line\">        lef.setJpaProperties(jpaProperties);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lef;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> JpaVendorAdapter <span class=\"title\">jpaVendorAdapter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        HibernateJpaVendorAdapter hibernateJpaVendorAdapter = <span class=\"keyword\">new</span> HibernateJpaVendorAdapter();</span><br><span class=\"line\">        hibernateJpaVendorAdapter.setShowSql(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        hibernateJpaVendorAdapter.setGenerateDdl(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        hibernateJpaVendorAdapter.setDatabase(Database.POSTGRESQL);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hibernateJpaVendorAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PlatformTransactionManager <span class=\"title\">transactionManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JpaTransactionManager();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(ApplicationConfig.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n"},{"title":"WebFlux & Reactor","date":"2020-04-16T15:00:00.000Z","_content":"\n# WebFlux & Reactor\n## Operator\n연산자의 종류는 매우 많으니, 일일이 설명하기는 힘든 부분이다. 아래 링크를 참고하자\n- [RxJS Marbles](https://rxmarbles.com/)\n\n## Stepverifier\n\n\n## Blocking Call Handling\n```java\nMono blockingWrapper = Mono.fromCallable(() -> { \n    return /* make a remote synchronous call */ \n});\nblockingWrapper = blockingWrapper.subscribeOn(Schedulers.boundedElastic()); \n```\nJDBC를 사용하는 경우, JDBC에 대한 구현 자체가 Blocking-Call로 발생하기 때문에, 그대로 사용할 경우 리액터 스레드가 빠르게 반환되지 않고 전반적인 어플리케이션 성능에 영향을 줄 수 있다. 이런 경우 때문에, 위 코드와 같이 스케줄러를 지정하여 사용하는 것이 리액터 레퍼런스에서 소개하는 적절한 방법이다. 아래 링크는 JDBC를 사용한 Blocking Call에 대한 이해를 좀 더 깊게 해줄 수 있는 좋은 글이다.\n\n- [리액티브하게 리팩토링하기 - JDBC 마이그레이션 해부](http://blog.lespinside.com/refactoring-to-react/)\n- [Spring 5 WebFlux and JDBC: To Block or Not to Block](https://dzone.com/articles/spring-5-webflux-and-jdbc-to-block-or-not-to-block)\n- [Spring: Blocking vs non-blocking: R2DBC vs JDBC and WebFlux vs Web MVC](https://technology.amis.nl/2020/04/10/spring-blocking-vs-non-blocking-r2dbc-vs-jdbc-and-webflux-vs-web-mvc/)\n\n## WebClient\n### Logging\nFilter를 사용하는 방법도 존재하지만, 필터에서는 Http Request와 Response의 디테일한 모든 부분을 보기 힘들다. Netty에 LoggingHandler를 활용하여 로깅을 설정할 수 있으며, 아래와 같이 설정하게 되면 오고가는 HTTP의 요청과 응답의 헤더와 바디를 로깅할 수 있다.\n\n\n```bash\nlogging.level.reactor.netty.http.client.HttpClient=DEBUG\n```\n\n\n```java\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.handler.logging.LoggingHandler;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.client.reactive.ReactorClientHttpConnector;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.reactive.function.client.WebClient;\nimport reactor.core.publisher.Mono;\nimport reactor.netty.channel.BootstrapHandlers;\nimport reactor.netty.http.client.HttpClient;\n\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\n\n@RestController\n@RequestMapping(\"/api\")\npublic class ApiController {\n    private static final HttpClient httpClient = HttpClient.create()\n            .tcpConfiguration(tcpClient ->\n                    tcpClient.bootstrap(bootstrap ->\n                            BootstrapHandlers.updateLogSupport(bootstrap, new HttpLoggingHandler(HttpClient.class))));\n\n    private static final WebClient webClient = WebClient.builder()\n            .clientConnector(new ReactorClientHttpConnector(httpClient))\n            .build();\n\n    @RequiredArgsConstructor\n    private static class Body {\n        private final String foo;\n    }\n\n    private static class HttpLoggingHandler extends LoggingHandler {\n\t  // 주의) LoggingHandler의 기본 생성자를 사용하게 될 경우, 로깅에 대한 디폴트 레벨이 지정된다. \n        public HttpLoggingHandler(Class<?> clazz) {\n            super(clazz);\n        }\n\n        @Override\n        protected String format(ChannelHandlerContext ctx, String event, Object arg) {\n            if (arg instanceof ByteBuf) {\n                ByteBuf msg = (ByteBuf) arg;\n                return msg.toString(StandardCharsets.UTF_8);\n            }\n            return super.format(ctx, event, arg);\n        }\n\n        @Override\n        public void channelRegistered(ChannelHandlerContext ctx) {\n            ctx.fireChannelRegistered();\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) {\n            ctx.fireChannelReadComplete();\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            ctx.fireChannelActive();\n        }\n\n        @Override\n        public void flush(ChannelHandlerContext ctx) {\n            ctx.flush();\n        }\n\n        @Override\n        public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {\n            ctx.connect(remoteAddress, localAddress, promise);\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n            ctx.fireUserEventTriggered(evt);\n        }\n    }\n\n    @GetMapping\n    public Mono<Map> res() {\n        return webClient.post()\n                .uri(\"https://postman-echo.com/post\")\n                .syncBody(\"{\\\"foo\\\" : \\\"bar\\\"}\")\n                .accept(MediaType.APPLICATION_JSON)\n                .exchange()\n                .flatMap(clientResponse -> clientResponse.bodyToMono(Map.class));\n    }\n\n\n}\n```\n\n![웹클라이언트_로깅이미지](https://i.imgur.com/OLFG7Uk.png)","source":"_posts/Spring/WEBFLUX.md","raw":"---\ntitle: 'WebFlux & Reactor'\ndate: 2020/4/17 00:00:00\ncategories:\n- Spring\n---\n\n# WebFlux & Reactor\n## Operator\n연산자의 종류는 매우 많으니, 일일이 설명하기는 힘든 부분이다. 아래 링크를 참고하자\n- [RxJS Marbles](https://rxmarbles.com/)\n\n## Stepverifier\n\n\n## Blocking Call Handling\n```java\nMono blockingWrapper = Mono.fromCallable(() -> { \n    return /* make a remote synchronous call */ \n});\nblockingWrapper = blockingWrapper.subscribeOn(Schedulers.boundedElastic()); \n```\nJDBC를 사용하는 경우, JDBC에 대한 구현 자체가 Blocking-Call로 발생하기 때문에, 그대로 사용할 경우 리액터 스레드가 빠르게 반환되지 않고 전반적인 어플리케이션 성능에 영향을 줄 수 있다. 이런 경우 때문에, 위 코드와 같이 스케줄러를 지정하여 사용하는 것이 리액터 레퍼런스에서 소개하는 적절한 방법이다. 아래 링크는 JDBC를 사용한 Blocking Call에 대한 이해를 좀 더 깊게 해줄 수 있는 좋은 글이다.\n\n- [리액티브하게 리팩토링하기 - JDBC 마이그레이션 해부](http://blog.lespinside.com/refactoring-to-react/)\n- [Spring 5 WebFlux and JDBC: To Block or Not to Block](https://dzone.com/articles/spring-5-webflux-and-jdbc-to-block-or-not-to-block)\n- [Spring: Blocking vs non-blocking: R2DBC vs JDBC and WebFlux vs Web MVC](https://technology.amis.nl/2020/04/10/spring-blocking-vs-non-blocking-r2dbc-vs-jdbc-and-webflux-vs-web-mvc/)\n\n## WebClient\n### Logging\nFilter를 사용하는 방법도 존재하지만, 필터에서는 Http Request와 Response의 디테일한 모든 부분을 보기 힘들다. Netty에 LoggingHandler를 활용하여 로깅을 설정할 수 있으며, 아래와 같이 설정하게 되면 오고가는 HTTP의 요청과 응답의 헤더와 바디를 로깅할 수 있다.\n\n\n```bash\nlogging.level.reactor.netty.http.client.HttpClient=DEBUG\n```\n\n\n```java\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.handler.logging.LoggingHandler;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.client.reactive.ReactorClientHttpConnector;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.reactive.function.client.WebClient;\nimport reactor.core.publisher.Mono;\nimport reactor.netty.channel.BootstrapHandlers;\nimport reactor.netty.http.client.HttpClient;\n\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\n\n@RestController\n@RequestMapping(\"/api\")\npublic class ApiController {\n    private static final HttpClient httpClient = HttpClient.create()\n            .tcpConfiguration(tcpClient ->\n                    tcpClient.bootstrap(bootstrap ->\n                            BootstrapHandlers.updateLogSupport(bootstrap, new HttpLoggingHandler(HttpClient.class))));\n\n    private static final WebClient webClient = WebClient.builder()\n            .clientConnector(new ReactorClientHttpConnector(httpClient))\n            .build();\n\n    @RequiredArgsConstructor\n    private static class Body {\n        private final String foo;\n    }\n\n    private static class HttpLoggingHandler extends LoggingHandler {\n\t  // 주의) LoggingHandler의 기본 생성자를 사용하게 될 경우, 로깅에 대한 디폴트 레벨이 지정된다. \n        public HttpLoggingHandler(Class<?> clazz) {\n            super(clazz);\n        }\n\n        @Override\n        protected String format(ChannelHandlerContext ctx, String event, Object arg) {\n            if (arg instanceof ByteBuf) {\n                ByteBuf msg = (ByteBuf) arg;\n                return msg.toString(StandardCharsets.UTF_8);\n            }\n            return super.format(ctx, event, arg);\n        }\n\n        @Override\n        public void channelRegistered(ChannelHandlerContext ctx) {\n            ctx.fireChannelRegistered();\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) {\n            ctx.fireChannelReadComplete();\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            ctx.fireChannelActive();\n        }\n\n        @Override\n        public void flush(ChannelHandlerContext ctx) {\n            ctx.flush();\n        }\n\n        @Override\n        public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {\n            ctx.connect(remoteAddress, localAddress, promise);\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n            ctx.fireUserEventTriggered(evt);\n        }\n    }\n\n    @GetMapping\n    public Mono<Map> res() {\n        return webClient.post()\n                .uri(\"https://postman-echo.com/post\")\n                .syncBody(\"{\\\"foo\\\" : \\\"bar\\\"}\")\n                .accept(MediaType.APPLICATION_JSON)\n                .exchange()\n                .flatMap(clientResponse -> clientResponse.bodyToMono(Map.class));\n    }\n\n\n}\n```\n\n![웹클라이언트_로깅이미지](https://i.imgur.com/OLFG7Uk.png)","slug":"Spring/WEBFLUX","published":1,"updated":"2021-08-02T12:33:34.015Z","_id":"ckrsup50z001ztjhvblzy9v8n","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"WebFlux-amp-Reactor\"><a href=\"#WebFlux-amp-Reactor\" class=\"headerlink\" title=\"WebFlux &amp; Reactor\"></a>WebFlux &amp; Reactor</h1><h2 id=\"Operator\"><a href=\"#Operator\" class=\"headerlink\" title=\"Operator\"></a>Operator</h2><p>연산자의 종류는 매우 많으니, 일일이 설명하기는 힘든 부분이다. 아래 링크를 참고하자</p>\n<ul>\n<li><a href=\"https://rxmarbles.com/\">RxJS Marbles</a></li>\n</ul>\n<h2 id=\"Stepverifier\"><a href=\"#Stepverifier\" class=\"headerlink\" title=\"Stepverifier\"></a>Stepverifier</h2><h2 id=\"Blocking-Call-Handling\"><a href=\"#Blocking-Call-Handling\" class=\"headerlink\" title=\"Blocking Call Handling\"></a>Blocking Call Handling</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mono blockingWrapper = Mono.fromCallable(() -&gt; &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"comment\">/* make a remote synchronous call */</span> </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">blockingWrapper = blockingWrapper.subscribeOn(Schedulers.boundedElastic()); </span><br></pre></td></tr></table></figure>\n<p>JDBC를 사용하는 경우, JDBC에 대한 구현 자체가 Blocking-Call로 발생하기 때문에, 그대로 사용할 경우 리액터 스레드가 빠르게 반환되지 않고 전반적인 어플리케이션 성능에 영향을 줄 수 있다. 이런 경우 때문에, 위 코드와 같이 스케줄러를 지정하여 사용하는 것이 리액터 레퍼런스에서 소개하는 적절한 방법이다. 아래 링크는 JDBC를 사용한 Blocking Call에 대한 이해를 좀 더 깊게 해줄 수 있는 좋은 글이다.</p>\n<ul>\n<li><a href=\"http://blog.lespinside.com/refactoring-to-react/\">리액티브하게 리팩토링하기 - JDBC 마이그레이션 해부</a></li>\n<li><a href=\"https://dzone.com/articles/spring-5-webflux-and-jdbc-to-block-or-not-to-block\">Spring 5 WebFlux and JDBC: To Block or Not to Block</a></li>\n<li><a href=\"https://technology.amis.nl/2020/04/10/spring-blocking-vs-non-blocking-r2dbc-vs-jdbc-and-webflux-vs-web-mvc/\">Spring: Blocking vs non-blocking: R2DBC vs JDBC and WebFlux vs Web MVC</a></li>\n</ul>\n<h2 id=\"WebClient\"><a href=\"#WebClient\" class=\"headerlink\" title=\"WebClient\"></a>WebClient</h2><h3 id=\"Logging\"><a href=\"#Logging\" class=\"headerlink\" title=\"Logging\"></a>Logging</h3><p>Filter를 사용하는 방법도 존재하지만, 필터에서는 Http Request와 Response의 디테일한 모든 부분을 보기 힘들다. Netty에 LoggingHandler를 활용하여 로깅을 설정할 수 있으며, 아래와 같이 설정하게 되면 오고가는 HTTP의 요청과 응답의 헤더와 바디를 로깅할 수 있다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logging.level.reactor.netty.http.client.HttpClient=DEBUG</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> io.netty.buffer.ByteBuf;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelPromise;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.RequiredArgsConstructor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.http.MediaType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.http.client.reactive.ReactorClientHttpConnector;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.reactive.function.client.WebClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> reactor.core.publisher.Mono;</span><br><span class=\"line\"><span class=\"keyword\">import</span> reactor.netty.channel.BootstrapHandlers;</span><br><span class=\"line\"><span class=\"keyword\">import</span> reactor.netty.http.client.HttpClient;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.SocketAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.charset.StandardCharsets;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/api&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HttpClient httpClient = HttpClient.create()</span><br><span class=\"line\">            .tcpConfiguration(tcpClient -&gt;</span><br><span class=\"line\">                    tcpClient.bootstrap(bootstrap -&gt;</span><br><span class=\"line\">                            BootstrapHandlers.updateLogSupport(bootstrap, <span class=\"keyword\">new</span> HttpLoggingHandler(HttpClient.class))));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> WebClient webClient = WebClient.builder()</span><br><span class=\"line\">            .clientConnector(<span class=\"keyword\">new</span> ReactorClientHttpConnector(httpClient))</span><br><span class=\"line\">            .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequiredArgsConstructor</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Body</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String foo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpLoggingHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">LoggingHandler</span> </span>&#123;</span><br><span class=\"line\">\t  <span class=\"comment\">// 주의) LoggingHandler의 기본 생성자를 사용하게 될 경우, 로깅에 대한 디폴트 레벨이 지정된다. </span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HttpLoggingHandler</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(clazz);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">format</span><span class=\"params\">(ChannelHandlerContext ctx, String event, Object arg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arg <span class=\"keyword\">instanceof</span> ByteBuf) &#123;</span><br><span class=\"line\">                ByteBuf msg = (ByteBuf) arg;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> msg.toString(StandardCharsets.UTF_8);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.format(ctx, event, arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRegistered</span><span class=\"params\">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class=\"line\">            ctx.fireChannelRegistered();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelReadComplete</span><span class=\"params\">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class=\"line\">            ctx.fireChannelReadComplete();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class=\"line\">            ctx.fireChannelActive();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">flush</span><span class=\"params\">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class=\"line\">            ctx.flush();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">connect</span><span class=\"params\">(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class=\"line\">            ctx.connect(remoteAddress, localAddress, promise);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">userEventTriggered</span><span class=\"params\">(ChannelHandlerContext ctx, Object evt)</span> </span>&#123;</span><br><span class=\"line\">            ctx.fireUserEventTriggered(evt);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Mono&lt;Map&gt; <span class=\"title\">res</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> webClient.post()</span><br><span class=\"line\">                .uri(<span class=\"string\">&quot;https://postman-echo.com/post&quot;</span>)</span><br><span class=\"line\">                .syncBody(<span class=\"string\">&quot;&#123;\\&quot;foo\\&quot; : \\&quot;bar\\&quot;&#125;&quot;</span>)</span><br><span class=\"line\">                .accept(MediaType.APPLICATION_JSON)</span><br><span class=\"line\">                .exchange()</span><br><span class=\"line\">                .flatMap(clientResponse -&gt; clientResponse.bodyToMono(Map.class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.imgur.com/OLFG7Uk.png\" alt=\"웹클라이언트_로깅이미지\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"WebFlux-amp-Reactor\"><a href=\"#WebFlux-amp-Reactor\" class=\"headerlink\" title=\"WebFlux &amp; Reactor\"></a>WebFlux &amp; Reactor</h1><h2 id=\"Operator\"><a href=\"#Operator\" class=\"headerlink\" title=\"Operator\"></a>Operator</h2><p>연산자의 종류는 매우 많으니, 일일이 설명하기는 힘든 부분이다. 아래 링크를 참고하자</p>\n<ul>\n<li><a href=\"https://rxmarbles.com/\">RxJS Marbles</a></li>\n</ul>\n<h2 id=\"Stepverifier\"><a href=\"#Stepverifier\" class=\"headerlink\" title=\"Stepverifier\"></a>Stepverifier</h2><h2 id=\"Blocking-Call-Handling\"><a href=\"#Blocking-Call-Handling\" class=\"headerlink\" title=\"Blocking Call Handling\"></a>Blocking Call Handling</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mono blockingWrapper = Mono.fromCallable(() -&gt; &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"comment\">/* make a remote synchronous call */</span> </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">blockingWrapper = blockingWrapper.subscribeOn(Schedulers.boundedElastic()); </span><br></pre></td></tr></table></figure>\n<p>JDBC를 사용하는 경우, JDBC에 대한 구현 자체가 Blocking-Call로 발생하기 때문에, 그대로 사용할 경우 리액터 스레드가 빠르게 반환되지 않고 전반적인 어플리케이션 성능에 영향을 줄 수 있다. 이런 경우 때문에, 위 코드와 같이 스케줄러를 지정하여 사용하는 것이 리액터 레퍼런스에서 소개하는 적절한 방법이다. 아래 링크는 JDBC를 사용한 Blocking Call에 대한 이해를 좀 더 깊게 해줄 수 있는 좋은 글이다.</p>\n<ul>\n<li><a href=\"http://blog.lespinside.com/refactoring-to-react/\">리액티브하게 리팩토링하기 - JDBC 마이그레이션 해부</a></li>\n<li><a href=\"https://dzone.com/articles/spring-5-webflux-and-jdbc-to-block-or-not-to-block\">Spring 5 WebFlux and JDBC: To Block or Not to Block</a></li>\n<li><a href=\"https://technology.amis.nl/2020/04/10/spring-blocking-vs-non-blocking-r2dbc-vs-jdbc-and-webflux-vs-web-mvc/\">Spring: Blocking vs non-blocking: R2DBC vs JDBC and WebFlux vs Web MVC</a></li>\n</ul>\n<h2 id=\"WebClient\"><a href=\"#WebClient\" class=\"headerlink\" title=\"WebClient\"></a>WebClient</h2><h3 id=\"Logging\"><a href=\"#Logging\" class=\"headerlink\" title=\"Logging\"></a>Logging</h3><p>Filter를 사용하는 방법도 존재하지만, 필터에서는 Http Request와 Response의 디테일한 모든 부분을 보기 힘들다. Netty에 LoggingHandler를 활용하여 로깅을 설정할 수 있으며, 아래와 같이 설정하게 되면 오고가는 HTTP의 요청과 응답의 헤더와 바디를 로깅할 수 있다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logging.level.reactor.netty.http.client.HttpClient=DEBUG</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> io.netty.buffer.ByteBuf;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.ChannelPromise;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.RequiredArgsConstructor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.http.MediaType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.http.client.reactive.ReactorClientHttpConnector;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.reactive.function.client.WebClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> reactor.core.publisher.Mono;</span><br><span class=\"line\"><span class=\"keyword\">import</span> reactor.netty.channel.BootstrapHandlers;</span><br><span class=\"line\"><span class=\"keyword\">import</span> reactor.netty.http.client.HttpClient;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.SocketAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.charset.StandardCharsets;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/api&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HttpClient httpClient = HttpClient.create()</span><br><span class=\"line\">            .tcpConfiguration(tcpClient -&gt;</span><br><span class=\"line\">                    tcpClient.bootstrap(bootstrap -&gt;</span><br><span class=\"line\">                            BootstrapHandlers.updateLogSupport(bootstrap, <span class=\"keyword\">new</span> HttpLoggingHandler(HttpClient.class))));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> WebClient webClient = WebClient.builder()</span><br><span class=\"line\">            .clientConnector(<span class=\"keyword\">new</span> ReactorClientHttpConnector(httpClient))</span><br><span class=\"line\">            .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequiredArgsConstructor</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Body</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String foo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpLoggingHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">LoggingHandler</span> </span>&#123;</span><br><span class=\"line\">\t  <span class=\"comment\">// 주의) LoggingHandler의 기본 생성자를 사용하게 될 경우, 로깅에 대한 디폴트 레벨이 지정된다. </span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HttpLoggingHandler</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(clazz);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">format</span><span class=\"params\">(ChannelHandlerContext ctx, String event, Object arg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arg <span class=\"keyword\">instanceof</span> ByteBuf) &#123;</span><br><span class=\"line\">                ByteBuf msg = (ByteBuf) arg;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> msg.toString(StandardCharsets.UTF_8);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.format(ctx, event, arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRegistered</span><span class=\"params\">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class=\"line\">            ctx.fireChannelRegistered();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelReadComplete</span><span class=\"params\">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class=\"line\">            ctx.fireChannelReadComplete();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class=\"line\">            ctx.fireChannelActive();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">flush</span><span class=\"params\">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class=\"line\">            ctx.flush();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">connect</span><span class=\"params\">(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class=\"line\">            ctx.connect(remoteAddress, localAddress, promise);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">userEventTriggered</span><span class=\"params\">(ChannelHandlerContext ctx, Object evt)</span> </span>&#123;</span><br><span class=\"line\">            ctx.fireUserEventTriggered(evt);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Mono&lt;Map&gt; <span class=\"title\">res</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> webClient.post()</span><br><span class=\"line\">                .uri(<span class=\"string\">&quot;https://postman-echo.com/post&quot;</span>)</span><br><span class=\"line\">                .syncBody(<span class=\"string\">&quot;&#123;\\&quot;foo\\&quot; : \\&quot;bar\\&quot;&#125;&quot;</span>)</span><br><span class=\"line\">                .accept(MediaType.APPLICATION_JSON)</span><br><span class=\"line\">                .exchange()</span><br><span class=\"line\">                .flatMap(clientResponse -&gt; clientResponse.bodyToMono(Map.class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.imgur.com/OLFG7Uk.png\" alt=\"웹클라이언트_로깅이미지\"></p>\n"},{"title":"WebStorm Optimize","date":"2019-07-11T15:00:00.000Z","_content":"\n# WebStorm Optimize\n- 불필요한 파일은 검색에서 제외(exlcude directory from search)\n\n  - Settings => Scopes => Create a custom scope\n  - exclude/include 옵션을 사용하여 디렉토리 지정\n  - 제외 옵션이 제대로 동작하는지 확인\n\n- JVM 옵션 설정(Congifure JVM Options)\n\n  - 참고 : https://gist.github.com/P7h/4388881\n\n  ```\n  -server\n  -Xms1024m\n  -Xmx3072m\n  -XX:NewSize=512m\n  -XX:MaxNewSize=512m\n  -XX:PermSize=512m\n  -XX:MaxPermSize=512m\n  -XX:+UseParNewGC\n  -XX:ParallelGCThreads=4\n  -XX:MaxTenuringThreshold=1\n  -XX:SurvivorRatio=8\n  -XX:+UseCodeCacheFlushing\n  -XX:+UseConcMarkSweepGC\n  -XX:+AggressiveOpts\n  -XX:+CMSClassUnloadingEnabled\n  -XX:+CMSIncrementalMode\n  -XX:+CMSIncrementalPacing\n  -XX:+CMSParallelRemarkEnabled\n  -XX:CMSInitiatingOccupancyFraction=65\n  -XX:+CMSScavengeBeforeRemark\n  -XX:+UseCMSInitiatingOccupancyOnly\n  -XX:ReservedCodeCacheSize=1024m\n  -XX:-TraceClassUnloading\n  -ea\n  -Dsun.io.useCanonCaches=false\n  ```\n\n- Configure idea.properties\n\n  - 소스 코드 편집기에서 편집 시, read/write lock 발생에 따라 지연이 생길 수 있음.\n\n    - [zero-latency mode](https://blog.jetbrains.com/idea/2015/08/experimental-zero-latency-typing-in-intellij-idea-15-eap/)를 활성화하여 지연을 줄임\n\n      ```\n      /Applications/WebStorm.app/Contents/bin/idea.properties\n      ```\n\n      ```\n      editor.zero.latency.typing=true\n      ```\n\n      ​\n\n  ​","source":"_posts/TOOL-IDE/WebStorm_Optimize.md","raw":"---\ntitle: 'WebStorm Optimize'\ndate: 2019/7/12 00:00:00\ncategories:\n- Spring\n---\n\n# WebStorm Optimize\n- 불필요한 파일은 검색에서 제외(exlcude directory from search)\n\n  - Settings => Scopes => Create a custom scope\n  - exclude/include 옵션을 사용하여 디렉토리 지정\n  - 제외 옵션이 제대로 동작하는지 확인\n\n- JVM 옵션 설정(Congifure JVM Options)\n\n  - 참고 : https://gist.github.com/P7h/4388881\n\n  ```\n  -server\n  -Xms1024m\n  -Xmx3072m\n  -XX:NewSize=512m\n  -XX:MaxNewSize=512m\n  -XX:PermSize=512m\n  -XX:MaxPermSize=512m\n  -XX:+UseParNewGC\n  -XX:ParallelGCThreads=4\n  -XX:MaxTenuringThreshold=1\n  -XX:SurvivorRatio=8\n  -XX:+UseCodeCacheFlushing\n  -XX:+UseConcMarkSweepGC\n  -XX:+AggressiveOpts\n  -XX:+CMSClassUnloadingEnabled\n  -XX:+CMSIncrementalMode\n  -XX:+CMSIncrementalPacing\n  -XX:+CMSParallelRemarkEnabled\n  -XX:CMSInitiatingOccupancyFraction=65\n  -XX:+CMSScavengeBeforeRemark\n  -XX:+UseCMSInitiatingOccupancyOnly\n  -XX:ReservedCodeCacheSize=1024m\n  -XX:-TraceClassUnloading\n  -ea\n  -Dsun.io.useCanonCaches=false\n  ```\n\n- Configure idea.properties\n\n  - 소스 코드 편집기에서 편집 시, read/write lock 발생에 따라 지연이 생길 수 있음.\n\n    - [zero-latency mode](https://blog.jetbrains.com/idea/2015/08/experimental-zero-latency-typing-in-intellij-idea-15-eap/)를 활성화하여 지연을 줄임\n\n      ```\n      /Applications/WebStorm.app/Contents/bin/idea.properties\n      ```\n\n      ```\n      editor.zero.latency.typing=true\n      ```\n\n      ​\n\n  ​","slug":"TOOL-IDE/WebStorm_Optimize","published":1,"updated":"2021-08-02T12:22:57.247Z","_id":"ckrsup5100020tjhv2gqe0maf","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"WebStorm-Optimize\"><a href=\"#WebStorm-Optimize\" class=\"headerlink\" title=\"WebStorm Optimize\"></a>WebStorm Optimize</h1><ul>\n<li><p>불필요한 파일은 검색에서 제외(exlcude directory from search)</p>\n<ul>\n<li>Settings =&gt; Scopes =&gt; Create a custom scope</li>\n<li>exclude/include 옵션을 사용하여 디렉토리 지정</li>\n<li>제외 옵션이 제대로 동작하는지 확인</li>\n</ul>\n</li>\n<li><p>JVM 옵션 설정(Congifure JVM Options)</p>\n<ul>\n<li>참고 : <a href=\"https://gist.github.com/P7h/4388881\">https://gist.github.com/P7h/4388881</a></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-server</span><br><span class=\"line\">-Xms1024m</span><br><span class=\"line\">-Xmx3072m</span><br><span class=\"line\">-XX:NewSize=512m</span><br><span class=\"line\">-XX:MaxNewSize=512m</span><br><span class=\"line\">-XX:PermSize=512m</span><br><span class=\"line\">-XX:MaxPermSize=512m</span><br><span class=\"line\">-XX:+UseParNewGC</span><br><span class=\"line\">-XX:ParallelGCThreads=4</span><br><span class=\"line\">-XX:MaxTenuringThreshold=1</span><br><span class=\"line\">-XX:SurvivorRatio=8</span><br><span class=\"line\">-XX:+UseCodeCacheFlushing</span><br><span class=\"line\">-XX:+UseConcMarkSweepGC</span><br><span class=\"line\">-XX:+AggressiveOpts</span><br><span class=\"line\">-XX:+CMSClassUnloadingEnabled</span><br><span class=\"line\">-XX:+CMSIncrementalMode</span><br><span class=\"line\">-XX:+CMSIncrementalPacing</span><br><span class=\"line\">-XX:+CMSParallelRemarkEnabled</span><br><span class=\"line\">-XX:CMSInitiatingOccupancyFraction=65</span><br><span class=\"line\">-XX:+CMSScavengeBeforeRemark</span><br><span class=\"line\">-XX:+UseCMSInitiatingOccupancyOnly</span><br><span class=\"line\">-XX:ReservedCodeCacheSize=1024m</span><br><span class=\"line\">-XX:-TraceClassUnloading</span><br><span class=\"line\">-ea</span><br><span class=\"line\">-Dsun.io.useCanonCaches=false</span><br></pre></td></tr></table></figure></li>\n<li><p>Configure idea.properties</p>\n<ul>\n<li><p>소스 코드 편집기에서 편집 시, read/write lock 발생에 따라 지연이 생길 수 있음.</p>\n<ul>\n<li><p><a href=\"https://blog.jetbrains.com/idea/2015/08/experimental-zero-latency-typing-in-intellij-idea-15-eap/\">zero-latency mode</a>를 활성화하여 지연을 줄임</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Applications/WebStorm.app/Contents/bin/idea.properties</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">editor.zero.latency.typing=true</span><br></pre></td></tr></table></figure>\n\n<p>​</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>​</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"WebStorm-Optimize\"><a href=\"#WebStorm-Optimize\" class=\"headerlink\" title=\"WebStorm Optimize\"></a>WebStorm Optimize</h1><ul>\n<li><p>불필요한 파일은 검색에서 제외(exlcude directory from search)</p>\n<ul>\n<li>Settings =&gt; Scopes =&gt; Create a custom scope</li>\n<li>exclude/include 옵션을 사용하여 디렉토리 지정</li>\n<li>제외 옵션이 제대로 동작하는지 확인</li>\n</ul>\n</li>\n<li><p>JVM 옵션 설정(Congifure JVM Options)</p>\n<ul>\n<li>참고 : <a href=\"https://gist.github.com/P7h/4388881\">https://gist.github.com/P7h/4388881</a></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-server</span><br><span class=\"line\">-Xms1024m</span><br><span class=\"line\">-Xmx3072m</span><br><span class=\"line\">-XX:NewSize=512m</span><br><span class=\"line\">-XX:MaxNewSize=512m</span><br><span class=\"line\">-XX:PermSize=512m</span><br><span class=\"line\">-XX:MaxPermSize=512m</span><br><span class=\"line\">-XX:+UseParNewGC</span><br><span class=\"line\">-XX:ParallelGCThreads=4</span><br><span class=\"line\">-XX:MaxTenuringThreshold=1</span><br><span class=\"line\">-XX:SurvivorRatio=8</span><br><span class=\"line\">-XX:+UseCodeCacheFlushing</span><br><span class=\"line\">-XX:+UseConcMarkSweepGC</span><br><span class=\"line\">-XX:+AggressiveOpts</span><br><span class=\"line\">-XX:+CMSClassUnloadingEnabled</span><br><span class=\"line\">-XX:+CMSIncrementalMode</span><br><span class=\"line\">-XX:+CMSIncrementalPacing</span><br><span class=\"line\">-XX:+CMSParallelRemarkEnabled</span><br><span class=\"line\">-XX:CMSInitiatingOccupancyFraction=65</span><br><span class=\"line\">-XX:+CMSScavengeBeforeRemark</span><br><span class=\"line\">-XX:+UseCMSInitiatingOccupancyOnly</span><br><span class=\"line\">-XX:ReservedCodeCacheSize=1024m</span><br><span class=\"line\">-XX:-TraceClassUnloading</span><br><span class=\"line\">-ea</span><br><span class=\"line\">-Dsun.io.useCanonCaches=false</span><br></pre></td></tr></table></figure></li>\n<li><p>Configure idea.properties</p>\n<ul>\n<li><p>소스 코드 편집기에서 편집 시, read/write lock 발생에 따라 지연이 생길 수 있음.</p>\n<ul>\n<li><p><a href=\"https://blog.jetbrains.com/idea/2015/08/experimental-zero-latency-typing-in-intellij-idea-15-eap/\">zero-latency mode</a>를 활성화하여 지연을 줄임</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Applications/WebStorm.app/Contents/bin/idea.properties</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">editor.zero.latency.typing=true</span><br></pre></td></tr></table></figure>\n\n<p>​</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>​</p>\n</li>\n</ul>\n"},{"title":"DDD Start - 3장","date":"2019-07-10T08:21:00.000Z","_content":"\n# DDD Start - 3장\n\n> DDD Start의 3장 내용을 정리\n\n## 애그리거트(Aggregate)\n### 도메인 모델에 대한 파악과 애그리거트\n- **상위 수준에서의 접근**과 **개별 객체 혹은 구현 단위**에서의 접근으로 나눌 수 있다. 상위 수준에서의 이해가 없는 상태에서 개별 객체에 대해 모델링을 하거나 개발을 하게 되면 상위 수준에서의 도메인 간의 관계가 어려워지게 된다.\n  > 상위 수준에서 올바른 이해를 바탕으로 개별 객체에 대한 모델링을 진행해야지 전체 모델링을 망가트리지 않으면서 추가 요구사항을 수행할 수 있기 때문에 큰 그림에서의 도메인 모델에 대한 이해는 필수이다.\n- 애그리거트 단위로 묶어서 상위 모델을 바라보면 상위 수준에서 도메인 모델 간의 관계를 쉽게 파악할 수 있다.\n\n```mermaid\ngraph LR\n    subgraph 주문\n        Address --- ShippingInfo\n        ShippingInfo --- Order\n        Order --- Orderer\n        ShippingInfo --- Receiver\n        Receiver --- Orderer\n        OrderLine --- Order\n        DeliveryTracking --- OrderLine\n        OrderLine --- Order\n        DeliveryTracking --- Order\n    end\n\n    subgraph 회원\n        Orderer --- Member\n        Member --- MemberGrade\n    end\n    subgraph 결제\n    Order --- PaymentInfo\n    end\n\n    subgraph 카테고리\n        Category\n    end    \n\n    subgraph 리뷰\n        Review\n    end\n\n    subgraph 상품\n        Product\n        Review --- Product\n        Category --- Product\n        Product --- OrderLine\n    end\n``` \n\n- 애그리거트 단위로 모델링을 하게 되면 좀 더 일관성 있는 구조를 가질 수 있게 되며, 일관성이 확보되는 만큼 복잡한 도메인 모델을 단순하고 확장에 용이한 구조로 가져갈 수 있게 된다.\n\n- 구현 모델에서 즉, 실제 애그리거트 단위로 객체를 만들게 되면 연관 객체(벨류, 엔티티)를 함께 생성하고 이에 대한 라이프사이클도 동일하게 가져가게 될 가능성이 높다.\n\n- 위 도표에서도 볼 수 있는 내용이지만, 애그리거트는 **경계**를 가지게 된다. **경계를 정하는 기준은 도메인 규칙과 요구사항을 기준으로 하면 된다.** 기준에 따라 함께 생성되는 객체나 요소들은 애그리거트로 묶일 가능성이 높게 된다.\n\n- 생성하고 변경하는 주체가 다르다면 같은 애그리거트로 묶이기 힘들 수 있다. 좋은 예가 바로 상품/리뷰의 관계이다. 상품은 담당자가 생성/변경하고 리뷰의 경우 실제 고객이 생성/변경하기 때문이다.\n  > 상품과 리뷰를 동시에 조회해야 하는 요구사항이 생긴다면 별도로 조회 전용에 대한 도메인(DAO)을 만들어서 구현하면 된다. 보통의 경우, 응용 영역에서 개별 애그리거트를 조회하여 이를 조합하는 형식이면 된다고 생각한다.\n\n### 애그리거트 루트\n- 애그리거트를 대표하는 엔티티 객체이며 **루트 엔티티**라고 부르기도 한다. 애그리거트에 속한 객체는 루트 엔티티에 직접/간접적으로 속하게 된다.\n- 애그리거트는 여러 객체로 구성되기 때문에 특정 객체만 만들어지는 상황이 생기면 안된다. 도메인의 규칙과 요구사항을 충실하게 지키기 위해서는 애그리거트에 속한 객체가 온전히 정상 상태를 가질 수 있어야 한다. 이러한 **일관된 상태/일관성**를 유지하기 위해서는 담당/관리할 객체가 필요하게 된다. 이것이 바로 `애그리거트 루트`이다.\n- 일관성을 유지해야 하기 때문에, 애그리거트 루트는 연관 객체들의 상태에 대한 제어권을 가지게 되며 도메인 기능에 대한 실제 구현을 담당하게 된다.\n- 애그리거트 루트가 아닌 외부에서 애그리거트에 속한 객체에 대한 직접적인 접근을 못하도록 해야 한다. \n- 도메인에 대한 구현을 응용 영역에서 담당할 수도 있지만, 이는 곧 여러 응용 클래스에서 도메인에 대한 중복 구현이 발생하게 되는 원인이 되게 된다. 가급적이면 응집성 있게 도메인 클래스에서 구현을 담당하도록 해야 하며 이를 지키기 위해서는 **세터 사용 지양** 그리고 **벨류 타입에 대한 불변 클래스 적극적 활용**하는 방법을 습관화 시켜야 한다.\n  > 세터를 외부에서 접근하게 되면, 엔티티의 상태 변화 제어가 어려워진다. 다시 말해, 상태 변경에 대하여 왜/어떻게 변했는지에 대한 추적이 어려워진다. \n  > 실제 어플리케이션 코드를 작성하다보면 이를 지키지 않고 습관적으로 게터/세터를 만들어 쓰는 것을 너무 많이 구경해왔다. 실제 초기 단계에서는 도메인에 대한 구현이나 요구사항이 복잡하지 않아 생기는 문제가 적겠지만, 추후 도메인과 비즈니스가 확장됨에 따라 변경이 발생하고 코드 베이스가 길어지면 관리하기 힘들어 지는 것이 자명한 사실이다. 코드 베이스가 길어지면 어쩔 수 없는 일이라고 생각하는 사람도 있겠지만 길어지더라도 변경에 대한 이유와 근거가 명확한 것이 추후 유지보수성이나 확장에 유리하다고 생각한다. \n  > 이러한 차원에서 가급적이면 세터 사용을 지양하고 도메인 클래스 혹은 도메인 서비스에서 상태 변경을 제어하도록 하여 일관성 있는 구현을 유지하는 것이 중요하다고 할 수 있다.\n\n- 엔티티 클래스 예시\n```kotlin\n@Embeddable\ndata class ArticleContent (\n    val content: String = \"\",\n    val contentType: String = \"\"\n)\n\n\n@Entity\n@Table(name = \"article\")\n@SecondaryTable(\n    name = \"article_content\",\n    pkJoinColumns = [PrimaryKeyJoinColumn(name = \"id\")]\n)\nclass Article private constructor() {\n    companion object {\n        fun create(\n            title: String = \"\",\n            content: ArticleContent = ArticleContent()\n        ) = Article().apply {\n            this.title = title\n            this.content = content\n        }\n    }\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    var id: Long = 0L\n        protected set\n\n    var title: String = \"\"\n        protected set\n\n    @Embedded\n    @AttributeOverrides(\n        value = [\n            AttributeOverride(\n                name = \"content\", column = Column(table = \"article_content\")\n            ),\n            AttributeOverride(\n                name = \"contentType\", column = Column(table = \"article_content\")\n            )\n        ]\n    )\n    var content: ArticleContent = ArticleContent()\n        protected set\n\n    fun modifyContent(content: ArticleContent) {\n        this.content = content\n    }\n\n}\n```\n위 클래스는 코틀린으로 작성한 JPA 엔티티 클래스이다. 여러 어노테이션을 사용해서 다소 복잡한 부분이 있긴 하겠지만, 애그리거트에 대한 충실한 구현을 한 클래스라고 생각한다.\n  - 세터 사용 제한\n  세터에 대한 접근 제한을 `protected` 로 지정하여 외부에서 프로퍼티에 대한 상태 변경을 하지 못하도록 함\n  - 불변 객체 사용\n  `ArticleContent`의 경우 코틀린의 데이터 클래스를 활용하였으며 실제 벨류 객체가 가지고 있는 값은 불변 프로퍼티(`val`)로 해당 값을 변경하기 위해서는 애그리거트에 있는 `content`값을 수정해야 한다. 세터에 대한 접근을 외부에서 할수 없기 때문에, 결국 애그리거트 클래스의 메서드를 활용하여 변경해줘야 하는데 변경은 `modifyContent`라는 메서드를 통하여 가능하다. 세터를 사용할때보다 좀 더 의미가 명확하다고 할 수 있다.\n\n#### 애그리거트 루트의 기능 구현\n- 애그리거트 루트는 내부의 연관 객체를 조합하여 기능을 완성하게 된다.\n- 도메인 규칙상 직접 기능 구현이 어려운 경우 기능 실행을 연관 객체에 위임할 수도 있다.\n- 주문 엔티티 예시\n  - 주문 목록 벨류 객체들을 참조하여 총 주문 금액을 구하는 예시\n    ```kotlin\n    @Entity\n    @Table(name = \"purchase_order\")\n    @Access(AccessType.FIELD)\n    class Order protected constructor() {\n        // ... 생략\n\n        @Column(name = \"total_amounts\")\n        @Convert(converter = MoneyConverter::class)\n        var totalAmount: Money = Money()\n            protected set\n\n        @ElementCollection\n        @CollectionTable(\n            name = \"order_line\",\n            joinColumns = [\n                JoinColumn(name = \"order_number\")\n            ]\n        )\n        @OrderBy(value = \"line_idx\")\n        var orderLines: MutableList<OrderLine> = mutableListOf()\n            protected set\n\n        private fun calculateTotalAmounts() {\n            this.totalAmount = Money(\n                totalAmount = this.orderLines\n                    .asSequence()\n                    .map { it.price.totalAmount * it.quantity }\n                    .sum()\n            )\n        }\n    }\n    ```\n  \n#### 트랜잭션\n- 트랜잭션의 범위는 작을수록 좋기 때문에, 가급적이면 애그리거트 단위로 트랜잭션을 제한하는 것이 좋다.\n- 한 트랜잭션에서 하나의 애그리거트만을 수정한다는 이야기는 결국 다른 애그리거트를 트랜잭션의 범위에 포함시키지 않겠다는 이야기와 같다. 애그리거트간의 의존이 생기기 시작하면 결국 결합도가 높아지게 되고 이는 곧 수정 비용이 증가하게 되므로 가급적이면 트랜잭션의 범위는 하나의 애그리거트로 제한하는 것이 좋다.\n- 만약, 여러 애그리거트를 수정해야 하는 상황이 생긴다면 `도메인 이벤트`를 구현하는 방법을 고려해보는 것이 좋다. 도메인 이벤트 구현을 사용하면 애그리거트간의 트랜잭션을 분리할수도 있으며 또한 구현 자체를 나눠서 할 수 있기 떄문에 코드에 대한 복잡성 역시 낮아지게 된다.\n\n### 레파지토리와 애그리거트\n- 애그리거트는 하나의 도메인 모델을 표현하고 있으므로, 도메인 모델의 영속성을 처리하는 레파지토리 또한 하나만 존재하는 것이 맞다.\n  - **물리적으로 별도의 테이블에 저장한다고 해서, 별도의 레파지토리를 각각 만들지는 않는다.**\n- 레파지토리는 최소 저장(`save`) 및 식별자 조회(`findById`)를 구현해줘야 한다. Data-JPA를 사용하게 되면 레파지토리에서 기본적으로 제공해야 하는 대부분의 기능을 커버하고 있기 때문에 구현이 어렵지 않다.\n- 애그리거트는 개념적으로 하나이기 때문에, 애그리거트 전체를 저장소에 영속화해야 한다.\n  - 만약 연관 엔티티/벨류 중 일부만 반영되면 일관성이 깨지므로 문제가 된다.\n\n\n### ID를 이용한 애그리거트 참조\n- 하나의 애그리거트에서 다른 애그리거트를 참조할 떄, 애그리거트의 관리 주체가 애그리거트 루트이므로 다른 애그리거트 루트를 참조한다는 이야기와 같다.\n- 다른 애그리거트를 참조하는 방법은 `연관관계`를 활용하는 방법도 있지만, 경계가 불분명해지고 확장 및 성능에 대한 이슈가 생길 수 있기 때문에 지양하는 것이 좋고, **ID를 활용하여 다른 애그리거트를 참조하는 것이 그나마 나은 방법이다.**\n  - 연관 관계를 매핑하게 되면 객체 그래프가 복잡해짐에 따라 트랜잭션에 대한 범위를 지정하는 것이 애매해질 수 있다.\n  - 결합도가 높아짐에 따라 수정/변경이 어려워진다. 또한, 서브도메인별로 시스템을 확장하거나 분리해야 할 경우, 애그리거트간에 관계 매핑때문에 변경하고 수정해야 할 부분이 많아질 수 밖에 없다.\n  - 애그리거트를 직접 참조하게 되면 패치 전략에 대한 판단도 해줘야 한다. 부가적으로 N+1에 대한 체크도 해줘야 하기 때문에 여러모로 손이 갈 수밖에 없다고 생각한다.\n\n- ID 참조를 활용하게 되면, 애그리거트 단위별로 경계가 명확해질 수 있으며 또한 하나의 애그리거트가 다른 애그리거트를 수정할 수 있는 문제를 원천적으로 막을 수 있게 된다. 또한, 애그리거트별로 다른 구현 기술을 사용할 수 있다. 트랜잭션이 중요한 애그리거트에는 RDBMS를 사용하고 조회/삽입/삭제 성능이 중요한 애그리거트에는 NoSQL(MongoDB, DynamoDB)등을 활용하는 전략을 사용할 수 있게 된다.\n  - 구현 기술이 달라지면 한 번의 쿼리로 해결을 할 수 없기 때문에, 별도의 캐시를 적용하거나 조회 전용 저장소를 구현하여 대응하면 된다.\n\n- **ID 참조를 이용하게 되었을 떄, 문제가 되는 부분이 하나 있는데 `조인`을 사용해야 하는 조회 관련 도메인에 대한 구현이다.** 해당 구현은 직접 코드로 해결하는 방법도 있지만 **별도의 조회 전용 도메인**을 작성하는 방법을 사용하는 것이 적절하다. JPA/Hibernate에서도 이런 조회 전용 도메인을 구현하는 방법을 제공해주고 있는데 바로 `@Subselect`를 이용하는 방법이다. 별도로 서브쿼리절을 사용하기 싫다면 Native쿼리를 매핑하여 사용하는 방법도 존재한다.\n\n\n### 애그리거트 간 집합 연관\n- 애그리거트간에 1:N, N:M의 관계를 정의하게 되면 주로 콜렉션을 활용하여 매핑을 하게 된다.\n- 보통 1:N의 경우, 성능상의 이슈가 있기 때문에 구현하는 경우가 드물다. 하지만 N에 해당하는 데이터 개수가 고정적이고 많지 않은 상황이라면 충분하게 사용할 수 있다고 생각한다. 또한 이런 경우에 모든 데이터를 패치해오는 것이 아닌 나눠서 쿼리하여 매핑할 수 있도록 하이버네이트에서는 `@BatchSize`와 같은 어노테이션을 제공해주고 있다.\n- 카테고리와 상품 애그리거트의 예를 들어 설명해보자면, 일반적인 조회 구현에서 하나의 카테고리에 속한 모든 상품을 조회하는 경우는 드물기 때문에, 먼저 조회해야 하는 카테고리의 식별자를 구하고 해당 식별자를 기준으로 상품 애그리거트를 조회하는 로직을 만드는 경우가 많다.\n- M:N의 경우, RDBMS를 이용하여 엔티티를 매핑해야 할 경우 보통 조인 테이블 전략을 많이 사용하게 된다. 아래 상품과 카테고리의 예를 살펴보면 쉽게 이해할 수 있는데, 상품 하나가 반드시 하나의 카테고리에만 속하는 것이 아니라 N개의 카테고리에 속할 경우를 생각해보면 매핑 데이터를 영속화 시킬 테이블이 필요하게 된다. 이 경우 조인테이블로 `PRODUCT_CATEGORY`를 사용하게 되는 것이다.\n\n```mermaid\ngraph LR\n    PRODUCT ---|1:N| PRODUCT_CATEGORY\n    PRODUCT_CATEGORY ---|N:1| CATEGORY\n```\n- 아래는 상품 애그리거트 기준으로 조인 테이블 매핑 예시를 보여주고 있다.\n```kotlin\n@Entity\n@Table(name = \"product\")\nclass Product protected constructor() {\n\t@EmbeddedId\n\tlateinit var id: ProductId\n\t\tprotected set\n\n\t@ElementCollection\n\t@CollectionTable(\n\t\tname = \"product_category\",\n                joinColumns = [JoinColumn(name = \"product_id\")]\n\t)\n\tlateinit var categoryIds: MutableSet<CategoryId>\n\t\tprotected set\n}\n```\n\n\n### 애그리거트를 팩토리로 사용하기\n- 애그리거트 객체를 생성할 떄, 도메인의 요구사항에 따라 처리 로직이 필요한 경우 이를 응용 레이어에서 구현하는 경우를 쉽게 볼 수 있는데, 이런 구현 방법도 틀리진 않았지만 중요 로직 처리가 응용 레이어에 노출됨에 따라 추후에 중복 가능성이 생기게 된다. 보통 이런 경우 애그리거트에서 해당 기능을 구현하게 되면 응집성 있는 코드 구현이 가능하고 또한 연관 엔티티를 참조하여 풍부하게 도메인의 요구사항을 표현할 수 있게 된다.\n- 애그리거트에 구현하기 힘들다면 별도로 `도메인 서비스`를 구현하거나 `팩토리 클래스`를 구현하는 방법을 생각해보는 것도 좋다.","source":"_posts/DDD/DDD_START_3.md","raw":"---\ntitle: DDD Start - 3장\ndate:  2019.7.10. 17:21:00\ncategories:\n- DDD\n---\n\n# DDD Start - 3장\n\n> DDD Start의 3장 내용을 정리\n\n## 애그리거트(Aggregate)\n### 도메인 모델에 대한 파악과 애그리거트\n- **상위 수준에서의 접근**과 **개별 객체 혹은 구현 단위**에서의 접근으로 나눌 수 있다. 상위 수준에서의 이해가 없는 상태에서 개별 객체에 대해 모델링을 하거나 개발을 하게 되면 상위 수준에서의 도메인 간의 관계가 어려워지게 된다.\n  > 상위 수준에서 올바른 이해를 바탕으로 개별 객체에 대한 모델링을 진행해야지 전체 모델링을 망가트리지 않으면서 추가 요구사항을 수행할 수 있기 때문에 큰 그림에서의 도메인 모델에 대한 이해는 필수이다.\n- 애그리거트 단위로 묶어서 상위 모델을 바라보면 상위 수준에서 도메인 모델 간의 관계를 쉽게 파악할 수 있다.\n\n```mermaid\ngraph LR\n    subgraph 주문\n        Address --- ShippingInfo\n        ShippingInfo --- Order\n        Order --- Orderer\n        ShippingInfo --- Receiver\n        Receiver --- Orderer\n        OrderLine --- Order\n        DeliveryTracking --- OrderLine\n        OrderLine --- Order\n        DeliveryTracking --- Order\n    end\n\n    subgraph 회원\n        Orderer --- Member\n        Member --- MemberGrade\n    end\n    subgraph 결제\n    Order --- PaymentInfo\n    end\n\n    subgraph 카테고리\n        Category\n    end    \n\n    subgraph 리뷰\n        Review\n    end\n\n    subgraph 상품\n        Product\n        Review --- Product\n        Category --- Product\n        Product --- OrderLine\n    end\n``` \n\n- 애그리거트 단위로 모델링을 하게 되면 좀 더 일관성 있는 구조를 가질 수 있게 되며, 일관성이 확보되는 만큼 복잡한 도메인 모델을 단순하고 확장에 용이한 구조로 가져갈 수 있게 된다.\n\n- 구현 모델에서 즉, 실제 애그리거트 단위로 객체를 만들게 되면 연관 객체(벨류, 엔티티)를 함께 생성하고 이에 대한 라이프사이클도 동일하게 가져가게 될 가능성이 높다.\n\n- 위 도표에서도 볼 수 있는 내용이지만, 애그리거트는 **경계**를 가지게 된다. **경계를 정하는 기준은 도메인 규칙과 요구사항을 기준으로 하면 된다.** 기준에 따라 함께 생성되는 객체나 요소들은 애그리거트로 묶일 가능성이 높게 된다.\n\n- 생성하고 변경하는 주체가 다르다면 같은 애그리거트로 묶이기 힘들 수 있다. 좋은 예가 바로 상품/리뷰의 관계이다. 상품은 담당자가 생성/변경하고 리뷰의 경우 실제 고객이 생성/변경하기 때문이다.\n  > 상품과 리뷰를 동시에 조회해야 하는 요구사항이 생긴다면 별도로 조회 전용에 대한 도메인(DAO)을 만들어서 구현하면 된다. 보통의 경우, 응용 영역에서 개별 애그리거트를 조회하여 이를 조합하는 형식이면 된다고 생각한다.\n\n### 애그리거트 루트\n- 애그리거트를 대표하는 엔티티 객체이며 **루트 엔티티**라고 부르기도 한다. 애그리거트에 속한 객체는 루트 엔티티에 직접/간접적으로 속하게 된다.\n- 애그리거트는 여러 객체로 구성되기 때문에 특정 객체만 만들어지는 상황이 생기면 안된다. 도메인의 규칙과 요구사항을 충실하게 지키기 위해서는 애그리거트에 속한 객체가 온전히 정상 상태를 가질 수 있어야 한다. 이러한 **일관된 상태/일관성**를 유지하기 위해서는 담당/관리할 객체가 필요하게 된다. 이것이 바로 `애그리거트 루트`이다.\n- 일관성을 유지해야 하기 때문에, 애그리거트 루트는 연관 객체들의 상태에 대한 제어권을 가지게 되며 도메인 기능에 대한 실제 구현을 담당하게 된다.\n- 애그리거트 루트가 아닌 외부에서 애그리거트에 속한 객체에 대한 직접적인 접근을 못하도록 해야 한다. \n- 도메인에 대한 구현을 응용 영역에서 담당할 수도 있지만, 이는 곧 여러 응용 클래스에서 도메인에 대한 중복 구현이 발생하게 되는 원인이 되게 된다. 가급적이면 응집성 있게 도메인 클래스에서 구현을 담당하도록 해야 하며 이를 지키기 위해서는 **세터 사용 지양** 그리고 **벨류 타입에 대한 불변 클래스 적극적 활용**하는 방법을 습관화 시켜야 한다.\n  > 세터를 외부에서 접근하게 되면, 엔티티의 상태 변화 제어가 어려워진다. 다시 말해, 상태 변경에 대하여 왜/어떻게 변했는지에 대한 추적이 어려워진다. \n  > 실제 어플리케이션 코드를 작성하다보면 이를 지키지 않고 습관적으로 게터/세터를 만들어 쓰는 것을 너무 많이 구경해왔다. 실제 초기 단계에서는 도메인에 대한 구현이나 요구사항이 복잡하지 않아 생기는 문제가 적겠지만, 추후 도메인과 비즈니스가 확장됨에 따라 변경이 발생하고 코드 베이스가 길어지면 관리하기 힘들어 지는 것이 자명한 사실이다. 코드 베이스가 길어지면 어쩔 수 없는 일이라고 생각하는 사람도 있겠지만 길어지더라도 변경에 대한 이유와 근거가 명확한 것이 추후 유지보수성이나 확장에 유리하다고 생각한다. \n  > 이러한 차원에서 가급적이면 세터 사용을 지양하고 도메인 클래스 혹은 도메인 서비스에서 상태 변경을 제어하도록 하여 일관성 있는 구현을 유지하는 것이 중요하다고 할 수 있다.\n\n- 엔티티 클래스 예시\n```kotlin\n@Embeddable\ndata class ArticleContent (\n    val content: String = \"\",\n    val contentType: String = \"\"\n)\n\n\n@Entity\n@Table(name = \"article\")\n@SecondaryTable(\n    name = \"article_content\",\n    pkJoinColumns = [PrimaryKeyJoinColumn(name = \"id\")]\n)\nclass Article private constructor() {\n    companion object {\n        fun create(\n            title: String = \"\",\n            content: ArticleContent = ArticleContent()\n        ) = Article().apply {\n            this.title = title\n            this.content = content\n        }\n    }\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    var id: Long = 0L\n        protected set\n\n    var title: String = \"\"\n        protected set\n\n    @Embedded\n    @AttributeOverrides(\n        value = [\n            AttributeOverride(\n                name = \"content\", column = Column(table = \"article_content\")\n            ),\n            AttributeOverride(\n                name = \"contentType\", column = Column(table = \"article_content\")\n            )\n        ]\n    )\n    var content: ArticleContent = ArticleContent()\n        protected set\n\n    fun modifyContent(content: ArticleContent) {\n        this.content = content\n    }\n\n}\n```\n위 클래스는 코틀린으로 작성한 JPA 엔티티 클래스이다. 여러 어노테이션을 사용해서 다소 복잡한 부분이 있긴 하겠지만, 애그리거트에 대한 충실한 구현을 한 클래스라고 생각한다.\n  - 세터 사용 제한\n  세터에 대한 접근 제한을 `protected` 로 지정하여 외부에서 프로퍼티에 대한 상태 변경을 하지 못하도록 함\n  - 불변 객체 사용\n  `ArticleContent`의 경우 코틀린의 데이터 클래스를 활용하였으며 실제 벨류 객체가 가지고 있는 값은 불변 프로퍼티(`val`)로 해당 값을 변경하기 위해서는 애그리거트에 있는 `content`값을 수정해야 한다. 세터에 대한 접근을 외부에서 할수 없기 때문에, 결국 애그리거트 클래스의 메서드를 활용하여 변경해줘야 하는데 변경은 `modifyContent`라는 메서드를 통하여 가능하다. 세터를 사용할때보다 좀 더 의미가 명확하다고 할 수 있다.\n\n#### 애그리거트 루트의 기능 구현\n- 애그리거트 루트는 내부의 연관 객체를 조합하여 기능을 완성하게 된다.\n- 도메인 규칙상 직접 기능 구현이 어려운 경우 기능 실행을 연관 객체에 위임할 수도 있다.\n- 주문 엔티티 예시\n  - 주문 목록 벨류 객체들을 참조하여 총 주문 금액을 구하는 예시\n    ```kotlin\n    @Entity\n    @Table(name = \"purchase_order\")\n    @Access(AccessType.FIELD)\n    class Order protected constructor() {\n        // ... 생략\n\n        @Column(name = \"total_amounts\")\n        @Convert(converter = MoneyConverter::class)\n        var totalAmount: Money = Money()\n            protected set\n\n        @ElementCollection\n        @CollectionTable(\n            name = \"order_line\",\n            joinColumns = [\n                JoinColumn(name = \"order_number\")\n            ]\n        )\n        @OrderBy(value = \"line_idx\")\n        var orderLines: MutableList<OrderLine> = mutableListOf()\n            protected set\n\n        private fun calculateTotalAmounts() {\n            this.totalAmount = Money(\n                totalAmount = this.orderLines\n                    .asSequence()\n                    .map { it.price.totalAmount * it.quantity }\n                    .sum()\n            )\n        }\n    }\n    ```\n  \n#### 트랜잭션\n- 트랜잭션의 범위는 작을수록 좋기 때문에, 가급적이면 애그리거트 단위로 트랜잭션을 제한하는 것이 좋다.\n- 한 트랜잭션에서 하나의 애그리거트만을 수정한다는 이야기는 결국 다른 애그리거트를 트랜잭션의 범위에 포함시키지 않겠다는 이야기와 같다. 애그리거트간의 의존이 생기기 시작하면 결국 결합도가 높아지게 되고 이는 곧 수정 비용이 증가하게 되므로 가급적이면 트랜잭션의 범위는 하나의 애그리거트로 제한하는 것이 좋다.\n- 만약, 여러 애그리거트를 수정해야 하는 상황이 생긴다면 `도메인 이벤트`를 구현하는 방법을 고려해보는 것이 좋다. 도메인 이벤트 구현을 사용하면 애그리거트간의 트랜잭션을 분리할수도 있으며 또한 구현 자체를 나눠서 할 수 있기 떄문에 코드에 대한 복잡성 역시 낮아지게 된다.\n\n### 레파지토리와 애그리거트\n- 애그리거트는 하나의 도메인 모델을 표현하고 있으므로, 도메인 모델의 영속성을 처리하는 레파지토리 또한 하나만 존재하는 것이 맞다.\n  - **물리적으로 별도의 테이블에 저장한다고 해서, 별도의 레파지토리를 각각 만들지는 않는다.**\n- 레파지토리는 최소 저장(`save`) 및 식별자 조회(`findById`)를 구현해줘야 한다. Data-JPA를 사용하게 되면 레파지토리에서 기본적으로 제공해야 하는 대부분의 기능을 커버하고 있기 때문에 구현이 어렵지 않다.\n- 애그리거트는 개념적으로 하나이기 때문에, 애그리거트 전체를 저장소에 영속화해야 한다.\n  - 만약 연관 엔티티/벨류 중 일부만 반영되면 일관성이 깨지므로 문제가 된다.\n\n\n### ID를 이용한 애그리거트 참조\n- 하나의 애그리거트에서 다른 애그리거트를 참조할 떄, 애그리거트의 관리 주체가 애그리거트 루트이므로 다른 애그리거트 루트를 참조한다는 이야기와 같다.\n- 다른 애그리거트를 참조하는 방법은 `연관관계`를 활용하는 방법도 있지만, 경계가 불분명해지고 확장 및 성능에 대한 이슈가 생길 수 있기 때문에 지양하는 것이 좋고, **ID를 활용하여 다른 애그리거트를 참조하는 것이 그나마 나은 방법이다.**\n  - 연관 관계를 매핑하게 되면 객체 그래프가 복잡해짐에 따라 트랜잭션에 대한 범위를 지정하는 것이 애매해질 수 있다.\n  - 결합도가 높아짐에 따라 수정/변경이 어려워진다. 또한, 서브도메인별로 시스템을 확장하거나 분리해야 할 경우, 애그리거트간에 관계 매핑때문에 변경하고 수정해야 할 부분이 많아질 수 밖에 없다.\n  - 애그리거트를 직접 참조하게 되면 패치 전략에 대한 판단도 해줘야 한다. 부가적으로 N+1에 대한 체크도 해줘야 하기 때문에 여러모로 손이 갈 수밖에 없다고 생각한다.\n\n- ID 참조를 활용하게 되면, 애그리거트 단위별로 경계가 명확해질 수 있으며 또한 하나의 애그리거트가 다른 애그리거트를 수정할 수 있는 문제를 원천적으로 막을 수 있게 된다. 또한, 애그리거트별로 다른 구현 기술을 사용할 수 있다. 트랜잭션이 중요한 애그리거트에는 RDBMS를 사용하고 조회/삽입/삭제 성능이 중요한 애그리거트에는 NoSQL(MongoDB, DynamoDB)등을 활용하는 전략을 사용할 수 있게 된다.\n  - 구현 기술이 달라지면 한 번의 쿼리로 해결을 할 수 없기 때문에, 별도의 캐시를 적용하거나 조회 전용 저장소를 구현하여 대응하면 된다.\n\n- **ID 참조를 이용하게 되었을 떄, 문제가 되는 부분이 하나 있는데 `조인`을 사용해야 하는 조회 관련 도메인에 대한 구현이다.** 해당 구현은 직접 코드로 해결하는 방법도 있지만 **별도의 조회 전용 도메인**을 작성하는 방법을 사용하는 것이 적절하다. JPA/Hibernate에서도 이런 조회 전용 도메인을 구현하는 방법을 제공해주고 있는데 바로 `@Subselect`를 이용하는 방법이다. 별도로 서브쿼리절을 사용하기 싫다면 Native쿼리를 매핑하여 사용하는 방법도 존재한다.\n\n\n### 애그리거트 간 집합 연관\n- 애그리거트간에 1:N, N:M의 관계를 정의하게 되면 주로 콜렉션을 활용하여 매핑을 하게 된다.\n- 보통 1:N의 경우, 성능상의 이슈가 있기 때문에 구현하는 경우가 드물다. 하지만 N에 해당하는 데이터 개수가 고정적이고 많지 않은 상황이라면 충분하게 사용할 수 있다고 생각한다. 또한 이런 경우에 모든 데이터를 패치해오는 것이 아닌 나눠서 쿼리하여 매핑할 수 있도록 하이버네이트에서는 `@BatchSize`와 같은 어노테이션을 제공해주고 있다.\n- 카테고리와 상품 애그리거트의 예를 들어 설명해보자면, 일반적인 조회 구현에서 하나의 카테고리에 속한 모든 상품을 조회하는 경우는 드물기 때문에, 먼저 조회해야 하는 카테고리의 식별자를 구하고 해당 식별자를 기준으로 상품 애그리거트를 조회하는 로직을 만드는 경우가 많다.\n- M:N의 경우, RDBMS를 이용하여 엔티티를 매핑해야 할 경우 보통 조인 테이블 전략을 많이 사용하게 된다. 아래 상품과 카테고리의 예를 살펴보면 쉽게 이해할 수 있는데, 상품 하나가 반드시 하나의 카테고리에만 속하는 것이 아니라 N개의 카테고리에 속할 경우를 생각해보면 매핑 데이터를 영속화 시킬 테이블이 필요하게 된다. 이 경우 조인테이블로 `PRODUCT_CATEGORY`를 사용하게 되는 것이다.\n\n```mermaid\ngraph LR\n    PRODUCT ---|1:N| PRODUCT_CATEGORY\n    PRODUCT_CATEGORY ---|N:1| CATEGORY\n```\n- 아래는 상품 애그리거트 기준으로 조인 테이블 매핑 예시를 보여주고 있다.\n```kotlin\n@Entity\n@Table(name = \"product\")\nclass Product protected constructor() {\n\t@EmbeddedId\n\tlateinit var id: ProductId\n\t\tprotected set\n\n\t@ElementCollection\n\t@CollectionTable(\n\t\tname = \"product_category\",\n                joinColumns = [JoinColumn(name = \"product_id\")]\n\t)\n\tlateinit var categoryIds: MutableSet<CategoryId>\n\t\tprotected set\n}\n```\n\n\n### 애그리거트를 팩토리로 사용하기\n- 애그리거트 객체를 생성할 떄, 도메인의 요구사항에 따라 처리 로직이 필요한 경우 이를 응용 레이어에서 구현하는 경우를 쉽게 볼 수 있는데, 이런 구현 방법도 틀리진 않았지만 중요 로직 처리가 응용 레이어에 노출됨에 따라 추후에 중복 가능성이 생기게 된다. 보통 이런 경우 애그리거트에서 해당 기능을 구현하게 되면 응집성 있는 코드 구현이 가능하고 또한 연관 엔티티를 참조하여 풍부하게 도메인의 요구사항을 표현할 수 있게 된다.\n- 애그리거트에 구현하기 힘들다면 별도로 `도메인 서비스`를 구현하거나 `팩토리 클래스`를 구현하는 방법을 생각해보는 것도 좋다.","slug":"DDD/DDD_START_3","published":1,"updated":"2021-08-02T12:02:38.789Z","_id":"ckrsup5130021tjhv72ii7vne","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"DDD-Start-3장\"><a href=\"#DDD-Start-3장\" class=\"headerlink\" title=\"DDD Start - 3장\"></a>DDD Start - 3장</h1><blockquote>\n<p>DDD Start의 3장 내용을 정리</p>\n</blockquote>\n<h2 id=\"애그리거트-Aggregate\"><a href=\"#애그리거트-Aggregate\" class=\"headerlink\" title=\"애그리거트(Aggregate)\"></a>애그리거트(Aggregate)</h2><h3 id=\"도메인-모델에-대한-파악과-애그리거트\"><a href=\"#도메인-모델에-대한-파악과-애그리거트\" class=\"headerlink\" title=\"도메인 모델에 대한 파악과 애그리거트\"></a>도메인 모델에 대한 파악과 애그리거트</h3><ul>\n<li><strong>상위 수준에서의 접근</strong>과 <strong>개별 객체 혹은 구현 단위</strong>에서의 접근으로 나눌 수 있다. 상위 수준에서의 이해가 없는 상태에서 개별 객체에 대해 모델링을 하거나 개발을 하게 되면 상위 수준에서의 도메인 간의 관계가 어려워지게 된다.<blockquote>\n<p>상위 수준에서 올바른 이해를 바탕으로 개별 객체에 대한 모델링을 진행해야지 전체 모델링을 망가트리지 않으면서 추가 요구사항을 수행할 수 있기 때문에 큰 그림에서의 도메인 모델에 대한 이해는 필수이다.</p>\n</blockquote>\n</li>\n<li>애그리거트 단위로 묶어서 상위 모델을 바라보면 상위 수준에서 도메인 모델 간의 관계를 쉽게 파악할 수 있다.</li>\n</ul>\n<pre class=\"mermaid\">graph LR\n    subgraph 주문\n        Address --- ShippingInfo\n        ShippingInfo --- Order\n        Order --- Orderer\n        ShippingInfo --- Receiver\n        Receiver --- Orderer\n        OrderLine --- Order\n        DeliveryTracking --- OrderLine\n        OrderLine --- Order\n        DeliveryTracking --- Order\n    end\n\n    subgraph 회원\n        Orderer --- Member\n        Member --- MemberGrade\n    end\n    subgraph 결제\n    Order --- PaymentInfo\n    end\n\n    subgraph 카테고리\n        Category\n    end    \n\n    subgraph 리뷰\n        Review\n    end\n\n    subgraph 상품\n        Product\n        Review --- Product\n        Category --- Product\n        Product --- OrderLine\n    end\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 애그리거트 단위로 모델링을 하게 되면 좀 더 일관성 있는 구조를 가질 수 있게 되며, 일관성이 확보되는 만큼 복잡한 도메인 모델을 단순하고 확장에 용이한 구조로 가져갈 수 있게 된다.</span><br><span class=\"line\"></span><br><span class=\"line\">- 구현 모델에서 즉, 실제 애그리거트 단위로 객체를 만들게 되면 연관 객체(벨류, 엔티티)를 함께 생성하고 이에 대한 라이프사이클도 동일하게 가져가게 될 가능성이 높다.</span><br><span class=\"line\"></span><br><span class=\"line\">- 위 도표에서도 볼 수 있는 내용이지만, 애그리거트는 **경계**를 가지게 된다. **경계를 정하는 기준은 도메인 규칙과 요구사항을 기준으로 하면 된다.** 기준에 따라 함께 생성되는 객체나 요소들은 애그리거트로 묶일 가능성이 높게 된다.</span><br><span class=\"line\"></span><br><span class=\"line\">- 생성하고 변경하는 주체가 다르다면 같은 애그리거트로 묶이기 힘들 수 있다. 좋은 예가 바로 상품/리뷰의 관계이다. 상품은 담당자가 생성/변경하고 리뷰의 경우 실제 고객이 생성/변경하기 때문이다.</span><br><span class=\"line\">  &gt; 상품과 리뷰를 동시에 조회해야 하는 요구사항이 생긴다면 별도로 조회 전용에 대한 도메인(DAO)을 만들어서 구현하면 된다. 보통의 경우, 응용 영역에서 개별 애그리거트를 조회하여 이를 조합하는 형식이면 된다고 생각한다.</span><br><span class=\"line\"></span><br><span class=\"line\">### 애그리거트 루트</span><br><span class=\"line\">- 애그리거트를 대표하는 엔티티 객체이며 **루트 엔티티**라고 부르기도 한다. 애그리거트에 속한 객체는 루트 엔티티에 직접/간접적으로 속하게 된다.</span><br><span class=\"line\">- 애그리거트는 여러 객체로 구성되기 때문에 특정 객체만 만들어지는 상황이 생기면 안된다. 도메인의 규칙과 요구사항을 충실하게 지키기 위해서는 애그리거트에 속한 객체가 온전히 정상 상태를 가질 수 있어야 한다. 이러한 **일관된 상태/일관성**를 유지하기 위해서는 담당/관리할 객체가 필요하게 된다. 이것이 바로 `애그리거트 루트`이다.</span><br><span class=\"line\">- 일관성을 유지해야 하기 때문에, 애그리거트 루트는 연관 객체들의 상태에 대한 제어권을 가지게 되며 도메인 기능에 대한 실제 구현을 담당하게 된다.</span><br><span class=\"line\">- 애그리거트 루트가 아닌 외부에서 애그리거트에 속한 객체에 대한 직접적인 접근을 못하도록 해야 한다. </span><br><span class=\"line\">- 도메인에 대한 구현을 응용 영역에서 담당할 수도 있지만, 이는 곧 여러 응용 클래스에서 도메인에 대한 중복 구현이 발생하게 되는 원인이 되게 된다. 가급적이면 응집성 있게 도메인 클래스에서 구현을 담당하도록 해야 하며 이를 지키기 위해서는 **세터 사용 지양** 그리고 **벨류 타입에 대한 불변 클래스 적극적 활용**하는 방법을 습관화 시켜야 한다.</span><br><span class=\"line\">  &gt; 세터를 외부에서 접근하게 되면, 엔티티의 상태 변화 제어가 어려워진다. 다시 말해, 상태 변경에 대하여 왜/어떻게 변했는지에 대한 추적이 어려워진다. </span><br><span class=\"line\">  &gt; 실제 어플리케이션 코드를 작성하다보면 이를 지키지 않고 습관적으로 게터/세터를 만들어 쓰는 것을 너무 많이 구경해왔다. 실제 초기 단계에서는 도메인에 대한 구현이나 요구사항이 복잡하지 않아 생기는 문제가 적겠지만, 추후 도메인과 비즈니스가 확장됨에 따라 변경이 발생하고 코드 베이스가 길어지면 관리하기 힘들어 지는 것이 자명한 사실이다. 코드 베이스가 길어지면 어쩔 수 없는 일이라고 생각하는 사람도 있겠지만 길어지더라도 변경에 대한 이유와 근거가 명확한 것이 추후 유지보수성이나 확장에 유리하다고 생각한다. </span><br><span class=\"line\">  &gt; 이러한 차원에서 가급적이면 세터 사용을 지양하고 도메인 클래스 혹은 도메인 서비스에서 상태 변경을 제어하도록 하여 일관성 있는 구현을 유지하는 것이 중요하다고 할 수 있다.</span><br><span class=\"line\"></span><br><span class=\"line\">- 엔티티 클래스 예시</span><br><span class=\"line\">```kotlin</span><br><span class=\"line\">@Embeddable</span><br><span class=\"line\">data class ArticleContent (</span><br><span class=\"line\">    val content: String = &quot;&quot;,</span><br><span class=\"line\">    val contentType: String = &quot;&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@Entity</span><br><span class=\"line\">@Table(name = &quot;article&quot;)</span><br><span class=\"line\">@SecondaryTable(</span><br><span class=\"line\">    name = &quot;article_content&quot;,</span><br><span class=\"line\">    pkJoinColumns = [PrimaryKeyJoinColumn(name = &quot;id&quot;)]</span><br><span class=\"line\">)</span><br><span class=\"line\">class Article private constructor() &#123;</span><br><span class=\"line\">    companion object &#123;</span><br><span class=\"line\">        fun create(</span><br><span class=\"line\">            title: String = &quot;&quot;,</span><br><span class=\"line\">            content: ArticleContent = ArticleContent()</span><br><span class=\"line\">        ) = Article().apply &#123;</span><br><span class=\"line\">            this.title = title</span><br><span class=\"line\">            this.content = content</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Id</span><br><span class=\"line\">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    var id: Long = 0L</span><br><span class=\"line\">        protected set</span><br><span class=\"line\"></span><br><span class=\"line\">    var title: String = &quot;&quot;</span><br><span class=\"line\">        protected set</span><br><span class=\"line\"></span><br><span class=\"line\">    @Embedded</span><br><span class=\"line\">    @AttributeOverrides(</span><br><span class=\"line\">        value = [</span><br><span class=\"line\">            AttributeOverride(</span><br><span class=\"line\">                name = &quot;content&quot;, column = Column(table = &quot;article_content&quot;)</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            AttributeOverride(</span><br><span class=\"line\">                name = &quot;contentType&quot;, column = Column(table = &quot;article_content&quot;)</span><br><span class=\"line\">            )</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    )</span><br><span class=\"line\">    var content: ArticleContent = ArticleContent()</span><br><span class=\"line\">        protected set</span><br><span class=\"line\"></span><br><span class=\"line\">    fun modifyContent(content: ArticleContent) &#123;</span><br><span class=\"line\">        this.content = content</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;&lt;/pre&gt;</span><br><span class=\"line\">위 클래스는 코틀린으로 작성한 JPA 엔티티 클래스이다. 여러 어노테이션을 사용해서 다소 복잡한 부분이 있긴 하겠지만, 애그리거트에 대한 충실한 구현을 한 클래스라고 생각한다.</span><br><span class=\"line\">  - 세터 사용 제한</span><br><span class=\"line\">  세터에 대한 접근 제한을 `protected` 로 지정하여 외부에서 프로퍼티에 대한 상태 변경을 하지 못하도록 함</span><br><span class=\"line\">  - 불변 객체 사용</span><br><span class=\"line\">  `ArticleContent`의 경우 코틀린의 데이터 클래스를 활용하였으며 실제 벨류 객체가 가지고 있는 값은 불변 프로퍼티(`val`)로 해당 값을 변경하기 위해서는 애그리거트에 있는 `content`값을 수정해야 한다. 세터에 대한 접근을 외부에서 할수 없기 때문에, 결국 애그리거트 클래스의 메서드를 활용하여 변경해줘야 하는데 변경은 `modifyContent`라는 메서드를 통하여 가능하다. 세터를 사용할때보다 좀 더 의미가 명확하다고 할 수 있다.</span><br><span class=\"line\"></span><br><span class=\"line\">#### 애그리거트 루트의 기능 구현</span><br><span class=\"line\">- 애그리거트 루트는 내부의 연관 객체를 조합하여 기능을 완성하게 된다.</span><br><span class=\"line\">- 도메인 규칙상 직접 기능 구현이 어려운 경우 기능 실행을 연관 객체에 위임할 수도 있다.</span><br><span class=\"line\">- 주문 엔티티 예시</span><br><span class=\"line\">  - 주문 목록 벨류 객체들을 참조하여 총 주문 금액을 구하는 예시</span><br><span class=\"line\">    ```kotlin</span><br><span class=\"line\">    @Entity</span><br><span class=\"line\">    @Table(name = &quot;purchase_order&quot;)</span><br><span class=\"line\">    @Access(AccessType.FIELD)</span><br><span class=\"line\">    class Order protected constructor() &#123;</span><br><span class=\"line\">        // ... 생략</span><br><span class=\"line\"></span><br><span class=\"line\">        @Column(name = &quot;total_amounts&quot;)</span><br><span class=\"line\">        @Convert(converter = MoneyConverter::class)</span><br><span class=\"line\">        var totalAmount: Money = Money()</span><br><span class=\"line\">            protected set</span><br><span class=\"line\"></span><br><span class=\"line\">        @ElementCollection</span><br><span class=\"line\">        @CollectionTable(</span><br><span class=\"line\">            name = &quot;order_line&quot;,</span><br><span class=\"line\">            joinColumns = [</span><br><span class=\"line\">                JoinColumn(name = &quot;order_number&quot;)</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        )</span><br><span class=\"line\">        @OrderBy(value = &quot;line_idx&quot;)</span><br><span class=\"line\">        var orderLines: MutableList&lt;OrderLine&gt; = mutableListOf()</span><br><span class=\"line\">            protected set</span><br><span class=\"line\"></span><br><span class=\"line\">        private fun calculateTotalAmounts() &#123;</span><br><span class=\"line\">            this.totalAmount = Money(</span><br><span class=\"line\">                totalAmount = this.orderLines</span><br><span class=\"line\">                    .asSequence()</span><br><span class=\"line\">                    .map &#123; it.price.totalAmount * it.quantity &#125;</span><br><span class=\"line\">                    .sum()</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n  \n#### 트랜잭션\n- 트랜잭션의 범위는 작을수록 좋기 때문에, 가급적이면 애그리거트 단위로 트랜잭션을 제한하는 것이 좋다.\n- 한 트랜잭션에서 하나의 애그리거트만을 수정한다는 이야기는 결국 다른 애그리거트를 트랜잭션의 범위에 포함시키지 않겠다는 이야기와 같다. 애그리거트간의 의존이 생기기 시작하면 결국 결합도가 높아지게 되고 이는 곧 수정 비용이 증가하게 되므로 가급적이면 트랜잭션의 범위는 하나의 애그리거트로 제한하는 것이 좋다.\n- 만약, 여러 애그리거트를 수정해야 하는 상황이 생긴다면 `도메인 이벤트`를 구현하는 방법을 고려해보는 것이 좋다. 도메인 이벤트 구현을 사용하면 애그리거트간의 트랜잭션을 분리할수도 있으며 또한 구현 자체를 나눠서 할 수 있기 떄문에 코드에 대한 복잡성 역시 낮아지게 된다.\n\n### 레파지토리와 애그리거트\n- 애그리거트는 하나의 도메인 모델을 표현하고 있으므로, 도메인 모델의 영속성을 처리하는 레파지토리 또한 하나만 존재하는 것이 맞다.\n  - **물리적으로 별도의 테이블에 저장한다고 해서, 별도의 레파지토리를 각각 만들지는 않는다.**\n- 레파지토리는 최소 저장(`save`) 및 식별자 조회(`findById`)를 구현해줘야 한다. Data-JPA를 사용하게 되면 레파지토리에서 기본적으로 제공해야 하는 대부분의 기능을 커버하고 있기 때문에 구현이 어렵지 않다.\n- 애그리거트는 개념적으로 하나이기 때문에, 애그리거트 전체를 저장소에 영속화해야 한다.\n  - 만약 연관 엔티티/벨류 중 일부만 반영되면 일관성이 깨지므로 문제가 된다.\n\n\n### ID를 이용한 애그리거트 참조\n- 하나의 애그리거트에서 다른 애그리거트를 참조할 떄, 애그리거트의 관리 주체가 애그리거트 루트이므로 다른 애그리거트 루트를 참조한다는 이야기와 같다.\n- 다른 애그리거트를 참조하는 방법은 `연관관계`를 활용하는 방법도 있지만, 경계가 불분명해지고 확장 및 성능에 대한 이슈가 생길 수 있기 때문에 지양하는 것이 좋고, **ID를 활용하여 다른 애그리거트를 참조하는 것이 그나마 나은 방법이다.**\n  - 연관 관계를 매핑하게 되면 객체 그래프가 복잡해짐에 따라 트랜잭션에 대한 범위를 지정하는 것이 애매해질 수 있다.\n  - 결합도가 높아짐에 따라 수정/변경이 어려워진다. 또한, 서브도메인별로 시스템을 확장하거나 분리해야 할 경우, 애그리거트간에 관계 매핑때문에 변경하고 수정해야 할 부분이 많아질 수 밖에 없다.\n  - 애그리거트를 직접 참조하게 되면 패치 전략에 대한 판단도 해줘야 한다. 부가적으로 N+1에 대한 체크도 해줘야 하기 때문에 여러모로 손이 갈 수밖에 없다고 생각한다.\n\n- ID 참조를 활용하게 되면, 애그리거트 단위별로 경계가 명확해질 수 있으며 또한 하나의 애그리거트가 다른 애그리거트를 수정할 수 있는 문제를 원천적으로 막을 수 있게 된다. 또한, 애그리거트별로 다른 구현 기술을 사용할 수 있다. 트랜잭션이 중요한 애그리거트에는 RDBMS를 사용하고 조회/삽입/삭제 성능이 중요한 애그리거트에는 NoSQL(MongoDB, DynamoDB)등을 활용하는 전략을 사용할 수 있게 된다.\n  - 구현 기술이 달라지면 한 번의 쿼리로 해결을 할 수 없기 때문에, 별도의 캐시를 적용하거나 조회 전용 저장소를 구현하여 대응하면 된다.\n\n- **ID 참조를 이용하게 되었을 떄, 문제가 되는 부분이 하나 있는데 `조인`을 사용해야 하는 조회 관련 도메인에 대한 구현이다.** 해당 구현은 직접 코드로 해결하는 방법도 있지만 **별도의 조회 전용 도메인**을 작성하는 방법을 사용하는 것이 적절하다. JPA/Hibernate에서도 이런 조회 전용 도메인을 구현하는 방법을 제공해주고 있는데 바로 `@Subselect`를 이용하는 방법이다. 별도로 서브쿼리절을 사용하기 싫다면 Native쿼리를 매핑하여 사용하는 방법도 존재한다.\n\n\n### 애그리거트 간 집합 연관\n- 애그리거트간에 1:N, N:M의 관계를 정의하게 되면 주로 콜렉션을 활용하여 매핑을 하게 된다.\n- 보통 1:N의 경우, 성능상의 이슈가 있기 때문에 구현하는 경우가 드물다. 하지만 N에 해당하는 데이터 개수가 고정적이고 많지 않은 상황이라면 충분하게 사용할 수 있다고 생각한다. 또한 이런 경우에 모든 데이터를 패치해오는 것이 아닌 나눠서 쿼리하여 매핑할 수 있도록 하이버네이트에서는 `@BatchSize`와 같은 어노테이션을 제공해주고 있다.\n- 카테고리와 상품 애그리거트의 예를 들어 설명해보자면, 일반적인 조회 구현에서 하나의 카테고리에 속한 모든 상품을 조회하는 경우는 드물기 때문에, 먼저 조회해야 하는 카테고리의 식별자를 구하고 해당 식별자를 기준으로 상품 애그리거트를 조회하는 로직을 만드는 경우가 많다.\n- M:N의 경우, RDBMS를 이용하여 엔티티를 매핑해야 할 경우 보통 조인 테이블 전략을 많이 사용하게 된다. 아래 상품과 카테고리의 예를 살펴보면 쉽게 이해할 수 있는데, 상품 하나가 반드시 하나의 카테고리에만 속하는 것이 아니라 N개의 카테고리에 속할 경우를 생각해보면 매핑 데이터를 영속화 시킬 테이블이 필요하게 된다. 이 경우 조인테이블로 `PRODUCT_CATEGORY`를 사용하게 되는 것이다.\n\n<pre class=\"mermaid\">graph LR\n    PRODUCT ---|1:N| PRODUCT_CATEGORY\n    PRODUCT_CATEGORY ---|N:1| CATEGORY</pre>\n<ul>\n<li>아래는 상품 애그리거트 기준으로 조인 테이블 매핑 예시를 보여주고 있다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table(name = <span class=\"meta-string\">&quot;product&quot;</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">constructor</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@EmbeddedId</span></span><br><span class=\"line\">\t<span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> id: ProductId</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@ElementCollection</span></span><br><span class=\"line\">\t<span class=\"meta\">@CollectionTable(</span></span><br><span class=\"line\"><span class=\"meta\">\t\tname = <span class=\"meta-string\">&quot;product_category&quot;</span>,</span></span><br><span class=\"line\"><span class=\"meta\">                joinColumns = [JoinColumn(name = <span class=\"meta-string\">&quot;product_id&quot;</span>)</span>]</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> categoryIds: MutableSet&lt;CategoryId&gt;</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"애그리거트를-팩토리로-사용하기\"><a href=\"#애그리거트를-팩토리로-사용하기\" class=\"headerlink\" title=\"애그리거트를 팩토리로 사용하기\"></a>애그리거트를 팩토리로 사용하기</h3><ul>\n<li>애그리거트 객체를 생성할 떄, 도메인의 요구사항에 따라 처리 로직이 필요한 경우 이를 응용 레이어에서 구현하는 경우를 쉽게 볼 수 있는데, 이런 구현 방법도 틀리진 않았지만 중요 로직 처리가 응용 레이어에 노출됨에 따라 추후에 중복 가능성이 생기게 된다. 보통 이런 경우 애그리거트에서 해당 기능을 구현하게 되면 응집성 있는 코드 구현이 가능하고 또한 연관 엔티티를 참조하여 풍부하게 도메인의 요구사항을 표현할 수 있게 된다.</li>\n<li>애그리거트에 구현하기 힘들다면 별도로 <code>도메인 서비스</code>를 구현하거나 <code>팩토리 클래스</code>를 구현하는 방법을 생각해보는 것도 좋다.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"DDD-Start-3장\"><a href=\"#DDD-Start-3장\" class=\"headerlink\" title=\"DDD Start - 3장\"></a>DDD Start - 3장</h1><blockquote>\n<p>DDD Start의 3장 내용을 정리</p>\n</blockquote>\n<h2 id=\"애그리거트-Aggregate\"><a href=\"#애그리거트-Aggregate\" class=\"headerlink\" title=\"애그리거트(Aggregate)\"></a>애그리거트(Aggregate)</h2><h3 id=\"도메인-모델에-대한-파악과-애그리거트\"><a href=\"#도메인-모델에-대한-파악과-애그리거트\" class=\"headerlink\" title=\"도메인 모델에 대한 파악과 애그리거트\"></a>도메인 모델에 대한 파악과 애그리거트</h3><ul>\n<li><strong>상위 수준에서의 접근</strong>과 <strong>개별 객체 혹은 구현 단위</strong>에서의 접근으로 나눌 수 있다. 상위 수준에서의 이해가 없는 상태에서 개별 객체에 대해 모델링을 하거나 개발을 하게 되면 상위 수준에서의 도메인 간의 관계가 어려워지게 된다.<blockquote>\n<p>상위 수준에서 올바른 이해를 바탕으로 개별 객체에 대한 모델링을 진행해야지 전체 모델링을 망가트리지 않으면서 추가 요구사항을 수행할 수 있기 때문에 큰 그림에서의 도메인 모델에 대한 이해는 필수이다.</p>\n</blockquote>\n</li>\n<li>애그리거트 단위로 묶어서 상위 모델을 바라보면 상위 수준에서 도메인 모델 간의 관계를 쉽게 파악할 수 있다.</li>\n</ul>\n<pre class=\"mermaid\">graph LR\n    subgraph 주문\n        Address --- ShippingInfo\n        ShippingInfo --- Order\n        Order --- Orderer\n        ShippingInfo --- Receiver\n        Receiver --- Orderer\n        OrderLine --- Order\n        DeliveryTracking --- OrderLine\n        OrderLine --- Order\n        DeliveryTracking --- Order\n    end\n\n    subgraph 회원\n        Orderer --- Member\n        Member --- MemberGrade\n    end\n    subgraph 결제\n    Order --- PaymentInfo\n    end\n\n    subgraph 카테고리\n        Category\n    end    \n\n    subgraph 리뷰\n        Review\n    end\n\n    subgraph 상품\n        Product\n        Review --- Product\n        Category --- Product\n        Product --- OrderLine\n    end\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 애그리거트 단위로 모델링을 하게 되면 좀 더 일관성 있는 구조를 가질 수 있게 되며, 일관성이 확보되는 만큼 복잡한 도메인 모델을 단순하고 확장에 용이한 구조로 가져갈 수 있게 된다.</span><br><span class=\"line\"></span><br><span class=\"line\">- 구현 모델에서 즉, 실제 애그리거트 단위로 객체를 만들게 되면 연관 객체(벨류, 엔티티)를 함께 생성하고 이에 대한 라이프사이클도 동일하게 가져가게 될 가능성이 높다.</span><br><span class=\"line\"></span><br><span class=\"line\">- 위 도표에서도 볼 수 있는 내용이지만, 애그리거트는 **경계**를 가지게 된다. **경계를 정하는 기준은 도메인 규칙과 요구사항을 기준으로 하면 된다.** 기준에 따라 함께 생성되는 객체나 요소들은 애그리거트로 묶일 가능성이 높게 된다.</span><br><span class=\"line\"></span><br><span class=\"line\">- 생성하고 변경하는 주체가 다르다면 같은 애그리거트로 묶이기 힘들 수 있다. 좋은 예가 바로 상품/리뷰의 관계이다. 상품은 담당자가 생성/변경하고 리뷰의 경우 실제 고객이 생성/변경하기 때문이다.</span><br><span class=\"line\">  &gt; 상품과 리뷰를 동시에 조회해야 하는 요구사항이 생긴다면 별도로 조회 전용에 대한 도메인(DAO)을 만들어서 구현하면 된다. 보통의 경우, 응용 영역에서 개별 애그리거트를 조회하여 이를 조합하는 형식이면 된다고 생각한다.</span><br><span class=\"line\"></span><br><span class=\"line\">### 애그리거트 루트</span><br><span class=\"line\">- 애그리거트를 대표하는 엔티티 객체이며 **루트 엔티티**라고 부르기도 한다. 애그리거트에 속한 객체는 루트 엔티티에 직접/간접적으로 속하게 된다.</span><br><span class=\"line\">- 애그리거트는 여러 객체로 구성되기 때문에 특정 객체만 만들어지는 상황이 생기면 안된다. 도메인의 규칙과 요구사항을 충실하게 지키기 위해서는 애그리거트에 속한 객체가 온전히 정상 상태를 가질 수 있어야 한다. 이러한 **일관된 상태/일관성**를 유지하기 위해서는 담당/관리할 객체가 필요하게 된다. 이것이 바로 `애그리거트 루트`이다.</span><br><span class=\"line\">- 일관성을 유지해야 하기 때문에, 애그리거트 루트는 연관 객체들의 상태에 대한 제어권을 가지게 되며 도메인 기능에 대한 실제 구현을 담당하게 된다.</span><br><span class=\"line\">- 애그리거트 루트가 아닌 외부에서 애그리거트에 속한 객체에 대한 직접적인 접근을 못하도록 해야 한다. </span><br><span class=\"line\">- 도메인에 대한 구현을 응용 영역에서 담당할 수도 있지만, 이는 곧 여러 응용 클래스에서 도메인에 대한 중복 구현이 발생하게 되는 원인이 되게 된다. 가급적이면 응집성 있게 도메인 클래스에서 구현을 담당하도록 해야 하며 이를 지키기 위해서는 **세터 사용 지양** 그리고 **벨류 타입에 대한 불변 클래스 적극적 활용**하는 방법을 습관화 시켜야 한다.</span><br><span class=\"line\">  &gt; 세터를 외부에서 접근하게 되면, 엔티티의 상태 변화 제어가 어려워진다. 다시 말해, 상태 변경에 대하여 왜/어떻게 변했는지에 대한 추적이 어려워진다. </span><br><span class=\"line\">  &gt; 실제 어플리케이션 코드를 작성하다보면 이를 지키지 않고 습관적으로 게터/세터를 만들어 쓰는 것을 너무 많이 구경해왔다. 실제 초기 단계에서는 도메인에 대한 구현이나 요구사항이 복잡하지 않아 생기는 문제가 적겠지만, 추후 도메인과 비즈니스가 확장됨에 따라 변경이 발생하고 코드 베이스가 길어지면 관리하기 힘들어 지는 것이 자명한 사실이다. 코드 베이스가 길어지면 어쩔 수 없는 일이라고 생각하는 사람도 있겠지만 길어지더라도 변경에 대한 이유와 근거가 명확한 것이 추후 유지보수성이나 확장에 유리하다고 생각한다. </span><br><span class=\"line\">  &gt; 이러한 차원에서 가급적이면 세터 사용을 지양하고 도메인 클래스 혹은 도메인 서비스에서 상태 변경을 제어하도록 하여 일관성 있는 구현을 유지하는 것이 중요하다고 할 수 있다.</span><br><span class=\"line\"></span><br><span class=\"line\">- 엔티티 클래스 예시</span><br><span class=\"line\">```kotlin</span><br><span class=\"line\">@Embeddable</span><br><span class=\"line\">data class ArticleContent (</span><br><span class=\"line\">    val content: String = &quot;&quot;,</span><br><span class=\"line\">    val contentType: String = &quot;&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@Entity</span><br><span class=\"line\">@Table(name = &quot;article&quot;)</span><br><span class=\"line\">@SecondaryTable(</span><br><span class=\"line\">    name = &quot;article_content&quot;,</span><br><span class=\"line\">    pkJoinColumns = [PrimaryKeyJoinColumn(name = &quot;id&quot;)]</span><br><span class=\"line\">)</span><br><span class=\"line\">class Article private constructor() &#123;</span><br><span class=\"line\">    companion object &#123;</span><br><span class=\"line\">        fun create(</span><br><span class=\"line\">            title: String = &quot;&quot;,</span><br><span class=\"line\">            content: ArticleContent = ArticleContent()</span><br><span class=\"line\">        ) = Article().apply &#123;</span><br><span class=\"line\">            this.title = title</span><br><span class=\"line\">            this.content = content</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Id</span><br><span class=\"line\">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    var id: Long = 0L</span><br><span class=\"line\">        protected set</span><br><span class=\"line\"></span><br><span class=\"line\">    var title: String = &quot;&quot;</span><br><span class=\"line\">        protected set</span><br><span class=\"line\"></span><br><span class=\"line\">    @Embedded</span><br><span class=\"line\">    @AttributeOverrides(</span><br><span class=\"line\">        value = [</span><br><span class=\"line\">            AttributeOverride(</span><br><span class=\"line\">                name = &quot;content&quot;, column = Column(table = &quot;article_content&quot;)</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            AttributeOverride(</span><br><span class=\"line\">                name = &quot;contentType&quot;, column = Column(table = &quot;article_content&quot;)</span><br><span class=\"line\">            )</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    )</span><br><span class=\"line\">    var content: ArticleContent = ArticleContent()</span><br><span class=\"line\">        protected set</span><br><span class=\"line\"></span><br><span class=\"line\">    fun modifyContent(content: ArticleContent) &#123;</span><br><span class=\"line\">        this.content = content</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;&lt;/pre&gt;</span><br><span class=\"line\">위 클래스는 코틀린으로 작성한 JPA 엔티티 클래스이다. 여러 어노테이션을 사용해서 다소 복잡한 부분이 있긴 하겠지만, 애그리거트에 대한 충실한 구현을 한 클래스라고 생각한다.</span><br><span class=\"line\">  - 세터 사용 제한</span><br><span class=\"line\">  세터에 대한 접근 제한을 `protected` 로 지정하여 외부에서 프로퍼티에 대한 상태 변경을 하지 못하도록 함</span><br><span class=\"line\">  - 불변 객체 사용</span><br><span class=\"line\">  `ArticleContent`의 경우 코틀린의 데이터 클래스를 활용하였으며 실제 벨류 객체가 가지고 있는 값은 불변 프로퍼티(`val`)로 해당 값을 변경하기 위해서는 애그리거트에 있는 `content`값을 수정해야 한다. 세터에 대한 접근을 외부에서 할수 없기 때문에, 결국 애그리거트 클래스의 메서드를 활용하여 변경해줘야 하는데 변경은 `modifyContent`라는 메서드를 통하여 가능하다. 세터를 사용할때보다 좀 더 의미가 명확하다고 할 수 있다.</span><br><span class=\"line\"></span><br><span class=\"line\">#### 애그리거트 루트의 기능 구현</span><br><span class=\"line\">- 애그리거트 루트는 내부의 연관 객체를 조합하여 기능을 완성하게 된다.</span><br><span class=\"line\">- 도메인 규칙상 직접 기능 구현이 어려운 경우 기능 실행을 연관 객체에 위임할 수도 있다.</span><br><span class=\"line\">- 주문 엔티티 예시</span><br><span class=\"line\">  - 주문 목록 벨류 객체들을 참조하여 총 주문 금액을 구하는 예시</span><br><span class=\"line\">    ```kotlin</span><br><span class=\"line\">    @Entity</span><br><span class=\"line\">    @Table(name = &quot;purchase_order&quot;)</span><br><span class=\"line\">    @Access(AccessType.FIELD)</span><br><span class=\"line\">    class Order protected constructor() &#123;</span><br><span class=\"line\">        // ... 생략</span><br><span class=\"line\"></span><br><span class=\"line\">        @Column(name = &quot;total_amounts&quot;)</span><br><span class=\"line\">        @Convert(converter = MoneyConverter::class)</span><br><span class=\"line\">        var totalAmount: Money = Money()</span><br><span class=\"line\">            protected set</span><br><span class=\"line\"></span><br><span class=\"line\">        @ElementCollection</span><br><span class=\"line\">        @CollectionTable(</span><br><span class=\"line\">            name = &quot;order_line&quot;,</span><br><span class=\"line\">            joinColumns = [</span><br><span class=\"line\">                JoinColumn(name = &quot;order_number&quot;)</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        )</span><br><span class=\"line\">        @OrderBy(value = &quot;line_idx&quot;)</span><br><span class=\"line\">        var orderLines: MutableList&lt;OrderLine&gt; = mutableListOf()</span><br><span class=\"line\">            protected set</span><br><span class=\"line\"></span><br><span class=\"line\">        private fun calculateTotalAmounts() &#123;</span><br><span class=\"line\">            this.totalAmount = Money(</span><br><span class=\"line\">                totalAmount = this.orderLines</span><br><span class=\"line\">                    .asSequence()</span><br><span class=\"line\">                    .map &#123; it.price.totalAmount * it.quantity &#125;</span><br><span class=\"line\">                    .sum()</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n  \n#### 트랜잭션\n- 트랜잭션의 범위는 작을수록 좋기 때문에, 가급적이면 애그리거트 단위로 트랜잭션을 제한하는 것이 좋다.\n- 한 트랜잭션에서 하나의 애그리거트만을 수정한다는 이야기는 결국 다른 애그리거트를 트랜잭션의 범위에 포함시키지 않겠다는 이야기와 같다. 애그리거트간의 의존이 생기기 시작하면 결국 결합도가 높아지게 되고 이는 곧 수정 비용이 증가하게 되므로 가급적이면 트랜잭션의 범위는 하나의 애그리거트로 제한하는 것이 좋다.\n- 만약, 여러 애그리거트를 수정해야 하는 상황이 생긴다면 `도메인 이벤트`를 구현하는 방법을 고려해보는 것이 좋다. 도메인 이벤트 구현을 사용하면 애그리거트간의 트랜잭션을 분리할수도 있으며 또한 구현 자체를 나눠서 할 수 있기 떄문에 코드에 대한 복잡성 역시 낮아지게 된다.\n\n### 레파지토리와 애그리거트\n- 애그리거트는 하나의 도메인 모델을 표현하고 있으므로, 도메인 모델의 영속성을 처리하는 레파지토리 또한 하나만 존재하는 것이 맞다.\n  - **물리적으로 별도의 테이블에 저장한다고 해서, 별도의 레파지토리를 각각 만들지는 않는다.**\n- 레파지토리는 최소 저장(`save`) 및 식별자 조회(`findById`)를 구현해줘야 한다. Data-JPA를 사용하게 되면 레파지토리에서 기본적으로 제공해야 하는 대부분의 기능을 커버하고 있기 때문에 구현이 어렵지 않다.\n- 애그리거트는 개념적으로 하나이기 때문에, 애그리거트 전체를 저장소에 영속화해야 한다.\n  - 만약 연관 엔티티/벨류 중 일부만 반영되면 일관성이 깨지므로 문제가 된다.\n\n\n### ID를 이용한 애그리거트 참조\n- 하나의 애그리거트에서 다른 애그리거트를 참조할 떄, 애그리거트의 관리 주체가 애그리거트 루트이므로 다른 애그리거트 루트를 참조한다는 이야기와 같다.\n- 다른 애그리거트를 참조하는 방법은 `연관관계`를 활용하는 방법도 있지만, 경계가 불분명해지고 확장 및 성능에 대한 이슈가 생길 수 있기 때문에 지양하는 것이 좋고, **ID를 활용하여 다른 애그리거트를 참조하는 것이 그나마 나은 방법이다.**\n  - 연관 관계를 매핑하게 되면 객체 그래프가 복잡해짐에 따라 트랜잭션에 대한 범위를 지정하는 것이 애매해질 수 있다.\n  - 결합도가 높아짐에 따라 수정/변경이 어려워진다. 또한, 서브도메인별로 시스템을 확장하거나 분리해야 할 경우, 애그리거트간에 관계 매핑때문에 변경하고 수정해야 할 부분이 많아질 수 밖에 없다.\n  - 애그리거트를 직접 참조하게 되면 패치 전략에 대한 판단도 해줘야 한다. 부가적으로 N+1에 대한 체크도 해줘야 하기 때문에 여러모로 손이 갈 수밖에 없다고 생각한다.\n\n- ID 참조를 활용하게 되면, 애그리거트 단위별로 경계가 명확해질 수 있으며 또한 하나의 애그리거트가 다른 애그리거트를 수정할 수 있는 문제를 원천적으로 막을 수 있게 된다. 또한, 애그리거트별로 다른 구현 기술을 사용할 수 있다. 트랜잭션이 중요한 애그리거트에는 RDBMS를 사용하고 조회/삽입/삭제 성능이 중요한 애그리거트에는 NoSQL(MongoDB, DynamoDB)등을 활용하는 전략을 사용할 수 있게 된다.\n  - 구현 기술이 달라지면 한 번의 쿼리로 해결을 할 수 없기 때문에, 별도의 캐시를 적용하거나 조회 전용 저장소를 구현하여 대응하면 된다.\n\n- **ID 참조를 이용하게 되었을 떄, 문제가 되는 부분이 하나 있는데 `조인`을 사용해야 하는 조회 관련 도메인에 대한 구현이다.** 해당 구현은 직접 코드로 해결하는 방법도 있지만 **별도의 조회 전용 도메인**을 작성하는 방법을 사용하는 것이 적절하다. JPA/Hibernate에서도 이런 조회 전용 도메인을 구현하는 방법을 제공해주고 있는데 바로 `@Subselect`를 이용하는 방법이다. 별도로 서브쿼리절을 사용하기 싫다면 Native쿼리를 매핑하여 사용하는 방법도 존재한다.\n\n\n### 애그리거트 간 집합 연관\n- 애그리거트간에 1:N, N:M의 관계를 정의하게 되면 주로 콜렉션을 활용하여 매핑을 하게 된다.\n- 보통 1:N의 경우, 성능상의 이슈가 있기 때문에 구현하는 경우가 드물다. 하지만 N에 해당하는 데이터 개수가 고정적이고 많지 않은 상황이라면 충분하게 사용할 수 있다고 생각한다. 또한 이런 경우에 모든 데이터를 패치해오는 것이 아닌 나눠서 쿼리하여 매핑할 수 있도록 하이버네이트에서는 `@BatchSize`와 같은 어노테이션을 제공해주고 있다.\n- 카테고리와 상품 애그리거트의 예를 들어 설명해보자면, 일반적인 조회 구현에서 하나의 카테고리에 속한 모든 상품을 조회하는 경우는 드물기 때문에, 먼저 조회해야 하는 카테고리의 식별자를 구하고 해당 식별자를 기준으로 상품 애그리거트를 조회하는 로직을 만드는 경우가 많다.\n- M:N의 경우, RDBMS를 이용하여 엔티티를 매핑해야 할 경우 보통 조인 테이블 전략을 많이 사용하게 된다. 아래 상품과 카테고리의 예를 살펴보면 쉽게 이해할 수 있는데, 상품 하나가 반드시 하나의 카테고리에만 속하는 것이 아니라 N개의 카테고리에 속할 경우를 생각해보면 매핑 데이터를 영속화 시킬 테이블이 필요하게 된다. 이 경우 조인테이블로 `PRODUCT_CATEGORY`를 사용하게 되는 것이다.\n\n<pre class=\"mermaid\">graph LR\n    PRODUCT ---|1:N| PRODUCT_CATEGORY\n    PRODUCT_CATEGORY ---|N:1| CATEGORY</pre>\n<ul>\n<li>아래는 상품 애그리거트 기준으로 조인 테이블 매핑 예시를 보여주고 있다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table(name = <span class=\"meta-string\">&quot;product&quot;</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">constructor</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"meta\">@EmbeddedId</span></span><br><span class=\"line\">\t<span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> id: ProductId</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@ElementCollection</span></span><br><span class=\"line\">\t<span class=\"meta\">@CollectionTable(</span></span><br><span class=\"line\"><span class=\"meta\">\t\tname = <span class=\"meta-string\">&quot;product_category&quot;</span>,</span></span><br><span class=\"line\"><span class=\"meta\">                joinColumns = [JoinColumn(name = <span class=\"meta-string\">&quot;product_id&quot;</span>)</span>]</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> categoryIds: MutableSet&lt;CategoryId&gt;</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"애그리거트를-팩토리로-사용하기\"><a href=\"#애그리거트를-팩토리로-사용하기\" class=\"headerlink\" title=\"애그리거트를 팩토리로 사용하기\"></a>애그리거트를 팩토리로 사용하기</h3><ul>\n<li>애그리거트 객체를 생성할 떄, 도메인의 요구사항에 따라 처리 로직이 필요한 경우 이를 응용 레이어에서 구현하는 경우를 쉽게 볼 수 있는데, 이런 구현 방법도 틀리진 않았지만 중요 로직 처리가 응용 레이어에 노출됨에 따라 추후에 중복 가능성이 생기게 된다. 보통 이런 경우 애그리거트에서 해당 기능을 구현하게 되면 응집성 있는 코드 구현이 가능하고 또한 연관 엔티티를 참조하여 풍부하게 도메인의 요구사항을 표현할 수 있게 된다.</li>\n<li>애그리거트에 구현하기 힘들다면 별도로 <code>도메인 서비스</code>를 구현하거나 <code>팩토리 클래스</code>를 구현하는 방법을 생각해보는 것도 좋다.</li>\n</ul>\n"},{"title":"Netty-In-Action","date":"2021-07-18T06:13:00.000Z","_content":"\n# Netty-In-Action\n\n# 1부, 네티 개념과 아키텍처\n\n## 1장. 네티: 비동기 이벤트 기반 네트워킹 프레임워크\n- 최초 자바 API(java.net)은 네이티브 시스템 소켓 라이브러리가 제공하는 블로킹 함수만 제공\n  - 다수의 클라이언트를 관리하려면 새로운 클라이언트 소켓마다 새로운 스레드를 할당해야 함.\n  - 여러 스레드가 입출력 데이터를 무한정 대기하는 상태가 유지될 수 있고, 이는 곧 리소스에 대한 낭비로 이어질 수 있음.\n  - 운영체제에 따라 다르지만 스텍의 기본 크기는 64KB ~ 1MB까지 차지할 수 있다. JVM이 많은 수의 스레드 생성을 지원하지만, 동시 접속이 한계에 이르는 순간(1만개 전후) 컨텍스트 스위칭에 따른 오버헤드가 심각한 문제가 될수 있다.\n- 네이티브 소켓 라이브러리에는 오래전부터 네트워크 리소스 사용률을 세부적으로 제어할수 있는 논블로킹(non-blocking) 호출이 포함되어 있다.\n  - setsockopt() 시스템 함수를 통한 블로킹 콜에 대한 옵션 설정 가능\n  - 이벤트 통지 API(epoll/kqueue)를 통하여 논블로킹 소켓의 집합을 등록하면 읽거나 기록할 데이터가 준비됐는지 여부를 알수 있다. [참고](https://long-zhou.github.io/2012/12/21/epoll-vs-kqueue.html)\n  - 논블로킹 입출력을 위한 자바의 기능 지원은 1.4부터 java.nio 패키지를 통하여 이뤄졌다.\n\n\n![java.nio.channels.Selector](https://drek4537l1klr.cloudfront.net/maurer/Figures/01fig02.jpg)\n- 자바의 논블로킹 설계의 핵심은 바로 `java.nio.channels.Selector` 클래스이다. 시스템의 이벤트 통지 API를 그대로 사용하며 언제나 읽기/쓰기 작업의 완료 상태를 확인할 수 있으므로 단일 스레드로 여러 동시 연결을 처리할 수 있다.\n  - 적은 수의 스레드로 더 많은 연결을 처리할 수 있으므로 컨텍스트 스위칭에 따른 오버헤드와 메모리 관리가 원활해짐\n  - 스레드의 상태가 점유가 되어 있지 않기 때문에, 입출력 외에 다른 작업을 사용할 수 있음.\n\n- 네티는 네트워킹 도메인에서 가장 유명한 자바 프레임워크로 기반 구현의 복잡성을 단순한 추상화로 감춰 개발자가 어플리케이션 구현 영역에 집중할 수 있도록 도와준다.\n  - 블로킹/논블로킹 방식의 모두 지원\n  - 코어 자바 API보다 높은 처리량과 짧은 지연 시간. 풀링/재사용을 통한 리소스 소비 감소, 메모리 복사 최소화\n\n- 이벤트 기반의 비동기식으로 어플리케이션을 작성할때는 특수한 문제에 대한 고려가 필요. \n  - 발생하는 이벤트에 대해 언제든지/순서에 상관없이 응답을 할 수 있음, 이는 곧, `증가하는 처리량에 맞게 시스템/네트워크/프로세스의 능력을 작업량 증가에 맞게 늘리는 능력`으로 정의할 수 있는 최고 수준의 확장성을 갖추는데 필수적임.\n  - 논블로킹 네트워크 연결은 작업 완료를 기다릴 필요가 없다. 비동기 코드는 바로 반환을 하며 완료가 되면 추후에 이를 통지하는 방식이다.\n  - 셀렉터는 적은 수의 스레드로 여러 연결에서 이벤트를 모니터링 할 수 있게 해줌\n\t\n\n- 네티의 핵심 컴포넌트\n  - Channel\n  하나 이상의 입출력 작업(읽기/쓰기)을 수행할수 있는 하드웨어 장치/파일/네트워크 소켓/프로그램 컴포넌트와 같은 엔티티에 대한 열린 연결, 들어오는 Inbound와 나가는 Outbound를 위한 운송수단으로 생각하자\n  - Callback\n  콜백은 관심 대상에게 작업 완료를 알리는 가장 일반적인 방법으로 네티는 이벤트를 처리할 때 내부적으로 콜백을 이용한다. 콜백 트리거가 되면 ChannelHandler 인터페이스 구현을 통해 이벤트를 처리할수 있다.\n  - Future\n  퓨처는 작업이 완료되면 어플리케이션에 이를 알리는 방법이다. 비동기 작업의 결과를 접근할 수 있게 해준다. JDK에서는 java.`util.concurrent.Future` 인터페이스를 제공하지만, 해당 구현은 `작업 완료 여부 확인`과 `완료전까지 블록킹`하는 기능만 존재한다. 네티는 이를 개선한 `ChannelFuture`를 사용한다. ChannelFuture에는 ChannelFutureListener 인스턴스를 하나 이상 등록할 수 있으며 완료시점에 operationComplete() 콜백 메소드가 호출이 된다. 해당 콜백 실행 시점에 완료/오류 등을 확인 가능하다.\n  네티의 모든 아웃바운드 입출력은 ChannelFuture를 반환하고 진행에 블로킹 작업은 없다. 모든것은 비동기에 이벤트 기반이다.\n\n- 이벤트와 핸들러\n네티는 작업 상태 변화를 알리기 위해 고유한 이벤트를 사용한다. `로깅`, `데이터 변환`, `흐름 제어`, `어플리케이션 논리` 등의 동작을 포함한다. 이벤트들은 크게 `인바운드`와 `아웃바운드` 데이터 흐름의 연관성을 기준으로 분류한다.\n모든 이벤트는 핸들러 클래스의 사용자 구현 메서드로 전달할 수 있다. **다시 말해, 각 핸들러 인스턴스는 특정 이벤트에 반응하여 실행하는 일종의 콜백이라고 이해하면 된다.**\n> * 인바운드: 연결 활성화/비활성화, 데이터 읽기, 사용자 이벤트, 오류 이벤트\n> * 아웃바운드: 원격 피어 연결 열기/닫기, 소켓에 데이터 쓰기/플러시\n\n\n\n## 2장. 첫 번째 네티 어플리케이션\n- 책의 경우 maven 기준으로 설명을 하고 있지만, 예제는 gradle 기반의 프로젝트에서 작성했으며, `4.1.65.Final` 버젼을 기준으로 실습 편의성을 위해 `netty-all` 디펜던시를 참조했다.\n```\ndependencies {\n  implementation 'io.netty:netty-all:4.1.65.Final'\n  ...\n}\n```\n\n#### EchoServer 코드 작성\n- 아래 `EchoServer` 및 `EchoServerHandler` 코드 작성 후 기동\n\n```java\npublic class EchoServer {\n\tprivate final int port;\n\n\tpublic EchoServer(int port) {\n\t\tthis.port = port;\n\t}\n\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tif (args.length < 1) {\n\t\t\tSystem.err.println(\"Usage: \" + EchoServer.class.getSimpleName() + \"<port>\");\n\t\t}\n\t\tint port = Integer.parseInt(args[0]);\n\t\tnew EchoServer(port).start();\n\t}\n\n\tpublic void start() throws InterruptedException {\n\t\tfinal EchoServerHandler echoServerHandler = new EchoServerHandler();\n\t\tEventLoopGroup group = new NioEventLoopGroup();\n\t\ttry {\n\t\t\tServerBootstrap b = new ServerBootstrap();\n\t\t\tb.group(group)\n\t\t\t\t.channel(NioServerSocketChannel.class)\n\t\t\t\t.localAddress(new InetSocketAddress(port))\n\t\t\t\t.childHandler(new ChannelInitializer<SocketChannel>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void initChannel(SocketChannel ch) throws Exception {\n\t\t\t\t\t\tSystem.out.println(\"initChannel\");\n\t\t\t\t\t\tch.pipeline().addLast(echoServerHandler);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tChannelFuture future = b.bind().sync();\n\t\t\tfuture.channel().closeFuture().sync();\n\t\t} finally {\n\t\t\tgroup.shutdownGracefully().sync();\n\t\t}\n\t}\n}\n```\n- 부트스트랩 하는 코드를 포함하고 있으며, 서버 연결 요청을 수신하는 포트를 서버와 바인딩하는 코드가 있어야 한다.\n- NioEventLoopGroup을 통하여 새로운 연결 수락 및 데이터 읽기/쓰기와 같은 이벤트를 처리\n- 서버가 바인딩하는 InetSocketAddress를 지정\n- 새로운 연결을 수락하고 Channel을 생성 후 ChannelInitializer를 통하여 EchoServerHandler 인스턴스를 Channel의 ChannelPipeline으로 추가한다.\n- ServerBootstrap.bind() 호출하여 서버를 바인딩\n\n```java\n@Sharable // 여러 Channel에서 공유할 수 있음을 나타나는 마커 인터페이스 \npublic class EchoServerHandler extends ChannelInboundHandlerAdapter {\n@Override\npublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\tfinal ByteBuf in = (ByteBuf) msg;\n\tSystem.out.println(\n\t\t\"Server received: \" + in.toString(CharsetUtil.UTF_8)\n\t);\n\tctx.write(in);\n}\n\n@Override\npublic void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n\tctx.writeAndFlush(Unpooled.EMPTY_BUFFER)\n\t\t.addListener(ChannelFutureListener.CLOSE);\n}\n\n@Override\npublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n\tcause.printStackTrace();\n\tctx.close();\n}\n}\n```\n\n- telnet을 통하여 Echo 메세지가 다시 telnet 클라이언트로 다시 전달이 되는지 확인하면 서버 코드 작성은 완료\n![텔넷테스트](https://i.imgur.com/jvDaSSu.png)\n- 서버에 들어오는 이벤트에 반응해야 하기 때문에 `ChannelInboundHandler` 구현체인 `ChannelInboundHandlerAdapter` 하위 클래스를 만들었고, 여기에 몇개 메소드를 오버라이드하여 메세지를 처리하도록 했다.\n  - `channelRead`: 메세지가 들어올때마다 호출\n  - `channelReadComplete`: channelRead()의 마지막 호출에서 현재 일괄 처리의 마지막 메세지를 처리했음을 핸들러에 통보\n  - `exceptionCaught`: 읽기 처리 중 예외가 발생하면 콜백됨, 예외 처리를 하지 않을 경우 ChannelPipeline의 마지막까지 이동 후 로깅이 되며, 가급적이면 하나 이상의 exceptionCaught를 구현하는 것이 바람직하다고 한다.\n- ChannelHandler는 네 가지 이벤트 유형을 제공하며, 어플리케이션은 ChannelHandler을 구현하거나 확장하여 이벤트를 후크하고 어플리케이션 로직을 제공해야 한다. ChannelHandler는 비즈니스 관심사에서 네트워크 관심사를 분리하는 것을 도와준다.\n\n#### EchoClient 코드 작성\n- 어플리케이션에서 필요한 `EchoClient`, `EchoClientHandler` 핸들러 코드는 아래와 같다.\n\n```java\n@Sharable\npublic class EchoClientHandler extends SimpleChannelInboundHandler<ByteBuf> {\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        ctx.writeAndFlush(\n\t\tUnpooled.copiedBuffer(\"Netty rocks!\", CharsetUtil.UTF_8)\n        );\n    }\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {\n        System.out.println(\n                \"Client received: \" + msg.toString(CharsetUtil.UTF_8)\n        );\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        cause.printStackTrace();\n        ctx.close();\n    }\n}\n```\n\n![ChannelHandler_Hierachy](https://i.imgur.com/VrnfrIE.png)\n- 서버와 마찬가지로 EchoClientHandler는 `ChannelInboundHandler` 인터페이스의 구현체인 `SimpleChannelInboundHandler`의 메소드를 오버라이드하여 필요한 작업을 처리한다.\n  - `channelActive()`: 서버 연결 후 콜백\n  - `channelRead0()`: 서버에서 메세지 수신 후 콜백\n  - `exceptionCaught()`: 처리 중 예외 시 콜백\n- `channelRead0()`에서 주의할 점은 전체 바이트 데이터 수신를 한 번에 수신한다는 보장이 없다. 경우에 따라 `channelRead0()` 메소드가 여러번 호출될 수 있다. 대신, TCP는 스트림 기반 프로토콜이므로 서버에서 보낸 순서대로 바이트 수신을 보장한다.\n  > 예시) AB|CDE|FG, ABC|DE|FG, AB|CD|EFG 와 같은 형태로 바이트를 수신할 수도 있다는 이야기이다.\n\n```java\npublic class EchoClient {\n    private final String host;\n    private final int port;\n\n    public EchoClient(String host, int port) {\n        this.port = port;\n        this.host = host;\n    }\n\n    public void start() throws InterruptedException {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n                    .channel(NioSocketChannel.class)\n                    .remoteAddress(new InetSocketAddress(host, port))\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline()\n\t\t\t\t    \t.addLast(new EchoClientHandler());\n                        }\n                    });\n            ChannelFuture f = b.connect().sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully().sync();\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        if (args.length < 1) {\n            System.err.println(\n                    \"Usage: \" + EchoClient.class.getSimpleName() + \"<host> <port>\"\n            );\n        }\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        new EchoClient(host, port).start();\n    }\n}\n```\n\n## 3장. 네티 컴포넌트와 설계\n### Channel, EventLoop, ChannelFuture\n- Channel: Socket\n- EventLoop: 제어 흐름, 멀티스레딩, 동시성 제어\n- ChannelFuture: 비동기 결과 알림\n\n#### Channel 인터페이스\n![Channel_Hierachy](https://i.imgur.com/Ovv6kg2.png)\n> 실제 구현 클래스와 인터페이스 종류는 더 다양하다.\n- `Channel` 인터페이스는 Socket으로 직접 작업할 때의 복잡성을 크게 완화하는 API를 제공\n\n#### EventLoop 인터페이스\n![EventLoop](https://i.imgur.com/rF7huZs.png)\n- 연결 수명주기 중 발생하는 이벤트를 처리하는 핵심 추상화 인터페이스\n\n![EventLoop](https://drek4537l1klr.cloudfront.net/maurer/Figures/03fig01.jpg)\n> 출처: Netty-In-Action\n\n- `Channel` - `EventLoop` - `Thread` - `EventLoopGroup` 사이에서의 상호작용은 아래와 같다\n  - 한 `EventLoopGroup`은 하나 이상의 EventLoop를 포함\n  - 한 `EventLoop`는 수명주기 동안 하나의 스레드에 바인딩\n  - 한 `EventLoop`에서 처리되는 모든 입출력은 전용 스레드에서 처리\n  - 한 `Channel`은 수명주기 동안 EventLoop에 등록\n  - 한 `EventLoop`는 하나 이상의 Channel로 할당 가능\n\n#### ChannelHandler와 ChannelPipeline\n![ChannelHandler](https://drek4537l1klr.cloudfront.net/maurer/Figures/03fig02.jpg)\n- `ChannelHandler` 인터페이스\n네티의 핵심 컴포넌트로 인바운드와 아웃바운드 데이터의 처리에 적용되는 모든 어플리케이션 논리를 처리하는 컨테이너 역할을 수행. 네트워크 이벤트에 의해 트리거되며 데이터를 변환하거나 예외처리하는 등의 모든 종류의 작업에 활용 가능하다.\n\n![ChannelPipeline](https://drek4537l1klr.cloudfront.net/maurer/Figures/03fig03_alt.jpg)\n- `ChannelPipeline` 인터페이스\n  - `ChannelPipeline`은 `ChannelHandler` 체인을 위한 컨테이너를 제공.\n  - 체인에서 인바운드/아웃바운드 이벤트를 전파하는 API를 정의한다.\n  - `ChannelHandler`는 아래와 같은 과정으로 `ChannelPipeline`에 설치\n    - `ChannelInitializer` 구현은 ServerBootstrap에 등록\n    - `ChannelInitializer.initChannel()`을 호출하면 ChannelInitializer가 ChannelHandler의 커스텀 집합을 파이프라인에 설치\n    - `ChannelInitializer`는 `ChannelPipeline`에서 자신을 제거\n  - 파이프라인을 통해 이벤트를 전달하는 역할은 `ChannelHandler`가 담당하며, 핸들러 객체는 이벤트를 수신하고 로직을 실행하며 체인상의 다음 핸들러로 데이터를 전달한다.\n  - 위 이미지에서 볼수 있듯이 인바운드/아웃바운드 핸들러는 같은 파이프라인에 설치가 가능하며 메세지/이벤트를 읽을 떄는 파이프라인 앞쪽에서 시작하며 체인상의 다음 ChannelInboundHandler로 데이터를 전달한다. 최종적으로 데이터가 파이프라인 뒤쪽에 이르면 모든 처리가 종료된다.\n  - 아웃바운드도 개념은 동일하며, 체인상에서 뒤쪽에서 시작하여 앞쪽에 이를 때까지 이동한다. Socket으로 나오는 부분에 도달하면 쓰기 작업이 트리거된다.\n  - 인바운드/아웃바운드 모두 ChannelHandler를 확장하지만, ChannelInboundHandler와 ChannelOutboundHandler의 구현을 구분하여 데이터 전달이 동일한 방향으로 수행되도록 보장한다.\n  - ChannelHandler를 하나 추가할 때 ChannelHandler와 ChannelPipeline의 바인딩을 나타내는 ChannelHandlerContext 하나가 할당된다. \n  - 네티에서는 메세지를 보내는 데 Channel에 직접할 기록하는 방법과 ChannelHandler와 연결된 ChannelHandlerContext 객체에 기록하는 두 가지 방법이 존재한다. 전자는 ChannelPipeline 뒤쪽에서 시작되며, 후자의 방법은 메세지가 ChannelPipeline의 다음 핸들러에서 시작된다.\n\n#### ChannelHandler에 대한 고찰\n- 네티는 비즈니스 로직을 쉽게 개발할 수 있도록 어댑터 클래스의 형태로 여러 기본 핸들러를 제공\n- 파이프라인의 각 핸들러는 체인의 다음 핸들러로 전달해야 하는데, 어댑터 클래스는 이 작업을 자동으로 해주고 특수한 동작이 필요한 메서드와 이벤트만 재정의할 수 있다.\n- 가장 자주 사용할 어댑터는 아래와 같다\n  - `ChannelHandlerAdapter`\n  - `ChannelInboundHandlerAdapter`\n  - `ChannelOutboundHandlerAdapter`\n  - `ChannelDuplexHandlerAdapter`\n\n#### 인코더/디코더\n- 메세지를 전송/수신할 때는 데이터를 변환해야 한다. 인바운드 메세지를 바이트에서 다른 포맷(보통 객체)로 변환하는 `디코딩` 과정을 거친다. 아웃바운드 메세지를 반대로 현재 포맷에서 바이트로 `인코딩` 되는 과정을 거친다. \n- 두 가지 변환 과정이 필요한 이유는 네트워크 데이터는 연속된 바이트여야하기 때문이다.\n- 네티가 제공하는 인코더/디코더 어댑터 클래스는 ChannelInboundHandler와 ChannelOutboundHandler를 구현한다.\n  - 인바운드 데이터의 경우 인바운드 Channel에서 읽는 각 메세지에 대해 호출되는 channelRead 메세지/이벤트를 재정의한다. 이 메서드는 제공된 디코더의 decode() 메서드를 호출한 후 디코딩된 바이트를 파이프라인 다음 ChannelInboundHandler에 전달한다. \n  - 아웃바운드 메세지를 위한 패턴은 반대이며 인코더가 메세지를 바이트로 변환한 후 다음 ChannelOutboundHandler로 전달한다.\n\n\n#### SimpleChannelInboundHandler 추상 클래스\n- 어플리케이션에서 들어오는 디코딩된 메세지를 수신하고 데이터에 비즈니스 논리를 적용하는 핸들러를 많이 사용하게 되는데 이러한 핸들러를 만들때 `SimpleChannelInboundHandler<T>`를 확장하면 되며, T는 처리하는 메세지의 제네릭 타입이다. 하나 이상의 메소드를 오버라이드하고 모든 핸들러 매서드에 인자로 전달되는 ChannelHandlerContext에 대한 참조를 얻는다.\n- 이 메소드에서 가장 중요한 메소드는 `channelRead0(ChannelHandlerContext T)`인데, 원하는대로 구현을 가능하지만 현재 입출력 스레드를 블로킹하지 않아야 한다는 요건이 있다.\n\n### 부트스트랩\n- 네티의 부트스트랩 클래스는 프로세스를 지정 포트에 바인딩(서버 부트스트랩)하거나 프로세스를 지정된 호스트의 지정된 포트에서 실행 중인 다른 호스트로 연결(클라이언트 부트스트랩)하는 등의 일을 하는 네트워크 레이어를 구성하는 컨테이너를 제공한다.\n\n| 범주 | Bootstrap | ServerBootstrap |\n|----------|:----------|:-------------:|\n| 네트워크 기능 | 원격 호스트/포트와 연결 |  로컬 포트로 바인딩 |\n| EventLoopGroup | 1 |  2 |\n\n- Bootstrap과 ServerBootstrap은 각기 EventLoopGroup의 수가 다른걸 볼 수 있다. \n\n![ServerBootstrap_EventLoopGroup](https://drek4537l1klr.cloudfront.net/maurer/Figures/03fig04_alt.jpg)\n\n- 서버의 경우, 첫 번째 집합은 로컬 포트와 바인됭 서버 자체의 수신 소켓을 나타내는 ServerChannel 하나를 포함하고 두 번째 집합은 서버가 수락한 연결마다 하나씩 들어오는 클라이언트 연결을 처리하기 위해 생성된 모든 Channel을 포함한다.\n- ServerChannel과 연결된 EventLoopGroup은 들어오는 연결 요청에 대해 Channel을 생성하는 역할을 EventLoop 하나에 할당한다. 연결이 수락되면 두 번째 EventLoopGroup이 해당 Channel에 EventLoop를 할당한다.\n\n\n## 4장 전송\n- 네티는 모든 전송 구현에 공통 API를 기반으로 사용하기 때문에 JDK를 직접 이용할 떄보다 변환이 훨씬 간단하다.\n  - 코드가 세부 구현 사항으로 오염될 우려가 적고, 광범위한 범위를 수정할 필요가 없어진다.\n","source":"_posts/Java/NETTY_IN_ACTION.md","raw":"---\ntitle: Netty-In-Action\ndate: 2021.7.18. 15:13\ncategories:\n- Java\n---\n\n# Netty-In-Action\n\n# 1부, 네티 개념과 아키텍처\n\n## 1장. 네티: 비동기 이벤트 기반 네트워킹 프레임워크\n- 최초 자바 API(java.net)은 네이티브 시스템 소켓 라이브러리가 제공하는 블로킹 함수만 제공\n  - 다수의 클라이언트를 관리하려면 새로운 클라이언트 소켓마다 새로운 스레드를 할당해야 함.\n  - 여러 스레드가 입출력 데이터를 무한정 대기하는 상태가 유지될 수 있고, 이는 곧 리소스에 대한 낭비로 이어질 수 있음.\n  - 운영체제에 따라 다르지만 스텍의 기본 크기는 64KB ~ 1MB까지 차지할 수 있다. JVM이 많은 수의 스레드 생성을 지원하지만, 동시 접속이 한계에 이르는 순간(1만개 전후) 컨텍스트 스위칭에 따른 오버헤드가 심각한 문제가 될수 있다.\n- 네이티브 소켓 라이브러리에는 오래전부터 네트워크 리소스 사용률을 세부적으로 제어할수 있는 논블로킹(non-blocking) 호출이 포함되어 있다.\n  - setsockopt() 시스템 함수를 통한 블로킹 콜에 대한 옵션 설정 가능\n  - 이벤트 통지 API(epoll/kqueue)를 통하여 논블로킹 소켓의 집합을 등록하면 읽거나 기록할 데이터가 준비됐는지 여부를 알수 있다. [참고](https://long-zhou.github.io/2012/12/21/epoll-vs-kqueue.html)\n  - 논블로킹 입출력을 위한 자바의 기능 지원은 1.4부터 java.nio 패키지를 통하여 이뤄졌다.\n\n\n![java.nio.channels.Selector](https://drek4537l1klr.cloudfront.net/maurer/Figures/01fig02.jpg)\n- 자바의 논블로킹 설계의 핵심은 바로 `java.nio.channels.Selector` 클래스이다. 시스템의 이벤트 통지 API를 그대로 사용하며 언제나 읽기/쓰기 작업의 완료 상태를 확인할 수 있으므로 단일 스레드로 여러 동시 연결을 처리할 수 있다.\n  - 적은 수의 스레드로 더 많은 연결을 처리할 수 있으므로 컨텍스트 스위칭에 따른 오버헤드와 메모리 관리가 원활해짐\n  - 스레드의 상태가 점유가 되어 있지 않기 때문에, 입출력 외에 다른 작업을 사용할 수 있음.\n\n- 네티는 네트워킹 도메인에서 가장 유명한 자바 프레임워크로 기반 구현의 복잡성을 단순한 추상화로 감춰 개발자가 어플리케이션 구현 영역에 집중할 수 있도록 도와준다.\n  - 블로킹/논블로킹 방식의 모두 지원\n  - 코어 자바 API보다 높은 처리량과 짧은 지연 시간. 풀링/재사용을 통한 리소스 소비 감소, 메모리 복사 최소화\n\n- 이벤트 기반의 비동기식으로 어플리케이션을 작성할때는 특수한 문제에 대한 고려가 필요. \n  - 발생하는 이벤트에 대해 언제든지/순서에 상관없이 응답을 할 수 있음, 이는 곧, `증가하는 처리량에 맞게 시스템/네트워크/프로세스의 능력을 작업량 증가에 맞게 늘리는 능력`으로 정의할 수 있는 최고 수준의 확장성을 갖추는데 필수적임.\n  - 논블로킹 네트워크 연결은 작업 완료를 기다릴 필요가 없다. 비동기 코드는 바로 반환을 하며 완료가 되면 추후에 이를 통지하는 방식이다.\n  - 셀렉터는 적은 수의 스레드로 여러 연결에서 이벤트를 모니터링 할 수 있게 해줌\n\t\n\n- 네티의 핵심 컴포넌트\n  - Channel\n  하나 이상의 입출력 작업(읽기/쓰기)을 수행할수 있는 하드웨어 장치/파일/네트워크 소켓/프로그램 컴포넌트와 같은 엔티티에 대한 열린 연결, 들어오는 Inbound와 나가는 Outbound를 위한 운송수단으로 생각하자\n  - Callback\n  콜백은 관심 대상에게 작업 완료를 알리는 가장 일반적인 방법으로 네티는 이벤트를 처리할 때 내부적으로 콜백을 이용한다. 콜백 트리거가 되면 ChannelHandler 인터페이스 구현을 통해 이벤트를 처리할수 있다.\n  - Future\n  퓨처는 작업이 완료되면 어플리케이션에 이를 알리는 방법이다. 비동기 작업의 결과를 접근할 수 있게 해준다. JDK에서는 java.`util.concurrent.Future` 인터페이스를 제공하지만, 해당 구현은 `작업 완료 여부 확인`과 `완료전까지 블록킹`하는 기능만 존재한다. 네티는 이를 개선한 `ChannelFuture`를 사용한다. ChannelFuture에는 ChannelFutureListener 인스턴스를 하나 이상 등록할 수 있으며 완료시점에 operationComplete() 콜백 메소드가 호출이 된다. 해당 콜백 실행 시점에 완료/오류 등을 확인 가능하다.\n  네티의 모든 아웃바운드 입출력은 ChannelFuture를 반환하고 진행에 블로킹 작업은 없다. 모든것은 비동기에 이벤트 기반이다.\n\n- 이벤트와 핸들러\n네티는 작업 상태 변화를 알리기 위해 고유한 이벤트를 사용한다. `로깅`, `데이터 변환`, `흐름 제어`, `어플리케이션 논리` 등의 동작을 포함한다. 이벤트들은 크게 `인바운드`와 `아웃바운드` 데이터 흐름의 연관성을 기준으로 분류한다.\n모든 이벤트는 핸들러 클래스의 사용자 구현 메서드로 전달할 수 있다. **다시 말해, 각 핸들러 인스턴스는 특정 이벤트에 반응하여 실행하는 일종의 콜백이라고 이해하면 된다.**\n> * 인바운드: 연결 활성화/비활성화, 데이터 읽기, 사용자 이벤트, 오류 이벤트\n> * 아웃바운드: 원격 피어 연결 열기/닫기, 소켓에 데이터 쓰기/플러시\n\n\n\n## 2장. 첫 번째 네티 어플리케이션\n- 책의 경우 maven 기준으로 설명을 하고 있지만, 예제는 gradle 기반의 프로젝트에서 작성했으며, `4.1.65.Final` 버젼을 기준으로 실습 편의성을 위해 `netty-all` 디펜던시를 참조했다.\n```\ndependencies {\n  implementation 'io.netty:netty-all:4.1.65.Final'\n  ...\n}\n```\n\n#### EchoServer 코드 작성\n- 아래 `EchoServer` 및 `EchoServerHandler` 코드 작성 후 기동\n\n```java\npublic class EchoServer {\n\tprivate final int port;\n\n\tpublic EchoServer(int port) {\n\t\tthis.port = port;\n\t}\n\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tif (args.length < 1) {\n\t\t\tSystem.err.println(\"Usage: \" + EchoServer.class.getSimpleName() + \"<port>\");\n\t\t}\n\t\tint port = Integer.parseInt(args[0]);\n\t\tnew EchoServer(port).start();\n\t}\n\n\tpublic void start() throws InterruptedException {\n\t\tfinal EchoServerHandler echoServerHandler = new EchoServerHandler();\n\t\tEventLoopGroup group = new NioEventLoopGroup();\n\t\ttry {\n\t\t\tServerBootstrap b = new ServerBootstrap();\n\t\t\tb.group(group)\n\t\t\t\t.channel(NioServerSocketChannel.class)\n\t\t\t\t.localAddress(new InetSocketAddress(port))\n\t\t\t\t.childHandler(new ChannelInitializer<SocketChannel>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void initChannel(SocketChannel ch) throws Exception {\n\t\t\t\t\t\tSystem.out.println(\"initChannel\");\n\t\t\t\t\t\tch.pipeline().addLast(echoServerHandler);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tChannelFuture future = b.bind().sync();\n\t\t\tfuture.channel().closeFuture().sync();\n\t\t} finally {\n\t\t\tgroup.shutdownGracefully().sync();\n\t\t}\n\t}\n}\n```\n- 부트스트랩 하는 코드를 포함하고 있으며, 서버 연결 요청을 수신하는 포트를 서버와 바인딩하는 코드가 있어야 한다.\n- NioEventLoopGroup을 통하여 새로운 연결 수락 및 데이터 읽기/쓰기와 같은 이벤트를 처리\n- 서버가 바인딩하는 InetSocketAddress를 지정\n- 새로운 연결을 수락하고 Channel을 생성 후 ChannelInitializer를 통하여 EchoServerHandler 인스턴스를 Channel의 ChannelPipeline으로 추가한다.\n- ServerBootstrap.bind() 호출하여 서버를 바인딩\n\n```java\n@Sharable // 여러 Channel에서 공유할 수 있음을 나타나는 마커 인터페이스 \npublic class EchoServerHandler extends ChannelInboundHandlerAdapter {\n@Override\npublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\tfinal ByteBuf in = (ByteBuf) msg;\n\tSystem.out.println(\n\t\t\"Server received: \" + in.toString(CharsetUtil.UTF_8)\n\t);\n\tctx.write(in);\n}\n\n@Override\npublic void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n\tctx.writeAndFlush(Unpooled.EMPTY_BUFFER)\n\t\t.addListener(ChannelFutureListener.CLOSE);\n}\n\n@Override\npublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n\tcause.printStackTrace();\n\tctx.close();\n}\n}\n```\n\n- telnet을 통하여 Echo 메세지가 다시 telnet 클라이언트로 다시 전달이 되는지 확인하면 서버 코드 작성은 완료\n![텔넷테스트](https://i.imgur.com/jvDaSSu.png)\n- 서버에 들어오는 이벤트에 반응해야 하기 때문에 `ChannelInboundHandler` 구현체인 `ChannelInboundHandlerAdapter` 하위 클래스를 만들었고, 여기에 몇개 메소드를 오버라이드하여 메세지를 처리하도록 했다.\n  - `channelRead`: 메세지가 들어올때마다 호출\n  - `channelReadComplete`: channelRead()의 마지막 호출에서 현재 일괄 처리의 마지막 메세지를 처리했음을 핸들러에 통보\n  - `exceptionCaught`: 읽기 처리 중 예외가 발생하면 콜백됨, 예외 처리를 하지 않을 경우 ChannelPipeline의 마지막까지 이동 후 로깅이 되며, 가급적이면 하나 이상의 exceptionCaught를 구현하는 것이 바람직하다고 한다.\n- ChannelHandler는 네 가지 이벤트 유형을 제공하며, 어플리케이션은 ChannelHandler을 구현하거나 확장하여 이벤트를 후크하고 어플리케이션 로직을 제공해야 한다. ChannelHandler는 비즈니스 관심사에서 네트워크 관심사를 분리하는 것을 도와준다.\n\n#### EchoClient 코드 작성\n- 어플리케이션에서 필요한 `EchoClient`, `EchoClientHandler` 핸들러 코드는 아래와 같다.\n\n```java\n@Sharable\npublic class EchoClientHandler extends SimpleChannelInboundHandler<ByteBuf> {\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        ctx.writeAndFlush(\n\t\tUnpooled.copiedBuffer(\"Netty rocks!\", CharsetUtil.UTF_8)\n        );\n    }\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {\n        System.out.println(\n                \"Client received: \" + msg.toString(CharsetUtil.UTF_8)\n        );\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        cause.printStackTrace();\n        ctx.close();\n    }\n}\n```\n\n![ChannelHandler_Hierachy](https://i.imgur.com/VrnfrIE.png)\n- 서버와 마찬가지로 EchoClientHandler는 `ChannelInboundHandler` 인터페이스의 구현체인 `SimpleChannelInboundHandler`의 메소드를 오버라이드하여 필요한 작업을 처리한다.\n  - `channelActive()`: 서버 연결 후 콜백\n  - `channelRead0()`: 서버에서 메세지 수신 후 콜백\n  - `exceptionCaught()`: 처리 중 예외 시 콜백\n- `channelRead0()`에서 주의할 점은 전체 바이트 데이터 수신를 한 번에 수신한다는 보장이 없다. 경우에 따라 `channelRead0()` 메소드가 여러번 호출될 수 있다. 대신, TCP는 스트림 기반 프로토콜이므로 서버에서 보낸 순서대로 바이트 수신을 보장한다.\n  > 예시) AB|CDE|FG, ABC|DE|FG, AB|CD|EFG 와 같은 형태로 바이트를 수신할 수도 있다는 이야기이다.\n\n```java\npublic class EchoClient {\n    private final String host;\n    private final int port;\n\n    public EchoClient(String host, int port) {\n        this.port = port;\n        this.host = host;\n    }\n\n    public void start() throws InterruptedException {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n                    .channel(NioSocketChannel.class)\n                    .remoteAddress(new InetSocketAddress(host, port))\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline()\n\t\t\t\t    \t.addLast(new EchoClientHandler());\n                        }\n                    });\n            ChannelFuture f = b.connect().sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully().sync();\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        if (args.length < 1) {\n            System.err.println(\n                    \"Usage: \" + EchoClient.class.getSimpleName() + \"<host> <port>\"\n            );\n        }\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        new EchoClient(host, port).start();\n    }\n}\n```\n\n## 3장. 네티 컴포넌트와 설계\n### Channel, EventLoop, ChannelFuture\n- Channel: Socket\n- EventLoop: 제어 흐름, 멀티스레딩, 동시성 제어\n- ChannelFuture: 비동기 결과 알림\n\n#### Channel 인터페이스\n![Channel_Hierachy](https://i.imgur.com/Ovv6kg2.png)\n> 실제 구현 클래스와 인터페이스 종류는 더 다양하다.\n- `Channel` 인터페이스는 Socket으로 직접 작업할 때의 복잡성을 크게 완화하는 API를 제공\n\n#### EventLoop 인터페이스\n![EventLoop](https://i.imgur.com/rF7huZs.png)\n- 연결 수명주기 중 발생하는 이벤트를 처리하는 핵심 추상화 인터페이스\n\n![EventLoop](https://drek4537l1klr.cloudfront.net/maurer/Figures/03fig01.jpg)\n> 출처: Netty-In-Action\n\n- `Channel` - `EventLoop` - `Thread` - `EventLoopGroup` 사이에서의 상호작용은 아래와 같다\n  - 한 `EventLoopGroup`은 하나 이상의 EventLoop를 포함\n  - 한 `EventLoop`는 수명주기 동안 하나의 스레드에 바인딩\n  - 한 `EventLoop`에서 처리되는 모든 입출력은 전용 스레드에서 처리\n  - 한 `Channel`은 수명주기 동안 EventLoop에 등록\n  - 한 `EventLoop`는 하나 이상의 Channel로 할당 가능\n\n#### ChannelHandler와 ChannelPipeline\n![ChannelHandler](https://drek4537l1klr.cloudfront.net/maurer/Figures/03fig02.jpg)\n- `ChannelHandler` 인터페이스\n네티의 핵심 컴포넌트로 인바운드와 아웃바운드 데이터의 처리에 적용되는 모든 어플리케이션 논리를 처리하는 컨테이너 역할을 수행. 네트워크 이벤트에 의해 트리거되며 데이터를 변환하거나 예외처리하는 등의 모든 종류의 작업에 활용 가능하다.\n\n![ChannelPipeline](https://drek4537l1klr.cloudfront.net/maurer/Figures/03fig03_alt.jpg)\n- `ChannelPipeline` 인터페이스\n  - `ChannelPipeline`은 `ChannelHandler` 체인을 위한 컨테이너를 제공.\n  - 체인에서 인바운드/아웃바운드 이벤트를 전파하는 API를 정의한다.\n  - `ChannelHandler`는 아래와 같은 과정으로 `ChannelPipeline`에 설치\n    - `ChannelInitializer` 구현은 ServerBootstrap에 등록\n    - `ChannelInitializer.initChannel()`을 호출하면 ChannelInitializer가 ChannelHandler의 커스텀 집합을 파이프라인에 설치\n    - `ChannelInitializer`는 `ChannelPipeline`에서 자신을 제거\n  - 파이프라인을 통해 이벤트를 전달하는 역할은 `ChannelHandler`가 담당하며, 핸들러 객체는 이벤트를 수신하고 로직을 실행하며 체인상의 다음 핸들러로 데이터를 전달한다.\n  - 위 이미지에서 볼수 있듯이 인바운드/아웃바운드 핸들러는 같은 파이프라인에 설치가 가능하며 메세지/이벤트를 읽을 떄는 파이프라인 앞쪽에서 시작하며 체인상의 다음 ChannelInboundHandler로 데이터를 전달한다. 최종적으로 데이터가 파이프라인 뒤쪽에 이르면 모든 처리가 종료된다.\n  - 아웃바운드도 개념은 동일하며, 체인상에서 뒤쪽에서 시작하여 앞쪽에 이를 때까지 이동한다. Socket으로 나오는 부분에 도달하면 쓰기 작업이 트리거된다.\n  - 인바운드/아웃바운드 모두 ChannelHandler를 확장하지만, ChannelInboundHandler와 ChannelOutboundHandler의 구현을 구분하여 데이터 전달이 동일한 방향으로 수행되도록 보장한다.\n  - ChannelHandler를 하나 추가할 때 ChannelHandler와 ChannelPipeline의 바인딩을 나타내는 ChannelHandlerContext 하나가 할당된다. \n  - 네티에서는 메세지를 보내는 데 Channel에 직접할 기록하는 방법과 ChannelHandler와 연결된 ChannelHandlerContext 객체에 기록하는 두 가지 방법이 존재한다. 전자는 ChannelPipeline 뒤쪽에서 시작되며, 후자의 방법은 메세지가 ChannelPipeline의 다음 핸들러에서 시작된다.\n\n#### ChannelHandler에 대한 고찰\n- 네티는 비즈니스 로직을 쉽게 개발할 수 있도록 어댑터 클래스의 형태로 여러 기본 핸들러를 제공\n- 파이프라인의 각 핸들러는 체인의 다음 핸들러로 전달해야 하는데, 어댑터 클래스는 이 작업을 자동으로 해주고 특수한 동작이 필요한 메서드와 이벤트만 재정의할 수 있다.\n- 가장 자주 사용할 어댑터는 아래와 같다\n  - `ChannelHandlerAdapter`\n  - `ChannelInboundHandlerAdapter`\n  - `ChannelOutboundHandlerAdapter`\n  - `ChannelDuplexHandlerAdapter`\n\n#### 인코더/디코더\n- 메세지를 전송/수신할 때는 데이터를 변환해야 한다. 인바운드 메세지를 바이트에서 다른 포맷(보통 객체)로 변환하는 `디코딩` 과정을 거친다. 아웃바운드 메세지를 반대로 현재 포맷에서 바이트로 `인코딩` 되는 과정을 거친다. \n- 두 가지 변환 과정이 필요한 이유는 네트워크 데이터는 연속된 바이트여야하기 때문이다.\n- 네티가 제공하는 인코더/디코더 어댑터 클래스는 ChannelInboundHandler와 ChannelOutboundHandler를 구현한다.\n  - 인바운드 데이터의 경우 인바운드 Channel에서 읽는 각 메세지에 대해 호출되는 channelRead 메세지/이벤트를 재정의한다. 이 메서드는 제공된 디코더의 decode() 메서드를 호출한 후 디코딩된 바이트를 파이프라인 다음 ChannelInboundHandler에 전달한다. \n  - 아웃바운드 메세지를 위한 패턴은 반대이며 인코더가 메세지를 바이트로 변환한 후 다음 ChannelOutboundHandler로 전달한다.\n\n\n#### SimpleChannelInboundHandler 추상 클래스\n- 어플리케이션에서 들어오는 디코딩된 메세지를 수신하고 데이터에 비즈니스 논리를 적용하는 핸들러를 많이 사용하게 되는데 이러한 핸들러를 만들때 `SimpleChannelInboundHandler<T>`를 확장하면 되며, T는 처리하는 메세지의 제네릭 타입이다. 하나 이상의 메소드를 오버라이드하고 모든 핸들러 매서드에 인자로 전달되는 ChannelHandlerContext에 대한 참조를 얻는다.\n- 이 메소드에서 가장 중요한 메소드는 `channelRead0(ChannelHandlerContext T)`인데, 원하는대로 구현을 가능하지만 현재 입출력 스레드를 블로킹하지 않아야 한다는 요건이 있다.\n\n### 부트스트랩\n- 네티의 부트스트랩 클래스는 프로세스를 지정 포트에 바인딩(서버 부트스트랩)하거나 프로세스를 지정된 호스트의 지정된 포트에서 실행 중인 다른 호스트로 연결(클라이언트 부트스트랩)하는 등의 일을 하는 네트워크 레이어를 구성하는 컨테이너를 제공한다.\n\n| 범주 | Bootstrap | ServerBootstrap |\n|----------|:----------|:-------------:|\n| 네트워크 기능 | 원격 호스트/포트와 연결 |  로컬 포트로 바인딩 |\n| EventLoopGroup | 1 |  2 |\n\n- Bootstrap과 ServerBootstrap은 각기 EventLoopGroup의 수가 다른걸 볼 수 있다. \n\n![ServerBootstrap_EventLoopGroup](https://drek4537l1klr.cloudfront.net/maurer/Figures/03fig04_alt.jpg)\n\n- 서버의 경우, 첫 번째 집합은 로컬 포트와 바인됭 서버 자체의 수신 소켓을 나타내는 ServerChannel 하나를 포함하고 두 번째 집합은 서버가 수락한 연결마다 하나씩 들어오는 클라이언트 연결을 처리하기 위해 생성된 모든 Channel을 포함한다.\n- ServerChannel과 연결된 EventLoopGroup은 들어오는 연결 요청에 대해 Channel을 생성하는 역할을 EventLoop 하나에 할당한다. 연결이 수락되면 두 번째 EventLoopGroup이 해당 Channel에 EventLoop를 할당한다.\n\n\n## 4장 전송\n- 네티는 모든 전송 구현에 공통 API를 기반으로 사용하기 때문에 JDK를 직접 이용할 떄보다 변환이 훨씬 간단하다.\n  - 코드가 세부 구현 사항으로 오염될 우려가 적고, 광범위한 범위를 수정할 필요가 없어진다.\n","slug":"Java/NETTY_IN_ACTION","published":1,"updated":"2021-08-02T11:59:39.897Z","_id":"ckrsup5160022tjhvhv9n3y4i","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Netty-In-Action\"><a href=\"#Netty-In-Action\" class=\"headerlink\" title=\"Netty-In-Action\"></a>Netty-In-Action</h1><h1 id=\"1부-네티-개념과-아키텍처\"><a href=\"#1부-네티-개념과-아키텍처\" class=\"headerlink\" title=\"1부, 네티 개념과 아키텍처\"></a>1부, 네티 개념과 아키텍처</h1><h2 id=\"1장-네티-비동기-이벤트-기반-네트워킹-프레임워크\"><a href=\"#1장-네티-비동기-이벤트-기반-네트워킹-프레임워크\" class=\"headerlink\" title=\"1장. 네티: 비동기 이벤트 기반 네트워킹 프레임워크\"></a>1장. 네티: 비동기 이벤트 기반 네트워킹 프레임워크</h2><ul>\n<li>최초 자바 API(java.net)은 네이티브 시스템 소켓 라이브러리가 제공하는 블로킹 함수만 제공<ul>\n<li>다수의 클라이언트를 관리하려면 새로운 클라이언트 소켓마다 새로운 스레드를 할당해야 함.</li>\n<li>여러 스레드가 입출력 데이터를 무한정 대기하는 상태가 유지될 수 있고, 이는 곧 리소스에 대한 낭비로 이어질 수 있음.</li>\n<li>운영체제에 따라 다르지만 스텍의 기본 크기는 64KB ~ 1MB까지 차지할 수 있다. JVM이 많은 수의 스레드 생성을 지원하지만, 동시 접속이 한계에 이르는 순간(1만개 전후) 컨텍스트 스위칭에 따른 오버헤드가 심각한 문제가 될수 있다.</li>\n</ul>\n</li>\n<li>네이티브 소켓 라이브러리에는 오래전부터 네트워크 리소스 사용률을 세부적으로 제어할수 있는 논블로킹(non-blocking) 호출이 포함되어 있다.<ul>\n<li>setsockopt() 시스템 함수를 통한 블로킹 콜에 대한 옵션 설정 가능</li>\n<li>이벤트 통지 API(epoll/kqueue)를 통하여 논블로킹 소켓의 집합을 등록하면 읽거나 기록할 데이터가 준비됐는지 여부를 알수 있다. <a href=\"https://long-zhou.github.io/2012/12/21/epoll-vs-kqueue.html\">참고</a></li>\n<li>논블로킹 입출력을 위한 자바의 기능 지원은 1.4부터 java.nio 패키지를 통하여 이뤄졌다.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://drek4537l1klr.cloudfront.net/maurer/Figures/01fig02.jpg\" alt=\"java.nio.channels.Selector\"></p>\n<ul>\n<li><p>자바의 논블로킹 설계의 핵심은 바로 <code>java.nio.channels.Selector</code> 클래스이다. 시스템의 이벤트 통지 API를 그대로 사용하며 언제나 읽기/쓰기 작업의 완료 상태를 확인할 수 있으므로 단일 스레드로 여러 동시 연결을 처리할 수 있다.</p>\n<ul>\n<li>적은 수의 스레드로 더 많은 연결을 처리할 수 있으므로 컨텍스트 스위칭에 따른 오버헤드와 메모리 관리가 원활해짐</li>\n<li>스레드의 상태가 점유가 되어 있지 않기 때문에, 입출력 외에 다른 작업을 사용할 수 있음.</li>\n</ul>\n</li>\n<li><p>네티는 네트워킹 도메인에서 가장 유명한 자바 프레임워크로 기반 구현의 복잡성을 단순한 추상화로 감춰 개발자가 어플리케이션 구현 영역에 집중할 수 있도록 도와준다.</p>\n<ul>\n<li>블로킹/논블로킹 방식의 모두 지원</li>\n<li>코어 자바 API보다 높은 처리량과 짧은 지연 시간. 풀링/재사용을 통한 리소스 소비 감소, 메모리 복사 최소화</li>\n</ul>\n</li>\n<li><p>이벤트 기반의 비동기식으로 어플리케이션을 작성할때는 특수한 문제에 대한 고려가 필요. </p>\n<ul>\n<li>발생하는 이벤트에 대해 언제든지/순서에 상관없이 응답을 할 수 있음, 이는 곧, <code>증가하는 처리량에 맞게 시스템/네트워크/프로세스의 능력을 작업량 증가에 맞게 늘리는 능력</code>으로 정의할 수 있는 최고 수준의 확장성을 갖추는데 필수적임.</li>\n<li>논블로킹 네트워크 연결은 작업 완료를 기다릴 필요가 없다. 비동기 코드는 바로 반환을 하며 완료가 되면 추후에 이를 통지하는 방식이다.</li>\n<li>셀렉터는 적은 수의 스레드로 여러 연결에서 이벤트를 모니터링 할 수 있게 해줌</li>\n</ul>\n</li>\n<li><p>네티의 핵심 컴포넌트</p>\n<ul>\n<li>Channel<br>하나 이상의 입출력 작업(읽기/쓰기)을 수행할수 있는 하드웨어 장치/파일/네트워크 소켓/프로그램 컴포넌트와 같은 엔티티에 대한 열린 연결, 들어오는 Inbound와 나가는 Outbound를 위한 운송수단으로 생각하자</li>\n<li>Callback<br>콜백은 관심 대상에게 작업 완료를 알리는 가장 일반적인 방법으로 네티는 이벤트를 처리할 때 내부적으로 콜백을 이용한다. 콜백 트리거가 되면 ChannelHandler 인터페이스 구현을 통해 이벤트를 처리할수 있다.</li>\n<li>Future<br>퓨처는 작업이 완료되면 어플리케이션에 이를 알리는 방법이다. 비동기 작업의 결과를 접근할 수 있게 해준다. JDK에서는 java.<code>util.concurrent.Future</code> 인터페이스를 제공하지만, 해당 구현은 <code>작업 완료 여부 확인</code>과 <code>완료전까지 블록킹</code>하는 기능만 존재한다. 네티는 이를 개선한 <code>ChannelFuture</code>를 사용한다. ChannelFuture에는 ChannelFutureListener 인스턴스를 하나 이상 등록할 수 있으며 완료시점에 operationComplete() 콜백 메소드가 호출이 된다. 해당 콜백 실행 시점에 완료/오류 등을 확인 가능하다.<br>네티의 모든 아웃바운드 입출력은 ChannelFuture를 반환하고 진행에 블로킹 작업은 없다. 모든것은 비동기에 이벤트 기반이다.</li>\n</ul>\n</li>\n<li><p>이벤트와 핸들러<br>네티는 작업 상태 변화를 알리기 위해 고유한 이벤트를 사용한다. <code>로깅</code>, <code>데이터 변환</code>, <code>흐름 제어</code>, <code>어플리케이션 논리</code> 등의 동작을 포함한다. 이벤트들은 크게 <code>인바운드</code>와 <code>아웃바운드</code> 데이터 흐름의 연관성을 기준으로 분류한다.<br>모든 이벤트는 핸들러 클래스의 사용자 구현 메서드로 전달할 수 있다. <strong>다시 말해, 각 핸들러 인스턴스는 특정 이벤트에 반응하여 실행하는 일종의 콜백이라고 이해하면 된다.</strong></p>\n<blockquote>\n<ul>\n<li>인바운드: 연결 활성화/비활성화, 데이터 읽기, 사용자 이벤트, 오류 이벤트</li>\n<li>아웃바운드: 원격 피어 연결 열기/닫기, 소켓에 데이터 쓰기/플러시</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"2장-첫-번째-네티-어플리케이션\"><a href=\"#2장-첫-번째-네티-어플리케이션\" class=\"headerlink\" title=\"2장. 첫 번째 네티 어플리케이션\"></a>2장. 첫 번째 네티 어플리케이션</h2><ul>\n<li>책의 경우 maven 기준으로 설명을 하고 있지만, 예제는 gradle 기반의 프로젝트에서 작성했으며, <code>4.1.65.Final</code> 버젼을 기준으로 실습 편의성을 위해 <code>netty-all</code> 디펜던시를 참조했다.<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  implementation &#x27;io.netty:netty-all:4.1.65.Final&#x27;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"EchoServer-코드-작성\"><a href=\"#EchoServer-코드-작성\" class=\"headerlink\" title=\"EchoServer 코드 작성\"></a>EchoServer 코드 작성</h4><ul>\n<li>아래 <code>EchoServer</code> 및 <code>EchoServerHandler</code> 코드 작성 후 기동</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoServer</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EchoServer</span><span class=\"params\">(<span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.port = port;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (args.length &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\tSystem.err.println(<span class=\"string\">&quot;Usage: &quot;</span> + EchoServer.class.getSimpleName() + <span class=\"string\">&quot;&lt;port&gt;&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> port = Integer.parseInt(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> EchoServer(port).start();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> EchoServerHandler echoServerHandler = <span class=\"keyword\">new</span> EchoServerHandler();</span><br><span class=\"line\">\t\tEventLoopGroup group = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tServerBootstrap b = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\">\t\t\tb.group(group)</span><br><span class=\"line\">\t\t\t\t.channel(NioServerSocketChannel.class)</span><br><span class=\"line\">\t\t\t\t.localAddress(<span class=\"keyword\">new</span> InetSocketAddress(port))</span><br><span class=\"line\">\t\t\t\t.childHandler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\tSystem.out.println(<span class=\"string\">&quot;initChannel&quot;</span>);</span><br><span class=\"line\">\t\t\t\t\t\tch.pipeline().addLast(echoServerHandler);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\tChannelFuture future = b.bind().sync();</span><br><span class=\"line\">\t\t\tfuture.channel().closeFuture().sync();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\tgroup.shutdownGracefully().sync();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>부트스트랩 하는 코드를 포함하고 있으며, 서버 연결 요청을 수신하는 포트를 서버와 바인딩하는 코드가 있어야 한다.</li>\n<li>NioEventLoopGroup을 통하여 새로운 연결 수락 및 데이터 읽기/쓰기와 같은 이벤트를 처리</li>\n<li>서버가 바인딩하는 InetSocketAddress를 지정</li>\n<li>새로운 연결을 수락하고 Channel을 생성 후 ChannelInitializer를 통하여 EchoServerHandler 인스턴스를 Channel의 ChannelPipeline으로 추가한다.</li>\n<li>ServerBootstrap.bind() 호출하여 서버를 바인딩</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Sharable</span> <span class=\"comment\">// 여러 Channel에서 공유할 수 있음을 나타나는 마커 인터페이스 </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoServerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> ByteBuf in = (ByteBuf) msg;</span><br><span class=\"line\">\tSystem.out.println(</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;Server received: &quot;</span> + in.toString(CharsetUtil.UTF_8)</span><br><span class=\"line\">\t);</span><br><span class=\"line\">\tctx.write(in);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelReadComplete</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\tctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class=\"line\">\t\t.addListener(ChannelFutureListener.CLOSE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx, Throwable cause)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\tcause.printStackTrace();</span><br><span class=\"line\">\tctx.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>telnet을 통하여 Echo 메세지가 다시 telnet 클라이언트로 다시 전달이 되는지 확인하면 서버 코드 작성은 완료<br><img src=\"https://i.imgur.com/jvDaSSu.png\" alt=\"텔넷테스트\"></li>\n<li>서버에 들어오는 이벤트에 반응해야 하기 때문에 <code>ChannelInboundHandler</code> 구현체인 <code>ChannelInboundHandlerAdapter</code> 하위 클래스를 만들었고, 여기에 몇개 메소드를 오버라이드하여 메세지를 처리하도록 했다.<ul>\n<li><code>channelRead</code>: 메세지가 들어올때마다 호출</li>\n<li><code>channelReadComplete</code>: channelRead()의 마지막 호출에서 현재 일괄 처리의 마지막 메세지를 처리했음을 핸들러에 통보</li>\n<li><code>exceptionCaught</code>: 읽기 처리 중 예외가 발생하면 콜백됨, 예외 처리를 하지 않을 경우 ChannelPipeline의 마지막까지 이동 후 로깅이 되며, 가급적이면 하나 이상의 exceptionCaught를 구현하는 것이 바람직하다고 한다.</li>\n</ul>\n</li>\n<li>ChannelHandler는 네 가지 이벤트 유형을 제공하며, 어플리케이션은 ChannelHandler을 구현하거나 확장하여 이벤트를 후크하고 어플리케이션 로직을 제공해야 한다. ChannelHandler는 비즈니스 관심사에서 네트워크 관심사를 분리하는 것을 도와준다.</li>\n</ul>\n<h4 id=\"EchoClient-코드-작성\"><a href=\"#EchoClient-코드-작성\" class=\"headerlink\" title=\"EchoClient 코드 작성\"></a>EchoClient 코드 작성</h4><ul>\n<li>어플리케이션에서 필요한 <code>EchoClient</code>, <code>EchoClientHandler</code> 핸들러 코드는 아래와 같다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Sharable</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoClientHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleChannelInboundHandler</span>&lt;<span class=\"title\">ByteBuf</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ctx.writeAndFlush(</span><br><span class=\"line\">\t\tUnpooled.copiedBuffer(<span class=\"string\">&quot;Netty rocks!&quot;</span>, CharsetUtil.UTF_8)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(</span><br><span class=\"line\">                <span class=\"string\">&quot;Client received: &quot;</span> + msg.toString(CharsetUtil.UTF_8)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx, Throwable cause)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        cause.printStackTrace();</span><br><span class=\"line\">        ctx.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.imgur.com/VrnfrIE.png\" alt=\"ChannelHandler_Hierachy\"></p>\n<ul>\n<li>서버와 마찬가지로 EchoClientHandler는 <code>ChannelInboundHandler</code> 인터페이스의 구현체인 <code>SimpleChannelInboundHandler</code>의 메소드를 오버라이드하여 필요한 작업을 처리한다.<ul>\n<li><code>channelActive()</code>: 서버 연결 후 콜백</li>\n<li><code>channelRead0()</code>: 서버에서 메세지 수신 후 콜백</li>\n<li><code>exceptionCaught()</code>: 처리 중 예외 시 콜백</li>\n</ul>\n</li>\n<li><code>channelRead0()</code>에서 주의할 점은 전체 바이트 데이터 수신를 한 번에 수신한다는 보장이 없다. 경우에 따라 <code>channelRead0()</code> 메소드가 여러번 호출될 수 있다. 대신, TCP는 스트림 기반 프로토콜이므로 서버에서 보낸 순서대로 바이트 수신을 보장한다.<blockquote>\n<p>예시) AB|CDE|FG, ABC|DE|FG, AB|CD|EFG 와 같은 형태로 바이트를 수신할 수도 있다는 이야기이다.</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoClient</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String host;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EchoClient</span><span class=\"params\">(String host, <span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.port = port;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.host = host;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        EventLoopGroup group = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Bootstrap b = <span class=\"keyword\">new</span> Bootstrap();</span><br><span class=\"line\">            b.group(group)</span><br><span class=\"line\">                    .channel(NioSocketChannel.class)</span><br><span class=\"line\">                    .remoteAddress(<span class=\"keyword\">new</span> InetSocketAddress(host, port))</span><br><span class=\"line\">                    .handler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                            ch.pipeline()</span><br><span class=\"line\">\t\t\t\t    \t.addLast(<span class=\"keyword\">new</span> EchoClientHandler());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">            ChannelFuture f = b.connect().sync();</span><br><span class=\"line\">            f.channel().closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            group.shutdownGracefully().sync();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.err.println(</span><br><span class=\"line\">                    <span class=\"string\">&quot;Usage: &quot;</span> + EchoClient.class.getSimpleName() + <span class=\"string\">&quot;&lt;host&gt; &lt;port&gt;&quot;</span></span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String host = args[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> port = Integer.parseInt(args[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">new</span> EchoClient(host, port).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3장-네티-컴포넌트와-설계\"><a href=\"#3장-네티-컴포넌트와-설계\" class=\"headerlink\" title=\"3장. 네티 컴포넌트와 설계\"></a>3장. 네티 컴포넌트와 설계</h2><h3 id=\"Channel-EventLoop-ChannelFuture\"><a href=\"#Channel-EventLoop-ChannelFuture\" class=\"headerlink\" title=\"Channel, EventLoop, ChannelFuture\"></a>Channel, EventLoop, ChannelFuture</h3><ul>\n<li>Channel: Socket</li>\n<li>EventLoop: 제어 흐름, 멀티스레딩, 동시성 제어</li>\n<li>ChannelFuture: 비동기 결과 알림</li>\n</ul>\n<h4 id=\"Channel-인터페이스\"><a href=\"#Channel-인터페이스\" class=\"headerlink\" title=\"Channel 인터페이스\"></a>Channel 인터페이스</h4><p><img src=\"https://i.imgur.com/Ovv6kg2.png\" alt=\"Channel_Hierachy\"></p>\n<blockquote>\n<p>실제 구현 클래스와 인터페이스 종류는 더 다양하다.</p>\n</blockquote>\n<ul>\n<li><code>Channel</code> 인터페이스는 Socket으로 직접 작업할 때의 복잡성을 크게 완화하는 API를 제공</li>\n</ul>\n<h4 id=\"EventLoop-인터페이스\"><a href=\"#EventLoop-인터페이스\" class=\"headerlink\" title=\"EventLoop 인터페이스\"></a>EventLoop 인터페이스</h4><p><img src=\"https://i.imgur.com/rF7huZs.png\" alt=\"EventLoop\"></p>\n<ul>\n<li>연결 수명주기 중 발생하는 이벤트를 처리하는 핵심 추상화 인터페이스</li>\n</ul>\n<p><img src=\"https://drek4537l1klr.cloudfront.net/maurer/Figures/03fig01.jpg\" alt=\"EventLoop\"></p>\n<blockquote>\n<p>출처: Netty-In-Action</p>\n</blockquote>\n<ul>\n<li><code>Channel</code> - <code>EventLoop</code> - <code>Thread</code> - <code>EventLoopGroup</code> 사이에서의 상호작용은 아래와 같다<ul>\n<li>한 <code>EventLoopGroup</code>은 하나 이상의 EventLoop를 포함</li>\n<li>한 <code>EventLoop</code>는 수명주기 동안 하나의 스레드에 바인딩</li>\n<li>한 <code>EventLoop</code>에서 처리되는 모든 입출력은 전용 스레드에서 처리</li>\n<li>한 <code>Channel</code>은 수명주기 동안 EventLoop에 등록</li>\n<li>한 <code>EventLoop</code>는 하나 이상의 Channel로 할당 가능</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ChannelHandler와-ChannelPipeline\"><a href=\"#ChannelHandler와-ChannelPipeline\" class=\"headerlink\" title=\"ChannelHandler와 ChannelPipeline\"></a>ChannelHandler와 ChannelPipeline</h4><p><img src=\"https://drek4537l1klr.cloudfront.net/maurer/Figures/03fig02.jpg\" alt=\"ChannelHandler\"></p>\n<ul>\n<li><code>ChannelHandler</code> 인터페이스<br>네티의 핵심 컴포넌트로 인바운드와 아웃바운드 데이터의 처리에 적용되는 모든 어플리케이션 논리를 처리하는 컨테이너 역할을 수행. 네트워크 이벤트에 의해 트리거되며 데이터를 변환하거나 예외처리하는 등의 모든 종류의 작업에 활용 가능하다.</li>\n</ul>\n<p><img src=\"https://drek4537l1klr.cloudfront.net/maurer/Figures/03fig03_alt.jpg\" alt=\"ChannelPipeline\"></p>\n<ul>\n<li><code>ChannelPipeline</code> 인터페이스<ul>\n<li><code>ChannelPipeline</code>은 <code>ChannelHandler</code> 체인을 위한 컨테이너를 제공.</li>\n<li>체인에서 인바운드/아웃바운드 이벤트를 전파하는 API를 정의한다.</li>\n<li><code>ChannelHandler</code>는 아래와 같은 과정으로 <code>ChannelPipeline</code>에 설치<ul>\n<li><code>ChannelInitializer</code> 구현은 ServerBootstrap에 등록</li>\n<li><code>ChannelInitializer.initChannel()</code>을 호출하면 ChannelInitializer가 ChannelHandler의 커스텀 집합을 파이프라인에 설치</li>\n<li><code>ChannelInitializer</code>는 <code>ChannelPipeline</code>에서 자신을 제거</li>\n</ul>\n</li>\n<li>파이프라인을 통해 이벤트를 전달하는 역할은 <code>ChannelHandler</code>가 담당하며, 핸들러 객체는 이벤트를 수신하고 로직을 실행하며 체인상의 다음 핸들러로 데이터를 전달한다.</li>\n<li>위 이미지에서 볼수 있듯이 인바운드/아웃바운드 핸들러는 같은 파이프라인에 설치가 가능하며 메세지/이벤트를 읽을 떄는 파이프라인 앞쪽에서 시작하며 체인상의 다음 ChannelInboundHandler로 데이터를 전달한다. 최종적으로 데이터가 파이프라인 뒤쪽에 이르면 모든 처리가 종료된다.</li>\n<li>아웃바운드도 개념은 동일하며, 체인상에서 뒤쪽에서 시작하여 앞쪽에 이를 때까지 이동한다. Socket으로 나오는 부분에 도달하면 쓰기 작업이 트리거된다.</li>\n<li>인바운드/아웃바운드 모두 ChannelHandler를 확장하지만, ChannelInboundHandler와 ChannelOutboundHandler의 구현을 구분하여 데이터 전달이 동일한 방향으로 수행되도록 보장한다.</li>\n<li>ChannelHandler를 하나 추가할 때 ChannelHandler와 ChannelPipeline의 바인딩을 나타내는 ChannelHandlerContext 하나가 할당된다. </li>\n<li>네티에서는 메세지를 보내는 데 Channel에 직접할 기록하는 방법과 ChannelHandler와 연결된 ChannelHandlerContext 객체에 기록하는 두 가지 방법이 존재한다. 전자는 ChannelPipeline 뒤쪽에서 시작되며, 후자의 방법은 메세지가 ChannelPipeline의 다음 핸들러에서 시작된다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ChannelHandler에-대한-고찰\"><a href=\"#ChannelHandler에-대한-고찰\" class=\"headerlink\" title=\"ChannelHandler에 대한 고찰\"></a>ChannelHandler에 대한 고찰</h4><ul>\n<li>네티는 비즈니스 로직을 쉽게 개발할 수 있도록 어댑터 클래스의 형태로 여러 기본 핸들러를 제공</li>\n<li>파이프라인의 각 핸들러는 체인의 다음 핸들러로 전달해야 하는데, 어댑터 클래스는 이 작업을 자동으로 해주고 특수한 동작이 필요한 메서드와 이벤트만 재정의할 수 있다.</li>\n<li>가장 자주 사용할 어댑터는 아래와 같다<ul>\n<li><code>ChannelHandlerAdapter</code></li>\n<li><code>ChannelInboundHandlerAdapter</code></li>\n<li><code>ChannelOutboundHandlerAdapter</code></li>\n<li><code>ChannelDuplexHandlerAdapter</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"인코더-디코더\"><a href=\"#인코더-디코더\" class=\"headerlink\" title=\"인코더/디코더\"></a>인코더/디코더</h4><ul>\n<li>메세지를 전송/수신할 때는 데이터를 변환해야 한다. 인바운드 메세지를 바이트에서 다른 포맷(보통 객체)로 변환하는 <code>디코딩</code> 과정을 거친다. 아웃바운드 메세지를 반대로 현재 포맷에서 바이트로 <code>인코딩</code> 되는 과정을 거친다. </li>\n<li>두 가지 변환 과정이 필요한 이유는 네트워크 데이터는 연속된 바이트여야하기 때문이다.</li>\n<li>네티가 제공하는 인코더/디코더 어댑터 클래스는 ChannelInboundHandler와 ChannelOutboundHandler를 구현한다.<ul>\n<li>인바운드 데이터의 경우 인바운드 Channel에서 읽는 각 메세지에 대해 호출되는 channelRead 메세지/이벤트를 재정의한다. 이 메서드는 제공된 디코더의 decode() 메서드를 호출한 후 디코딩된 바이트를 파이프라인 다음 ChannelInboundHandler에 전달한다. </li>\n<li>아웃바운드 메세지를 위한 패턴은 반대이며 인코더가 메세지를 바이트로 변환한 후 다음 ChannelOutboundHandler로 전달한다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"SimpleChannelInboundHandler-추상-클래스\"><a href=\"#SimpleChannelInboundHandler-추상-클래스\" class=\"headerlink\" title=\"SimpleChannelInboundHandler 추상 클래스\"></a>SimpleChannelInboundHandler 추상 클래스</h4><ul>\n<li>어플리케이션에서 들어오는 디코딩된 메세지를 수신하고 데이터에 비즈니스 논리를 적용하는 핸들러를 많이 사용하게 되는데 이러한 핸들러를 만들때 <code>SimpleChannelInboundHandler&lt;T&gt;</code>를 확장하면 되며, T는 처리하는 메세지의 제네릭 타입이다. 하나 이상의 메소드를 오버라이드하고 모든 핸들러 매서드에 인자로 전달되는 ChannelHandlerContext에 대한 참조를 얻는다.</li>\n<li>이 메소드에서 가장 중요한 메소드는 <code>channelRead0(ChannelHandlerContext T)</code>인데, 원하는대로 구현을 가능하지만 현재 입출력 스레드를 블로킹하지 않아야 한다는 요건이 있다.</li>\n</ul>\n<h3 id=\"부트스트랩\"><a href=\"#부트스트랩\" class=\"headerlink\" title=\"부트스트랩\"></a>부트스트랩</h3><ul>\n<li>네티의 부트스트랩 클래스는 프로세스를 지정 포트에 바인딩(서버 부트스트랩)하거나 프로세스를 지정된 호스트의 지정된 포트에서 실행 중인 다른 호스트로 연결(클라이언트 부트스트랩)하는 등의 일을 하는 네트워크 레이어를 구성하는 컨테이너를 제공한다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>범주</th>\n<th align=\"left\">Bootstrap</th>\n<th align=\"center\">ServerBootstrap</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>네트워크 기능</td>\n<td align=\"left\">원격 호스트/포트와 연결</td>\n<td align=\"center\">로컬 포트로 바인딩</td>\n</tr>\n<tr>\n<td>EventLoopGroup</td>\n<td align=\"left\">1</td>\n<td align=\"center\">2</td>\n</tr>\n</tbody></table>\n<ul>\n<li>Bootstrap과 ServerBootstrap은 각기 EventLoopGroup의 수가 다른걸 볼 수 있다. </li>\n</ul>\n<p><img src=\"https://drek4537l1klr.cloudfront.net/maurer/Figures/03fig04_alt.jpg\" alt=\"ServerBootstrap_EventLoopGroup\"></p>\n<ul>\n<li>서버의 경우, 첫 번째 집합은 로컬 포트와 바인됭 서버 자체의 수신 소켓을 나타내는 ServerChannel 하나를 포함하고 두 번째 집합은 서버가 수락한 연결마다 하나씩 들어오는 클라이언트 연결을 처리하기 위해 생성된 모든 Channel을 포함한다.</li>\n<li>ServerChannel과 연결된 EventLoopGroup은 들어오는 연결 요청에 대해 Channel을 생성하는 역할을 EventLoop 하나에 할당한다. 연결이 수락되면 두 번째 EventLoopGroup이 해당 Channel에 EventLoop를 할당한다.</li>\n</ul>\n<h2 id=\"4장-전송\"><a href=\"#4장-전송\" class=\"headerlink\" title=\"4장 전송\"></a>4장 전송</h2><ul>\n<li>네티는 모든 전송 구현에 공통 API를 기반으로 사용하기 때문에 JDK를 직접 이용할 떄보다 변환이 훨씬 간단하다.<ul>\n<li>코드가 세부 구현 사항으로 오염될 우려가 적고, 광범위한 범위를 수정할 필요가 없어진다.</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Netty-In-Action\"><a href=\"#Netty-In-Action\" class=\"headerlink\" title=\"Netty-In-Action\"></a>Netty-In-Action</h1><h1 id=\"1부-네티-개념과-아키텍처\"><a href=\"#1부-네티-개념과-아키텍처\" class=\"headerlink\" title=\"1부, 네티 개념과 아키텍처\"></a>1부, 네티 개념과 아키텍처</h1><h2 id=\"1장-네티-비동기-이벤트-기반-네트워킹-프레임워크\"><a href=\"#1장-네티-비동기-이벤트-기반-네트워킹-프레임워크\" class=\"headerlink\" title=\"1장. 네티: 비동기 이벤트 기반 네트워킹 프레임워크\"></a>1장. 네티: 비동기 이벤트 기반 네트워킹 프레임워크</h2><ul>\n<li>최초 자바 API(java.net)은 네이티브 시스템 소켓 라이브러리가 제공하는 블로킹 함수만 제공<ul>\n<li>다수의 클라이언트를 관리하려면 새로운 클라이언트 소켓마다 새로운 스레드를 할당해야 함.</li>\n<li>여러 스레드가 입출력 데이터를 무한정 대기하는 상태가 유지될 수 있고, 이는 곧 리소스에 대한 낭비로 이어질 수 있음.</li>\n<li>운영체제에 따라 다르지만 스텍의 기본 크기는 64KB ~ 1MB까지 차지할 수 있다. JVM이 많은 수의 스레드 생성을 지원하지만, 동시 접속이 한계에 이르는 순간(1만개 전후) 컨텍스트 스위칭에 따른 오버헤드가 심각한 문제가 될수 있다.</li>\n</ul>\n</li>\n<li>네이티브 소켓 라이브러리에는 오래전부터 네트워크 리소스 사용률을 세부적으로 제어할수 있는 논블로킹(non-blocking) 호출이 포함되어 있다.<ul>\n<li>setsockopt() 시스템 함수를 통한 블로킹 콜에 대한 옵션 설정 가능</li>\n<li>이벤트 통지 API(epoll/kqueue)를 통하여 논블로킹 소켓의 집합을 등록하면 읽거나 기록할 데이터가 준비됐는지 여부를 알수 있다. <a href=\"https://long-zhou.github.io/2012/12/21/epoll-vs-kqueue.html\">참고</a></li>\n<li>논블로킹 입출력을 위한 자바의 기능 지원은 1.4부터 java.nio 패키지를 통하여 이뤄졌다.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://drek4537l1klr.cloudfront.net/maurer/Figures/01fig02.jpg\" alt=\"java.nio.channels.Selector\"></p>\n<ul>\n<li><p>자바의 논블로킹 설계의 핵심은 바로 <code>java.nio.channels.Selector</code> 클래스이다. 시스템의 이벤트 통지 API를 그대로 사용하며 언제나 읽기/쓰기 작업의 완료 상태를 확인할 수 있으므로 단일 스레드로 여러 동시 연결을 처리할 수 있다.</p>\n<ul>\n<li>적은 수의 스레드로 더 많은 연결을 처리할 수 있으므로 컨텍스트 스위칭에 따른 오버헤드와 메모리 관리가 원활해짐</li>\n<li>스레드의 상태가 점유가 되어 있지 않기 때문에, 입출력 외에 다른 작업을 사용할 수 있음.</li>\n</ul>\n</li>\n<li><p>네티는 네트워킹 도메인에서 가장 유명한 자바 프레임워크로 기반 구현의 복잡성을 단순한 추상화로 감춰 개발자가 어플리케이션 구현 영역에 집중할 수 있도록 도와준다.</p>\n<ul>\n<li>블로킹/논블로킹 방식의 모두 지원</li>\n<li>코어 자바 API보다 높은 처리량과 짧은 지연 시간. 풀링/재사용을 통한 리소스 소비 감소, 메모리 복사 최소화</li>\n</ul>\n</li>\n<li><p>이벤트 기반의 비동기식으로 어플리케이션을 작성할때는 특수한 문제에 대한 고려가 필요. </p>\n<ul>\n<li>발생하는 이벤트에 대해 언제든지/순서에 상관없이 응답을 할 수 있음, 이는 곧, <code>증가하는 처리량에 맞게 시스템/네트워크/프로세스의 능력을 작업량 증가에 맞게 늘리는 능력</code>으로 정의할 수 있는 최고 수준의 확장성을 갖추는데 필수적임.</li>\n<li>논블로킹 네트워크 연결은 작업 완료를 기다릴 필요가 없다. 비동기 코드는 바로 반환을 하며 완료가 되면 추후에 이를 통지하는 방식이다.</li>\n<li>셀렉터는 적은 수의 스레드로 여러 연결에서 이벤트를 모니터링 할 수 있게 해줌</li>\n</ul>\n</li>\n<li><p>네티의 핵심 컴포넌트</p>\n<ul>\n<li>Channel<br>하나 이상의 입출력 작업(읽기/쓰기)을 수행할수 있는 하드웨어 장치/파일/네트워크 소켓/프로그램 컴포넌트와 같은 엔티티에 대한 열린 연결, 들어오는 Inbound와 나가는 Outbound를 위한 운송수단으로 생각하자</li>\n<li>Callback<br>콜백은 관심 대상에게 작업 완료를 알리는 가장 일반적인 방법으로 네티는 이벤트를 처리할 때 내부적으로 콜백을 이용한다. 콜백 트리거가 되면 ChannelHandler 인터페이스 구현을 통해 이벤트를 처리할수 있다.</li>\n<li>Future<br>퓨처는 작업이 완료되면 어플리케이션에 이를 알리는 방법이다. 비동기 작업의 결과를 접근할 수 있게 해준다. JDK에서는 java.<code>util.concurrent.Future</code> 인터페이스를 제공하지만, 해당 구현은 <code>작업 완료 여부 확인</code>과 <code>완료전까지 블록킹</code>하는 기능만 존재한다. 네티는 이를 개선한 <code>ChannelFuture</code>를 사용한다. ChannelFuture에는 ChannelFutureListener 인스턴스를 하나 이상 등록할 수 있으며 완료시점에 operationComplete() 콜백 메소드가 호출이 된다. 해당 콜백 실행 시점에 완료/오류 등을 확인 가능하다.<br>네티의 모든 아웃바운드 입출력은 ChannelFuture를 반환하고 진행에 블로킹 작업은 없다. 모든것은 비동기에 이벤트 기반이다.</li>\n</ul>\n</li>\n<li><p>이벤트와 핸들러<br>네티는 작업 상태 변화를 알리기 위해 고유한 이벤트를 사용한다. <code>로깅</code>, <code>데이터 변환</code>, <code>흐름 제어</code>, <code>어플리케이션 논리</code> 등의 동작을 포함한다. 이벤트들은 크게 <code>인바운드</code>와 <code>아웃바운드</code> 데이터 흐름의 연관성을 기준으로 분류한다.<br>모든 이벤트는 핸들러 클래스의 사용자 구현 메서드로 전달할 수 있다. <strong>다시 말해, 각 핸들러 인스턴스는 특정 이벤트에 반응하여 실행하는 일종의 콜백이라고 이해하면 된다.</strong></p>\n<blockquote>\n<ul>\n<li>인바운드: 연결 활성화/비활성화, 데이터 읽기, 사용자 이벤트, 오류 이벤트</li>\n<li>아웃바운드: 원격 피어 연결 열기/닫기, 소켓에 데이터 쓰기/플러시</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"2장-첫-번째-네티-어플리케이션\"><a href=\"#2장-첫-번째-네티-어플리케이션\" class=\"headerlink\" title=\"2장. 첫 번째 네티 어플리케이션\"></a>2장. 첫 번째 네티 어플리케이션</h2><ul>\n<li>책의 경우 maven 기준으로 설명을 하고 있지만, 예제는 gradle 기반의 프로젝트에서 작성했으며, <code>4.1.65.Final</code> 버젼을 기준으로 실습 편의성을 위해 <code>netty-all</code> 디펜던시를 참조했다.<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  implementation &#x27;io.netty:netty-all:4.1.65.Final&#x27;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"EchoServer-코드-작성\"><a href=\"#EchoServer-코드-작성\" class=\"headerlink\" title=\"EchoServer 코드 작성\"></a>EchoServer 코드 작성</h4><ul>\n<li>아래 <code>EchoServer</code> 및 <code>EchoServerHandler</code> 코드 작성 후 기동</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoServer</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EchoServer</span><span class=\"params\">(<span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.port = port;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (args.length &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\tSystem.err.println(<span class=\"string\">&quot;Usage: &quot;</span> + EchoServer.class.getSimpleName() + <span class=\"string\">&quot;&lt;port&gt;&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> port = Integer.parseInt(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> EchoServer(port).start();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> EchoServerHandler echoServerHandler = <span class=\"keyword\">new</span> EchoServerHandler();</span><br><span class=\"line\">\t\tEventLoopGroup group = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tServerBootstrap b = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\">\t\t\tb.group(group)</span><br><span class=\"line\">\t\t\t\t.channel(NioServerSocketChannel.class)</span><br><span class=\"line\">\t\t\t\t.localAddress(<span class=\"keyword\">new</span> InetSocketAddress(port))</span><br><span class=\"line\">\t\t\t\t.childHandler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\tSystem.out.println(<span class=\"string\">&quot;initChannel&quot;</span>);</span><br><span class=\"line\">\t\t\t\t\t\tch.pipeline().addLast(echoServerHandler);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\tChannelFuture future = b.bind().sync();</span><br><span class=\"line\">\t\t\tfuture.channel().closeFuture().sync();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\tgroup.shutdownGracefully().sync();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>부트스트랩 하는 코드를 포함하고 있으며, 서버 연결 요청을 수신하는 포트를 서버와 바인딩하는 코드가 있어야 한다.</li>\n<li>NioEventLoopGroup을 통하여 새로운 연결 수락 및 데이터 읽기/쓰기와 같은 이벤트를 처리</li>\n<li>서버가 바인딩하는 InetSocketAddress를 지정</li>\n<li>새로운 연결을 수락하고 Channel을 생성 후 ChannelInitializer를 통하여 EchoServerHandler 인스턴스를 Channel의 ChannelPipeline으로 추가한다.</li>\n<li>ServerBootstrap.bind() 호출하여 서버를 바인딩</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Sharable</span> <span class=\"comment\">// 여러 Channel에서 공유할 수 있음을 나타나는 마커 인터페이스 </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoServerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> ByteBuf in = (ByteBuf) msg;</span><br><span class=\"line\">\tSystem.out.println(</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;Server received: &quot;</span> + in.toString(CharsetUtil.UTF_8)</span><br><span class=\"line\">\t);</span><br><span class=\"line\">\tctx.write(in);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelReadComplete</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\tctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class=\"line\">\t\t.addListener(ChannelFutureListener.CLOSE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx, Throwable cause)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\tcause.printStackTrace();</span><br><span class=\"line\">\tctx.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>telnet을 통하여 Echo 메세지가 다시 telnet 클라이언트로 다시 전달이 되는지 확인하면 서버 코드 작성은 완료<br><img src=\"https://i.imgur.com/jvDaSSu.png\" alt=\"텔넷테스트\"></li>\n<li>서버에 들어오는 이벤트에 반응해야 하기 때문에 <code>ChannelInboundHandler</code> 구현체인 <code>ChannelInboundHandlerAdapter</code> 하위 클래스를 만들었고, 여기에 몇개 메소드를 오버라이드하여 메세지를 처리하도록 했다.<ul>\n<li><code>channelRead</code>: 메세지가 들어올때마다 호출</li>\n<li><code>channelReadComplete</code>: channelRead()의 마지막 호출에서 현재 일괄 처리의 마지막 메세지를 처리했음을 핸들러에 통보</li>\n<li><code>exceptionCaught</code>: 읽기 처리 중 예외가 발생하면 콜백됨, 예외 처리를 하지 않을 경우 ChannelPipeline의 마지막까지 이동 후 로깅이 되며, 가급적이면 하나 이상의 exceptionCaught를 구현하는 것이 바람직하다고 한다.</li>\n</ul>\n</li>\n<li>ChannelHandler는 네 가지 이벤트 유형을 제공하며, 어플리케이션은 ChannelHandler을 구현하거나 확장하여 이벤트를 후크하고 어플리케이션 로직을 제공해야 한다. ChannelHandler는 비즈니스 관심사에서 네트워크 관심사를 분리하는 것을 도와준다.</li>\n</ul>\n<h4 id=\"EchoClient-코드-작성\"><a href=\"#EchoClient-코드-작성\" class=\"headerlink\" title=\"EchoClient 코드 작성\"></a>EchoClient 코드 작성</h4><ul>\n<li>어플리케이션에서 필요한 <code>EchoClient</code>, <code>EchoClientHandler</code> 핸들러 코드는 아래와 같다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Sharable</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoClientHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleChannelInboundHandler</span>&lt;<span class=\"title\">ByteBuf</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ctx.writeAndFlush(</span><br><span class=\"line\">\t\tUnpooled.copiedBuffer(<span class=\"string\">&quot;Netty rocks!&quot;</span>, CharsetUtil.UTF_8)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(</span><br><span class=\"line\">                <span class=\"string\">&quot;Client received: &quot;</span> + msg.toString(CharsetUtil.UTF_8)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">exceptionCaught</span><span class=\"params\">(ChannelHandlerContext ctx, Throwable cause)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        cause.printStackTrace();</span><br><span class=\"line\">        ctx.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.imgur.com/VrnfrIE.png\" alt=\"ChannelHandler_Hierachy\"></p>\n<ul>\n<li>서버와 마찬가지로 EchoClientHandler는 <code>ChannelInboundHandler</code> 인터페이스의 구현체인 <code>SimpleChannelInboundHandler</code>의 메소드를 오버라이드하여 필요한 작업을 처리한다.<ul>\n<li><code>channelActive()</code>: 서버 연결 후 콜백</li>\n<li><code>channelRead0()</code>: 서버에서 메세지 수신 후 콜백</li>\n<li><code>exceptionCaught()</code>: 처리 중 예외 시 콜백</li>\n</ul>\n</li>\n<li><code>channelRead0()</code>에서 주의할 점은 전체 바이트 데이터 수신를 한 번에 수신한다는 보장이 없다. 경우에 따라 <code>channelRead0()</code> 메소드가 여러번 호출될 수 있다. 대신, TCP는 스트림 기반 프로토콜이므로 서버에서 보낸 순서대로 바이트 수신을 보장한다.<blockquote>\n<p>예시) AB|CDE|FG, ABC|DE|FG, AB|CD|EFG 와 같은 형태로 바이트를 수신할 수도 있다는 이야기이다.</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EchoClient</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String host;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EchoClient</span><span class=\"params\">(String host, <span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.port = port;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.host = host;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        EventLoopGroup group = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Bootstrap b = <span class=\"keyword\">new</span> Bootstrap();</span><br><span class=\"line\">            b.group(group)</span><br><span class=\"line\">                    .channel(NioSocketChannel.class)</span><br><span class=\"line\">                    .remoteAddress(<span class=\"keyword\">new</span> InetSocketAddress(host, port))</span><br><span class=\"line\">                    .handler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                            ch.pipeline()</span><br><span class=\"line\">\t\t\t\t    \t.addLast(<span class=\"keyword\">new</span> EchoClientHandler());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">            ChannelFuture f = b.connect().sync();</span><br><span class=\"line\">            f.channel().closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            group.shutdownGracefully().sync();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.err.println(</span><br><span class=\"line\">                    <span class=\"string\">&quot;Usage: &quot;</span> + EchoClient.class.getSimpleName() + <span class=\"string\">&quot;&lt;host&gt; &lt;port&gt;&quot;</span></span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String host = args[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> port = Integer.parseInt(args[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">new</span> EchoClient(host, port).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3장-네티-컴포넌트와-설계\"><a href=\"#3장-네티-컴포넌트와-설계\" class=\"headerlink\" title=\"3장. 네티 컴포넌트와 설계\"></a>3장. 네티 컴포넌트와 설계</h2><h3 id=\"Channel-EventLoop-ChannelFuture\"><a href=\"#Channel-EventLoop-ChannelFuture\" class=\"headerlink\" title=\"Channel, EventLoop, ChannelFuture\"></a>Channel, EventLoop, ChannelFuture</h3><ul>\n<li>Channel: Socket</li>\n<li>EventLoop: 제어 흐름, 멀티스레딩, 동시성 제어</li>\n<li>ChannelFuture: 비동기 결과 알림</li>\n</ul>\n<h4 id=\"Channel-인터페이스\"><a href=\"#Channel-인터페이스\" class=\"headerlink\" title=\"Channel 인터페이스\"></a>Channel 인터페이스</h4><p><img src=\"https://i.imgur.com/Ovv6kg2.png\" alt=\"Channel_Hierachy\"></p>\n<blockquote>\n<p>실제 구현 클래스와 인터페이스 종류는 더 다양하다.</p>\n</blockquote>\n<ul>\n<li><code>Channel</code> 인터페이스는 Socket으로 직접 작업할 때의 복잡성을 크게 완화하는 API를 제공</li>\n</ul>\n<h4 id=\"EventLoop-인터페이스\"><a href=\"#EventLoop-인터페이스\" class=\"headerlink\" title=\"EventLoop 인터페이스\"></a>EventLoop 인터페이스</h4><p><img src=\"https://i.imgur.com/rF7huZs.png\" alt=\"EventLoop\"></p>\n<ul>\n<li>연결 수명주기 중 발생하는 이벤트를 처리하는 핵심 추상화 인터페이스</li>\n</ul>\n<p><img src=\"https://drek4537l1klr.cloudfront.net/maurer/Figures/03fig01.jpg\" alt=\"EventLoop\"></p>\n<blockquote>\n<p>출처: Netty-In-Action</p>\n</blockquote>\n<ul>\n<li><code>Channel</code> - <code>EventLoop</code> - <code>Thread</code> - <code>EventLoopGroup</code> 사이에서의 상호작용은 아래와 같다<ul>\n<li>한 <code>EventLoopGroup</code>은 하나 이상의 EventLoop를 포함</li>\n<li>한 <code>EventLoop</code>는 수명주기 동안 하나의 스레드에 바인딩</li>\n<li>한 <code>EventLoop</code>에서 처리되는 모든 입출력은 전용 스레드에서 처리</li>\n<li>한 <code>Channel</code>은 수명주기 동안 EventLoop에 등록</li>\n<li>한 <code>EventLoop</code>는 하나 이상의 Channel로 할당 가능</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ChannelHandler와-ChannelPipeline\"><a href=\"#ChannelHandler와-ChannelPipeline\" class=\"headerlink\" title=\"ChannelHandler와 ChannelPipeline\"></a>ChannelHandler와 ChannelPipeline</h4><p><img src=\"https://drek4537l1klr.cloudfront.net/maurer/Figures/03fig02.jpg\" alt=\"ChannelHandler\"></p>\n<ul>\n<li><code>ChannelHandler</code> 인터페이스<br>네티의 핵심 컴포넌트로 인바운드와 아웃바운드 데이터의 처리에 적용되는 모든 어플리케이션 논리를 처리하는 컨테이너 역할을 수행. 네트워크 이벤트에 의해 트리거되며 데이터를 변환하거나 예외처리하는 등의 모든 종류의 작업에 활용 가능하다.</li>\n</ul>\n<p><img src=\"https://drek4537l1klr.cloudfront.net/maurer/Figures/03fig03_alt.jpg\" alt=\"ChannelPipeline\"></p>\n<ul>\n<li><code>ChannelPipeline</code> 인터페이스<ul>\n<li><code>ChannelPipeline</code>은 <code>ChannelHandler</code> 체인을 위한 컨테이너를 제공.</li>\n<li>체인에서 인바운드/아웃바운드 이벤트를 전파하는 API를 정의한다.</li>\n<li><code>ChannelHandler</code>는 아래와 같은 과정으로 <code>ChannelPipeline</code>에 설치<ul>\n<li><code>ChannelInitializer</code> 구현은 ServerBootstrap에 등록</li>\n<li><code>ChannelInitializer.initChannel()</code>을 호출하면 ChannelInitializer가 ChannelHandler의 커스텀 집합을 파이프라인에 설치</li>\n<li><code>ChannelInitializer</code>는 <code>ChannelPipeline</code>에서 자신을 제거</li>\n</ul>\n</li>\n<li>파이프라인을 통해 이벤트를 전달하는 역할은 <code>ChannelHandler</code>가 담당하며, 핸들러 객체는 이벤트를 수신하고 로직을 실행하며 체인상의 다음 핸들러로 데이터를 전달한다.</li>\n<li>위 이미지에서 볼수 있듯이 인바운드/아웃바운드 핸들러는 같은 파이프라인에 설치가 가능하며 메세지/이벤트를 읽을 떄는 파이프라인 앞쪽에서 시작하며 체인상의 다음 ChannelInboundHandler로 데이터를 전달한다. 최종적으로 데이터가 파이프라인 뒤쪽에 이르면 모든 처리가 종료된다.</li>\n<li>아웃바운드도 개념은 동일하며, 체인상에서 뒤쪽에서 시작하여 앞쪽에 이를 때까지 이동한다. Socket으로 나오는 부분에 도달하면 쓰기 작업이 트리거된다.</li>\n<li>인바운드/아웃바운드 모두 ChannelHandler를 확장하지만, ChannelInboundHandler와 ChannelOutboundHandler의 구현을 구분하여 데이터 전달이 동일한 방향으로 수행되도록 보장한다.</li>\n<li>ChannelHandler를 하나 추가할 때 ChannelHandler와 ChannelPipeline의 바인딩을 나타내는 ChannelHandlerContext 하나가 할당된다. </li>\n<li>네티에서는 메세지를 보내는 데 Channel에 직접할 기록하는 방법과 ChannelHandler와 연결된 ChannelHandlerContext 객체에 기록하는 두 가지 방법이 존재한다. 전자는 ChannelPipeline 뒤쪽에서 시작되며, 후자의 방법은 메세지가 ChannelPipeline의 다음 핸들러에서 시작된다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ChannelHandler에-대한-고찰\"><a href=\"#ChannelHandler에-대한-고찰\" class=\"headerlink\" title=\"ChannelHandler에 대한 고찰\"></a>ChannelHandler에 대한 고찰</h4><ul>\n<li>네티는 비즈니스 로직을 쉽게 개발할 수 있도록 어댑터 클래스의 형태로 여러 기본 핸들러를 제공</li>\n<li>파이프라인의 각 핸들러는 체인의 다음 핸들러로 전달해야 하는데, 어댑터 클래스는 이 작업을 자동으로 해주고 특수한 동작이 필요한 메서드와 이벤트만 재정의할 수 있다.</li>\n<li>가장 자주 사용할 어댑터는 아래와 같다<ul>\n<li><code>ChannelHandlerAdapter</code></li>\n<li><code>ChannelInboundHandlerAdapter</code></li>\n<li><code>ChannelOutboundHandlerAdapter</code></li>\n<li><code>ChannelDuplexHandlerAdapter</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"인코더-디코더\"><a href=\"#인코더-디코더\" class=\"headerlink\" title=\"인코더/디코더\"></a>인코더/디코더</h4><ul>\n<li>메세지를 전송/수신할 때는 데이터를 변환해야 한다. 인바운드 메세지를 바이트에서 다른 포맷(보통 객체)로 변환하는 <code>디코딩</code> 과정을 거친다. 아웃바운드 메세지를 반대로 현재 포맷에서 바이트로 <code>인코딩</code> 되는 과정을 거친다. </li>\n<li>두 가지 변환 과정이 필요한 이유는 네트워크 데이터는 연속된 바이트여야하기 때문이다.</li>\n<li>네티가 제공하는 인코더/디코더 어댑터 클래스는 ChannelInboundHandler와 ChannelOutboundHandler를 구현한다.<ul>\n<li>인바운드 데이터의 경우 인바운드 Channel에서 읽는 각 메세지에 대해 호출되는 channelRead 메세지/이벤트를 재정의한다. 이 메서드는 제공된 디코더의 decode() 메서드를 호출한 후 디코딩된 바이트를 파이프라인 다음 ChannelInboundHandler에 전달한다. </li>\n<li>아웃바운드 메세지를 위한 패턴은 반대이며 인코더가 메세지를 바이트로 변환한 후 다음 ChannelOutboundHandler로 전달한다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"SimpleChannelInboundHandler-추상-클래스\"><a href=\"#SimpleChannelInboundHandler-추상-클래스\" class=\"headerlink\" title=\"SimpleChannelInboundHandler 추상 클래스\"></a>SimpleChannelInboundHandler 추상 클래스</h4><ul>\n<li>어플리케이션에서 들어오는 디코딩된 메세지를 수신하고 데이터에 비즈니스 논리를 적용하는 핸들러를 많이 사용하게 되는데 이러한 핸들러를 만들때 <code>SimpleChannelInboundHandler&lt;T&gt;</code>를 확장하면 되며, T는 처리하는 메세지의 제네릭 타입이다. 하나 이상의 메소드를 오버라이드하고 모든 핸들러 매서드에 인자로 전달되는 ChannelHandlerContext에 대한 참조를 얻는다.</li>\n<li>이 메소드에서 가장 중요한 메소드는 <code>channelRead0(ChannelHandlerContext T)</code>인데, 원하는대로 구현을 가능하지만 현재 입출력 스레드를 블로킹하지 않아야 한다는 요건이 있다.</li>\n</ul>\n<h3 id=\"부트스트랩\"><a href=\"#부트스트랩\" class=\"headerlink\" title=\"부트스트랩\"></a>부트스트랩</h3><ul>\n<li>네티의 부트스트랩 클래스는 프로세스를 지정 포트에 바인딩(서버 부트스트랩)하거나 프로세스를 지정된 호스트의 지정된 포트에서 실행 중인 다른 호스트로 연결(클라이언트 부트스트랩)하는 등의 일을 하는 네트워크 레이어를 구성하는 컨테이너를 제공한다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>범주</th>\n<th align=\"left\">Bootstrap</th>\n<th align=\"center\">ServerBootstrap</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>네트워크 기능</td>\n<td align=\"left\">원격 호스트/포트와 연결</td>\n<td align=\"center\">로컬 포트로 바인딩</td>\n</tr>\n<tr>\n<td>EventLoopGroup</td>\n<td align=\"left\">1</td>\n<td align=\"center\">2</td>\n</tr>\n</tbody></table>\n<ul>\n<li>Bootstrap과 ServerBootstrap은 각기 EventLoopGroup의 수가 다른걸 볼 수 있다. </li>\n</ul>\n<p><img src=\"https://drek4537l1klr.cloudfront.net/maurer/Figures/03fig04_alt.jpg\" alt=\"ServerBootstrap_EventLoopGroup\"></p>\n<ul>\n<li>서버의 경우, 첫 번째 집합은 로컬 포트와 바인됭 서버 자체의 수신 소켓을 나타내는 ServerChannel 하나를 포함하고 두 번째 집합은 서버가 수락한 연결마다 하나씩 들어오는 클라이언트 연결을 처리하기 위해 생성된 모든 Channel을 포함한다.</li>\n<li>ServerChannel과 연결된 EventLoopGroup은 들어오는 연결 요청에 대해 Channel을 생성하는 역할을 EventLoop 하나에 할당한다. 연결이 수락되면 두 번째 EventLoopGroup이 해당 Channel에 EventLoop를 할당한다.</li>\n</ul>\n<h2 id=\"4장-전송\"><a href=\"#4장-전송\" class=\"headerlink\" title=\"4장 전송\"></a>4장 전송</h2><ul>\n<li>네티는 모든 전송 구현에 공통 API를 기반으로 사용하기 때문에 JDK를 직접 이용할 떄보다 변환이 훨씬 간단하다.<ul>\n<li>코드가 세부 구현 사항으로 오염될 우려가 적고, 광범위한 범위를 수정할 필요가 없어진다.</li>\n</ul>\n</li>\n</ul>\n"},{"title":"How to make sense of Kotlin coroutines","date":"2019-03-02T11:13:00.000Z","_content":"\n# How to make sense of Kotlin coroutines\n\n> 본 글은 [How to make sense of Kotlin coroutines](https://proandroiddev.com/how-to-make-sense-of-kotlin-coroutines-b666c7151b93)을 읽고 발번역(?)한 내용입니다. 영어에 유창한 분들은 링크를 참고해주세요.\n\n코루틴은 완벽하게 읽고 유지 보수가 가능한 비동기 코드를 작성하는 좋은 방법이다. Kotlin은 단일 언어 구문으로 비동기 프로그래밍의 기본 요소를 제공하는데, 바로 `suspend` 키워드이다. 이 키워드와 함께 라이브러리 함수가 빛을 발합니다.\n\n## What is a coroutine?\nKotlin팀은 `Coroutine`을 `경량 스레드: Light-Weighted-Thread`로 정의했습니다. **그것들은 실제 스레드가 실행 할 수 있는 일종의 작업입니다.** [Kotlinlang.org](https://kotlinlang.org/)의 배너는 다음과 같습니다.\n\n![](https://cdn-images-1.medium.com/max/1600/1*OEX52nKgM1SHGO4l1mvV1A.gif)\n\n가장 흥미로운 점은 스레드가 특정 \"정지 지점\"에서 코루틴 실행을 중지하고 다른 작업을 수행 할 수 있다는 것이다. 나중에 코루틴을 다시 시작하거나 다른 스레드가 처리 할 수 ​​있습니다.\n\n따라서 정확성을 높이기 위해 하나의 코 루틴은 정확하게 하나의 \"작업\"이 아니라 오히려 특정 보장 된 순서로 실행되는 \"하위 작업\"의 순서입니다. 코드가 하나의 순차 블록에 있는 것처럼 보이더라도 정지 기능에 대한 각 호출은 동시 루틴 내의 새로운 \"하위 작업\"의 시작을 제한합니다.\n\n이는 우리에게 `suspending functions`에 관련된 주제를 다시 던져준다.\n\n## Suspending functions\n당신은 어쩌면 kotlinx의 `delay` 또는 Ktor의 `HttpClient.post`와 같은 함수를 발견 했을 수도 있는데, 이 함수들은 반환되기 전에 무언가를 기다리거나 집중적으로 작업해야하며 suspend 키워드로 표시되어있을 수 있습니다.\n\n```kotlin\nsuspend fun delay(timeMillis: Long) {...}\nsuspend fun someNetworkCallReturningValue(): SomeType {\n ...\n}\n```\n우리가 위에서 본 것처럼 이를 `suspending function`이라고 합니다.\n\n> 일시 중단 함수는 현재 스레드를 차단하지 않고 현재 코루틴의 실행을 일시 중단 할 수 있습니다.\n\n다시 말해, 당신이 보고 있는 코드가 `suspending function`을 호출하는 순간에 실행을 중지 할 수 있으며 나중에 다시 시작 될 수도 있다는 이야기이다. **그러나, 그 동안 현재 쓰레드가 무엇을 할 지에 대해서는 아무 말도 하지 않는다.**\n\n그 시점에서 또 다른 coroutine을 실행하는 것으로 돌아갈 수 있으며, 나중에 우리가 남긴 coroutine을 다시 실행할 수 있습니다. 이 모든 것은 일시 중지되지 않는 함수 세계에서 일시 중지 함수를 호출하는 방법에 의해 제어되지만 함수 일시 중단에 대해 본질적으로 비동기는 없습니다.\n\n> 일시 중단 기능은 명시 적으로 사용되는 경우에만 비동기식입니다.\n\n우리는 나중에 이것을 보게 될 것이다. 그러나 지금 당장은 함수를 일시 정지하는 것으로 생각하면 잠시 시간을내어 선언하는 특수 함수로 간주 할 수 있습니다. 그리고 그들은 암시적으로 스레드의 복잡성과 파견에 대해 걱정할 필요없이 함수를 하위 작업으로 암시 적으로 분할한다는 점을 명심하십시오. 그것이 실제로 그들이 훌륭한 이유입니다. 여러분이 내부에있을 때 걱정할 필요가 없습니다.\n\n### The suspending world is nicely sequential\n아마 `suspending function`에 특별한 반환 유형이 없는 것을 알아차렸을 수 있다. Java의 `Future` 또는 JavaScript의 `Promise`과 같은 래퍼가 필요하지 않습니다. 이것은 `Promise`을 반환하는 JavaScript의 비동기 함수와 달리 일시 중단 함수가 비동기 적이라는 사실을 강조합니다.\n\n> 내부 정지 함수로부터, 함수 호출에 대해 순차적으로 추론 할 수 있습니다.\n\n이것이 바로 비동기식 소재를 Kotlin에서 쉽게 추론 할 수 있게 하는 이유이다. `suspending function` 내에서 다른 `suspending function`에 대한 호출은 일반 함수 호출과 같이 작동합니다. 우리는 반환 값을 얻고 나머지 코드를 실행하기 전에 호출 된 함수의 실행을 기다릴 필요가 있다.\n\n```kotlin\nsuspend fun someNetworkCallReturningSomething(): Something {\n    // some networking operations making use of the suspending mechanism\n}\n\nsuspend fun someBusyFunction(): Unit {\n    delay(1000L)\n    println(\"Printed after 1 second\")\n    val something: Something = someNetworkCallReturningSomething()\n    println(\"Received $something from network\")\n}\n```\n\n이것이 나중에 복잡한 비동기 코드를 간단한 방법으로 작성할 수 있게 해줍니다.\n\n### Bridging the normal world and the suspending world\n일반 함수에서 `suspending function`을 직접 호출하면 컴파일 할 수 없다. 이에 대한 일반적인 설명은 *`coroutines` 만 일시 중단 될 수 있기 때문에* 이라고 설명하고 있다. 이런 설명을 통해 우리는 `suspending function`을 수행 할 `coroutine`을 생성해야 한다는 결론을 내릴 수 있다.\n\n개념적으로 함수를 일시 중단하는 것은 선언에서 \"실행하는 데 약간의 시간이 걸릴\"수 있습니다. 자신이 일시 중지 기능이 아니라면 다음 두 가지 중 하나를 명시 적으로 수행해야합니다.\n\n- 기다리는 동안 실제로 스레드를 차단합니다 (일반적인 함수 호출과 같이).\n- 비동기로 시작하여 즉시 수행하고 (여러 가지 가능한 방법으로 수행 할 수 있음)\n\n선택을 표현하는 방법으로 코 루틴 (coroutine)을 생성하는 것을 볼 수 있습니다. 명시 적이어야합니다 (그리고 이것은 대단합니다!) 이것은 coroutine 빌더라고하는 함수를 사용하여 수행됩니다.\n\n## Coroutine builders\n`Coroutine Builder`는 주어진 `suspending function`을 실행하는 새로운 `Coroutine`을 작성하는 간단한 함수입니다. 이러한 `Coroutine Builder`는 `suspending function`이 아닌 일반 함수에서 호출될 수 있는데, 왜냐하면 이러한 빌더 함수들은 `suspending function`이 아니기 때문입니다. 마치 일반 함수와 `suspending function` 함수 세계와의 가교 역할을 수행한다고 생각하시면 편합니다.\n\n\nKotlin 표준 라이브러리에는 여러 가지 `Coroutine Builder`가 포함되어있어 다양한 작업을 수행 할 수 있습니다. 다음 하위 절에서 몇 가지를 볼 것입니다.\n\n### Block the current thread with “runBlocking”\n코틀린의 일반 함수에서 `suspending function`을 다루는 가장 간단한 방법은 현제 실행 중인 스레드를 블록하고 기다리는 방법입니다. 현재 스레드를 블록하는 `Coroutine Builder` 함수는 바로 `runBlocking`입니다. \n\n```kotlin\nfun main() { \n    println(\"Hello,\")\n    \n    // 주어진 suspending lambda function을 실행하는 코루틴을 만들 수 있으며\n    // 그리고 현재 실행중인 스레드를 해당 함수의 실행이 마무리 될떄까지 블락합니다.\n    runBlocking {\n        // coroutine 함수 내부, 함수는 2초동안 정지상태로 유지됨.\n        delay(2000L)\n    }\n    \n    // 아래 코드는 2초 뒤에 실행됨\n    println(\"World!\")\n}\n```\n\n`runBlocking`의 컨텍스트에서 주어진 `suspending function`과 호출 계층 구조에 있는 자식은 실행이 끝날 때까지 현재 스레드를 효과적으로 차단합니다. `runBlocking`에 전달 된 함수는 서명에서 알 수 있듯이 runBlocking 자체가 일시 중지되지 않고 (스레드 블로킹 인 경우에도) 일시 중단 함수입니다.\n\n![](https://i.imgur.com/i5aj0dj.png)\n\n`main()` 함수에서 일종의 최상위 코루틴을 제공하고 JVM을 활성 상태로 유지하는 데 종종 사용됩니다 (구조화 된 동시성에 대한 섹션에서 볼 수 있습니다).\n\n### Fire-and-forget with “launch”\n일반적으로 `coroutine`의 핵심은 스레드를 블록하는 것이 아니라 비동기 작업을 시작하는 것입니다. `launch`이라는 `Coroutine Builder`는 백그라운드에서 `coroutine`을 시작하고 그동안 계속 작업 할 수 있게 합니다.\n\nKotlin 문서를 통해 아래와 같은 예제를 확인 할 수 있다.\n\n```kotlin\nfun main() { \n    GlobalScope.launch { // 새로운 코루틴을 백그라운드에서 실행하고 이후 단계를 진행한다.\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\") // main thread continues here immediately    \n    runBlocking {     // 그러나 이 표현식은 현제 실행중인 스레드를 블락한다.\n        delay(2000L)  // 우리가 2초 가량 대기하는 동안에도 JVM은 살이 있는 상태를 유지한다.        \n    } \n}\n```\n\n의견은 스스로에 대해 말해야합니다. 그러면 \"Hello\"가 즉시 인쇄되고 두 번째 후에 \"World!\"가 추가됩니다. 이 예제의 목적을 위해라도 어찌되었던간에 메인 함수를 블록해야 `launch`에서 무슨 일이 발생하는지 확인 할 수 있습니다. 그래서 JVM을 계속 유지하기 위해 `runBlocking`을 여기에서 다시 사용하고 있습니다.\n\n### Get a result asynchronously with “async”\n다음은 값을 반환하는 비동기 작업을 수행 할 수 있는 `async`라는 또 다른 `Coroutine Builder`입니다.\n\n```kotlin\nfun main() {\n    val deferredResult: Deferred<String> = GlobalScope.async {\n        delay(1000L)\n        \"World!\"\n    }\n    \n    runBlocking {\n        println(\"Hello, ${deferredResult.await()}\")\n    }\n}\n```\n\n지연 값의 결과를 얻으려면 async가 편리한 Deferred 객체를 반환합니다. 이는 자바의 `Future` 또는 자바스크립트의 `Promise`와 같습니다. 지연 값에 대해 `await`를 호출함으로써 결과를 기다리고 획득 할 수 있습니다.\n\n`await`는 일반적인 블록킹 함수가 아닌 `suspending function`입니다. 이말인 즉슨, 메인 함수에서 호출 할 수 없다는 것을 의미합니다. 결과를 기다리기 위해 실제 main 함수를 블록해야 해야 되며 그래서 여기서 `runBlocking`을 사용하여 호출을 대기시킵니다.\n\n날카로운 눈빛을 가진 사람들은 GlobalScope를 다시 보았을 수 있습니다. 그래서 이제 GlobalScope에 대해 이야기 하려고 합니다.\nGlobalScope란 coroutines의 계층을 만들 수 있는 도구라고 볼 수 있습니다. Kotlin팀은 이를 구조화 된 동시성([structured concurrency](https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency))이라 부르고 있습니다.\n\n## Structured concurrency\n만약 위에서 봤던 예제들을 잘 따라왔다면, 고전적인 \"블록을 완료하고 내 코루틴이 끝날 때까지 기다리는\" 패턴을 알아야 할 필요가 있음을 눈치 챘을 것이다.\n\nJava에서는 위에서와 같은 패턴을 구현하는 방법으로 대개 스레드에 대한 참조를 유지하고 모든 스레드를 기다리는 동안 주 스레드를 블록하기 위해 스레드에 대한 참조를 유지하고 모든 스레드에 대한 join을 호출하여 결과를 얻습니다. 우리는 Kotlin의 coroutine을 이용하여 비슷한 일을 할 수 있습니다. 그러나 이것은 전혀 관용적이지 않습니다.\n\nKotlin에서는 `coroutines`을 계층 구조로도 생성 할 수 있습니다. 이 계층 구조를 사용하면 부모 coroutine이 자동으로 자식 coroutines의 수명주기를 관리 할 수 ​​있습니다. 예를 들어, 하위 코루틴의 실행이 완료 할 때까지 기다리는 일도, 그 중 하나에서 예외가 발생하는 경우 모든 하위 코루틴의 실행을 취소 할 수 있습니다.\n\n\n### Creating a hierarchy of coroutines\n`coroutine`에서 호출하면 안되는 `runBlocking`을 제외하고 모든 `Coroutine Builder`는 `CoroutineScope` 클래스의 확장 함수 형태로 선언되어 있는데, `coroutine`을 구조화하도록 권장합니다.\n\n```kotlin\nfun <T> runBlocking(...): T {...}\nfun <T> CoroutineScope.async(...): Deferred<T> {...}\nfun <T> CoroutineScope.launch(...): Job {...}\nfun <E> CoroutineScope.produce(...): ReceiveChannel<E> {...}\n...\n```\n\nCoroutine을 생성하려면 GlobalScope (최상위 수준, Top-Level Coroutine) 또는 이미 존재하는 `CoroutineScope` (해당 범위의 자식 Coroutine)에서 이러한 빌더를 호출해야합니다.\n\n\nIn fact, if you write a function that creates coroutines, you should declare it as an extension of the CoroutineScope class too\n사실, `coroutine`을 만드는 함수를 작성한다면 `CoroutineScope` 클래스의 확장으로 선언해야합니다. 이는 관례적으로 `Coroutine Builder`를 쉽게 호출 할 수 있게 해주는데, 왜냐하면 `Coroutine Scope`에 대한 참조를 `this`를 통하여 할 수 있기 때문입니다.\n\n`Coroutine Builder`의 매소드 시그니처를 살펴보면 매개 변수로 사용하는 `suspending function`이 `CoroutineScope` 클래스의 확장 기능으로 정의되어 있음을 알 수 있습니다.\n\n```kotlin\nfun <T> CoroutineScope.async(\n    ...\n    block: suspend CoroutineScope.() -> T\n): Deferred<T> {\n    ...\n}\n```\n\n이는 수신자를 지정하지 않고도 그 함수의 내부에서 다른 `Coroutine Builder`를 호출 할 수 있음을 의미합니다. 그리고, 암시적인 수신자는 현재 코루틴의 자식 스코프가 될 수 있습니다. 이때 현재 코루틴은 부모로서의 역할을 수행하게 됩니다.\n\n이전 예제를 보다 관용적인 방식으로 구조화 하는 방법은 아래와 같습니다.\n```kotlin\nfun main() = runBlocking {\n    val deferredResult = async {\n        delay(1000L)\n        \"World!\"\n    }\n    println(\"Hello, ${deferredResult.await()}\")\n}\n\nfun main() = runBlocking { \n    launch {\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n}\n\nfun main() = runBlocking {\n    delay(1000L)\n    println(\"Hello, World!\")\n}\n```\n\n범위가 wrapping runBlocking 호출에 의해 제공되기 때문에 더 이상 GlobalScope가 필요하지 않습니다. 또한 자식 `Coroutine`이 끝날 때까지 기다릴 필요가 없습니다. `runBlocking`은 모든 자식이 자신의 실행을 완료하기 전에 완료 될 때까지 기다릴 것이므로 주 스레드는 `runBlocking`에 의해 블록 상태를 유지합니다.\n\n\n### The coroutineScope builder\n`runBlocking`을 사용하는 것은 `coroutine` 내부에서 권장하지 않을 수 있음을 알 수 있을 것이다. 이는 Kotlin팀이 `coroutine` 내부에서 현재 스레드가 블록되지 않길 원하기도 했고, 대신 `suspending function`을 사용하길 권하고 있습니다. runBlocking에 해당하는 중단은 coroutineScope 빌더입니다.\n\n`coroutineScope`는 모든 자식 코루틴이 실행을 완료 할 때까지 현재의 coroutine을 일시 중단합니다. 다음은 Kotlin 문서에서 직접 취한 예제입니다:\n\n```kotlin\nfun main() = runBlocking { // this: CoroutineScope\n    launch { \n        delay(200L)\n        println(\"Task from runBlocking\")\n    }\n    \n    coroutineScope { // Creates a new coroutine scope\n        launch {\n            delay(500L) \n            println(\"Task from nested launch\")\n        }\n    \n        delay(100L)\n        println(\"Task from coroutine scope\") // This line will be printed before nested launch\n    }\n    \n    println(\"Coroutine scope is over\") // This line is not printed until nested launch completes\n}\n```\n\n## Beyond the basics\n여기에서 설명하는 기본 구성 요소는 실제로 코 틀린의 coroutines 개념의 가장 큰 측면이 아닙니다. 우리는 `channel`, `producer` 및 `consumer` 등을 사용하여 동시성이 필요한 것을 정말 멋지게 표현하기 위해 `coroutine`을 사용할 수 있습니다. 그러나 우리는 먼저 이러한 빌딩 블록을 이해해야하며 그 위에 더 높은 추상화를 만들기 시작해야한다고 생각합니다.\n\n`coroutine`에 관해서는 많은 이야기가 있습니다.이 기사는 물론 표면적인 내용이 많긴 하지만, 이 글이 코루틴과 `suspending function`을 더 잘 이해하는데 도움이 되기를 바랍니다.\n\n특정 부분에 대해 더 궁금하거나 이 글이 도움이 된다면 저에게 알려주시면 좋을꺼 같습니다. 만약 자잘한 실수가 보이면 망설이지 말고 알려주시구요.\n\n\n## Very helpful resources\n조금 시간을 할애 할 수 있다면, Kotlin Conf에서 Roman Elizarov가 발표했던 코루틴 관련 영상을 보시길 추천합니다. \n\n### Coroutines in practice\n이 강연에서 Roman은 코루틴에 대해 아주 빠르게 요약하고 이어서 `channels`, `actors` 등을 사용하여 코루틴을 아주 잘 사용하는 방법을 설명하고 있습니다.\n\n- [KotlinConf 2018 - Kotlin Coroutines in Practice by Roman Elizarov](https://www.youtube.com/watch?v=a3agLJQ6vt8)\n\n\n### Kotlin conf 2017\n2017 Kotlin conf에서 발표했던 내용 역시 여전히 유용합니다.\n- Introduction to Coroutines : 이것은 기본적으로 내 기사의 내용이지만 보다 정확하고 나은 설명이 포함되어 있습니다\n- Deep Dive into Coroutines : 함수 및 coroutine을 실제로 중단시키는 방법에 대한 세부 정보를 설명합니다. 매우 계몽적인\n","source":"_posts/Kotlin/How_to_make_sense_of_Kotlin_coroutines.md","raw":"---\ntitle: 'How to make sense of Kotlin coroutines'\ndate: 2019.3.2. 20:13\ncategories:\n- Kotlin\n---\n\n# How to make sense of Kotlin coroutines\n\n> 본 글은 [How to make sense of Kotlin coroutines](https://proandroiddev.com/how-to-make-sense-of-kotlin-coroutines-b666c7151b93)을 읽고 발번역(?)한 내용입니다. 영어에 유창한 분들은 링크를 참고해주세요.\n\n코루틴은 완벽하게 읽고 유지 보수가 가능한 비동기 코드를 작성하는 좋은 방법이다. Kotlin은 단일 언어 구문으로 비동기 프로그래밍의 기본 요소를 제공하는데, 바로 `suspend` 키워드이다. 이 키워드와 함께 라이브러리 함수가 빛을 발합니다.\n\n## What is a coroutine?\nKotlin팀은 `Coroutine`을 `경량 스레드: Light-Weighted-Thread`로 정의했습니다. **그것들은 실제 스레드가 실행 할 수 있는 일종의 작업입니다.** [Kotlinlang.org](https://kotlinlang.org/)의 배너는 다음과 같습니다.\n\n![](https://cdn-images-1.medium.com/max/1600/1*OEX52nKgM1SHGO4l1mvV1A.gif)\n\n가장 흥미로운 점은 스레드가 특정 \"정지 지점\"에서 코루틴 실행을 중지하고 다른 작업을 수행 할 수 있다는 것이다. 나중에 코루틴을 다시 시작하거나 다른 스레드가 처리 할 수 ​​있습니다.\n\n따라서 정확성을 높이기 위해 하나의 코 루틴은 정확하게 하나의 \"작업\"이 아니라 오히려 특정 보장 된 순서로 실행되는 \"하위 작업\"의 순서입니다. 코드가 하나의 순차 블록에 있는 것처럼 보이더라도 정지 기능에 대한 각 호출은 동시 루틴 내의 새로운 \"하위 작업\"의 시작을 제한합니다.\n\n이는 우리에게 `suspending functions`에 관련된 주제를 다시 던져준다.\n\n## Suspending functions\n당신은 어쩌면 kotlinx의 `delay` 또는 Ktor의 `HttpClient.post`와 같은 함수를 발견 했을 수도 있는데, 이 함수들은 반환되기 전에 무언가를 기다리거나 집중적으로 작업해야하며 suspend 키워드로 표시되어있을 수 있습니다.\n\n```kotlin\nsuspend fun delay(timeMillis: Long) {...}\nsuspend fun someNetworkCallReturningValue(): SomeType {\n ...\n}\n```\n우리가 위에서 본 것처럼 이를 `suspending function`이라고 합니다.\n\n> 일시 중단 함수는 현재 스레드를 차단하지 않고 현재 코루틴의 실행을 일시 중단 할 수 있습니다.\n\n다시 말해, 당신이 보고 있는 코드가 `suspending function`을 호출하는 순간에 실행을 중지 할 수 있으며 나중에 다시 시작 될 수도 있다는 이야기이다. **그러나, 그 동안 현재 쓰레드가 무엇을 할 지에 대해서는 아무 말도 하지 않는다.**\n\n그 시점에서 또 다른 coroutine을 실행하는 것으로 돌아갈 수 있으며, 나중에 우리가 남긴 coroutine을 다시 실행할 수 있습니다. 이 모든 것은 일시 중지되지 않는 함수 세계에서 일시 중지 함수를 호출하는 방법에 의해 제어되지만 함수 일시 중단에 대해 본질적으로 비동기는 없습니다.\n\n> 일시 중단 기능은 명시 적으로 사용되는 경우에만 비동기식입니다.\n\n우리는 나중에 이것을 보게 될 것이다. 그러나 지금 당장은 함수를 일시 정지하는 것으로 생각하면 잠시 시간을내어 선언하는 특수 함수로 간주 할 수 있습니다. 그리고 그들은 암시적으로 스레드의 복잡성과 파견에 대해 걱정할 필요없이 함수를 하위 작업으로 암시 적으로 분할한다는 점을 명심하십시오. 그것이 실제로 그들이 훌륭한 이유입니다. 여러분이 내부에있을 때 걱정할 필요가 없습니다.\n\n### The suspending world is nicely sequential\n아마 `suspending function`에 특별한 반환 유형이 없는 것을 알아차렸을 수 있다. Java의 `Future` 또는 JavaScript의 `Promise`과 같은 래퍼가 필요하지 않습니다. 이것은 `Promise`을 반환하는 JavaScript의 비동기 함수와 달리 일시 중단 함수가 비동기 적이라는 사실을 강조합니다.\n\n> 내부 정지 함수로부터, 함수 호출에 대해 순차적으로 추론 할 수 있습니다.\n\n이것이 바로 비동기식 소재를 Kotlin에서 쉽게 추론 할 수 있게 하는 이유이다. `suspending function` 내에서 다른 `suspending function`에 대한 호출은 일반 함수 호출과 같이 작동합니다. 우리는 반환 값을 얻고 나머지 코드를 실행하기 전에 호출 된 함수의 실행을 기다릴 필요가 있다.\n\n```kotlin\nsuspend fun someNetworkCallReturningSomething(): Something {\n    // some networking operations making use of the suspending mechanism\n}\n\nsuspend fun someBusyFunction(): Unit {\n    delay(1000L)\n    println(\"Printed after 1 second\")\n    val something: Something = someNetworkCallReturningSomething()\n    println(\"Received $something from network\")\n}\n```\n\n이것이 나중에 복잡한 비동기 코드를 간단한 방법으로 작성할 수 있게 해줍니다.\n\n### Bridging the normal world and the suspending world\n일반 함수에서 `suspending function`을 직접 호출하면 컴파일 할 수 없다. 이에 대한 일반적인 설명은 *`coroutines` 만 일시 중단 될 수 있기 때문에* 이라고 설명하고 있다. 이런 설명을 통해 우리는 `suspending function`을 수행 할 `coroutine`을 생성해야 한다는 결론을 내릴 수 있다.\n\n개념적으로 함수를 일시 중단하는 것은 선언에서 \"실행하는 데 약간의 시간이 걸릴\"수 있습니다. 자신이 일시 중지 기능이 아니라면 다음 두 가지 중 하나를 명시 적으로 수행해야합니다.\n\n- 기다리는 동안 실제로 스레드를 차단합니다 (일반적인 함수 호출과 같이).\n- 비동기로 시작하여 즉시 수행하고 (여러 가지 가능한 방법으로 수행 할 수 있음)\n\n선택을 표현하는 방법으로 코 루틴 (coroutine)을 생성하는 것을 볼 수 있습니다. 명시 적이어야합니다 (그리고 이것은 대단합니다!) 이것은 coroutine 빌더라고하는 함수를 사용하여 수행됩니다.\n\n## Coroutine builders\n`Coroutine Builder`는 주어진 `suspending function`을 실행하는 새로운 `Coroutine`을 작성하는 간단한 함수입니다. 이러한 `Coroutine Builder`는 `suspending function`이 아닌 일반 함수에서 호출될 수 있는데, 왜냐하면 이러한 빌더 함수들은 `suspending function`이 아니기 때문입니다. 마치 일반 함수와 `suspending function` 함수 세계와의 가교 역할을 수행한다고 생각하시면 편합니다.\n\n\nKotlin 표준 라이브러리에는 여러 가지 `Coroutine Builder`가 포함되어있어 다양한 작업을 수행 할 수 있습니다. 다음 하위 절에서 몇 가지를 볼 것입니다.\n\n### Block the current thread with “runBlocking”\n코틀린의 일반 함수에서 `suspending function`을 다루는 가장 간단한 방법은 현제 실행 중인 스레드를 블록하고 기다리는 방법입니다. 현재 스레드를 블록하는 `Coroutine Builder` 함수는 바로 `runBlocking`입니다. \n\n```kotlin\nfun main() { \n    println(\"Hello,\")\n    \n    // 주어진 suspending lambda function을 실행하는 코루틴을 만들 수 있으며\n    // 그리고 현재 실행중인 스레드를 해당 함수의 실행이 마무리 될떄까지 블락합니다.\n    runBlocking {\n        // coroutine 함수 내부, 함수는 2초동안 정지상태로 유지됨.\n        delay(2000L)\n    }\n    \n    // 아래 코드는 2초 뒤에 실행됨\n    println(\"World!\")\n}\n```\n\n`runBlocking`의 컨텍스트에서 주어진 `suspending function`과 호출 계층 구조에 있는 자식은 실행이 끝날 때까지 현재 스레드를 효과적으로 차단합니다. `runBlocking`에 전달 된 함수는 서명에서 알 수 있듯이 runBlocking 자체가 일시 중지되지 않고 (스레드 블로킹 인 경우에도) 일시 중단 함수입니다.\n\n![](https://i.imgur.com/i5aj0dj.png)\n\n`main()` 함수에서 일종의 최상위 코루틴을 제공하고 JVM을 활성 상태로 유지하는 데 종종 사용됩니다 (구조화 된 동시성에 대한 섹션에서 볼 수 있습니다).\n\n### Fire-and-forget with “launch”\n일반적으로 `coroutine`의 핵심은 스레드를 블록하는 것이 아니라 비동기 작업을 시작하는 것입니다. `launch`이라는 `Coroutine Builder`는 백그라운드에서 `coroutine`을 시작하고 그동안 계속 작업 할 수 있게 합니다.\n\nKotlin 문서를 통해 아래와 같은 예제를 확인 할 수 있다.\n\n```kotlin\nfun main() { \n    GlobalScope.launch { // 새로운 코루틴을 백그라운드에서 실행하고 이후 단계를 진행한다.\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\") // main thread continues here immediately    \n    runBlocking {     // 그러나 이 표현식은 현제 실행중인 스레드를 블락한다.\n        delay(2000L)  // 우리가 2초 가량 대기하는 동안에도 JVM은 살이 있는 상태를 유지한다.        \n    } \n}\n```\n\n의견은 스스로에 대해 말해야합니다. 그러면 \"Hello\"가 즉시 인쇄되고 두 번째 후에 \"World!\"가 추가됩니다. 이 예제의 목적을 위해라도 어찌되었던간에 메인 함수를 블록해야 `launch`에서 무슨 일이 발생하는지 확인 할 수 있습니다. 그래서 JVM을 계속 유지하기 위해 `runBlocking`을 여기에서 다시 사용하고 있습니다.\n\n### Get a result asynchronously with “async”\n다음은 값을 반환하는 비동기 작업을 수행 할 수 있는 `async`라는 또 다른 `Coroutine Builder`입니다.\n\n```kotlin\nfun main() {\n    val deferredResult: Deferred<String> = GlobalScope.async {\n        delay(1000L)\n        \"World!\"\n    }\n    \n    runBlocking {\n        println(\"Hello, ${deferredResult.await()}\")\n    }\n}\n```\n\n지연 값의 결과를 얻으려면 async가 편리한 Deferred 객체를 반환합니다. 이는 자바의 `Future` 또는 자바스크립트의 `Promise`와 같습니다. 지연 값에 대해 `await`를 호출함으로써 결과를 기다리고 획득 할 수 있습니다.\n\n`await`는 일반적인 블록킹 함수가 아닌 `suspending function`입니다. 이말인 즉슨, 메인 함수에서 호출 할 수 없다는 것을 의미합니다. 결과를 기다리기 위해 실제 main 함수를 블록해야 해야 되며 그래서 여기서 `runBlocking`을 사용하여 호출을 대기시킵니다.\n\n날카로운 눈빛을 가진 사람들은 GlobalScope를 다시 보았을 수 있습니다. 그래서 이제 GlobalScope에 대해 이야기 하려고 합니다.\nGlobalScope란 coroutines의 계층을 만들 수 있는 도구라고 볼 수 있습니다. Kotlin팀은 이를 구조화 된 동시성([structured concurrency](https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency))이라 부르고 있습니다.\n\n## Structured concurrency\n만약 위에서 봤던 예제들을 잘 따라왔다면, 고전적인 \"블록을 완료하고 내 코루틴이 끝날 때까지 기다리는\" 패턴을 알아야 할 필요가 있음을 눈치 챘을 것이다.\n\nJava에서는 위에서와 같은 패턴을 구현하는 방법으로 대개 스레드에 대한 참조를 유지하고 모든 스레드를 기다리는 동안 주 스레드를 블록하기 위해 스레드에 대한 참조를 유지하고 모든 스레드에 대한 join을 호출하여 결과를 얻습니다. 우리는 Kotlin의 coroutine을 이용하여 비슷한 일을 할 수 있습니다. 그러나 이것은 전혀 관용적이지 않습니다.\n\nKotlin에서는 `coroutines`을 계층 구조로도 생성 할 수 있습니다. 이 계층 구조를 사용하면 부모 coroutine이 자동으로 자식 coroutines의 수명주기를 관리 할 수 ​​있습니다. 예를 들어, 하위 코루틴의 실행이 완료 할 때까지 기다리는 일도, 그 중 하나에서 예외가 발생하는 경우 모든 하위 코루틴의 실행을 취소 할 수 있습니다.\n\n\n### Creating a hierarchy of coroutines\n`coroutine`에서 호출하면 안되는 `runBlocking`을 제외하고 모든 `Coroutine Builder`는 `CoroutineScope` 클래스의 확장 함수 형태로 선언되어 있는데, `coroutine`을 구조화하도록 권장합니다.\n\n```kotlin\nfun <T> runBlocking(...): T {...}\nfun <T> CoroutineScope.async(...): Deferred<T> {...}\nfun <T> CoroutineScope.launch(...): Job {...}\nfun <E> CoroutineScope.produce(...): ReceiveChannel<E> {...}\n...\n```\n\nCoroutine을 생성하려면 GlobalScope (최상위 수준, Top-Level Coroutine) 또는 이미 존재하는 `CoroutineScope` (해당 범위의 자식 Coroutine)에서 이러한 빌더를 호출해야합니다.\n\n\nIn fact, if you write a function that creates coroutines, you should declare it as an extension of the CoroutineScope class too\n사실, `coroutine`을 만드는 함수를 작성한다면 `CoroutineScope` 클래스의 확장으로 선언해야합니다. 이는 관례적으로 `Coroutine Builder`를 쉽게 호출 할 수 있게 해주는데, 왜냐하면 `Coroutine Scope`에 대한 참조를 `this`를 통하여 할 수 있기 때문입니다.\n\n`Coroutine Builder`의 매소드 시그니처를 살펴보면 매개 변수로 사용하는 `suspending function`이 `CoroutineScope` 클래스의 확장 기능으로 정의되어 있음을 알 수 있습니다.\n\n```kotlin\nfun <T> CoroutineScope.async(\n    ...\n    block: suspend CoroutineScope.() -> T\n): Deferred<T> {\n    ...\n}\n```\n\n이는 수신자를 지정하지 않고도 그 함수의 내부에서 다른 `Coroutine Builder`를 호출 할 수 있음을 의미합니다. 그리고, 암시적인 수신자는 현재 코루틴의 자식 스코프가 될 수 있습니다. 이때 현재 코루틴은 부모로서의 역할을 수행하게 됩니다.\n\n이전 예제를 보다 관용적인 방식으로 구조화 하는 방법은 아래와 같습니다.\n```kotlin\nfun main() = runBlocking {\n    val deferredResult = async {\n        delay(1000L)\n        \"World!\"\n    }\n    println(\"Hello, ${deferredResult.await()}\")\n}\n\nfun main() = runBlocking { \n    launch {\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n}\n\nfun main() = runBlocking {\n    delay(1000L)\n    println(\"Hello, World!\")\n}\n```\n\n범위가 wrapping runBlocking 호출에 의해 제공되기 때문에 더 이상 GlobalScope가 필요하지 않습니다. 또한 자식 `Coroutine`이 끝날 때까지 기다릴 필요가 없습니다. `runBlocking`은 모든 자식이 자신의 실행을 완료하기 전에 완료 될 때까지 기다릴 것이므로 주 스레드는 `runBlocking`에 의해 블록 상태를 유지합니다.\n\n\n### The coroutineScope builder\n`runBlocking`을 사용하는 것은 `coroutine` 내부에서 권장하지 않을 수 있음을 알 수 있을 것이다. 이는 Kotlin팀이 `coroutine` 내부에서 현재 스레드가 블록되지 않길 원하기도 했고, 대신 `suspending function`을 사용하길 권하고 있습니다. runBlocking에 해당하는 중단은 coroutineScope 빌더입니다.\n\n`coroutineScope`는 모든 자식 코루틴이 실행을 완료 할 때까지 현재의 coroutine을 일시 중단합니다. 다음은 Kotlin 문서에서 직접 취한 예제입니다:\n\n```kotlin\nfun main() = runBlocking { // this: CoroutineScope\n    launch { \n        delay(200L)\n        println(\"Task from runBlocking\")\n    }\n    \n    coroutineScope { // Creates a new coroutine scope\n        launch {\n            delay(500L) \n            println(\"Task from nested launch\")\n        }\n    \n        delay(100L)\n        println(\"Task from coroutine scope\") // This line will be printed before nested launch\n    }\n    \n    println(\"Coroutine scope is over\") // This line is not printed until nested launch completes\n}\n```\n\n## Beyond the basics\n여기에서 설명하는 기본 구성 요소는 실제로 코 틀린의 coroutines 개념의 가장 큰 측면이 아닙니다. 우리는 `channel`, `producer` 및 `consumer` 등을 사용하여 동시성이 필요한 것을 정말 멋지게 표현하기 위해 `coroutine`을 사용할 수 있습니다. 그러나 우리는 먼저 이러한 빌딩 블록을 이해해야하며 그 위에 더 높은 추상화를 만들기 시작해야한다고 생각합니다.\n\n`coroutine`에 관해서는 많은 이야기가 있습니다.이 기사는 물론 표면적인 내용이 많긴 하지만, 이 글이 코루틴과 `suspending function`을 더 잘 이해하는데 도움이 되기를 바랍니다.\n\n특정 부분에 대해 더 궁금하거나 이 글이 도움이 된다면 저에게 알려주시면 좋을꺼 같습니다. 만약 자잘한 실수가 보이면 망설이지 말고 알려주시구요.\n\n\n## Very helpful resources\n조금 시간을 할애 할 수 있다면, Kotlin Conf에서 Roman Elizarov가 발표했던 코루틴 관련 영상을 보시길 추천합니다. \n\n### Coroutines in practice\n이 강연에서 Roman은 코루틴에 대해 아주 빠르게 요약하고 이어서 `channels`, `actors` 등을 사용하여 코루틴을 아주 잘 사용하는 방법을 설명하고 있습니다.\n\n- [KotlinConf 2018 - Kotlin Coroutines in Practice by Roman Elizarov](https://www.youtube.com/watch?v=a3agLJQ6vt8)\n\n\n### Kotlin conf 2017\n2017 Kotlin conf에서 발표했던 내용 역시 여전히 유용합니다.\n- Introduction to Coroutines : 이것은 기본적으로 내 기사의 내용이지만 보다 정확하고 나은 설명이 포함되어 있습니다\n- Deep Dive into Coroutines : 함수 및 coroutine을 실제로 중단시키는 방법에 대한 세부 정보를 설명합니다. 매우 계몽적인\n","slug":"Kotlin/How_to_make_sense_of_Kotlin_coroutines","published":1,"updated":"2021-08-02T12:06:48.518Z","_id":"ckrsup5170023tjhv90moeysd","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"How-to-make-sense-of-Kotlin-coroutines\"><a href=\"#How-to-make-sense-of-Kotlin-coroutines\" class=\"headerlink\" title=\"How to make sense of Kotlin coroutines\"></a>How to make sense of Kotlin coroutines</h1><blockquote>\n<p>본 글은 <a href=\"https://proandroiddev.com/how-to-make-sense-of-kotlin-coroutines-b666c7151b93\">How to make sense of Kotlin coroutines</a>을 읽고 발번역(?)한 내용입니다. 영어에 유창한 분들은 링크를 참고해주세요.</p>\n</blockquote>\n<p>코루틴은 완벽하게 읽고 유지 보수가 가능한 비동기 코드를 작성하는 좋은 방법이다. Kotlin은 단일 언어 구문으로 비동기 프로그래밍의 기본 요소를 제공하는데, 바로 <code>suspend</code> 키워드이다. 이 키워드와 함께 라이브러리 함수가 빛을 발합니다.</p>\n<h2 id=\"What-is-a-coroutine\"><a href=\"#What-is-a-coroutine\" class=\"headerlink\" title=\"What is a coroutine?\"></a>What is a coroutine?</h2><p>Kotlin팀은 <code>Coroutine</code>을 <code>경량 스레드: Light-Weighted-Thread</code>로 정의했습니다. <strong>그것들은 실제 스레드가 실행 할 수 있는 일종의 작업입니다.</strong> <a href=\"https://kotlinlang.org/\">Kotlinlang.org</a>의 배너는 다음과 같습니다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*OEX52nKgM1SHGO4l1mvV1A.gif\"></p>\n<p>가장 흥미로운 점은 스레드가 특정 “정지 지점”에서 코루틴 실행을 중지하고 다른 작업을 수행 할 수 있다는 것이다. 나중에 코루틴을 다시 시작하거나 다른 스레드가 처리 할 수 ​​있습니다.</p>\n<p>따라서 정확성을 높이기 위해 하나의 코 루틴은 정확하게 하나의 “작업”이 아니라 오히려 특정 보장 된 순서로 실행되는 “하위 작업”의 순서입니다. 코드가 하나의 순차 블록에 있는 것처럼 보이더라도 정지 기능에 대한 각 호출은 동시 루틴 내의 새로운 “하위 작업”의 시작을 제한합니다.</p>\n<p>이는 우리에게 <code>suspending functions</code>에 관련된 주제를 다시 던져준다.</p>\n<h2 id=\"Suspending-functions\"><a href=\"#Suspending-functions\" class=\"headerlink\" title=\"Suspending functions\"></a>Suspending functions</h2><p>당신은 어쩌면 kotlinx의 <code>delay</code> 또는 Ktor의 <code>HttpClient.post</code>와 같은 함수를 발견 했을 수도 있는데, 이 함수들은 반환되기 전에 무언가를 기다리거나 집중적으로 작업해야하며 suspend 키워드로 표시되어있을 수 있습니다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">delay</span><span class=\"params\">(timeMillis: <span class=\"type\">Long</span>)</span></span> &#123;...&#125;</span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">someNetworkCallReturningValue</span><span class=\"params\">()</span></span>: SomeType &#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>우리가 위에서 본 것처럼 이를 <code>suspending function</code>이라고 합니다.</p>\n<blockquote>\n<p>일시 중단 함수는 현재 스레드를 차단하지 않고 현재 코루틴의 실행을 일시 중단 할 수 있습니다.</p>\n</blockquote>\n<p>다시 말해, 당신이 보고 있는 코드가 <code>suspending function</code>을 호출하는 순간에 실행을 중지 할 수 있으며 나중에 다시 시작 될 수도 있다는 이야기이다. <strong>그러나, 그 동안 현재 쓰레드가 무엇을 할 지에 대해서는 아무 말도 하지 않는다.</strong></p>\n<p>그 시점에서 또 다른 coroutine을 실행하는 것으로 돌아갈 수 있으며, 나중에 우리가 남긴 coroutine을 다시 실행할 수 있습니다. 이 모든 것은 일시 중지되지 않는 함수 세계에서 일시 중지 함수를 호출하는 방법에 의해 제어되지만 함수 일시 중단에 대해 본질적으로 비동기는 없습니다.</p>\n<blockquote>\n<p>일시 중단 기능은 명시 적으로 사용되는 경우에만 비동기식입니다.</p>\n</blockquote>\n<p>우리는 나중에 이것을 보게 될 것이다. 그러나 지금 당장은 함수를 일시 정지하는 것으로 생각하면 잠시 시간을내어 선언하는 특수 함수로 간주 할 수 있습니다. 그리고 그들은 암시적으로 스레드의 복잡성과 파견에 대해 걱정할 필요없이 함수를 하위 작업으로 암시 적으로 분할한다는 점을 명심하십시오. 그것이 실제로 그들이 훌륭한 이유입니다. 여러분이 내부에있을 때 걱정할 필요가 없습니다.</p>\n<h3 id=\"The-suspending-world-is-nicely-sequential\"><a href=\"#The-suspending-world-is-nicely-sequential\" class=\"headerlink\" title=\"The suspending world is nicely sequential\"></a>The suspending world is nicely sequential</h3><p>아마 <code>suspending function</code>에 특별한 반환 유형이 없는 것을 알아차렸을 수 있다. Java의 <code>Future</code> 또는 JavaScript의 <code>Promise</code>과 같은 래퍼가 필요하지 않습니다. 이것은 <code>Promise</code>을 반환하는 JavaScript의 비동기 함수와 달리 일시 중단 함수가 비동기 적이라는 사실을 강조합니다.</p>\n<blockquote>\n<p>내부 정지 함수로부터, 함수 호출에 대해 순차적으로 추론 할 수 있습니다.</p>\n</blockquote>\n<p>이것이 바로 비동기식 소재를 Kotlin에서 쉽게 추론 할 수 있게 하는 이유이다. <code>suspending function</code> 내에서 다른 <code>suspending function</code>에 대한 호출은 일반 함수 호출과 같이 작동합니다. 우리는 반환 값을 얻고 나머지 코드를 실행하기 전에 호출 된 함수의 실행을 기다릴 필요가 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">someNetworkCallReturningSomething</span><span class=\"params\">()</span></span>: Something &#123;</span><br><span class=\"line\">    <span class=\"comment\">// some networking operations making use of the suspending mechanism</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">someBusyFunction</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Unit</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Printed after 1 second&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> something: Something = someNetworkCallReturningSomething()</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Received <span class=\"variable\">$something</span> from network&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이것이 나중에 복잡한 비동기 코드를 간단한 방법으로 작성할 수 있게 해줍니다.</p>\n<h3 id=\"Bridging-the-normal-world-and-the-suspending-world\"><a href=\"#Bridging-the-normal-world-and-the-suspending-world\" class=\"headerlink\" title=\"Bridging the normal world and the suspending world\"></a>Bridging the normal world and the suspending world</h3><p>일반 함수에서 <code>suspending function</code>을 직접 호출하면 컴파일 할 수 없다. 이에 대한 일반적인 설명은 <em><code>coroutines</code> 만 일시 중단 될 수 있기 때문에</em> 이라고 설명하고 있다. 이런 설명을 통해 우리는 <code>suspending function</code>을 수행 할 <code>coroutine</code>을 생성해야 한다는 결론을 내릴 수 있다.</p>\n<p>개념적으로 함수를 일시 중단하는 것은 선언에서 “실행하는 데 약간의 시간이 걸릴”수 있습니다. 자신이 일시 중지 기능이 아니라면 다음 두 가지 중 하나를 명시 적으로 수행해야합니다.</p>\n<ul>\n<li>기다리는 동안 실제로 스레드를 차단합니다 (일반적인 함수 호출과 같이).</li>\n<li>비동기로 시작하여 즉시 수행하고 (여러 가지 가능한 방법으로 수행 할 수 있음)</li>\n</ul>\n<p>선택을 표현하는 방법으로 코 루틴 (coroutine)을 생성하는 것을 볼 수 있습니다. 명시 적이어야합니다 (그리고 이것은 대단합니다!) 이것은 coroutine 빌더라고하는 함수를 사용하여 수행됩니다.</p>\n<h2 id=\"Coroutine-builders\"><a href=\"#Coroutine-builders\" class=\"headerlink\" title=\"Coroutine builders\"></a>Coroutine builders</h2><p><code>Coroutine Builder</code>는 주어진 <code>suspending function</code>을 실행하는 새로운 <code>Coroutine</code>을 작성하는 간단한 함수입니다. 이러한 <code>Coroutine Builder</code>는 <code>suspending function</code>이 아닌 일반 함수에서 호출될 수 있는데, 왜냐하면 이러한 빌더 함수들은 <code>suspending function</code>이 아니기 때문입니다. 마치 일반 함수와 <code>suspending function</code> 함수 세계와의 가교 역할을 수행한다고 생각하시면 편합니다.</p>\n<p>Kotlin 표준 라이브러리에는 여러 가지 <code>Coroutine Builder</code>가 포함되어있어 다양한 작업을 수행 할 수 있습니다. 다음 하위 절에서 몇 가지를 볼 것입니다.</p>\n<h3 id=\"Block-the-current-thread-with-“runBlocking”\"><a href=\"#Block-the-current-thread-with-“runBlocking”\" class=\"headerlink\" title=\"Block the current thread with “runBlocking”\"></a>Block the current thread with “runBlocking”</h3><p>코틀린의 일반 함수에서 <code>suspending function</code>을 다루는 가장 간단한 방법은 현제 실행 중인 스레드를 블록하고 기다리는 방법입니다. 현재 스레드를 블록하는 <code>Coroutine Builder</code> 함수는 바로 <code>runBlocking</code>입니다. </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123; </span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello,&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 주어진 suspending lambda function을 실행하는 코루틴을 만들 수 있으며</span></span><br><span class=\"line\">    <span class=\"comment\">// 그리고 현재 실행중인 스레드를 해당 함수의 실행이 마무리 될떄까지 블락합니다.</span></span><br><span class=\"line\">    runBlocking &#123;</span><br><span class=\"line\">        <span class=\"comment\">// coroutine 함수 내부, 함수는 2초동안 정지상태로 유지됨.</span></span><br><span class=\"line\">        delay(<span class=\"number\">2000L</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 아래 코드는 2초 뒤에 실행됨</span></span><br><span class=\"line\">    println(<span class=\"string\">&quot;World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>runBlocking</code>의 컨텍스트에서 주어진 <code>suspending function</code>과 호출 계층 구조에 있는 자식은 실행이 끝날 때까지 현재 스레드를 효과적으로 차단합니다. <code>runBlocking</code>에 전달 된 함수는 서명에서 알 수 있듯이 runBlocking 자체가 일시 중지되지 않고 (스레드 블로킹 인 경우에도) 일시 중단 함수입니다.</p>\n<p><img src=\"https://i.imgur.com/i5aj0dj.png\"></p>\n<p><code>main()</code> 함수에서 일종의 최상위 코루틴을 제공하고 JVM을 활성 상태로 유지하는 데 종종 사용됩니다 (구조화 된 동시성에 대한 섹션에서 볼 수 있습니다).</p>\n<h3 id=\"Fire-and-forget-with-“launch”\"><a href=\"#Fire-and-forget-with-“launch”\" class=\"headerlink\" title=\"Fire-and-forget with “launch”\"></a>Fire-and-forget with “launch”</h3><p>일반적으로 <code>coroutine</code>의 핵심은 스레드를 블록하는 것이 아니라 비동기 작업을 시작하는 것입니다. <code>launch</code>이라는 <code>Coroutine Builder</code>는 백그라운드에서 <code>coroutine</code>을 시작하고 그동안 계속 작업 할 수 있게 합니다.</p>\n<p>Kotlin 문서를 통해 아래와 같은 예제를 확인 할 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123; </span><br><span class=\"line\">    GlobalScope.launch &#123; <span class=\"comment\">// 새로운 코루틴을 백그라운드에서 실행하고 이후 단계를 진행한다.</span></span><br><span class=\"line\">        delay(<span class=\"number\">1000L</span>)</span><br><span class=\"line\">        println(<span class=\"string\">&quot;World!&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello,&quot;</span>) <span class=\"comment\">// main thread continues here immediately    </span></span><br><span class=\"line\">    runBlocking &#123;     <span class=\"comment\">// 그러나 이 표현식은 현제 실행중인 스레드를 블락한다.</span></span><br><span class=\"line\">        delay(<span class=\"number\">2000L</span>)  <span class=\"comment\">// 우리가 2초 가량 대기하는 동안에도 JVM은 살이 있는 상태를 유지한다.        </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>의견은 스스로에 대해 말해야합니다. 그러면 “Hello”가 즉시 인쇄되고 두 번째 후에 “World!”가 추가됩니다. 이 예제의 목적을 위해라도 어찌되었던간에 메인 함수를 블록해야 <code>launch</code>에서 무슨 일이 발생하는지 확인 할 수 있습니다. 그래서 JVM을 계속 유지하기 위해 <code>runBlocking</code>을 여기에서 다시 사용하고 있습니다.</p>\n<h3 id=\"Get-a-result-asynchronously-with-“async”\"><a href=\"#Get-a-result-asynchronously-with-“async”\" class=\"headerlink\" title=\"Get a result asynchronously with “async”\"></a>Get a result asynchronously with “async”</h3><p>다음은 값을 반환하는 비동기 작업을 수행 할 수 있는 <code>async</code>라는 또 다른 <code>Coroutine Builder</code>입니다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> deferredResult: Deferred&lt;String&gt; = GlobalScope.async &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">1000L</span>)</span><br><span class=\"line\">        <span class=\"string\">&quot;World!&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    runBlocking &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Hello, <span class=\"subst\">$&#123;deferredResult.await()&#125;</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>지연 값의 결과를 얻으려면 async가 편리한 Deferred 객체를 반환합니다. 이는 자바의 <code>Future</code> 또는 자바스크립트의 <code>Promise</code>와 같습니다. 지연 값에 대해 <code>await</code>를 호출함으로써 결과를 기다리고 획득 할 수 있습니다.</p>\n<p><code>await</code>는 일반적인 블록킹 함수가 아닌 <code>suspending function</code>입니다. 이말인 즉슨, 메인 함수에서 호출 할 수 없다는 것을 의미합니다. 결과를 기다리기 위해 실제 main 함수를 블록해야 해야 되며 그래서 여기서 <code>runBlocking</code>을 사용하여 호출을 대기시킵니다.</p>\n<p>날카로운 눈빛을 가진 사람들은 GlobalScope를 다시 보았을 수 있습니다. 그래서 이제 GlobalScope에 대해 이야기 하려고 합니다.<br>GlobalScope란 coroutines의 계층을 만들 수 있는 도구라고 볼 수 있습니다. Kotlin팀은 이를 구조화 된 동시성(<a href=\"https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency\">structured concurrency</a>)이라 부르고 있습니다.</p>\n<h2 id=\"Structured-concurrency\"><a href=\"#Structured-concurrency\" class=\"headerlink\" title=\"Structured concurrency\"></a>Structured concurrency</h2><p>만약 위에서 봤던 예제들을 잘 따라왔다면, 고전적인 “블록을 완료하고 내 코루틴이 끝날 때까지 기다리는” 패턴을 알아야 할 필요가 있음을 눈치 챘을 것이다.</p>\n<p>Java에서는 위에서와 같은 패턴을 구현하는 방법으로 대개 스레드에 대한 참조를 유지하고 모든 스레드를 기다리는 동안 주 스레드를 블록하기 위해 스레드에 대한 참조를 유지하고 모든 스레드에 대한 join을 호출하여 결과를 얻습니다. 우리는 Kotlin의 coroutine을 이용하여 비슷한 일을 할 수 있습니다. 그러나 이것은 전혀 관용적이지 않습니다.</p>\n<p>Kotlin에서는 <code>coroutines</code>을 계층 구조로도 생성 할 수 있습니다. 이 계층 구조를 사용하면 부모 coroutine이 자동으로 자식 coroutines의 수명주기를 관리 할 수 ​​있습니다. 예를 들어, 하위 코루틴의 실행이 완료 할 때까지 기다리는 일도, 그 중 하나에서 예외가 발생하는 경우 모든 하위 코루틴의 실행을 취소 할 수 있습니다.</p>\n<h3 id=\"Creating-a-hierarchy-of-coroutines\"><a href=\"#Creating-a-hierarchy-of-coroutines\" class=\"headerlink\" title=\"Creating a hierarchy of coroutines\"></a>Creating a hierarchy of coroutines</h3><p><code>coroutine</code>에서 호출하면 안되는 <code>runBlocking</code>을 제외하고 모든 <code>Coroutine Builder</code>는 <code>CoroutineScope</code> 클래스의 확장 함수 형태로 선언되어 있는데, <code>coroutine</code>을 구조화하도록 권장합니다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">runBlocking</span><span class=\"params\">(...)</span></span>: T &#123;...&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> CoroutineScope.<span class=\"title\">async</span><span class=\"params\">(...)</span></span>: Deferred&lt;T&gt; &#123;...&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> CoroutineScope.<span class=\"title\">launch</span><span class=\"params\">(...)</span></span>: Job &#123;...&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;E&gt;</span> CoroutineScope.<span class=\"title\">produce</span><span class=\"params\">(...)</span></span>: ReceiveChannel&lt;E&gt; &#123;...&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>Coroutine을 생성하려면 GlobalScope (최상위 수준, Top-Level Coroutine) 또는 이미 존재하는 <code>CoroutineScope</code> (해당 범위의 자식 Coroutine)에서 이러한 빌더를 호출해야합니다.</p>\n<p>In fact, if you write a function that creates coroutines, you should declare it as an extension of the CoroutineScope class too<br>사실, <code>coroutine</code>을 만드는 함수를 작성한다면 <code>CoroutineScope</code> 클래스의 확장으로 선언해야합니다. 이는 관례적으로 <code>Coroutine Builder</code>를 쉽게 호출 할 수 있게 해주는데, 왜냐하면 <code>Coroutine Scope</code>에 대한 참조를 <code>this</code>를 통하여 할 수 있기 때문입니다.</p>\n<p><code>Coroutine Builder</code>의 매소드 시그니처를 살펴보면 매개 변수로 사용하는 <code>suspending function</code>이 <code>CoroutineScope</code> 클래스의 확장 기능으로 정의되어 있음을 알 수 있습니다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> CoroutineScope.<span class=\"title\">async</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    ...</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    block: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">T</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: Deferred&lt;T&gt; &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이는 수신자를 지정하지 않고도 그 함수의 내부에서 다른 <code>Coroutine Builder</code>를 호출 할 수 있음을 의미합니다. 그리고, 암시적인 수신자는 현재 코루틴의 자식 스코프가 될 수 있습니다. 이때 현재 코루틴은 부모로서의 역할을 수행하게 됩니다.</p>\n<p>이전 예제를 보다 관용적인 방식으로 구조화 하는 방법은 아래와 같습니다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> deferredResult = async &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">1000L</span>)</span><br><span class=\"line\">        <span class=\"string\">&quot;World!&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello, <span class=\"subst\">$&#123;deferredResult.await()&#125;</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking &#123; </span><br><span class=\"line\">    launch &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">1000L</span>)</span><br><span class=\"line\">        println(<span class=\"string\">&quot;World!&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello,&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello, World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>범위가 wrapping runBlocking 호출에 의해 제공되기 때문에 더 이상 GlobalScope가 필요하지 않습니다. 또한 자식 <code>Coroutine</code>이 끝날 때까지 기다릴 필요가 없습니다. <code>runBlocking</code>은 모든 자식이 자신의 실행을 완료하기 전에 완료 될 때까지 기다릴 것이므로 주 스레드는 <code>runBlocking</code>에 의해 블록 상태를 유지합니다.</p>\n<h3 id=\"The-coroutineScope-builder\"><a href=\"#The-coroutineScope-builder\" class=\"headerlink\" title=\"The coroutineScope builder\"></a>The coroutineScope builder</h3><p><code>runBlocking</code>을 사용하는 것은 <code>coroutine</code> 내부에서 권장하지 않을 수 있음을 알 수 있을 것이다. 이는 Kotlin팀이 <code>coroutine</code> 내부에서 현재 스레드가 블록되지 않길 원하기도 했고, 대신 <code>suspending function</code>을 사용하길 권하고 있습니다. runBlocking에 해당하는 중단은 coroutineScope 빌더입니다.</p>\n<p><code>coroutineScope</code>는 모든 자식 코루틴이 실행을 완료 할 때까지 현재의 coroutine을 일시 중단합니다. 다음은 Kotlin 문서에서 직접 취한 예제입니다:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking &#123; <span class=\"comment\">// this: CoroutineScope</span></span><br><span class=\"line\">    launch &#123; </span><br><span class=\"line\">        delay(<span class=\"number\">200L</span>)</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Task from runBlocking&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    coroutineScope &#123; <span class=\"comment\">// Creates a new coroutine scope</span></span><br><span class=\"line\">        launch &#123;</span><br><span class=\"line\">            delay(<span class=\"number\">500L</span>) </span><br><span class=\"line\">            println(<span class=\"string\">&quot;Task from nested launch&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Task from coroutine scope&quot;</span>) <span class=\"comment\">// This line will be printed before nested launch</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    println(<span class=\"string\">&quot;Coroutine scope is over&quot;</span>) <span class=\"comment\">// This line is not printed until nested launch completes</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Beyond-the-basics\"><a href=\"#Beyond-the-basics\" class=\"headerlink\" title=\"Beyond the basics\"></a>Beyond the basics</h2><p>여기에서 설명하는 기본 구성 요소는 실제로 코 틀린의 coroutines 개념의 가장 큰 측면이 아닙니다. 우리는 <code>channel</code>, <code>producer</code> 및 <code>consumer</code> 등을 사용하여 동시성이 필요한 것을 정말 멋지게 표현하기 위해 <code>coroutine</code>을 사용할 수 있습니다. 그러나 우리는 먼저 이러한 빌딩 블록을 이해해야하며 그 위에 더 높은 추상화를 만들기 시작해야한다고 생각합니다.</p>\n<p><code>coroutine</code>에 관해서는 많은 이야기가 있습니다.이 기사는 물론 표면적인 내용이 많긴 하지만, 이 글이 코루틴과 <code>suspending function</code>을 더 잘 이해하는데 도움이 되기를 바랍니다.</p>\n<p>특정 부분에 대해 더 궁금하거나 이 글이 도움이 된다면 저에게 알려주시면 좋을꺼 같습니다. 만약 자잘한 실수가 보이면 망설이지 말고 알려주시구요.</p>\n<h2 id=\"Very-helpful-resources\"><a href=\"#Very-helpful-resources\" class=\"headerlink\" title=\"Very helpful resources\"></a>Very helpful resources</h2><p>조금 시간을 할애 할 수 있다면, Kotlin Conf에서 Roman Elizarov가 발표했던 코루틴 관련 영상을 보시길 추천합니다. </p>\n<h3 id=\"Coroutines-in-practice\"><a href=\"#Coroutines-in-practice\" class=\"headerlink\" title=\"Coroutines in practice\"></a>Coroutines in practice</h3><p>이 강연에서 Roman은 코루틴에 대해 아주 빠르게 요약하고 이어서 <code>channels</code>, <code>actors</code> 등을 사용하여 코루틴을 아주 잘 사용하는 방법을 설명하고 있습니다.</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=a3agLJQ6vt8\">KotlinConf 2018 - Kotlin Coroutines in Practice by Roman Elizarov</a></li>\n</ul>\n<h3 id=\"Kotlin-conf-2017\"><a href=\"#Kotlin-conf-2017\" class=\"headerlink\" title=\"Kotlin conf 2017\"></a>Kotlin conf 2017</h3><p>2017 Kotlin conf에서 발표했던 내용 역시 여전히 유용합니다.</p>\n<ul>\n<li>Introduction to Coroutines : 이것은 기본적으로 내 기사의 내용이지만 보다 정확하고 나은 설명이 포함되어 있습니다</li>\n<li>Deep Dive into Coroutines : 함수 및 coroutine을 실제로 중단시키는 방법에 대한 세부 정보를 설명합니다. 매우 계몽적인</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"How-to-make-sense-of-Kotlin-coroutines\"><a href=\"#How-to-make-sense-of-Kotlin-coroutines\" class=\"headerlink\" title=\"How to make sense of Kotlin coroutines\"></a>How to make sense of Kotlin coroutines</h1><blockquote>\n<p>본 글은 <a href=\"https://proandroiddev.com/how-to-make-sense-of-kotlin-coroutines-b666c7151b93\">How to make sense of Kotlin coroutines</a>을 읽고 발번역(?)한 내용입니다. 영어에 유창한 분들은 링크를 참고해주세요.</p>\n</blockquote>\n<p>코루틴은 완벽하게 읽고 유지 보수가 가능한 비동기 코드를 작성하는 좋은 방법이다. Kotlin은 단일 언어 구문으로 비동기 프로그래밍의 기본 요소를 제공하는데, 바로 <code>suspend</code> 키워드이다. 이 키워드와 함께 라이브러리 함수가 빛을 발합니다.</p>\n<h2 id=\"What-is-a-coroutine\"><a href=\"#What-is-a-coroutine\" class=\"headerlink\" title=\"What is a coroutine?\"></a>What is a coroutine?</h2><p>Kotlin팀은 <code>Coroutine</code>을 <code>경량 스레드: Light-Weighted-Thread</code>로 정의했습니다. <strong>그것들은 실제 스레드가 실행 할 수 있는 일종의 작업입니다.</strong> <a href=\"https://kotlinlang.org/\">Kotlinlang.org</a>의 배너는 다음과 같습니다.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*OEX52nKgM1SHGO4l1mvV1A.gif\"></p>\n<p>가장 흥미로운 점은 스레드가 특정 “정지 지점”에서 코루틴 실행을 중지하고 다른 작업을 수행 할 수 있다는 것이다. 나중에 코루틴을 다시 시작하거나 다른 스레드가 처리 할 수 ​​있습니다.</p>\n<p>따라서 정확성을 높이기 위해 하나의 코 루틴은 정확하게 하나의 “작업”이 아니라 오히려 특정 보장 된 순서로 실행되는 “하위 작업”의 순서입니다. 코드가 하나의 순차 블록에 있는 것처럼 보이더라도 정지 기능에 대한 각 호출은 동시 루틴 내의 새로운 “하위 작업”의 시작을 제한합니다.</p>\n<p>이는 우리에게 <code>suspending functions</code>에 관련된 주제를 다시 던져준다.</p>\n<h2 id=\"Suspending-functions\"><a href=\"#Suspending-functions\" class=\"headerlink\" title=\"Suspending functions\"></a>Suspending functions</h2><p>당신은 어쩌면 kotlinx의 <code>delay</code> 또는 Ktor의 <code>HttpClient.post</code>와 같은 함수를 발견 했을 수도 있는데, 이 함수들은 반환되기 전에 무언가를 기다리거나 집중적으로 작업해야하며 suspend 키워드로 표시되어있을 수 있습니다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">delay</span><span class=\"params\">(timeMillis: <span class=\"type\">Long</span>)</span></span> &#123;...&#125;</span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">someNetworkCallReturningValue</span><span class=\"params\">()</span></span>: SomeType &#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>우리가 위에서 본 것처럼 이를 <code>suspending function</code>이라고 합니다.</p>\n<blockquote>\n<p>일시 중단 함수는 현재 스레드를 차단하지 않고 현재 코루틴의 실행을 일시 중단 할 수 있습니다.</p>\n</blockquote>\n<p>다시 말해, 당신이 보고 있는 코드가 <code>suspending function</code>을 호출하는 순간에 실행을 중지 할 수 있으며 나중에 다시 시작 될 수도 있다는 이야기이다. <strong>그러나, 그 동안 현재 쓰레드가 무엇을 할 지에 대해서는 아무 말도 하지 않는다.</strong></p>\n<p>그 시점에서 또 다른 coroutine을 실행하는 것으로 돌아갈 수 있으며, 나중에 우리가 남긴 coroutine을 다시 실행할 수 있습니다. 이 모든 것은 일시 중지되지 않는 함수 세계에서 일시 중지 함수를 호출하는 방법에 의해 제어되지만 함수 일시 중단에 대해 본질적으로 비동기는 없습니다.</p>\n<blockquote>\n<p>일시 중단 기능은 명시 적으로 사용되는 경우에만 비동기식입니다.</p>\n</blockquote>\n<p>우리는 나중에 이것을 보게 될 것이다. 그러나 지금 당장은 함수를 일시 정지하는 것으로 생각하면 잠시 시간을내어 선언하는 특수 함수로 간주 할 수 있습니다. 그리고 그들은 암시적으로 스레드의 복잡성과 파견에 대해 걱정할 필요없이 함수를 하위 작업으로 암시 적으로 분할한다는 점을 명심하십시오. 그것이 실제로 그들이 훌륭한 이유입니다. 여러분이 내부에있을 때 걱정할 필요가 없습니다.</p>\n<h3 id=\"The-suspending-world-is-nicely-sequential\"><a href=\"#The-suspending-world-is-nicely-sequential\" class=\"headerlink\" title=\"The suspending world is nicely sequential\"></a>The suspending world is nicely sequential</h3><p>아마 <code>suspending function</code>에 특별한 반환 유형이 없는 것을 알아차렸을 수 있다. Java의 <code>Future</code> 또는 JavaScript의 <code>Promise</code>과 같은 래퍼가 필요하지 않습니다. 이것은 <code>Promise</code>을 반환하는 JavaScript의 비동기 함수와 달리 일시 중단 함수가 비동기 적이라는 사실을 강조합니다.</p>\n<blockquote>\n<p>내부 정지 함수로부터, 함수 호출에 대해 순차적으로 추론 할 수 있습니다.</p>\n</blockquote>\n<p>이것이 바로 비동기식 소재를 Kotlin에서 쉽게 추론 할 수 있게 하는 이유이다. <code>suspending function</code> 내에서 다른 <code>suspending function</code>에 대한 호출은 일반 함수 호출과 같이 작동합니다. 우리는 반환 값을 얻고 나머지 코드를 실행하기 전에 호출 된 함수의 실행을 기다릴 필요가 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">someNetworkCallReturningSomething</span><span class=\"params\">()</span></span>: Something &#123;</span><br><span class=\"line\">    <span class=\"comment\">// some networking operations making use of the suspending mechanism</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">someBusyFunction</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Unit</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Printed after 1 second&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> something: Something = someNetworkCallReturningSomething()</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Received <span class=\"variable\">$something</span> from network&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이것이 나중에 복잡한 비동기 코드를 간단한 방법으로 작성할 수 있게 해줍니다.</p>\n<h3 id=\"Bridging-the-normal-world-and-the-suspending-world\"><a href=\"#Bridging-the-normal-world-and-the-suspending-world\" class=\"headerlink\" title=\"Bridging the normal world and the suspending world\"></a>Bridging the normal world and the suspending world</h3><p>일반 함수에서 <code>suspending function</code>을 직접 호출하면 컴파일 할 수 없다. 이에 대한 일반적인 설명은 <em><code>coroutines</code> 만 일시 중단 될 수 있기 때문에</em> 이라고 설명하고 있다. 이런 설명을 통해 우리는 <code>suspending function</code>을 수행 할 <code>coroutine</code>을 생성해야 한다는 결론을 내릴 수 있다.</p>\n<p>개념적으로 함수를 일시 중단하는 것은 선언에서 “실행하는 데 약간의 시간이 걸릴”수 있습니다. 자신이 일시 중지 기능이 아니라면 다음 두 가지 중 하나를 명시 적으로 수행해야합니다.</p>\n<ul>\n<li>기다리는 동안 실제로 스레드를 차단합니다 (일반적인 함수 호출과 같이).</li>\n<li>비동기로 시작하여 즉시 수행하고 (여러 가지 가능한 방법으로 수행 할 수 있음)</li>\n</ul>\n<p>선택을 표현하는 방법으로 코 루틴 (coroutine)을 생성하는 것을 볼 수 있습니다. 명시 적이어야합니다 (그리고 이것은 대단합니다!) 이것은 coroutine 빌더라고하는 함수를 사용하여 수행됩니다.</p>\n<h2 id=\"Coroutine-builders\"><a href=\"#Coroutine-builders\" class=\"headerlink\" title=\"Coroutine builders\"></a>Coroutine builders</h2><p><code>Coroutine Builder</code>는 주어진 <code>suspending function</code>을 실행하는 새로운 <code>Coroutine</code>을 작성하는 간단한 함수입니다. 이러한 <code>Coroutine Builder</code>는 <code>suspending function</code>이 아닌 일반 함수에서 호출될 수 있는데, 왜냐하면 이러한 빌더 함수들은 <code>suspending function</code>이 아니기 때문입니다. 마치 일반 함수와 <code>suspending function</code> 함수 세계와의 가교 역할을 수행한다고 생각하시면 편합니다.</p>\n<p>Kotlin 표준 라이브러리에는 여러 가지 <code>Coroutine Builder</code>가 포함되어있어 다양한 작업을 수행 할 수 있습니다. 다음 하위 절에서 몇 가지를 볼 것입니다.</p>\n<h3 id=\"Block-the-current-thread-with-“runBlocking”\"><a href=\"#Block-the-current-thread-with-“runBlocking”\" class=\"headerlink\" title=\"Block the current thread with “runBlocking”\"></a>Block the current thread with “runBlocking”</h3><p>코틀린의 일반 함수에서 <code>suspending function</code>을 다루는 가장 간단한 방법은 현제 실행 중인 스레드를 블록하고 기다리는 방법입니다. 현재 스레드를 블록하는 <code>Coroutine Builder</code> 함수는 바로 <code>runBlocking</code>입니다. </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123; </span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello,&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 주어진 suspending lambda function을 실행하는 코루틴을 만들 수 있으며</span></span><br><span class=\"line\">    <span class=\"comment\">// 그리고 현재 실행중인 스레드를 해당 함수의 실행이 마무리 될떄까지 블락합니다.</span></span><br><span class=\"line\">    runBlocking &#123;</span><br><span class=\"line\">        <span class=\"comment\">// coroutine 함수 내부, 함수는 2초동안 정지상태로 유지됨.</span></span><br><span class=\"line\">        delay(<span class=\"number\">2000L</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 아래 코드는 2초 뒤에 실행됨</span></span><br><span class=\"line\">    println(<span class=\"string\">&quot;World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>runBlocking</code>의 컨텍스트에서 주어진 <code>suspending function</code>과 호출 계층 구조에 있는 자식은 실행이 끝날 때까지 현재 스레드를 효과적으로 차단합니다. <code>runBlocking</code>에 전달 된 함수는 서명에서 알 수 있듯이 runBlocking 자체가 일시 중지되지 않고 (스레드 블로킹 인 경우에도) 일시 중단 함수입니다.</p>\n<p><img src=\"https://i.imgur.com/i5aj0dj.png\"></p>\n<p><code>main()</code> 함수에서 일종의 최상위 코루틴을 제공하고 JVM을 활성 상태로 유지하는 데 종종 사용됩니다 (구조화 된 동시성에 대한 섹션에서 볼 수 있습니다).</p>\n<h3 id=\"Fire-and-forget-with-“launch”\"><a href=\"#Fire-and-forget-with-“launch”\" class=\"headerlink\" title=\"Fire-and-forget with “launch”\"></a>Fire-and-forget with “launch”</h3><p>일반적으로 <code>coroutine</code>의 핵심은 스레드를 블록하는 것이 아니라 비동기 작업을 시작하는 것입니다. <code>launch</code>이라는 <code>Coroutine Builder</code>는 백그라운드에서 <code>coroutine</code>을 시작하고 그동안 계속 작업 할 수 있게 합니다.</p>\n<p>Kotlin 문서를 통해 아래와 같은 예제를 확인 할 수 있다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123; </span><br><span class=\"line\">    GlobalScope.launch &#123; <span class=\"comment\">// 새로운 코루틴을 백그라운드에서 실행하고 이후 단계를 진행한다.</span></span><br><span class=\"line\">        delay(<span class=\"number\">1000L</span>)</span><br><span class=\"line\">        println(<span class=\"string\">&quot;World!&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello,&quot;</span>) <span class=\"comment\">// main thread continues here immediately    </span></span><br><span class=\"line\">    runBlocking &#123;     <span class=\"comment\">// 그러나 이 표현식은 현제 실행중인 스레드를 블락한다.</span></span><br><span class=\"line\">        delay(<span class=\"number\">2000L</span>)  <span class=\"comment\">// 우리가 2초 가량 대기하는 동안에도 JVM은 살이 있는 상태를 유지한다.        </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>의견은 스스로에 대해 말해야합니다. 그러면 “Hello”가 즉시 인쇄되고 두 번째 후에 “World!”가 추가됩니다. 이 예제의 목적을 위해라도 어찌되었던간에 메인 함수를 블록해야 <code>launch</code>에서 무슨 일이 발생하는지 확인 할 수 있습니다. 그래서 JVM을 계속 유지하기 위해 <code>runBlocking</code>을 여기에서 다시 사용하고 있습니다.</p>\n<h3 id=\"Get-a-result-asynchronously-with-“async”\"><a href=\"#Get-a-result-asynchronously-with-“async”\" class=\"headerlink\" title=\"Get a result asynchronously with “async”\"></a>Get a result asynchronously with “async”</h3><p>다음은 값을 반환하는 비동기 작업을 수행 할 수 있는 <code>async</code>라는 또 다른 <code>Coroutine Builder</code>입니다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> deferredResult: Deferred&lt;String&gt; = GlobalScope.async &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">1000L</span>)</span><br><span class=\"line\">        <span class=\"string\">&quot;World!&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    runBlocking &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Hello, <span class=\"subst\">$&#123;deferredResult.await()&#125;</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>지연 값의 결과를 얻으려면 async가 편리한 Deferred 객체를 반환합니다. 이는 자바의 <code>Future</code> 또는 자바스크립트의 <code>Promise</code>와 같습니다. 지연 값에 대해 <code>await</code>를 호출함으로써 결과를 기다리고 획득 할 수 있습니다.</p>\n<p><code>await</code>는 일반적인 블록킹 함수가 아닌 <code>suspending function</code>입니다. 이말인 즉슨, 메인 함수에서 호출 할 수 없다는 것을 의미합니다. 결과를 기다리기 위해 실제 main 함수를 블록해야 해야 되며 그래서 여기서 <code>runBlocking</code>을 사용하여 호출을 대기시킵니다.</p>\n<p>날카로운 눈빛을 가진 사람들은 GlobalScope를 다시 보았을 수 있습니다. 그래서 이제 GlobalScope에 대해 이야기 하려고 합니다.<br>GlobalScope란 coroutines의 계층을 만들 수 있는 도구라고 볼 수 있습니다. Kotlin팀은 이를 구조화 된 동시성(<a href=\"https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency\">structured concurrency</a>)이라 부르고 있습니다.</p>\n<h2 id=\"Structured-concurrency\"><a href=\"#Structured-concurrency\" class=\"headerlink\" title=\"Structured concurrency\"></a>Structured concurrency</h2><p>만약 위에서 봤던 예제들을 잘 따라왔다면, 고전적인 “블록을 완료하고 내 코루틴이 끝날 때까지 기다리는” 패턴을 알아야 할 필요가 있음을 눈치 챘을 것이다.</p>\n<p>Java에서는 위에서와 같은 패턴을 구현하는 방법으로 대개 스레드에 대한 참조를 유지하고 모든 스레드를 기다리는 동안 주 스레드를 블록하기 위해 스레드에 대한 참조를 유지하고 모든 스레드에 대한 join을 호출하여 결과를 얻습니다. 우리는 Kotlin의 coroutine을 이용하여 비슷한 일을 할 수 있습니다. 그러나 이것은 전혀 관용적이지 않습니다.</p>\n<p>Kotlin에서는 <code>coroutines</code>을 계층 구조로도 생성 할 수 있습니다. 이 계층 구조를 사용하면 부모 coroutine이 자동으로 자식 coroutines의 수명주기를 관리 할 수 ​​있습니다. 예를 들어, 하위 코루틴의 실행이 완료 할 때까지 기다리는 일도, 그 중 하나에서 예외가 발생하는 경우 모든 하위 코루틴의 실행을 취소 할 수 있습니다.</p>\n<h3 id=\"Creating-a-hierarchy-of-coroutines\"><a href=\"#Creating-a-hierarchy-of-coroutines\" class=\"headerlink\" title=\"Creating a hierarchy of coroutines\"></a>Creating a hierarchy of coroutines</h3><p><code>coroutine</code>에서 호출하면 안되는 <code>runBlocking</code>을 제외하고 모든 <code>Coroutine Builder</code>는 <code>CoroutineScope</code> 클래스의 확장 함수 형태로 선언되어 있는데, <code>coroutine</code>을 구조화하도록 권장합니다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">runBlocking</span><span class=\"params\">(...)</span></span>: T &#123;...&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> CoroutineScope.<span class=\"title\">async</span><span class=\"params\">(...)</span></span>: Deferred&lt;T&gt; &#123;...&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> CoroutineScope.<span class=\"title\">launch</span><span class=\"params\">(...)</span></span>: Job &#123;...&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;E&gt;</span> CoroutineScope.<span class=\"title\">produce</span><span class=\"params\">(...)</span></span>: ReceiveChannel&lt;E&gt; &#123;...&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>Coroutine을 생성하려면 GlobalScope (최상위 수준, Top-Level Coroutine) 또는 이미 존재하는 <code>CoroutineScope</code> (해당 범위의 자식 Coroutine)에서 이러한 빌더를 호출해야합니다.</p>\n<p>In fact, if you write a function that creates coroutines, you should declare it as an extension of the CoroutineScope class too<br>사실, <code>coroutine</code>을 만드는 함수를 작성한다면 <code>CoroutineScope</code> 클래스의 확장으로 선언해야합니다. 이는 관례적으로 <code>Coroutine Builder</code>를 쉽게 호출 할 수 있게 해주는데, 왜냐하면 <code>Coroutine Scope</code>에 대한 참조를 <code>this</code>를 통하여 할 수 있기 때문입니다.</p>\n<p><code>Coroutine Builder</code>의 매소드 시그니처를 살펴보면 매개 변수로 사용하는 <code>suspending function</code>이 <code>CoroutineScope</code> 클래스의 확장 기능으로 정의되어 있음을 알 수 있습니다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> CoroutineScope.<span class=\"title\">async</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    ...</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    block: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">T</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: Deferred&lt;T&gt; &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이는 수신자를 지정하지 않고도 그 함수의 내부에서 다른 <code>Coroutine Builder</code>를 호출 할 수 있음을 의미합니다. 그리고, 암시적인 수신자는 현재 코루틴의 자식 스코프가 될 수 있습니다. 이때 현재 코루틴은 부모로서의 역할을 수행하게 됩니다.</p>\n<p>이전 예제를 보다 관용적인 방식으로 구조화 하는 방법은 아래와 같습니다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> deferredResult = async &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">1000L</span>)</span><br><span class=\"line\">        <span class=\"string\">&quot;World!&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello, <span class=\"subst\">$&#123;deferredResult.await()&#125;</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking &#123; </span><br><span class=\"line\">    launch &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">1000L</span>)</span><br><span class=\"line\">        println(<span class=\"string\">&quot;World!&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello,&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Hello, World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>범위가 wrapping runBlocking 호출에 의해 제공되기 때문에 더 이상 GlobalScope가 필요하지 않습니다. 또한 자식 <code>Coroutine</code>이 끝날 때까지 기다릴 필요가 없습니다. <code>runBlocking</code>은 모든 자식이 자신의 실행을 완료하기 전에 완료 될 때까지 기다릴 것이므로 주 스레드는 <code>runBlocking</code>에 의해 블록 상태를 유지합니다.</p>\n<h3 id=\"The-coroutineScope-builder\"><a href=\"#The-coroutineScope-builder\" class=\"headerlink\" title=\"The coroutineScope builder\"></a>The coroutineScope builder</h3><p><code>runBlocking</code>을 사용하는 것은 <code>coroutine</code> 내부에서 권장하지 않을 수 있음을 알 수 있을 것이다. 이는 Kotlin팀이 <code>coroutine</code> 내부에서 현재 스레드가 블록되지 않길 원하기도 했고, 대신 <code>suspending function</code>을 사용하길 권하고 있습니다. runBlocking에 해당하는 중단은 coroutineScope 빌더입니다.</p>\n<p><code>coroutineScope</code>는 모든 자식 코루틴이 실행을 완료 할 때까지 현재의 coroutine을 일시 중단합니다. 다음은 Kotlin 문서에서 직접 취한 예제입니다:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking &#123; <span class=\"comment\">// this: CoroutineScope</span></span><br><span class=\"line\">    launch &#123; </span><br><span class=\"line\">        delay(<span class=\"number\">200L</span>)</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Task from runBlocking&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    coroutineScope &#123; <span class=\"comment\">// Creates a new coroutine scope</span></span><br><span class=\"line\">        launch &#123;</span><br><span class=\"line\">            delay(<span class=\"number\">500L</span>) </span><br><span class=\"line\">            println(<span class=\"string\">&quot;Task from nested launch&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Task from coroutine scope&quot;</span>) <span class=\"comment\">// This line will be printed before nested launch</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    println(<span class=\"string\">&quot;Coroutine scope is over&quot;</span>) <span class=\"comment\">// This line is not printed until nested launch completes</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Beyond-the-basics\"><a href=\"#Beyond-the-basics\" class=\"headerlink\" title=\"Beyond the basics\"></a>Beyond the basics</h2><p>여기에서 설명하는 기본 구성 요소는 실제로 코 틀린의 coroutines 개념의 가장 큰 측면이 아닙니다. 우리는 <code>channel</code>, <code>producer</code> 및 <code>consumer</code> 등을 사용하여 동시성이 필요한 것을 정말 멋지게 표현하기 위해 <code>coroutine</code>을 사용할 수 있습니다. 그러나 우리는 먼저 이러한 빌딩 블록을 이해해야하며 그 위에 더 높은 추상화를 만들기 시작해야한다고 생각합니다.</p>\n<p><code>coroutine</code>에 관해서는 많은 이야기가 있습니다.이 기사는 물론 표면적인 내용이 많긴 하지만, 이 글이 코루틴과 <code>suspending function</code>을 더 잘 이해하는데 도움이 되기를 바랍니다.</p>\n<p>특정 부분에 대해 더 궁금하거나 이 글이 도움이 된다면 저에게 알려주시면 좋을꺼 같습니다. 만약 자잘한 실수가 보이면 망설이지 말고 알려주시구요.</p>\n<h2 id=\"Very-helpful-resources\"><a href=\"#Very-helpful-resources\" class=\"headerlink\" title=\"Very helpful resources\"></a>Very helpful resources</h2><p>조금 시간을 할애 할 수 있다면, Kotlin Conf에서 Roman Elizarov가 발표했던 코루틴 관련 영상을 보시길 추천합니다. </p>\n<h3 id=\"Coroutines-in-practice\"><a href=\"#Coroutines-in-practice\" class=\"headerlink\" title=\"Coroutines in practice\"></a>Coroutines in practice</h3><p>이 강연에서 Roman은 코루틴에 대해 아주 빠르게 요약하고 이어서 <code>channels</code>, <code>actors</code> 등을 사용하여 코루틴을 아주 잘 사용하는 방법을 설명하고 있습니다.</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=a3agLJQ6vt8\">KotlinConf 2018 - Kotlin Coroutines in Practice by Roman Elizarov</a></li>\n</ul>\n<h3 id=\"Kotlin-conf-2017\"><a href=\"#Kotlin-conf-2017\" class=\"headerlink\" title=\"Kotlin conf 2017\"></a>Kotlin conf 2017</h3><p>2017 Kotlin conf에서 발표했던 내용 역시 여전히 유용합니다.</p>\n<ul>\n<li>Introduction to Coroutines : 이것은 기본적으로 내 기사의 내용이지만 보다 정확하고 나은 설명이 포함되어 있습니다</li>\n<li>Deep Dive into Coroutines : 함수 및 coroutine을 실제로 중단시키는 방법에 대한 세부 정보를 설명합니다. 매우 계몽적인</li>\n</ul>\n"},{"title":"Kotlin-In-Action Generics","date":"2021-07-27T10:44:00.000Z","_content":"\n# Kotlin-In-Action Generics\n\n## 9장 제네릭스\n\n- `실체화한 타입 파라미터`를 사용하면 인라인 함수 호출에서 타입 인자로 쓰인 구체적인 타입을 실행시점에 알 수 있다.\n- `선언 지점 변성`을 사용하면 기저 타입은 같지만, 타입 인자가 다른 두 제네릭 타입 `Type<A>`와 `Type<B>`가 있을 때 타입 인자 A와 B의 상위/하위 타입 관계에 따라 두 제네릭 타입의 상위/하위 타입 관계가 어떻게 되는지 지정할 수 있다.\n  - `List<Any>`를 인자로 받는 함수가 있다고 했을 때, `List<Int>`타입의 값을 전달할 수 있는지 여부를 선언 지점 변성을 통해 지정할수 있음.\n- `사용 지점 변성`은 같은 목표(제네릭 타입 값 사이의 상위/하위 타입 관계 지정)를 제네릭 타입 값을 사용하는 위치에서 파라미터 타입에 대한 제약을 표시하는 방식으로 달성\n\n## 제네릭 타입 파라미터\n- 제네릭 타입의 인스턴스를 만들기 위해서는 타입 파라미터를 구체적인 타입 인자(Type Argument)로 치환해야 한다.\n  - List 타입이 있다고 했을 때, 명확하게 `문자열을 담는 리스트 = List<String>`\n  - Map 타입은 제네릭 타입변수로 `Map<K, V>`형태로 선언이 되어 있고, 이를 인스턴스화 할때 `Map<String, Person>`처럼 구체적인 타입 인자를 넘겨 인스턴스화 할수 있다.\n\n- 코틀린 컴파일러의 경우, 보통 타입과 마찬가지로 타입 인자도 추론이 가능하다\n```kotlin\nval authors = listOf(\"John\", \"Sveltna\")\n```\n- 빈 리스트의 경우, 추론할 값이 없기 때문에 직접 타입을 명시 해줘야 한다.\n\n```kotlin\nval authors: List<String> = emptyList();\nval authors = emptyList<String>();\n```\n\n- 제네릭 함수를 호출할 때는 반드시 구체 타입으로 타입 인자를 넘겨줘야 하는데, 대표적인 예로는 컬렉션을 다루는 함수들이 그 예시이다. 아래 `List<T>`의 slice 확장 함수를 예로 들면, 타입 파라미터 T가 수신객체와 반환 타입으로 사용된다. **타입 추론이 가능한 구체 타입으로 사용 시, 별도로 제네릭 지정이 불필요하다.**\n\n```kotlin\npublic fun <T> List<T>.slice(indices: IntRange): List<T>\n```\n\n- 타입 파라미터 선언은 `클래스`, `인터페이스`, `클래스/인터페이스의 메소드`, `확장 함수`, `최상위 함수`에서 선언이 가능하다. \n- 코틀린에서는 아래와 같이 `제네릭 확장 프로퍼티` 선언이 가능하다. 확장 프로퍼티에 대해서만 가능하며 일반 프로퍼티는 타입 파라미터를 가질 수 없다.\n\n```kotlin\nval <T> List<T>.penultimate: T\n\tget() = this[size - 2]\n```\n\n- 자바와 마찬가지로 제네릭 클래스를 확장/구현하기 위해서는 하위 클래스에서 기저 클래스의 구체 타입을 명시하거나 혹은 타입 파라미터로 받은 타입을 넘겨줘야 확장/구현이 가능하다.\n```kotlin\nclass StringList: List<String> { ... }\nclass ArrayList<T>: List<T> { ... }\n```\n\n- 타입 파리미터는 사용할 수 있는 타입을 제한할 수 있다. 타입 파라미터에 대한 **상한(upper-bound)** 을 지정한다고 표현하며 제네릭 타입을 인스턴스화 하는 시점에는 상한 타입이거나 혹은 상한 타입의 하위 타입만 가능하게 된다. **상한을 지정하게 되면 해당 타입의 값은 상한 타입으로 취급이 가능하게 된다.**\n\n```kotlin\nfun <T : Number> List<T>.sum(): T // Kotlin\n<T extend Number> T sum(List<T> list) // Java\n```\n\n- 두 인자값 중 큰 값을 찾는 제네릭 함수를 만든다고 할때, Comparable 인터페이스를 활용하여 코드를 작성한다고 해보자. \n\n```kotlin\nfun <T: Comparable<T>> max(first: T, second: T): T {\n\t// 코틀린 컴파일러에 의해 first.compareTo(second) > 0으로 변한다.\n\treturn if (first > second) first else second\n}\n\nprintln(max(\"kotlin\", \"java\")) // kotlin\nprintln(max(\"kotlin\", 42\")) // 42의 경우 첫 번째 인자의 타입 정보와 일치하지 않기 때문에 컴파일 에러\n```\n\n- 타입 파라미터에 대해 두 가지 이상의 제약을 걸수도 있다. 아래 코드에서는 `CharSequence`와 `Appendable` 인터페이스를 구현해야 하는 제약을 건 예제이다.\n\n```kotlin\nfun <T> ensureTraillingPeriod(seq: T) where T: CharSequence, T: Appendable {\n\tif (!seq.endsWith('.')) seq.append('.')\n}\n```\n\n- 아무런 상한을 정하지 않을 경우 기본적으로 `<T: Any?>`로 선언한 것과 같다. Nullable이 아닌 타입 파라미터를 받고자 한다면 `<T: Any>`로 지정해야 한다.\n\n- 만약 `<T:Any>`로 선언해둔 타입파라미터에 `String?`등과 같은 널 허용 타입을 지정하게 되면 String?은 Any의 하위 타입이 아니기 때문에 컴파일 에러가 발생하게 된다.\n\n```kotlin\nclass A<T> {\n\t// 타입 파라미터 T에 대해 별도의 상한을 지정하지 않았기 때문에 `Nullable`\n\tfun process(value: T) {\n\t\tvalue?.hashCode()\n\t}\n}\n\nclass B<T: Any> {\n\t// 타입 파라미터 T에 대해 Any로 상한을 지정하였기 때문에 NonNull\n\tfun process(value: T) {\n\t\tvalue.hashCode()\n\t}\n}\n```\n\n## 실행 시 제네릭스의 동작: 소거된 타입 파리미터와 실체화된 타입 파라미터\n- JVM에서 제네릭은 타입 소거(Type Erasure)를 사용해 구현되며 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다는 뜻이 된다.\n  > `List<String>`의 인스턴스를 만들더라도 런타임엔 List라는 타입정보만 남을뿐 String 원소를 저장하는지에 대한 정보를 알수 없다. 타입 정보가 지워지는 것이 단점만 있는 것은 아니고 전반적인 메모리 사용량이 줄어들기 때문에 나름 장점도 존재한다.\n\n```kotlin\nval list1: List<String> = listOf(\"a\",\"b\")\nval list2: List<Int> = listOf(1,2,3)\n```\n\n- 위 예제 코드를 통해 살펴보면, list1과 list2는 실제 런타임 시점에서는 List 타입으로만 취급되며 List의 제네릭 타입이 String인지 Int인지는 체크하는 것이 불가능하다. 다시 말해, `is`를 통한 타입 검사등은 할 수 없다는 이야기이다.\n\n- 코틀린에서는 `inline` 함수를 사용해 타입 정보가 지워지지 않게 할 수 있는데 이러한 것을 가리켜 실체화(reified)라고 한다.\n\n- 제네릭 타입을 알수 없을 경우 스타 프로젝션을 사용하여 포현하면 된다.\n- 타입을 알수 없는 경우에도 `as` 혹은 `as?` 캐스팅은 가능하다. 하지만, 타입 인자가 다른 타입으로 캐스팅해도 캐스팅 자체를 성공해버리기 때문에 이점은 조심해야 한다.\n\n- 아래 코드를 살펴보면 코드 자체는 컴파일에 성공하지만 인자로 넘어오는 값에 따라 여러 예외 상황을 맞이 할 수 있다. Set 인스턴스를 넘기게 될 경우 엘비스 이후에 있는 예외 코드가 실행이 되게 될것이고, `List<String>`의 인스턴스를 넘기게 될 경우 캐스팅은 성공하겠지만 sum() 함수를 호출하는 과정에서 `ClassCastException`을 만나게 될 것이다.\n\n```kotlin\nfun printSum(c: Collection<*>) {\n\tval intList = c as? List<Int> \n\t?: throw IllegalArgumentException(\"List is Expected\")\n\tprintln(intList.sum())\n}\n```\n\n- 만약 컴파일 시점에 타입 정보를 추론할 수 있는 상황이라면 코틀린 컴파일러는 is 검사를 허용해준다. 아래 코드에서는 `Collection<Int>`로 넘어오는 인자 타입을 추론할 수 있는 상황이기 때문에 is 검사를 허용하게 해준다. \n\n- IDE에서 테스트해보면 ***안전하지 못한 is 체크는 금지하고 위험한 as 캐스팅은 warning을 출력한다.***\n\n```kotlin\nfun printSumB(c: Collection<Int>) {\n\tif (c is List<Int>) {\n\t\tprintln(c.sum())\n\t}\n}\n```\n\n- `inline` 함수를 사용하여 타입 파라미터 실체화를 사용하게 되면, 실행 시점에 인라인 함수의 타입인자를 알수 있게 되는데, 만약 인라인 함수가 람다를 인자로 사용하는 상황이라면 별도의 익명 클래스나 객체가 생성되지 않기 때문에 성능상으로 좀 더 나아질 수도 있다.\n\n- 컴파일러는 인라인 함수의 본문을 구현한 바이트코드를 함수가 호출되는 모든 지점에 삽입하게 되고 컴파일러는 호출한 부분의 타입 인자를 활용해 해당 함수에서 사용하는 정확한 타입 정보를 알수 있게 된다. \n\n- Iterable.filterIsInstance 표준 함수를 예시로 살펴보면, 실제 filterIsInstance를 호출하는 함수 내부에서 inline 함수를 호출하기 때문에 해당 함수 본문의 바이트코드가 호출한 부분에 채워지게 된다. 본문을 대치하게 됨으로써 실제 제네릭으로 넘어간 타입 정보 역시 런타임에서도 타입 정보가 지워지지 않고 유지된다.\n\n```kotlin\nfun reifiedFilterList(): List<String> {\n\treturn listOf(\"one\", 2, \"three\")\n\t.filterIsInstance<String>()\n}\n\n// 함수 선언부\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<R>\n```\n\n- **자바코드에서 코틀린 코드를 호출할 경우, inline 함수의 실체화된 타입 파라미터는 사용할 수 없다고 한다.** \n  > 자바에서는 코틀린의 함수를 보통 함수처럼 호출하기 때문에 코틀린에서처럼 인라인 함수의 본문 대치가 불가능하다.\n\n- 보통 inline 함수에서는 람다를 사용한 코드가 일반적인데, 위 filterIsInstance의 경우 람다 선언이 없이 구체화된 타입 정보를 런타임에 알기 위해 사용한 것이다. 일반적으로 람다를 사용하지 않는 인라인 함수는 성능적으로 유리하지 않으며 JVM내에서도 일반 함수를 호출해도 강력하게 인라이닝할 수 있도록 기술적인 장치가 존재한다고 한다.\n  - [baeldung_jvm-method-inlining](https://www.baeldung.com/jvm-method-inlining)\n\n- `java.lang.Class` 타입 인자를 인자로 받아서 처리하는 코드를 만들 때, inline 함수의 실체화 타입 파라미터를 사용하는 것 또한 유용하다. 클래스 타 타입 인자를 받아서 처리하는 API 중 대표적인 유스케이스로는 JDK의 ServiceLoader가 있고, 또한 자주 사용하는 `jackson`과 같은 직렬화/역직렬화 라이브러리에서도 클래스 타입 인자를 넘겨서 처리하는 API가 존재한다.\n\n- 아래의 예제 코드처럼 타입 파라미터로 전달된 T에 대해 `::class.java` 구문을 사용하여 클래스에 대한 참조를 얻는 방법도 가능하다.\n\n```kotlin\ninline fun <reified T: Any> getServiceLoader(): ServiceLoader<T> {\n    return ServiceLoader.load(T::class.java)\n}\n\n// jackson-module-kotlin\ninline fun <reified T> jacksonTypeRef(): TypeReference<T> = object: TypeReference<T>() {}\n```\n\n- 실체화 타입 파라미터의 사용 가능한 경우와 제약사항은 아래와 같다.\n  - 사용 가능한 경우\n    * 타입 검사와 캐스팅(is, as)\n    * 리플렉션 API\n    * 코틀린 타입에 대응하는 자바 Class 타입 얻기(::class.java)\n    * 다른 함수 호출 시, 타입 인자로 사용\n  - 제약 사항\n    * 타입 파라미터의 인스턴스 생성\n    * 타입 파라미터 클래스의 동반 객체 메소드 호출\n    * 일반 타입파라미터를 실체화 타입 파라미터를 인자로 받는 함수에 넘기기\n    * 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 `reified`로 지정\n\n- 실체화 타입 파라미터를 사용하는 인라인 함수에서 람다를 사용하게 될 경우, 경우에 따라 인라이닝을 할 수 없는 경우도 발생하기도 하며, 성능 문제로 인라이닝을 안하고 싶을 수도 있다. 이럴 경우 `noinline` 키워드를 사용하여 인라이닝을 금지 시킬수 있다.\n\n\n## 변성(variance)\n- 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념\n> `List<String>`, `List<Any>`와 같이 기저 타입이 같고 타입이 인자가 다를 경우\n\n- 변성은 코드에서 위험할 여지가 있는 메소드를 호출할 수 없게 만듬으로써 제네릭 타입의 인스턴스 역할을 하는 클래스 인스턴스를 잘못 사용하는 일이 없게 방지하는 역할을 수행한다.\n\n- `String`의 경우 `Any`를 확장하기 때문에 `Any`타입을 받는 함수에 `String`타입의 인자를 넘겨도 안전하겠지만, `List<String>`, `List<Any>`의 경우 확실한 안정성을 이야기할 순 없다. 아래 예제를 보면, 문자열로 선언된 mutableList에 정수값 42가 추가되고 maxBy 함수를 호출하는 과정에서 Integer에 대해 캐스팅 익셉션이 발생하는 걸 확인할 수 있다. \n\n```kotlin\nfun printContents(list: List<Any>) {\n\tprintln(list.joinToString())\n}\n\nfun addAnswer(list: MutableList<Any>) {\n\tlist.add(42)\n}\n\nval strings = mutableListOf(\"abc\", \"bac\")\naddAnswer(strings)\n\n// ClassCastException: Integer cannot be cast to String\nprintln(strings.maxBy { it.length }) \n\n```\n\n- 어떤 함수가 만약 리스트의 값을 추가/변경하면 타입 불일치가 생길 수 있으니 `List<Any>` 대신 `List<String>`을 넘길 수 없다. 하지만, 원소의 추가/변경이 없을 경우 `List<Any>` 대신 `List<String>`을 넘겨도 안전하다. 코틀린에서는 리스트의 변경 가능성에 따라 적절한 인터페이스를 선택하게 되면 추가/변경을 막을 수 있어 안전하지 못한 호출을 막을 수 있다.\n\n- `타입 =! 클래스`\n  - **제네릭 클래스가 아닌 경우 클래스 이름을 타입으로 바로 사용할 수 있다.** 단순한 예제로 `val x: String`가 있다.\n  - 제네릭 클래스에서는 상황이 복잡하다. `List`는 타입이 아니고 클래스이며 실제 타입 파라미터가 추가된 `List<String>`, `List<Int>` 등이 제대로 된 타입이다. 제네릭 클래스는 결국 무수하게 많은 타입을 만들 수 있게 된다.\n- `하위 타입`\n  - A 타입의 값을 받을 수 있는 인자에 B 타입 값이 들어갈 수 있다면 `A타입은 B타입의 상위 타입`, `B타입은 A타입의 하위 타입` 으로 정리할 수 있다. 예를 들어, `Number`타입의 인자를 받을 수 있는 함수에 `Int`값을 넘길 수 있기에 둘 사이의 관계는 `Number타입은 Int타입의 상위 타입`, `Int타입은 Number타입의 하위 타입`으로 상/하위 타입 관계를 표현할 수 있게 된다.\n- **타입 관계의 중요성은 컴파일러가 변수 대입이나 인자 전달 시 하위 타입 검사를 매번 수행하기 때문이다.** Int 타입의 인자를 받는 함수에 Number 타입 인자를 넣어 호출하게 되면 하위 타입 검사에서 Int 타입의 하위 타입이 Number가 아니기 때문에 컴파일이 되지 않게 된다.\n\n- 간단한 경우 하위 타입은 하위 클래스와 같게 된다. 앞에서의 예처럼 Int 클래스는 Number 클래스의 하위 클래스이므로 Int는 Number의 하위 타입이다. \n\n- 하지만 코틀린의 Nullable과 NonNull 타입의 관계를 생각해보면 이야기가 조금 더 복잡해지는데, `Int?` 타입 선언에는 `Int`타입의 값을 넣거나 변수 선언을 해도 무관하지만, 반대로 `Int`타입엔 `Int?`를 선언하는 건 불가능하기 때문에 둘 사이의 관계는 `Int?타입은 Int타입의 상위 타입` 혹은 `Int타입은 Int?타입의 하위 타입`이라고 정리할 수 있다.\n\n```kotlin\nval s: String = \"abc\"\nval t: String? = s // String이 String?의 하위 타입이므로 이 대입은 가능\n```\n\n- 제네릭 타입을 인스턴스화 할때, 타입 인자에 서로 다른 타입이 들어가고 서로 하위 타입 관계가 성립하지 않은 걸 가리켜 `무공변(invariant)`라고 한다.\n\n- 타입 A가 B의 하위 타입이면 `List<A>`는 `List<B>`의 하위 타입이며 이런 관계를 `공변적(covariant)`라고 한다.\n\n- **공변성(`covariant`)**\n  - 공변적인 관계를 표현할 때는 out 키워드를 넣어 표현한다.\n\n  ```kotlin\n  interface Producer<out T> {\n\t  fun produce(): T\n  }\n  ```\n  - 클래스의 타입 파라미터를 공변적으로 만들면 함수 정의에 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 그 클래스의 인스턴스를 함수 인자나 반환 값으로 사용할 수 있다.\n  - 타입 파라미터를 공변적으로 지정하면 클래스 내부에서 그 파라미터를 사용하는 방법을 제한한다\n    * 타입 안정성을 위해 항상 아웃(out) 위치에 있어야 한다. 클래스가 타입의 값을 생상할 수 있지만 값을 소비할 수 없다는 이야기이다.\n  - 클래스 맴버 선언 시, 타입 파라미터를 사용할 수 있는 지점은 out/in으로 나뉘며, out으로 선언할 경우 반환 타입(생산)에 쓰이며 in 으로 선언할 경우 값을 소비하는 역할로 한정이 된다. \n\n  ```kotlin\n  interface Transformaer<T> {\n\t// t의 인자는 in 위치, 반환 타입 T는 out 위치\n\tfun transform(t: T): T\n  }\n  ```\n  - **다시 정리하면, 공변성은 하위 타입 관계가 유지되며, 아웃 키워드를 통해 공변성을 표현하며 아웃으로 선언하게 되면 아웃 위치에서만 사용이 가능하다.**\n\n  ```kotlin\n  class Herd<out T: Animal> {\n\tval size: Int\n\t\tget() = ...\n\toperator fun get(i: Int): T { ... }\n  }\n  ```\n  - 위 클래스는 Herd 클래스에 Animal의 하위 타입을 받는 타입이며, 공변성을 표현하고 있고 타입 한정을 Animal로 지정하여 T타입은 자연스럽게 Animal 타입으로 취급된다. 또한 공변성을 표현하고 있기 때문에 반환 타입으로만 해당 타입을 지정하는 것이 가능하다.\n  또한, Animal뿐만 아니라 이를 상속하는 타입이 있다면 해당 타입을 타입 파라미터로 지정하는 것이 가능하다. 예를 들어 Cat이 Animal의 하위 타입이라면 get을 호출하는 부분에서 Cat을 반환해도 아무런 문제가 없게 된다.\n\n  - 타입 파라미터는 함수 파라미터 타입이나 반환 타입으로만 쓰이지 않고, 다른 타입 파라미터의 인자로도 사용할 수 있다.\n  - 생성자 파라미터는 인이나 아웃 어느 쪽도 아니며 타입 파라미터가 out 으로 선언되어 있어도 그 타입을 생성자 파라미터 선언에 사용할 수 있다. 생성자는 나중에 호출할 수 있는 메소드가 아니기 때문에 위험할 여지가 없다.\n  - `val`, `var` 키워드를 생성자 파라미터에 사용할 경우 게터 혹은 세터를 정의하는 것고 같기 때문에 읽기 전용 프로퍼티는 아웃 위치에 그리고 변경 가능 프로퍼티는 인 위치에 해당한다.\n\n  ```kotlin\n  class Herd<T: Animal>(var leadAnimal: T, vararg animals: T) { ... }\n  ```\n\n- **반공변성(`contravariance`)**\n  - 타입 B가 A의 하위 타입인 경우, `Consumer<A>`가 `Consumer<B>`의 하위 타입인 관계가 성립하면 제네릭 클래스 `Consumer<T>`는 타입 인자 T에 대해 `반공변`을 표현한다고 할 수 있다.\n    * Animal의 하위 타입인 Cat이 `Consumer<Animal>`가 `Consumer<Cat>`의 하위 타입 관계가 성립될 경우 이를 반공변 관계가 성립한다고 할 수 있다.\n  - in이라는 키워드는 그 키워드가 붙은 타입이 이 클래스의 메소드 안으로 전달돼 메소드에 의해 소비된다는 뜻이다. 다시 말해, 오직 인 위치에서만 사용할 수 있다는 뜻이다.\n\n- **공변 vs 반공변 vs 무공변**\n  | 공변성 | 반공변성 | 무공변성 |\n  |:---|:---|:---|\n  | `Producer<out T>` | `Consumer<in T>` | `MutableList<T>` |\n  | 타입 인자의 하위 타입 관계가 <br/>제네릭 타입에서도 유지된다. | 타입 인자의 하위 타입 관계가<br/>제네릭 타입에서 뒤집힌다. | 하위 타입 관계가 성립하지 않음 |\n  | `Producer<Cat>`은 `Producer<Animal>`의 하위 타입이다.| `Consumer<Animal>`은 `Consumer<Cat>`의   하위 타입이다. | |\n  | T를 아웃 위치에서만 사용 | T를 인 위치에서만 사용 | T를 아무 위치에서나 사용 가능 |\n\n- 아래 Function 인터페이스은 공변과 반공변을 설명하기 아주 좋은 예제이다. 인자로 받는 P 타입에 대해서는 반공변성을 유지하며, R 타입에 대해서는 공변성을 띄게 된다. \n\n```kotlin\ninterface Function1<in P, out R> {\n    operator fun invoke(p: P): R\n} \n```\n\n- Cat과 Animal의 예제를 위 Function1에 대입해보면 `(Cat) -> Number`와 `(Animal) -> Int`에서도 하위 타입 관계가 성립하게 된다. 위 Function1의 경우 코틀린의 표현으로 바꿔보자면 `(Cat) -> Number`를 받는 인자에 `(Animal) -> Int`의 함수 인스턴스를 넘기더라도 하위 타입 관계가 성립하기 때문에 호출에 문제가 없게 되는 것이다. \n\n> 다시 정리하면 반공변의 경우 타입의 하위 관계를 반대로, 공변의 경우 타입의 하위 관계를 그대로 유지, 무공변의 경우 타입 파라미터간의 하위 타입 관계가 전혀 없는 것으로 정리할 수 있다.\n\n- **변성의 종류**\n  * `선언 지점 변성(declaration site variance)`: 클래스 선언에 지정하는 것을 선언 지점 변성이라 부르며, 한번의 선언만으로 변성을 추가 지정할 필요가 없으므로 코드가 간결해진다. \n  * `사용 지점 변성(use site variance)`: 자바에서처럼 타입 파라미터가 있는 타입을 사용할때 마다 해당 타입 파라미터를 하위 타입이나 상위 타입 중 어떤 타입으로 대치할 수 있는지 명시하는 방법을 사용 지점 변성이라고 한다. 자바의 `한정 와일드카드 타입(bounded wildcard)`을 사용하는 것을 생각하면 된다.(`? extends` , `? super`) 물론 **코틀린도 자바에서처럼 사용 지점 변성을 지원한다.** 공변적이거나 혹은 반공변적인지 선언할 수 없다면 사용 지점 변성을 사용하여 타입 파라미터가 나오는 지점에 변성을 정의하면 된다.\n\n- 변성을 지정하지 않은 클래스를 사용할 때 변성에 대한 지정이 가능하다. 대표적인 예제로 MutableList가 있다. MutableList는 타입 파라미터로 넘어는 값을 생산할 수도 있고 소비할수도 있게 되는데, 변성에 대한 지정을 통하여 이를 제어할 수 있게 된다.\n\n```kotlin\nfun <T> copyData(source: MutableList<out T>, destination: MutableList<T>) {\n\tfor(item in source) {\n\t\tdestination.add(item)\n\t}\n}\n```\n- 위 예제에서 `source`의 타입 선언을 `MutableList<out T>`로 지정해뒀는데, out 키워드를 붙임으로서 무공변인 MutableList에서 공변으로 제약을 붙인 타입으로 프로젝션을 시킬 수 있게 된다. 이럴 경우 값을 소비하는 add 함수등을 사용하게 될 경우 `Out-projected type ....`과 같은 에러를 만나게 될 수 있다. \n- **정리하면, 타입 선언에서 [타입 파라미터를 사용하는 위치]라면 어디에나 [변성 변경자]를 붙일 수 있으며, [파라미터 타입, 로컬 변수 타입, 함수 반환 타입] 등에 타입 파라미터가 쓰이는 경우 in이나 out 변경자를 붙일 수 있다. 이를 가리켜 `타입 프로젝션(type projection)`이라 부른다.**\n  * `List<out T>`처럼 이미 변성 변경자가 붙어 있는 클래스에 out 프로젝션을 하는 것은 의미가 없으므로 컴파일러와 IDE가 친절하게(?) 경고를 하게 될 것이다.","source":"_posts/Kotlin/Kotlin_In_Action.md","raw":"---\ntitle: 'Kotlin-In-Action Generics'\ndate: 2021.7.27. 19:44\ncategories:\n- Kotlin\n---\n\n# Kotlin-In-Action Generics\n\n## 9장 제네릭스\n\n- `실체화한 타입 파라미터`를 사용하면 인라인 함수 호출에서 타입 인자로 쓰인 구체적인 타입을 실행시점에 알 수 있다.\n- `선언 지점 변성`을 사용하면 기저 타입은 같지만, 타입 인자가 다른 두 제네릭 타입 `Type<A>`와 `Type<B>`가 있을 때 타입 인자 A와 B의 상위/하위 타입 관계에 따라 두 제네릭 타입의 상위/하위 타입 관계가 어떻게 되는지 지정할 수 있다.\n  - `List<Any>`를 인자로 받는 함수가 있다고 했을 때, `List<Int>`타입의 값을 전달할 수 있는지 여부를 선언 지점 변성을 통해 지정할수 있음.\n- `사용 지점 변성`은 같은 목표(제네릭 타입 값 사이의 상위/하위 타입 관계 지정)를 제네릭 타입 값을 사용하는 위치에서 파라미터 타입에 대한 제약을 표시하는 방식으로 달성\n\n## 제네릭 타입 파라미터\n- 제네릭 타입의 인스턴스를 만들기 위해서는 타입 파라미터를 구체적인 타입 인자(Type Argument)로 치환해야 한다.\n  - List 타입이 있다고 했을 때, 명확하게 `문자열을 담는 리스트 = List<String>`\n  - Map 타입은 제네릭 타입변수로 `Map<K, V>`형태로 선언이 되어 있고, 이를 인스턴스화 할때 `Map<String, Person>`처럼 구체적인 타입 인자를 넘겨 인스턴스화 할수 있다.\n\n- 코틀린 컴파일러의 경우, 보통 타입과 마찬가지로 타입 인자도 추론이 가능하다\n```kotlin\nval authors = listOf(\"John\", \"Sveltna\")\n```\n- 빈 리스트의 경우, 추론할 값이 없기 때문에 직접 타입을 명시 해줘야 한다.\n\n```kotlin\nval authors: List<String> = emptyList();\nval authors = emptyList<String>();\n```\n\n- 제네릭 함수를 호출할 때는 반드시 구체 타입으로 타입 인자를 넘겨줘야 하는데, 대표적인 예로는 컬렉션을 다루는 함수들이 그 예시이다. 아래 `List<T>`의 slice 확장 함수를 예로 들면, 타입 파라미터 T가 수신객체와 반환 타입으로 사용된다. **타입 추론이 가능한 구체 타입으로 사용 시, 별도로 제네릭 지정이 불필요하다.**\n\n```kotlin\npublic fun <T> List<T>.slice(indices: IntRange): List<T>\n```\n\n- 타입 파라미터 선언은 `클래스`, `인터페이스`, `클래스/인터페이스의 메소드`, `확장 함수`, `최상위 함수`에서 선언이 가능하다. \n- 코틀린에서는 아래와 같이 `제네릭 확장 프로퍼티` 선언이 가능하다. 확장 프로퍼티에 대해서만 가능하며 일반 프로퍼티는 타입 파라미터를 가질 수 없다.\n\n```kotlin\nval <T> List<T>.penultimate: T\n\tget() = this[size - 2]\n```\n\n- 자바와 마찬가지로 제네릭 클래스를 확장/구현하기 위해서는 하위 클래스에서 기저 클래스의 구체 타입을 명시하거나 혹은 타입 파라미터로 받은 타입을 넘겨줘야 확장/구현이 가능하다.\n```kotlin\nclass StringList: List<String> { ... }\nclass ArrayList<T>: List<T> { ... }\n```\n\n- 타입 파리미터는 사용할 수 있는 타입을 제한할 수 있다. 타입 파라미터에 대한 **상한(upper-bound)** 을 지정한다고 표현하며 제네릭 타입을 인스턴스화 하는 시점에는 상한 타입이거나 혹은 상한 타입의 하위 타입만 가능하게 된다. **상한을 지정하게 되면 해당 타입의 값은 상한 타입으로 취급이 가능하게 된다.**\n\n```kotlin\nfun <T : Number> List<T>.sum(): T // Kotlin\n<T extend Number> T sum(List<T> list) // Java\n```\n\n- 두 인자값 중 큰 값을 찾는 제네릭 함수를 만든다고 할때, Comparable 인터페이스를 활용하여 코드를 작성한다고 해보자. \n\n```kotlin\nfun <T: Comparable<T>> max(first: T, second: T): T {\n\t// 코틀린 컴파일러에 의해 first.compareTo(second) > 0으로 변한다.\n\treturn if (first > second) first else second\n}\n\nprintln(max(\"kotlin\", \"java\")) // kotlin\nprintln(max(\"kotlin\", 42\")) // 42의 경우 첫 번째 인자의 타입 정보와 일치하지 않기 때문에 컴파일 에러\n```\n\n- 타입 파라미터에 대해 두 가지 이상의 제약을 걸수도 있다. 아래 코드에서는 `CharSequence`와 `Appendable` 인터페이스를 구현해야 하는 제약을 건 예제이다.\n\n```kotlin\nfun <T> ensureTraillingPeriod(seq: T) where T: CharSequence, T: Appendable {\n\tif (!seq.endsWith('.')) seq.append('.')\n}\n```\n\n- 아무런 상한을 정하지 않을 경우 기본적으로 `<T: Any?>`로 선언한 것과 같다. Nullable이 아닌 타입 파라미터를 받고자 한다면 `<T: Any>`로 지정해야 한다.\n\n- 만약 `<T:Any>`로 선언해둔 타입파라미터에 `String?`등과 같은 널 허용 타입을 지정하게 되면 String?은 Any의 하위 타입이 아니기 때문에 컴파일 에러가 발생하게 된다.\n\n```kotlin\nclass A<T> {\n\t// 타입 파라미터 T에 대해 별도의 상한을 지정하지 않았기 때문에 `Nullable`\n\tfun process(value: T) {\n\t\tvalue?.hashCode()\n\t}\n}\n\nclass B<T: Any> {\n\t// 타입 파라미터 T에 대해 Any로 상한을 지정하였기 때문에 NonNull\n\tfun process(value: T) {\n\t\tvalue.hashCode()\n\t}\n}\n```\n\n## 실행 시 제네릭스의 동작: 소거된 타입 파리미터와 실체화된 타입 파라미터\n- JVM에서 제네릭은 타입 소거(Type Erasure)를 사용해 구현되며 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다는 뜻이 된다.\n  > `List<String>`의 인스턴스를 만들더라도 런타임엔 List라는 타입정보만 남을뿐 String 원소를 저장하는지에 대한 정보를 알수 없다. 타입 정보가 지워지는 것이 단점만 있는 것은 아니고 전반적인 메모리 사용량이 줄어들기 때문에 나름 장점도 존재한다.\n\n```kotlin\nval list1: List<String> = listOf(\"a\",\"b\")\nval list2: List<Int> = listOf(1,2,3)\n```\n\n- 위 예제 코드를 통해 살펴보면, list1과 list2는 실제 런타임 시점에서는 List 타입으로만 취급되며 List의 제네릭 타입이 String인지 Int인지는 체크하는 것이 불가능하다. 다시 말해, `is`를 통한 타입 검사등은 할 수 없다는 이야기이다.\n\n- 코틀린에서는 `inline` 함수를 사용해 타입 정보가 지워지지 않게 할 수 있는데 이러한 것을 가리켜 실체화(reified)라고 한다.\n\n- 제네릭 타입을 알수 없을 경우 스타 프로젝션을 사용하여 포현하면 된다.\n- 타입을 알수 없는 경우에도 `as` 혹은 `as?` 캐스팅은 가능하다. 하지만, 타입 인자가 다른 타입으로 캐스팅해도 캐스팅 자체를 성공해버리기 때문에 이점은 조심해야 한다.\n\n- 아래 코드를 살펴보면 코드 자체는 컴파일에 성공하지만 인자로 넘어오는 값에 따라 여러 예외 상황을 맞이 할 수 있다. Set 인스턴스를 넘기게 될 경우 엘비스 이후에 있는 예외 코드가 실행이 되게 될것이고, `List<String>`의 인스턴스를 넘기게 될 경우 캐스팅은 성공하겠지만 sum() 함수를 호출하는 과정에서 `ClassCastException`을 만나게 될 것이다.\n\n```kotlin\nfun printSum(c: Collection<*>) {\n\tval intList = c as? List<Int> \n\t?: throw IllegalArgumentException(\"List is Expected\")\n\tprintln(intList.sum())\n}\n```\n\n- 만약 컴파일 시점에 타입 정보를 추론할 수 있는 상황이라면 코틀린 컴파일러는 is 검사를 허용해준다. 아래 코드에서는 `Collection<Int>`로 넘어오는 인자 타입을 추론할 수 있는 상황이기 때문에 is 검사를 허용하게 해준다. \n\n- IDE에서 테스트해보면 ***안전하지 못한 is 체크는 금지하고 위험한 as 캐스팅은 warning을 출력한다.***\n\n```kotlin\nfun printSumB(c: Collection<Int>) {\n\tif (c is List<Int>) {\n\t\tprintln(c.sum())\n\t}\n}\n```\n\n- `inline` 함수를 사용하여 타입 파라미터 실체화를 사용하게 되면, 실행 시점에 인라인 함수의 타입인자를 알수 있게 되는데, 만약 인라인 함수가 람다를 인자로 사용하는 상황이라면 별도의 익명 클래스나 객체가 생성되지 않기 때문에 성능상으로 좀 더 나아질 수도 있다.\n\n- 컴파일러는 인라인 함수의 본문을 구현한 바이트코드를 함수가 호출되는 모든 지점에 삽입하게 되고 컴파일러는 호출한 부분의 타입 인자를 활용해 해당 함수에서 사용하는 정확한 타입 정보를 알수 있게 된다. \n\n- Iterable.filterIsInstance 표준 함수를 예시로 살펴보면, 실제 filterIsInstance를 호출하는 함수 내부에서 inline 함수를 호출하기 때문에 해당 함수 본문의 바이트코드가 호출한 부분에 채워지게 된다. 본문을 대치하게 됨으로써 실제 제네릭으로 넘어간 타입 정보 역시 런타임에서도 타입 정보가 지워지지 않고 유지된다.\n\n```kotlin\nfun reifiedFilterList(): List<String> {\n\treturn listOf(\"one\", 2, \"three\")\n\t.filterIsInstance<String>()\n}\n\n// 함수 선언부\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<R>\n```\n\n- **자바코드에서 코틀린 코드를 호출할 경우, inline 함수의 실체화된 타입 파라미터는 사용할 수 없다고 한다.** \n  > 자바에서는 코틀린의 함수를 보통 함수처럼 호출하기 때문에 코틀린에서처럼 인라인 함수의 본문 대치가 불가능하다.\n\n- 보통 inline 함수에서는 람다를 사용한 코드가 일반적인데, 위 filterIsInstance의 경우 람다 선언이 없이 구체화된 타입 정보를 런타임에 알기 위해 사용한 것이다. 일반적으로 람다를 사용하지 않는 인라인 함수는 성능적으로 유리하지 않으며 JVM내에서도 일반 함수를 호출해도 강력하게 인라이닝할 수 있도록 기술적인 장치가 존재한다고 한다.\n  - [baeldung_jvm-method-inlining](https://www.baeldung.com/jvm-method-inlining)\n\n- `java.lang.Class` 타입 인자를 인자로 받아서 처리하는 코드를 만들 때, inline 함수의 실체화 타입 파라미터를 사용하는 것 또한 유용하다. 클래스 타 타입 인자를 받아서 처리하는 API 중 대표적인 유스케이스로는 JDK의 ServiceLoader가 있고, 또한 자주 사용하는 `jackson`과 같은 직렬화/역직렬화 라이브러리에서도 클래스 타입 인자를 넘겨서 처리하는 API가 존재한다.\n\n- 아래의 예제 코드처럼 타입 파라미터로 전달된 T에 대해 `::class.java` 구문을 사용하여 클래스에 대한 참조를 얻는 방법도 가능하다.\n\n```kotlin\ninline fun <reified T: Any> getServiceLoader(): ServiceLoader<T> {\n    return ServiceLoader.load(T::class.java)\n}\n\n// jackson-module-kotlin\ninline fun <reified T> jacksonTypeRef(): TypeReference<T> = object: TypeReference<T>() {}\n```\n\n- 실체화 타입 파라미터의 사용 가능한 경우와 제약사항은 아래와 같다.\n  - 사용 가능한 경우\n    * 타입 검사와 캐스팅(is, as)\n    * 리플렉션 API\n    * 코틀린 타입에 대응하는 자바 Class 타입 얻기(::class.java)\n    * 다른 함수 호출 시, 타입 인자로 사용\n  - 제약 사항\n    * 타입 파라미터의 인스턴스 생성\n    * 타입 파라미터 클래스의 동반 객체 메소드 호출\n    * 일반 타입파라미터를 실체화 타입 파라미터를 인자로 받는 함수에 넘기기\n    * 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 `reified`로 지정\n\n- 실체화 타입 파라미터를 사용하는 인라인 함수에서 람다를 사용하게 될 경우, 경우에 따라 인라이닝을 할 수 없는 경우도 발생하기도 하며, 성능 문제로 인라이닝을 안하고 싶을 수도 있다. 이럴 경우 `noinline` 키워드를 사용하여 인라이닝을 금지 시킬수 있다.\n\n\n## 변성(variance)\n- 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념\n> `List<String>`, `List<Any>`와 같이 기저 타입이 같고 타입이 인자가 다를 경우\n\n- 변성은 코드에서 위험할 여지가 있는 메소드를 호출할 수 없게 만듬으로써 제네릭 타입의 인스턴스 역할을 하는 클래스 인스턴스를 잘못 사용하는 일이 없게 방지하는 역할을 수행한다.\n\n- `String`의 경우 `Any`를 확장하기 때문에 `Any`타입을 받는 함수에 `String`타입의 인자를 넘겨도 안전하겠지만, `List<String>`, `List<Any>`의 경우 확실한 안정성을 이야기할 순 없다. 아래 예제를 보면, 문자열로 선언된 mutableList에 정수값 42가 추가되고 maxBy 함수를 호출하는 과정에서 Integer에 대해 캐스팅 익셉션이 발생하는 걸 확인할 수 있다. \n\n```kotlin\nfun printContents(list: List<Any>) {\n\tprintln(list.joinToString())\n}\n\nfun addAnswer(list: MutableList<Any>) {\n\tlist.add(42)\n}\n\nval strings = mutableListOf(\"abc\", \"bac\")\naddAnswer(strings)\n\n// ClassCastException: Integer cannot be cast to String\nprintln(strings.maxBy { it.length }) \n\n```\n\n- 어떤 함수가 만약 리스트의 값을 추가/변경하면 타입 불일치가 생길 수 있으니 `List<Any>` 대신 `List<String>`을 넘길 수 없다. 하지만, 원소의 추가/변경이 없을 경우 `List<Any>` 대신 `List<String>`을 넘겨도 안전하다. 코틀린에서는 리스트의 변경 가능성에 따라 적절한 인터페이스를 선택하게 되면 추가/변경을 막을 수 있어 안전하지 못한 호출을 막을 수 있다.\n\n- `타입 =! 클래스`\n  - **제네릭 클래스가 아닌 경우 클래스 이름을 타입으로 바로 사용할 수 있다.** 단순한 예제로 `val x: String`가 있다.\n  - 제네릭 클래스에서는 상황이 복잡하다. `List`는 타입이 아니고 클래스이며 실제 타입 파라미터가 추가된 `List<String>`, `List<Int>` 등이 제대로 된 타입이다. 제네릭 클래스는 결국 무수하게 많은 타입을 만들 수 있게 된다.\n- `하위 타입`\n  - A 타입의 값을 받을 수 있는 인자에 B 타입 값이 들어갈 수 있다면 `A타입은 B타입의 상위 타입`, `B타입은 A타입의 하위 타입` 으로 정리할 수 있다. 예를 들어, `Number`타입의 인자를 받을 수 있는 함수에 `Int`값을 넘길 수 있기에 둘 사이의 관계는 `Number타입은 Int타입의 상위 타입`, `Int타입은 Number타입의 하위 타입`으로 상/하위 타입 관계를 표현할 수 있게 된다.\n- **타입 관계의 중요성은 컴파일러가 변수 대입이나 인자 전달 시 하위 타입 검사를 매번 수행하기 때문이다.** Int 타입의 인자를 받는 함수에 Number 타입 인자를 넣어 호출하게 되면 하위 타입 검사에서 Int 타입의 하위 타입이 Number가 아니기 때문에 컴파일이 되지 않게 된다.\n\n- 간단한 경우 하위 타입은 하위 클래스와 같게 된다. 앞에서의 예처럼 Int 클래스는 Number 클래스의 하위 클래스이므로 Int는 Number의 하위 타입이다. \n\n- 하지만 코틀린의 Nullable과 NonNull 타입의 관계를 생각해보면 이야기가 조금 더 복잡해지는데, `Int?` 타입 선언에는 `Int`타입의 값을 넣거나 변수 선언을 해도 무관하지만, 반대로 `Int`타입엔 `Int?`를 선언하는 건 불가능하기 때문에 둘 사이의 관계는 `Int?타입은 Int타입의 상위 타입` 혹은 `Int타입은 Int?타입의 하위 타입`이라고 정리할 수 있다.\n\n```kotlin\nval s: String = \"abc\"\nval t: String? = s // String이 String?의 하위 타입이므로 이 대입은 가능\n```\n\n- 제네릭 타입을 인스턴스화 할때, 타입 인자에 서로 다른 타입이 들어가고 서로 하위 타입 관계가 성립하지 않은 걸 가리켜 `무공변(invariant)`라고 한다.\n\n- 타입 A가 B의 하위 타입이면 `List<A>`는 `List<B>`의 하위 타입이며 이런 관계를 `공변적(covariant)`라고 한다.\n\n- **공변성(`covariant`)**\n  - 공변적인 관계를 표현할 때는 out 키워드를 넣어 표현한다.\n\n  ```kotlin\n  interface Producer<out T> {\n\t  fun produce(): T\n  }\n  ```\n  - 클래스의 타입 파라미터를 공변적으로 만들면 함수 정의에 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 그 클래스의 인스턴스를 함수 인자나 반환 값으로 사용할 수 있다.\n  - 타입 파라미터를 공변적으로 지정하면 클래스 내부에서 그 파라미터를 사용하는 방법을 제한한다\n    * 타입 안정성을 위해 항상 아웃(out) 위치에 있어야 한다. 클래스가 타입의 값을 생상할 수 있지만 값을 소비할 수 없다는 이야기이다.\n  - 클래스 맴버 선언 시, 타입 파라미터를 사용할 수 있는 지점은 out/in으로 나뉘며, out으로 선언할 경우 반환 타입(생산)에 쓰이며 in 으로 선언할 경우 값을 소비하는 역할로 한정이 된다. \n\n  ```kotlin\n  interface Transformaer<T> {\n\t// t의 인자는 in 위치, 반환 타입 T는 out 위치\n\tfun transform(t: T): T\n  }\n  ```\n  - **다시 정리하면, 공변성은 하위 타입 관계가 유지되며, 아웃 키워드를 통해 공변성을 표현하며 아웃으로 선언하게 되면 아웃 위치에서만 사용이 가능하다.**\n\n  ```kotlin\n  class Herd<out T: Animal> {\n\tval size: Int\n\t\tget() = ...\n\toperator fun get(i: Int): T { ... }\n  }\n  ```\n  - 위 클래스는 Herd 클래스에 Animal의 하위 타입을 받는 타입이며, 공변성을 표현하고 있고 타입 한정을 Animal로 지정하여 T타입은 자연스럽게 Animal 타입으로 취급된다. 또한 공변성을 표현하고 있기 때문에 반환 타입으로만 해당 타입을 지정하는 것이 가능하다.\n  또한, Animal뿐만 아니라 이를 상속하는 타입이 있다면 해당 타입을 타입 파라미터로 지정하는 것이 가능하다. 예를 들어 Cat이 Animal의 하위 타입이라면 get을 호출하는 부분에서 Cat을 반환해도 아무런 문제가 없게 된다.\n\n  - 타입 파라미터는 함수 파라미터 타입이나 반환 타입으로만 쓰이지 않고, 다른 타입 파라미터의 인자로도 사용할 수 있다.\n  - 생성자 파라미터는 인이나 아웃 어느 쪽도 아니며 타입 파라미터가 out 으로 선언되어 있어도 그 타입을 생성자 파라미터 선언에 사용할 수 있다. 생성자는 나중에 호출할 수 있는 메소드가 아니기 때문에 위험할 여지가 없다.\n  - `val`, `var` 키워드를 생성자 파라미터에 사용할 경우 게터 혹은 세터를 정의하는 것고 같기 때문에 읽기 전용 프로퍼티는 아웃 위치에 그리고 변경 가능 프로퍼티는 인 위치에 해당한다.\n\n  ```kotlin\n  class Herd<T: Animal>(var leadAnimal: T, vararg animals: T) { ... }\n  ```\n\n- **반공변성(`contravariance`)**\n  - 타입 B가 A의 하위 타입인 경우, `Consumer<A>`가 `Consumer<B>`의 하위 타입인 관계가 성립하면 제네릭 클래스 `Consumer<T>`는 타입 인자 T에 대해 `반공변`을 표현한다고 할 수 있다.\n    * Animal의 하위 타입인 Cat이 `Consumer<Animal>`가 `Consumer<Cat>`의 하위 타입 관계가 성립될 경우 이를 반공변 관계가 성립한다고 할 수 있다.\n  - in이라는 키워드는 그 키워드가 붙은 타입이 이 클래스의 메소드 안으로 전달돼 메소드에 의해 소비된다는 뜻이다. 다시 말해, 오직 인 위치에서만 사용할 수 있다는 뜻이다.\n\n- **공변 vs 반공변 vs 무공변**\n  | 공변성 | 반공변성 | 무공변성 |\n  |:---|:---|:---|\n  | `Producer<out T>` | `Consumer<in T>` | `MutableList<T>` |\n  | 타입 인자의 하위 타입 관계가 <br/>제네릭 타입에서도 유지된다. | 타입 인자의 하위 타입 관계가<br/>제네릭 타입에서 뒤집힌다. | 하위 타입 관계가 성립하지 않음 |\n  | `Producer<Cat>`은 `Producer<Animal>`의 하위 타입이다.| `Consumer<Animal>`은 `Consumer<Cat>`의   하위 타입이다. | |\n  | T를 아웃 위치에서만 사용 | T를 인 위치에서만 사용 | T를 아무 위치에서나 사용 가능 |\n\n- 아래 Function 인터페이스은 공변과 반공변을 설명하기 아주 좋은 예제이다. 인자로 받는 P 타입에 대해서는 반공변성을 유지하며, R 타입에 대해서는 공변성을 띄게 된다. \n\n```kotlin\ninterface Function1<in P, out R> {\n    operator fun invoke(p: P): R\n} \n```\n\n- Cat과 Animal의 예제를 위 Function1에 대입해보면 `(Cat) -> Number`와 `(Animal) -> Int`에서도 하위 타입 관계가 성립하게 된다. 위 Function1의 경우 코틀린의 표현으로 바꿔보자면 `(Cat) -> Number`를 받는 인자에 `(Animal) -> Int`의 함수 인스턴스를 넘기더라도 하위 타입 관계가 성립하기 때문에 호출에 문제가 없게 되는 것이다. \n\n> 다시 정리하면 반공변의 경우 타입의 하위 관계를 반대로, 공변의 경우 타입의 하위 관계를 그대로 유지, 무공변의 경우 타입 파라미터간의 하위 타입 관계가 전혀 없는 것으로 정리할 수 있다.\n\n- **변성의 종류**\n  * `선언 지점 변성(declaration site variance)`: 클래스 선언에 지정하는 것을 선언 지점 변성이라 부르며, 한번의 선언만으로 변성을 추가 지정할 필요가 없으므로 코드가 간결해진다. \n  * `사용 지점 변성(use site variance)`: 자바에서처럼 타입 파라미터가 있는 타입을 사용할때 마다 해당 타입 파라미터를 하위 타입이나 상위 타입 중 어떤 타입으로 대치할 수 있는지 명시하는 방법을 사용 지점 변성이라고 한다. 자바의 `한정 와일드카드 타입(bounded wildcard)`을 사용하는 것을 생각하면 된다.(`? extends` , `? super`) 물론 **코틀린도 자바에서처럼 사용 지점 변성을 지원한다.** 공변적이거나 혹은 반공변적인지 선언할 수 없다면 사용 지점 변성을 사용하여 타입 파라미터가 나오는 지점에 변성을 정의하면 된다.\n\n- 변성을 지정하지 않은 클래스를 사용할 때 변성에 대한 지정이 가능하다. 대표적인 예제로 MutableList가 있다. MutableList는 타입 파라미터로 넘어는 값을 생산할 수도 있고 소비할수도 있게 되는데, 변성에 대한 지정을 통하여 이를 제어할 수 있게 된다.\n\n```kotlin\nfun <T> copyData(source: MutableList<out T>, destination: MutableList<T>) {\n\tfor(item in source) {\n\t\tdestination.add(item)\n\t}\n}\n```\n- 위 예제에서 `source`의 타입 선언을 `MutableList<out T>`로 지정해뒀는데, out 키워드를 붙임으로서 무공변인 MutableList에서 공변으로 제약을 붙인 타입으로 프로젝션을 시킬 수 있게 된다. 이럴 경우 값을 소비하는 add 함수등을 사용하게 될 경우 `Out-projected type ....`과 같은 에러를 만나게 될 수 있다. \n- **정리하면, 타입 선언에서 [타입 파라미터를 사용하는 위치]라면 어디에나 [변성 변경자]를 붙일 수 있으며, [파라미터 타입, 로컬 변수 타입, 함수 반환 타입] 등에 타입 파라미터가 쓰이는 경우 in이나 out 변경자를 붙일 수 있다. 이를 가리켜 `타입 프로젝션(type projection)`이라 부른다.**\n  * `List<out T>`처럼 이미 변성 변경자가 붙어 있는 클래스에 out 프로젝션을 하는 것은 의미가 없으므로 컴파일러와 IDE가 친절하게(?) 경고를 하게 될 것이다.","slug":"Kotlin/Kotlin_In_Action","published":1,"updated":"2021-08-02T11:59:22.033Z","_id":"ckrsup51d0024tjhv0gfh3ani","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Kotlin-In-Action-Generics\"><a href=\"#Kotlin-In-Action-Generics\" class=\"headerlink\" title=\"Kotlin-In-Action Generics\"></a>Kotlin-In-Action Generics</h1><h2 id=\"9장-제네릭스\"><a href=\"#9장-제네릭스\" class=\"headerlink\" title=\"9장 제네릭스\"></a>9장 제네릭스</h2><ul>\n<li><code>실체화한 타입 파라미터</code>를 사용하면 인라인 함수 호출에서 타입 인자로 쓰인 구체적인 타입을 실행시점에 알 수 있다.</li>\n<li><code>선언 지점 변성</code>을 사용하면 기저 타입은 같지만, 타입 인자가 다른 두 제네릭 타입 <code>Type&lt;A&gt;</code>와 <code>Type&lt;B&gt;</code>가 있을 때 타입 인자 A와 B의 상위/하위 타입 관계에 따라 두 제네릭 타입의 상위/하위 타입 관계가 어떻게 되는지 지정할 수 있다.<ul>\n<li><code>List&lt;Any&gt;</code>를 인자로 받는 함수가 있다고 했을 때, <code>List&lt;Int&gt;</code>타입의 값을 전달할 수 있는지 여부를 선언 지점 변성을 통해 지정할수 있음.</li>\n</ul>\n</li>\n<li><code>사용 지점 변성</code>은 같은 목표(제네릭 타입 값 사이의 상위/하위 타입 관계 지정)를 제네릭 타입 값을 사용하는 위치에서 파라미터 타입에 대한 제약을 표시하는 방식으로 달성</li>\n</ul>\n<h2 id=\"제네릭-타입-파라미터\"><a href=\"#제네릭-타입-파라미터\" class=\"headerlink\" title=\"제네릭 타입 파라미터\"></a>제네릭 타입 파라미터</h2><ul>\n<li><p>제네릭 타입의 인스턴스를 만들기 위해서는 타입 파라미터를 구체적인 타입 인자(Type Argument)로 치환해야 한다.</p>\n<ul>\n<li>List 타입이 있다고 했을 때, 명확하게 <code>문자열을 담는 리스트 = List&lt;String&gt;</code></li>\n<li>Map 타입은 제네릭 타입변수로 <code>Map&lt;K, V&gt;</code>형태로 선언이 되어 있고, 이를 인스턴스화 할때 <code>Map&lt;String, Person&gt;</code>처럼 구체적인 타입 인자를 넘겨 인스턴스화 할수 있다.</li>\n</ul>\n</li>\n<li><p>코틀린 컴파일러의 경우, 보통 타입과 마찬가지로 타입 인자도 추론이 가능하다</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> authors = listOf(<span class=\"string\">&quot;John&quot;</span>, <span class=\"string\">&quot;Sveltna&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n<li><p>빈 리스트의 경우, 추론할 값이 없기 때문에 직접 타입을 명시 해줘야 한다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> authors: List&lt;String&gt; = emptyList();</span><br><span class=\"line\"><span class=\"keyword\">val</span> authors = emptyList&lt;String&gt;();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>제네릭 함수를 호출할 때는 반드시 구체 타입으로 타입 인자를 넘겨줘야 하는데, 대표적인 예로는 컬렉션을 다루는 함수들이 그 예시이다. 아래 <code>List&lt;T&gt;</code>의 slice 확장 함수를 예로 들면, 타입 파라미터 T가 수신객체와 반환 타입으로 사용된다. <strong>타입 추론이 가능한 구체 타입으로 사용 시, 별도로 제네릭 지정이 불필요하다.</strong></li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> List<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">slice</span><span class=\"params\">(indices: <span class=\"type\">IntRange</span>)</span></span>: List&lt;T&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>타입 파라미터 선언은 <code>클래스</code>, <code>인터페이스</code>, <code>클래스/인터페이스의 메소드</code>, <code>확장 함수</code>, <code>최상위 함수</code>에서 선언이 가능하다. </li>\n<li>코틀린에서는 아래와 같이 <code>제네릭 확장 프로퍼티</code> 선언이 가능하다. 확장 프로퍼티에 대해서만 가능하며 일반 프로퍼티는 타입 파라미터를 가질 수 없다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> &lt;T&gt; List&lt;T&gt;.penultimate: T</span><br><span class=\"line\">\t<span class=\"keyword\">get</span>() = <span class=\"keyword\">this</span>[size - <span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>자바와 마찬가지로 제네릭 클래스를 확장/구현하기 위해서는 하위 클래스에서 기저 클래스의 구체 타입을 명시하거나 혹은 타입 파라미터로 받은 타입을 넘겨줘야 확장/구현이 가능하다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringList</span>: <span class=\"type\">List</span>&lt;<span class=\"type\">String</span>&gt; </span>&#123; ... &#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"type\">T</span>&gt;: <span class=\"type\">List</span>&lt;<span class=\"type\">T</span>&gt; </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>타입 파리미터는 사용할 수 있는 타입을 제한할 수 있다. 타입 파라미터에 대한 <strong>상한(upper-bound)</strong> 을 지정한다고 표현하며 제네릭 타입을 인스턴스화 하는 시점에는 상한 타입이거나 혹은 상한 타입의 하위 타입만 가능하게 된다. <strong>상한을 지정하게 되면 해당 타입의 값은 상한 타입으로 취급이 가능하게 된다.</strong></p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T : Number&gt;</span> List<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">sum</span><span class=\"params\">()</span></span>: T <span class=\"comment\">// Kotlin</span></span><br><span class=\"line\">&lt;T extend Number&gt; T sum(List&lt;T&gt; list) <span class=\"comment\">// Java</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>두 인자값 중 큰 값을 찾는 제네릭 함수를 만든다고 할때, Comparable 인터페이스를 활용하여 코드를 작성한다고 해보자. </li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T: Comparable&lt;T&gt;</span>&gt; <span class=\"title\">max</span><span class=\"params\">(first: <span class=\"type\">T</span>, second: <span class=\"type\">T</span>)</span></span>: T &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 코틀린 컴파일러에 의해 first.compareTo(second) &gt; 0으로 변한다.</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">if</span> (first &gt; second) first <span class=\"keyword\">else</span> second</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">println(max(<span class=\"string\">&quot;kotlin&quot;</span>, <span class=\"string\">&quot;java&quot;</span>)) <span class=\"comment\">// kotlin</span></span><br><span class=\"line\">println(max(<span class=\"string\">&quot;kotlin&quot;</span>, <span class=\"number\">42</span><span class=\"string\">&quot;)) // 42의 경우 첫 번째 인자의 타입 정보와 일치하지 않기 때문에 컴파일 에러</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>타입 파라미터에 대해 두 가지 이상의 제약을 걸수도 있다. 아래 코드에서는 <code>CharSequence</code>와 <code>Appendable</code> 인터페이스를 구현해야 하는 제약을 건 예제이다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">ensureTraillingPeriod</span><span class=\"params\">(seq: <span class=\"type\">T</span>)</span></span> <span class=\"keyword\">where</span> T: CharSequence, T: Appendable &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!seq.endsWith(<span class=\"string\">&#x27;.&#x27;</span>)) seq.append(<span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>아무런 상한을 정하지 않을 경우 기본적으로 <code>&lt;T: Any?&gt;</code>로 선언한 것과 같다. Nullable이 아닌 타입 파라미터를 받고자 한다면 <code>&lt;T: Any&gt;</code>로 지정해야 한다.</p>\n</li>\n<li><p>만약 <code>&lt;T:Any&gt;</code>로 선언해둔 타입파라미터에 <code>String?</code>등과 같은 널 허용 타입을 지정하게 되면 String?은 Any의 하위 타입이 아니기 때문에 컴파일 에러가 발생하게 된다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&lt;<span class=\"type\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 타입 파라미터 T에 대해 별도의 상한을 지정하지 않았기 때문에 `Nullable`</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">process</span><span class=\"params\">(value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tvalue?.hashCode()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&lt;<span class=\"type\">T: Any</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 타입 파라미터 T에 대해 Any로 상한을 지정하였기 때문에 NonNull</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">process</span><span class=\"params\">(value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tvalue.hashCode()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"실행-시-제네릭스의-동작-소거된-타입-파리미터와-실체화된-타입-파라미터\"><a href=\"#실행-시-제네릭스의-동작-소거된-타입-파리미터와-실체화된-타입-파라미터\" class=\"headerlink\" title=\"실행 시 제네릭스의 동작: 소거된 타입 파리미터와 실체화된 타입 파라미터\"></a>실행 시 제네릭스의 동작: 소거된 타입 파리미터와 실체화된 타입 파라미터</h2><ul>\n<li>JVM에서 제네릭은 타입 소거(Type Erasure)를 사용해 구현되며 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다는 뜻이 된다.<blockquote>\n<p><code>List&lt;String&gt;</code>의 인스턴스를 만들더라도 런타임엔 List라는 타입정보만 남을뿐 String 원소를 저장하는지에 대한 정보를 알수 없다. 타입 정보가 지워지는 것이 단점만 있는 것은 아니고 전반적인 메모리 사용량이 줄어들기 때문에 나름 장점도 존재한다.</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> list1: List&lt;String&gt; = listOf(<span class=\"string\">&quot;a&quot;</span>,<span class=\"string\">&quot;b&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> list2: List&lt;<span class=\"built_in\">Int</span>&gt; = listOf(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>위 예제 코드를 통해 살펴보면, list1과 list2는 실제 런타임 시점에서는 List 타입으로만 취급되며 List의 제네릭 타입이 String인지 Int인지는 체크하는 것이 불가능하다. 다시 말해, <code>is</code>를 통한 타입 검사등은 할 수 없다는 이야기이다.</p>\n</li>\n<li><p>코틀린에서는 <code>inline</code> 함수를 사용해 타입 정보가 지워지지 않게 할 수 있는데 이러한 것을 가리켜 실체화(reified)라고 한다.</p>\n</li>\n<li><p>제네릭 타입을 알수 없을 경우 스타 프로젝션을 사용하여 포현하면 된다.</p>\n</li>\n<li><p>타입을 알수 없는 경우에도 <code>as</code> 혹은 <code>as?</code> 캐스팅은 가능하다. 하지만, 타입 인자가 다른 타입으로 캐스팅해도 캐스팅 자체를 성공해버리기 때문에 이점은 조심해야 한다.</p>\n</li>\n<li><p>아래 코드를 살펴보면 코드 자체는 컴파일에 성공하지만 인자로 넘어오는 값에 따라 여러 예외 상황을 맞이 할 수 있다. Set 인스턴스를 넘기게 될 경우 엘비스 이후에 있는 예외 코드가 실행이 되게 될것이고, <code>List&lt;String&gt;</code>의 인스턴스를 넘기게 될 경우 캐스팅은 성공하겠지만 sum() 함수를 호출하는 과정에서 <code>ClassCastException</code>을 만나게 될 것이다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">printSum</span><span class=\"params\">(c: <span class=\"type\">Collection</span>&lt;*&gt;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> intList = c <span class=\"keyword\">as</span>? List&lt;<span class=\"built_in\">Int</span>&gt; </span><br><span class=\"line\">\t?: <span class=\"keyword\">throw</span> IllegalArgumentException(<span class=\"string\">&quot;List is Expected&quot;</span>)</span><br><span class=\"line\">\tprintln(intList.sum())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>만약 컴파일 시점에 타입 정보를 추론할 수 있는 상황이라면 코틀린 컴파일러는 is 검사를 허용해준다. 아래 코드에서는 <code>Collection&lt;Int&gt;</code>로 넘어오는 인자 타입을 추론할 수 있는 상황이기 때문에 is 검사를 허용하게 해준다. </p>\n</li>\n<li><p>IDE에서 테스트해보면 <em><strong>안전하지 못한 is 체크는 금지하고 위험한 as 캐스팅은 warning을 출력한다.</strong></em></p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">printSumB</span><span class=\"params\">(c: <span class=\"type\">Collection</span>&lt;<span class=\"type\">Int</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c <span class=\"keyword\">is</span> List&lt;<span class=\"built_in\">Int</span>&gt;) &#123;</span><br><span class=\"line\">\t\tprintln(c.sum())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>inline</code> 함수를 사용하여 타입 파라미터 실체화를 사용하게 되면, 실행 시점에 인라인 함수의 타입인자를 알수 있게 되는데, 만약 인라인 함수가 람다를 인자로 사용하는 상황이라면 별도의 익명 클래스나 객체가 생성되지 않기 때문에 성능상으로 좀 더 나아질 수도 있다.</p>\n</li>\n<li><p>컴파일러는 인라인 함수의 본문을 구현한 바이트코드를 함수가 호출되는 모든 지점에 삽입하게 되고 컴파일러는 호출한 부분의 타입 인자를 활용해 해당 함수에서 사용하는 정확한 타입 정보를 알수 있게 된다. </p>\n</li>\n<li><p>Iterable.filterIsInstance 표준 함수를 예시로 살펴보면, 실제 filterIsInstance를 호출하는 함수 내부에서 inline 함수를 호출하기 때문에 해당 함수 본문의 바이트코드가 호출한 부분에 채워지게 된다. 본문을 대치하게 됨으로써 실제 제네릭으로 넘어간 타입 정보 역시 런타임에서도 타입 정보가 지워지지 않고 유지된다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">reifiedFilterList</span><span class=\"params\">()</span></span>: List&lt;String&gt; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> listOf(<span class=\"string\">&quot;one&quot;</span>, <span class=\"number\">2</span>, <span class=\"string\">&quot;three&quot;</span>)</span><br><span class=\"line\">\t.filterIsInstance&lt;String&gt;()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 함수 선언부</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;<span class=\"keyword\">reified</span> R&gt;</span> Iterable<span class=\"type\">&lt;*&gt;</span>.<span class=\"title\">filterIsInstance</span><span class=\"params\">()</span></span>: List&lt;R&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>자바코드에서 코틀린 코드를 호출할 경우, inline 함수의 실체화된 타입 파라미터는 사용할 수 없다고 한다.</strong> </p>\n<blockquote>\n<p>자바에서는 코틀린의 함수를 보통 함수처럼 호출하기 때문에 코틀린에서처럼 인라인 함수의 본문 대치가 불가능하다.</p>\n</blockquote>\n</li>\n<li><p>보통 inline 함수에서는 람다를 사용한 코드가 일반적인데, 위 filterIsInstance의 경우 람다 선언이 없이 구체화된 타입 정보를 런타임에 알기 위해 사용한 것이다. 일반적으로 람다를 사용하지 않는 인라인 함수는 성능적으로 유리하지 않으며 JVM내에서도 일반 함수를 호출해도 강력하게 인라이닝할 수 있도록 기술적인 장치가 존재한다고 한다.</p>\n<ul>\n<li><a href=\"https://www.baeldung.com/jvm-method-inlining\">baeldung_jvm-method-inlining</a></li>\n</ul>\n</li>\n<li><p><code>java.lang.Class</code> 타입 인자를 인자로 받아서 처리하는 코드를 만들 때, inline 함수의 실체화 타입 파라미터를 사용하는 것 또한 유용하다. 클래스 타 타입 인자를 받아서 처리하는 API 중 대표적인 유스케이스로는 JDK의 ServiceLoader가 있고, 또한 자주 사용하는 <code>jackson</code>과 같은 직렬화/역직렬화 라이브러리에서도 클래스 타입 인자를 넘겨서 처리하는 API가 존재한다.</p>\n</li>\n<li><p>아래의 예제 코드처럼 타입 파라미터로 전달된 T에 대해 <code>::class.java</code> 구문을 사용하여 클래스에 대한 참조를 얻는 방법도 가능하다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;<span class=\"keyword\">reified</span> T: Any&gt;</span> <span class=\"title\">getServiceLoader</span><span class=\"params\">()</span></span>: ServiceLoader&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ServiceLoader.load(T::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// jackson-module-kotlin</span></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;<span class=\"keyword\">reified</span> T&gt;</span> <span class=\"title\">jacksonTypeRef</span><span class=\"params\">()</span></span>: TypeReference&lt;T&gt; = <span class=\"keyword\">object</span>: TypeReference&lt;T&gt;() &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>실체화 타입 파라미터의 사용 가능한 경우와 제약사항은 아래와 같다.</p>\n<ul>\n<li>사용 가능한 경우<ul>\n<li>타입 검사와 캐스팅(is, as)</li>\n<li>리플렉션 API</li>\n<li>코틀린 타입에 대응하는 자바 Class 타입 얻기(::class.java)</li>\n<li>다른 함수 호출 시, 타입 인자로 사용</li>\n</ul>\n</li>\n<li>제약 사항<ul>\n<li>타입 파라미터의 인스턴스 생성</li>\n<li>타입 파라미터 클래스의 동반 객체 메소드 호출</li>\n<li>일반 타입파라미터를 실체화 타입 파라미터를 인자로 받는 함수에 넘기기</li>\n<li>클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 <code>reified</code>로 지정</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>실체화 타입 파라미터를 사용하는 인라인 함수에서 람다를 사용하게 될 경우, 경우에 따라 인라이닝을 할 수 없는 경우도 발생하기도 하며, 성능 문제로 인라이닝을 안하고 싶을 수도 있다. 이럴 경우 <code>noinline</code> 키워드를 사용하여 인라이닝을 금지 시킬수 있다.</p>\n</li>\n</ul>\n<h2 id=\"변성-variance\"><a href=\"#변성-variance\" class=\"headerlink\" title=\"변성(variance)\"></a>변성(variance)</h2><ul>\n<li><p>기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념</p>\n<blockquote>\n<p><code>List&lt;String&gt;</code>, <code>List&lt;Any&gt;</code>와 같이 기저 타입이 같고 타입이 인자가 다를 경우</p>\n</blockquote>\n</li>\n<li><p>변성은 코드에서 위험할 여지가 있는 메소드를 호출할 수 없게 만듬으로써 제네릭 타입의 인스턴스 역할을 하는 클래스 인스턴스를 잘못 사용하는 일이 없게 방지하는 역할을 수행한다.</p>\n</li>\n<li><p><code>String</code>의 경우 <code>Any</code>를 확장하기 때문에 <code>Any</code>타입을 받는 함수에 <code>String</code>타입의 인자를 넘겨도 안전하겠지만, <code>List&lt;String&gt;</code>, <code>List&lt;Any&gt;</code>의 경우 확실한 안정성을 이야기할 순 없다. 아래 예제를 보면, 문자열로 선언된 mutableList에 정수값 42가 추가되고 maxBy 함수를 호출하는 과정에서 Integer에 대해 캐스팅 익셉션이 발생하는 걸 확인할 수 있다. </p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">printContents</span><span class=\"params\">(list: <span class=\"type\">List</span>&lt;<span class=\"type\">Any</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">\tprintln(list.joinToString())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">addAnswer</span><span class=\"params\">(list: <span class=\"type\">MutableList</span>&lt;<span class=\"type\">Any</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">\tlist.add(<span class=\"number\">42</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> strings = mutableListOf(<span class=\"string\">&quot;abc&quot;</span>, <span class=\"string\">&quot;bac&quot;</span>)</span><br><span class=\"line\">addAnswer(strings)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ClassCastException: Integer cannot be cast to String</span></span><br><span class=\"line\">println(strings.maxBy &#123; it.length &#125;) </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>어떤 함수가 만약 리스트의 값을 추가/변경하면 타입 불일치가 생길 수 있으니 <code>List&lt;Any&gt;</code> 대신 <code>List&lt;String&gt;</code>을 넘길 수 없다. 하지만, 원소의 추가/변경이 없을 경우 <code>List&lt;Any&gt;</code> 대신 <code>List&lt;String&gt;</code>을 넘겨도 안전하다. 코틀린에서는 리스트의 변경 가능성에 따라 적절한 인터페이스를 선택하게 되면 추가/변경을 막을 수 있어 안전하지 못한 호출을 막을 수 있다.</p>\n</li>\n<li><p><code>타입 =! 클래스</code></p>\n<ul>\n<li><strong>제네릭 클래스가 아닌 경우 클래스 이름을 타입으로 바로 사용할 수 있다.</strong> 단순한 예제로 <code>val x: String</code>가 있다.</li>\n<li>제네릭 클래스에서는 상황이 복잡하다. <code>List</code>는 타입이 아니고 클래스이며 실제 타입 파라미터가 추가된 <code>List&lt;String&gt;</code>, <code>List&lt;Int&gt;</code> 등이 제대로 된 타입이다. 제네릭 클래스는 결국 무수하게 많은 타입을 만들 수 있게 된다.</li>\n</ul>\n</li>\n<li><p><code>하위 타입</code></p>\n<ul>\n<li>A 타입의 값을 받을 수 있는 인자에 B 타입 값이 들어갈 수 있다면 <code>A타입은 B타입의 상위 타입</code>, <code>B타입은 A타입의 하위 타입</code> 으로 정리할 수 있다. 예를 들어, <code>Number</code>타입의 인자를 받을 수 있는 함수에 <code>Int</code>값을 넘길 수 있기에 둘 사이의 관계는 <code>Number타입은 Int타입의 상위 타입</code>, <code>Int타입은 Number타입의 하위 타입</code>으로 상/하위 타입 관계를 표현할 수 있게 된다.</li>\n</ul>\n</li>\n<li><p><strong>타입 관계의 중요성은 컴파일러가 변수 대입이나 인자 전달 시 하위 타입 검사를 매번 수행하기 때문이다.</strong> Int 타입의 인자를 받는 함수에 Number 타입 인자를 넣어 호출하게 되면 하위 타입 검사에서 Int 타입의 하위 타입이 Number가 아니기 때문에 컴파일이 되지 않게 된다.</p>\n</li>\n<li><p>간단한 경우 하위 타입은 하위 클래스와 같게 된다. 앞에서의 예처럼 Int 클래스는 Number 클래스의 하위 클래스이므로 Int는 Number의 하위 타입이다. </p>\n</li>\n<li><p>하지만 코틀린의 Nullable과 NonNull 타입의 관계를 생각해보면 이야기가 조금 더 복잡해지는데, <code>Int?</code> 타입 선언에는 <code>Int</code>타입의 값을 넣거나 변수 선언을 해도 무관하지만, 반대로 <code>Int</code>타입엔 <code>Int?</code>를 선언하는 건 불가능하기 때문에 둘 사이의 관계는 <code>Int?타입은 Int타입의 상위 타입</code> 혹은 <code>Int타입은 Int?타입의 하위 타입</code>이라고 정리할 수 있다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> s: String = <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> t: String? = s <span class=\"comment\">// String이 String?의 하위 타입이므로 이 대입은 가능</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>제네릭 타입을 인스턴스화 할때, 타입 인자에 서로 다른 타입이 들어가고 서로 하위 타입 관계가 성립하지 않은 걸 가리켜 <code>무공변(invariant)</code>라고 한다.</p>\n</li>\n<li><p>타입 A가 B의 하위 타입이면 <code>List&lt;A&gt;</code>는 <code>List&lt;B&gt;</code>의 하위 타입이며 이런 관계를 <code>공변적(covariant)</code>라고 한다.</p>\n</li>\n<li><p><strong>공변성(<code>covariant</code>)</strong></p>\n<ul>\n<li>공변적인 관계를 표현할 때는 out 키워드를 넣어 표현한다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Producer</span>&lt;<span class=\"type\">out T</span>&gt; </span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">produce</span><span class=\"params\">()</span></span>: T</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>클래스의 타입 파라미터를 공변적으로 만들면 함수 정의에 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 그 클래스의 인스턴스를 함수 인자나 반환 값으로 사용할 수 있다.</li>\n<li>타입 파라미터를 공변적으로 지정하면 클래스 내부에서 그 파라미터를 사용하는 방법을 제한한다<ul>\n<li>타입 안정성을 위해 항상 아웃(out) 위치에 있어야 한다. 클래스가 타입의 값을 생상할 수 있지만 값을 소비할 수 없다는 이야기이다.</li>\n</ul>\n</li>\n<li>클래스 맴버 선언 시, 타입 파라미터를 사용할 수 있는 지점은 out/in으로 나뉘며, out으로 선언할 경우 반환 타입(생산)에 쓰이며 in 으로 선언할 경우 값을 소비하는 역할로 한정이 된다. </li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Transformaer</span>&lt;<span class=\"type\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// t의 인자는 in 위치, 반환 타입 T는 out 위치</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">transform</span><span class=\"params\">(t: <span class=\"type\">T</span>)</span></span>: T</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>다시 정리하면, 공변성은 하위 타입 관계가 유지되며, 아웃 키워드를 통해 공변성을 표현하며 아웃으로 선언하게 되면 아웃 위치에서만 사용이 가능하다.</strong></li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Herd</span>&lt;<span class=\"type\">out T: Animal</span>&gt; </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">val</span> size: <span class=\"built_in\">Int</span></span><br><span class=\"line\">\t<span class=\"keyword\">get</span>() = ...</span><br><span class=\"line\"><span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get</span><span class=\"params\">(i: <span class=\"type\">Int</span>)</span></span>: T &#123; ... &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>위 클래스는 Herd 클래스에 Animal의 하위 타입을 받는 타입이며, 공변성을 표현하고 있고 타입 한정을 Animal로 지정하여 T타입은 자연스럽게 Animal 타입으로 취급된다. 또한 공변성을 표현하고 있기 때문에 반환 타입으로만 해당 타입을 지정하는 것이 가능하다.<br>또한, Animal뿐만 아니라 이를 상속하는 타입이 있다면 해당 타입을 타입 파라미터로 지정하는 것이 가능하다. 예를 들어 Cat이 Animal의 하위 타입이라면 get을 호출하는 부분에서 Cat을 반환해도 아무런 문제가 없게 된다.</p>\n</li>\n<li><p>타입 파라미터는 함수 파라미터 타입이나 반환 타입으로만 쓰이지 않고, 다른 타입 파라미터의 인자로도 사용할 수 있다.</p>\n</li>\n<li><p>생성자 파라미터는 인이나 아웃 어느 쪽도 아니며 타입 파라미터가 out 으로 선언되어 있어도 그 타입을 생성자 파라미터 선언에 사용할 수 있다. 생성자는 나중에 호출할 수 있는 메소드가 아니기 때문에 위험할 여지가 없다.</p>\n</li>\n<li><p><code>val</code>, <code>var</code> 키워드를 생성자 파라미터에 사용할 경우 게터 혹은 세터를 정의하는 것고 같기 때문에 읽기 전용 프로퍼티는 아웃 위치에 그리고 변경 가능 프로퍼티는 인 위치에 해당한다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Herd</span>&lt;<span class=\"type\">T: Animal</span>&gt;</span>(<span class=\"keyword\">var</span> leadAnimal: T, <span class=\"keyword\">vararg</span> animals: T) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>반공변성(<code>contravariance</code>)</strong></p>\n<ul>\n<li>타입 B가 A의 하위 타입인 경우, <code>Consumer&lt;A&gt;</code>가 <code>Consumer&lt;B&gt;</code>의 하위 타입인 관계가 성립하면 제네릭 클래스 <code>Consumer&lt;T&gt;</code>는 타입 인자 T에 대해 <code>반공변</code>을 표현한다고 할 수 있다.<ul>\n<li>Animal의 하위 타입인 Cat이 <code>Consumer&lt;Animal&gt;</code>가 <code>Consumer&lt;Cat&gt;</code>의 하위 타입 관계가 성립될 경우 이를 반공변 관계가 성립한다고 할 수 있다.</li>\n</ul>\n</li>\n<li>in이라는 키워드는 그 키워드가 붙은 타입이 이 클래스의 메소드 안으로 전달돼 메소드에 의해 소비된다는 뜻이다. 다시 말해, 오직 인 위치에서만 사용할 수 있다는 뜻이다.</li>\n</ul>\n</li>\n<li><p><strong>공변 vs 반공변 vs 무공변</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">공변성</th>\n<th align=\"left\">반공변성</th>\n<th align=\"left\">무공변성</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>Producer&lt;out T&gt;</code></td>\n<td align=\"left\"><code>Consumer&lt;in T&gt;</code></td>\n<td align=\"left\"><code>MutableList&lt;T&gt;</code></td>\n</tr>\n<tr>\n<td align=\"left\">타입 인자의 하위 타입 관계가 <br/>제네릭 타입에서도 유지된다.</td>\n<td align=\"left\">타입 인자의 하위 타입 관계가<br/>제네릭 타입에서 뒤집힌다.</td>\n<td align=\"left\">하위 타입 관계가 성립하지 않음</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Producer&lt;Cat&gt;</code>은 <code>Producer&lt;Animal&gt;</code>의 하위 타입이다.</td>\n<td align=\"left\"><code>Consumer&lt;Animal&gt;</code>은 <code>Consumer&lt;Cat&gt;</code>의   하위 타입이다.</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">T를 아웃 위치에서만 사용</td>\n<td align=\"left\">T를 인 위치에서만 사용</td>\n<td align=\"left\">T를 아무 위치에서나 사용 가능</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>아래 Function 인터페이스은 공변과 반공변을 설명하기 아주 좋은 예제이다. 인자로 받는 P 타입에 대해서는 반공변성을 유지하며, R 타입에 대해서는 공변성을 띄게 된다. </p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Function1</span>&lt;<span class=\"type\">in P, out R</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">invoke</span><span class=\"params\">(p: <span class=\"type\">P</span>)</span></span>: R</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Cat과 Animal의 예제를 위 Function1에 대입해보면 <code>(Cat) -&gt; Number</code>와 <code>(Animal) -&gt; Int</code>에서도 하위 타입 관계가 성립하게 된다. 위 Function1의 경우 코틀린의 표현으로 바꿔보자면 <code>(Cat) -&gt; Number</code>를 받는 인자에 <code>(Animal) -&gt; Int</code>의 함수 인스턴스를 넘기더라도 하위 타입 관계가 성립하기 때문에 호출에 문제가 없게 되는 것이다. </li>\n</ul>\n<blockquote>\n<p>다시 정리하면 반공변의 경우 타입의 하위 관계를 반대로, 공변의 경우 타입의 하위 관계를 그대로 유지, 무공변의 경우 타입 파라미터간의 하위 타입 관계가 전혀 없는 것으로 정리할 수 있다.</p>\n</blockquote>\n<ul>\n<li><p><strong>변성의 종류</strong></p>\n<ul>\n<li><code>선언 지점 변성(declaration site variance)</code>: 클래스 선언에 지정하는 것을 선언 지점 변성이라 부르며, 한번의 선언만으로 변성을 추가 지정할 필요가 없으므로 코드가 간결해진다. </li>\n<li><code>사용 지점 변성(use site variance)</code>: 자바에서처럼 타입 파라미터가 있는 타입을 사용할때 마다 해당 타입 파라미터를 하위 타입이나 상위 타입 중 어떤 타입으로 대치할 수 있는지 명시하는 방법을 사용 지점 변성이라고 한다. 자바의 <code>한정 와일드카드 타입(bounded wildcard)</code>을 사용하는 것을 생각하면 된다.(<code>? extends</code> , <code>? super</code>) 물론 <strong>코틀린도 자바에서처럼 사용 지점 변성을 지원한다.</strong> 공변적이거나 혹은 반공변적인지 선언할 수 없다면 사용 지점 변성을 사용하여 타입 파라미터가 나오는 지점에 변성을 정의하면 된다.</li>\n</ul>\n</li>\n<li><p>변성을 지정하지 않은 클래스를 사용할 때 변성에 대한 지정이 가능하다. 대표적인 예제로 MutableList가 있다. MutableList는 타입 파라미터로 넘어는 값을 생산할 수도 있고 소비할수도 있게 되는데, 변성에 대한 지정을 통하여 이를 제어할 수 있게 된다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">copyData</span><span class=\"params\">(source: <span class=\"type\">MutableList</span>&lt;<span class=\"type\">out</span> <span class=\"type\">T</span>&gt;, destination: <span class=\"type\">MutableList</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(item <span class=\"keyword\">in</span> source) &#123;</span><br><span class=\"line\">\t\tdestination.add(item)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>위 예제에서 <code>source</code>의 타입 선언을 <code>MutableList&lt;out T&gt;</code>로 지정해뒀는데, out 키워드를 붙임으로서 무공변인 MutableList에서 공변으로 제약을 붙인 타입으로 프로젝션을 시킬 수 있게 된다. 이럴 경우 값을 소비하는 add 함수등을 사용하게 될 경우 <code>Out-projected type ....</code>과 같은 에러를 만나게 될 수 있다. </li>\n<li><strong>정리하면, 타입 선언에서 [타입 파라미터를 사용하는 위치]라면 어디에나 [변성 변경자]를 붙일 수 있으며, [파라미터 타입, 로컬 변수 타입, 함수 반환 타입] 등에 타입 파라미터가 쓰이는 경우 in이나 out 변경자를 붙일 수 있다. 이를 가리켜 <code>타입 프로젝션(type projection)</code>이라 부른다.</strong><ul>\n<li><code>List&lt;out T&gt;</code>처럼 이미 변성 변경자가 붙어 있는 클래스에 out 프로젝션을 하는 것은 의미가 없으므로 컴파일러와 IDE가 친절하게(?) 경고를 하게 될 것이다.</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Kotlin-In-Action-Generics\"><a href=\"#Kotlin-In-Action-Generics\" class=\"headerlink\" title=\"Kotlin-In-Action Generics\"></a>Kotlin-In-Action Generics</h1><h2 id=\"9장-제네릭스\"><a href=\"#9장-제네릭스\" class=\"headerlink\" title=\"9장 제네릭스\"></a>9장 제네릭스</h2><ul>\n<li><code>실체화한 타입 파라미터</code>를 사용하면 인라인 함수 호출에서 타입 인자로 쓰인 구체적인 타입을 실행시점에 알 수 있다.</li>\n<li><code>선언 지점 변성</code>을 사용하면 기저 타입은 같지만, 타입 인자가 다른 두 제네릭 타입 <code>Type&lt;A&gt;</code>와 <code>Type&lt;B&gt;</code>가 있을 때 타입 인자 A와 B의 상위/하위 타입 관계에 따라 두 제네릭 타입의 상위/하위 타입 관계가 어떻게 되는지 지정할 수 있다.<ul>\n<li><code>List&lt;Any&gt;</code>를 인자로 받는 함수가 있다고 했을 때, <code>List&lt;Int&gt;</code>타입의 값을 전달할 수 있는지 여부를 선언 지점 변성을 통해 지정할수 있음.</li>\n</ul>\n</li>\n<li><code>사용 지점 변성</code>은 같은 목표(제네릭 타입 값 사이의 상위/하위 타입 관계 지정)를 제네릭 타입 값을 사용하는 위치에서 파라미터 타입에 대한 제약을 표시하는 방식으로 달성</li>\n</ul>\n<h2 id=\"제네릭-타입-파라미터\"><a href=\"#제네릭-타입-파라미터\" class=\"headerlink\" title=\"제네릭 타입 파라미터\"></a>제네릭 타입 파라미터</h2><ul>\n<li><p>제네릭 타입의 인스턴스를 만들기 위해서는 타입 파라미터를 구체적인 타입 인자(Type Argument)로 치환해야 한다.</p>\n<ul>\n<li>List 타입이 있다고 했을 때, 명확하게 <code>문자열을 담는 리스트 = List&lt;String&gt;</code></li>\n<li>Map 타입은 제네릭 타입변수로 <code>Map&lt;K, V&gt;</code>형태로 선언이 되어 있고, 이를 인스턴스화 할때 <code>Map&lt;String, Person&gt;</code>처럼 구체적인 타입 인자를 넘겨 인스턴스화 할수 있다.</li>\n</ul>\n</li>\n<li><p>코틀린 컴파일러의 경우, 보통 타입과 마찬가지로 타입 인자도 추론이 가능하다</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> authors = listOf(<span class=\"string\">&quot;John&quot;</span>, <span class=\"string\">&quot;Sveltna&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n<li><p>빈 리스트의 경우, 추론할 값이 없기 때문에 직접 타입을 명시 해줘야 한다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> authors: List&lt;String&gt; = emptyList();</span><br><span class=\"line\"><span class=\"keyword\">val</span> authors = emptyList&lt;String&gt;();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>제네릭 함수를 호출할 때는 반드시 구체 타입으로 타입 인자를 넘겨줘야 하는데, 대표적인 예로는 컬렉션을 다루는 함수들이 그 예시이다. 아래 <code>List&lt;T&gt;</code>의 slice 확장 함수를 예로 들면, 타입 파라미터 T가 수신객체와 반환 타입으로 사용된다. <strong>타입 추론이 가능한 구체 타입으로 사용 시, 별도로 제네릭 지정이 불필요하다.</strong></li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> List<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">slice</span><span class=\"params\">(indices: <span class=\"type\">IntRange</span>)</span></span>: List&lt;T&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>타입 파라미터 선언은 <code>클래스</code>, <code>인터페이스</code>, <code>클래스/인터페이스의 메소드</code>, <code>확장 함수</code>, <code>최상위 함수</code>에서 선언이 가능하다. </li>\n<li>코틀린에서는 아래와 같이 <code>제네릭 확장 프로퍼티</code> 선언이 가능하다. 확장 프로퍼티에 대해서만 가능하며 일반 프로퍼티는 타입 파라미터를 가질 수 없다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> &lt;T&gt; List&lt;T&gt;.penultimate: T</span><br><span class=\"line\">\t<span class=\"keyword\">get</span>() = <span class=\"keyword\">this</span>[size - <span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>자바와 마찬가지로 제네릭 클래스를 확장/구현하기 위해서는 하위 클래스에서 기저 클래스의 구체 타입을 명시하거나 혹은 타입 파라미터로 받은 타입을 넘겨줘야 확장/구현이 가능하다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringList</span>: <span class=\"type\">List</span>&lt;<span class=\"type\">String</span>&gt; </span>&#123; ... &#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"type\">T</span>&gt;: <span class=\"type\">List</span>&lt;<span class=\"type\">T</span>&gt; </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>타입 파리미터는 사용할 수 있는 타입을 제한할 수 있다. 타입 파라미터에 대한 <strong>상한(upper-bound)</strong> 을 지정한다고 표현하며 제네릭 타입을 인스턴스화 하는 시점에는 상한 타입이거나 혹은 상한 타입의 하위 타입만 가능하게 된다. <strong>상한을 지정하게 되면 해당 타입의 값은 상한 타입으로 취급이 가능하게 된다.</strong></p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T : Number&gt;</span> List<span class=\"type\">&lt;T&gt;</span>.<span class=\"title\">sum</span><span class=\"params\">()</span></span>: T <span class=\"comment\">// Kotlin</span></span><br><span class=\"line\">&lt;T extend Number&gt; T sum(List&lt;T&gt; list) <span class=\"comment\">// Java</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>두 인자값 중 큰 값을 찾는 제네릭 함수를 만든다고 할때, Comparable 인터페이스를 활용하여 코드를 작성한다고 해보자. </li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T: Comparable&lt;T&gt;</span>&gt; <span class=\"title\">max</span><span class=\"params\">(first: <span class=\"type\">T</span>, second: <span class=\"type\">T</span>)</span></span>: T &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 코틀린 컴파일러에 의해 first.compareTo(second) &gt; 0으로 변한다.</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">if</span> (first &gt; second) first <span class=\"keyword\">else</span> second</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">println(max(<span class=\"string\">&quot;kotlin&quot;</span>, <span class=\"string\">&quot;java&quot;</span>)) <span class=\"comment\">// kotlin</span></span><br><span class=\"line\">println(max(<span class=\"string\">&quot;kotlin&quot;</span>, <span class=\"number\">42</span><span class=\"string\">&quot;)) // 42의 경우 첫 번째 인자의 타입 정보와 일치하지 않기 때문에 컴파일 에러</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>타입 파라미터에 대해 두 가지 이상의 제약을 걸수도 있다. 아래 코드에서는 <code>CharSequence</code>와 <code>Appendable</code> 인터페이스를 구현해야 하는 제약을 건 예제이다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">ensureTraillingPeriod</span><span class=\"params\">(seq: <span class=\"type\">T</span>)</span></span> <span class=\"keyword\">where</span> T: CharSequence, T: Appendable &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!seq.endsWith(<span class=\"string\">&#x27;.&#x27;</span>)) seq.append(<span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>아무런 상한을 정하지 않을 경우 기본적으로 <code>&lt;T: Any?&gt;</code>로 선언한 것과 같다. Nullable이 아닌 타입 파라미터를 받고자 한다면 <code>&lt;T: Any&gt;</code>로 지정해야 한다.</p>\n</li>\n<li><p>만약 <code>&lt;T:Any&gt;</code>로 선언해둔 타입파라미터에 <code>String?</code>등과 같은 널 허용 타입을 지정하게 되면 String?은 Any의 하위 타입이 아니기 때문에 컴파일 에러가 발생하게 된다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&lt;<span class=\"type\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 타입 파라미터 T에 대해 별도의 상한을 지정하지 않았기 때문에 `Nullable`</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">process</span><span class=\"params\">(value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tvalue?.hashCode()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&lt;<span class=\"type\">T: Any</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 타입 파라미터 T에 대해 Any로 상한을 지정하였기 때문에 NonNull</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">process</span><span class=\"params\">(value: <span class=\"type\">T</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tvalue.hashCode()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"실행-시-제네릭스의-동작-소거된-타입-파리미터와-실체화된-타입-파라미터\"><a href=\"#실행-시-제네릭스의-동작-소거된-타입-파리미터와-실체화된-타입-파라미터\" class=\"headerlink\" title=\"실행 시 제네릭스의 동작: 소거된 타입 파리미터와 실체화된 타입 파라미터\"></a>실행 시 제네릭스의 동작: 소거된 타입 파리미터와 실체화된 타입 파라미터</h2><ul>\n<li>JVM에서 제네릭은 타입 소거(Type Erasure)를 사용해 구현되며 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다는 뜻이 된다.<blockquote>\n<p><code>List&lt;String&gt;</code>의 인스턴스를 만들더라도 런타임엔 List라는 타입정보만 남을뿐 String 원소를 저장하는지에 대한 정보를 알수 없다. 타입 정보가 지워지는 것이 단점만 있는 것은 아니고 전반적인 메모리 사용량이 줄어들기 때문에 나름 장점도 존재한다.</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> list1: List&lt;String&gt; = listOf(<span class=\"string\">&quot;a&quot;</span>,<span class=\"string\">&quot;b&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> list2: List&lt;<span class=\"built_in\">Int</span>&gt; = listOf(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>위 예제 코드를 통해 살펴보면, list1과 list2는 실제 런타임 시점에서는 List 타입으로만 취급되며 List의 제네릭 타입이 String인지 Int인지는 체크하는 것이 불가능하다. 다시 말해, <code>is</code>를 통한 타입 검사등은 할 수 없다는 이야기이다.</p>\n</li>\n<li><p>코틀린에서는 <code>inline</code> 함수를 사용해 타입 정보가 지워지지 않게 할 수 있는데 이러한 것을 가리켜 실체화(reified)라고 한다.</p>\n</li>\n<li><p>제네릭 타입을 알수 없을 경우 스타 프로젝션을 사용하여 포현하면 된다.</p>\n</li>\n<li><p>타입을 알수 없는 경우에도 <code>as</code> 혹은 <code>as?</code> 캐스팅은 가능하다. 하지만, 타입 인자가 다른 타입으로 캐스팅해도 캐스팅 자체를 성공해버리기 때문에 이점은 조심해야 한다.</p>\n</li>\n<li><p>아래 코드를 살펴보면 코드 자체는 컴파일에 성공하지만 인자로 넘어오는 값에 따라 여러 예외 상황을 맞이 할 수 있다. Set 인스턴스를 넘기게 될 경우 엘비스 이후에 있는 예외 코드가 실행이 되게 될것이고, <code>List&lt;String&gt;</code>의 인스턴스를 넘기게 될 경우 캐스팅은 성공하겠지만 sum() 함수를 호출하는 과정에서 <code>ClassCastException</code>을 만나게 될 것이다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">printSum</span><span class=\"params\">(c: <span class=\"type\">Collection</span>&lt;*&gt;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">val</span> intList = c <span class=\"keyword\">as</span>? List&lt;<span class=\"built_in\">Int</span>&gt; </span><br><span class=\"line\">\t?: <span class=\"keyword\">throw</span> IllegalArgumentException(<span class=\"string\">&quot;List is Expected&quot;</span>)</span><br><span class=\"line\">\tprintln(intList.sum())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>만약 컴파일 시점에 타입 정보를 추론할 수 있는 상황이라면 코틀린 컴파일러는 is 검사를 허용해준다. 아래 코드에서는 <code>Collection&lt;Int&gt;</code>로 넘어오는 인자 타입을 추론할 수 있는 상황이기 때문에 is 검사를 허용하게 해준다. </p>\n</li>\n<li><p>IDE에서 테스트해보면 <em><strong>안전하지 못한 is 체크는 금지하고 위험한 as 캐스팅은 warning을 출력한다.</strong></em></p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">printSumB</span><span class=\"params\">(c: <span class=\"type\">Collection</span>&lt;<span class=\"type\">Int</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c <span class=\"keyword\">is</span> List&lt;<span class=\"built_in\">Int</span>&gt;) &#123;</span><br><span class=\"line\">\t\tprintln(c.sum())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>inline</code> 함수를 사용하여 타입 파라미터 실체화를 사용하게 되면, 실행 시점에 인라인 함수의 타입인자를 알수 있게 되는데, 만약 인라인 함수가 람다를 인자로 사용하는 상황이라면 별도의 익명 클래스나 객체가 생성되지 않기 때문에 성능상으로 좀 더 나아질 수도 있다.</p>\n</li>\n<li><p>컴파일러는 인라인 함수의 본문을 구현한 바이트코드를 함수가 호출되는 모든 지점에 삽입하게 되고 컴파일러는 호출한 부분의 타입 인자를 활용해 해당 함수에서 사용하는 정확한 타입 정보를 알수 있게 된다. </p>\n</li>\n<li><p>Iterable.filterIsInstance 표준 함수를 예시로 살펴보면, 실제 filterIsInstance를 호출하는 함수 내부에서 inline 함수를 호출하기 때문에 해당 함수 본문의 바이트코드가 호출한 부분에 채워지게 된다. 본문을 대치하게 됨으로써 실제 제네릭으로 넘어간 타입 정보 역시 런타임에서도 타입 정보가 지워지지 않고 유지된다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">reifiedFilterList</span><span class=\"params\">()</span></span>: List&lt;String&gt; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> listOf(<span class=\"string\">&quot;one&quot;</span>, <span class=\"number\">2</span>, <span class=\"string\">&quot;three&quot;</span>)</span><br><span class=\"line\">\t.filterIsInstance&lt;String&gt;()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 함수 선언부</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;<span class=\"keyword\">reified</span> R&gt;</span> Iterable<span class=\"type\">&lt;*&gt;</span>.<span class=\"title\">filterIsInstance</span><span class=\"params\">()</span></span>: List&lt;R&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>자바코드에서 코틀린 코드를 호출할 경우, inline 함수의 실체화된 타입 파라미터는 사용할 수 없다고 한다.</strong> </p>\n<blockquote>\n<p>자바에서는 코틀린의 함수를 보통 함수처럼 호출하기 때문에 코틀린에서처럼 인라인 함수의 본문 대치가 불가능하다.</p>\n</blockquote>\n</li>\n<li><p>보통 inline 함수에서는 람다를 사용한 코드가 일반적인데, 위 filterIsInstance의 경우 람다 선언이 없이 구체화된 타입 정보를 런타임에 알기 위해 사용한 것이다. 일반적으로 람다를 사용하지 않는 인라인 함수는 성능적으로 유리하지 않으며 JVM내에서도 일반 함수를 호출해도 강력하게 인라이닝할 수 있도록 기술적인 장치가 존재한다고 한다.</p>\n<ul>\n<li><a href=\"https://www.baeldung.com/jvm-method-inlining\">baeldung_jvm-method-inlining</a></li>\n</ul>\n</li>\n<li><p><code>java.lang.Class</code> 타입 인자를 인자로 받아서 처리하는 코드를 만들 때, inline 함수의 실체화 타입 파라미터를 사용하는 것 또한 유용하다. 클래스 타 타입 인자를 받아서 처리하는 API 중 대표적인 유스케이스로는 JDK의 ServiceLoader가 있고, 또한 자주 사용하는 <code>jackson</code>과 같은 직렬화/역직렬화 라이브러리에서도 클래스 타입 인자를 넘겨서 처리하는 API가 존재한다.</p>\n</li>\n<li><p>아래의 예제 코드처럼 타입 파라미터로 전달된 T에 대해 <code>::class.java</code> 구문을 사용하여 클래스에 대한 참조를 얻는 방법도 가능하다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;<span class=\"keyword\">reified</span> T: Any&gt;</span> <span class=\"title\">getServiceLoader</span><span class=\"params\">()</span></span>: ServiceLoader&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ServiceLoader.load(T::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// jackson-module-kotlin</span></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;<span class=\"keyword\">reified</span> T&gt;</span> <span class=\"title\">jacksonTypeRef</span><span class=\"params\">()</span></span>: TypeReference&lt;T&gt; = <span class=\"keyword\">object</span>: TypeReference&lt;T&gt;() &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>실체화 타입 파라미터의 사용 가능한 경우와 제약사항은 아래와 같다.</p>\n<ul>\n<li>사용 가능한 경우<ul>\n<li>타입 검사와 캐스팅(is, as)</li>\n<li>리플렉션 API</li>\n<li>코틀린 타입에 대응하는 자바 Class 타입 얻기(::class.java)</li>\n<li>다른 함수 호출 시, 타입 인자로 사용</li>\n</ul>\n</li>\n<li>제약 사항<ul>\n<li>타입 파라미터의 인스턴스 생성</li>\n<li>타입 파라미터 클래스의 동반 객체 메소드 호출</li>\n<li>일반 타입파라미터를 실체화 타입 파라미터를 인자로 받는 함수에 넘기기</li>\n<li>클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 <code>reified</code>로 지정</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>실체화 타입 파라미터를 사용하는 인라인 함수에서 람다를 사용하게 될 경우, 경우에 따라 인라이닝을 할 수 없는 경우도 발생하기도 하며, 성능 문제로 인라이닝을 안하고 싶을 수도 있다. 이럴 경우 <code>noinline</code> 키워드를 사용하여 인라이닝을 금지 시킬수 있다.</p>\n</li>\n</ul>\n<h2 id=\"변성-variance\"><a href=\"#변성-variance\" class=\"headerlink\" title=\"변성(variance)\"></a>변성(variance)</h2><ul>\n<li><p>기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념</p>\n<blockquote>\n<p><code>List&lt;String&gt;</code>, <code>List&lt;Any&gt;</code>와 같이 기저 타입이 같고 타입이 인자가 다를 경우</p>\n</blockquote>\n</li>\n<li><p>변성은 코드에서 위험할 여지가 있는 메소드를 호출할 수 없게 만듬으로써 제네릭 타입의 인스턴스 역할을 하는 클래스 인스턴스를 잘못 사용하는 일이 없게 방지하는 역할을 수행한다.</p>\n</li>\n<li><p><code>String</code>의 경우 <code>Any</code>를 확장하기 때문에 <code>Any</code>타입을 받는 함수에 <code>String</code>타입의 인자를 넘겨도 안전하겠지만, <code>List&lt;String&gt;</code>, <code>List&lt;Any&gt;</code>의 경우 확실한 안정성을 이야기할 순 없다. 아래 예제를 보면, 문자열로 선언된 mutableList에 정수값 42가 추가되고 maxBy 함수를 호출하는 과정에서 Integer에 대해 캐스팅 익셉션이 발생하는 걸 확인할 수 있다. </p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">printContents</span><span class=\"params\">(list: <span class=\"type\">List</span>&lt;<span class=\"type\">Any</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">\tprintln(list.joinToString())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">addAnswer</span><span class=\"params\">(list: <span class=\"type\">MutableList</span>&lt;<span class=\"type\">Any</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">\tlist.add(<span class=\"number\">42</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> strings = mutableListOf(<span class=\"string\">&quot;abc&quot;</span>, <span class=\"string\">&quot;bac&quot;</span>)</span><br><span class=\"line\">addAnswer(strings)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ClassCastException: Integer cannot be cast to String</span></span><br><span class=\"line\">println(strings.maxBy &#123; it.length &#125;) </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>어떤 함수가 만약 리스트의 값을 추가/변경하면 타입 불일치가 생길 수 있으니 <code>List&lt;Any&gt;</code> 대신 <code>List&lt;String&gt;</code>을 넘길 수 없다. 하지만, 원소의 추가/변경이 없을 경우 <code>List&lt;Any&gt;</code> 대신 <code>List&lt;String&gt;</code>을 넘겨도 안전하다. 코틀린에서는 리스트의 변경 가능성에 따라 적절한 인터페이스를 선택하게 되면 추가/변경을 막을 수 있어 안전하지 못한 호출을 막을 수 있다.</p>\n</li>\n<li><p><code>타입 =! 클래스</code></p>\n<ul>\n<li><strong>제네릭 클래스가 아닌 경우 클래스 이름을 타입으로 바로 사용할 수 있다.</strong> 단순한 예제로 <code>val x: String</code>가 있다.</li>\n<li>제네릭 클래스에서는 상황이 복잡하다. <code>List</code>는 타입이 아니고 클래스이며 실제 타입 파라미터가 추가된 <code>List&lt;String&gt;</code>, <code>List&lt;Int&gt;</code> 등이 제대로 된 타입이다. 제네릭 클래스는 결국 무수하게 많은 타입을 만들 수 있게 된다.</li>\n</ul>\n</li>\n<li><p><code>하위 타입</code></p>\n<ul>\n<li>A 타입의 값을 받을 수 있는 인자에 B 타입 값이 들어갈 수 있다면 <code>A타입은 B타입의 상위 타입</code>, <code>B타입은 A타입의 하위 타입</code> 으로 정리할 수 있다. 예를 들어, <code>Number</code>타입의 인자를 받을 수 있는 함수에 <code>Int</code>값을 넘길 수 있기에 둘 사이의 관계는 <code>Number타입은 Int타입의 상위 타입</code>, <code>Int타입은 Number타입의 하위 타입</code>으로 상/하위 타입 관계를 표현할 수 있게 된다.</li>\n</ul>\n</li>\n<li><p><strong>타입 관계의 중요성은 컴파일러가 변수 대입이나 인자 전달 시 하위 타입 검사를 매번 수행하기 때문이다.</strong> Int 타입의 인자를 받는 함수에 Number 타입 인자를 넣어 호출하게 되면 하위 타입 검사에서 Int 타입의 하위 타입이 Number가 아니기 때문에 컴파일이 되지 않게 된다.</p>\n</li>\n<li><p>간단한 경우 하위 타입은 하위 클래스와 같게 된다. 앞에서의 예처럼 Int 클래스는 Number 클래스의 하위 클래스이므로 Int는 Number의 하위 타입이다. </p>\n</li>\n<li><p>하지만 코틀린의 Nullable과 NonNull 타입의 관계를 생각해보면 이야기가 조금 더 복잡해지는데, <code>Int?</code> 타입 선언에는 <code>Int</code>타입의 값을 넣거나 변수 선언을 해도 무관하지만, 반대로 <code>Int</code>타입엔 <code>Int?</code>를 선언하는 건 불가능하기 때문에 둘 사이의 관계는 <code>Int?타입은 Int타입의 상위 타입</code> 혹은 <code>Int타입은 Int?타입의 하위 타입</code>이라고 정리할 수 있다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> s: String = <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> t: String? = s <span class=\"comment\">// String이 String?의 하위 타입이므로 이 대입은 가능</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>제네릭 타입을 인스턴스화 할때, 타입 인자에 서로 다른 타입이 들어가고 서로 하위 타입 관계가 성립하지 않은 걸 가리켜 <code>무공변(invariant)</code>라고 한다.</p>\n</li>\n<li><p>타입 A가 B의 하위 타입이면 <code>List&lt;A&gt;</code>는 <code>List&lt;B&gt;</code>의 하위 타입이며 이런 관계를 <code>공변적(covariant)</code>라고 한다.</p>\n</li>\n<li><p><strong>공변성(<code>covariant</code>)</strong></p>\n<ul>\n<li>공변적인 관계를 표현할 때는 out 키워드를 넣어 표현한다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Producer</span>&lt;<span class=\"type\">out T</span>&gt; </span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">produce</span><span class=\"params\">()</span></span>: T</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>클래스의 타입 파라미터를 공변적으로 만들면 함수 정의에 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 그 클래스의 인스턴스를 함수 인자나 반환 값으로 사용할 수 있다.</li>\n<li>타입 파라미터를 공변적으로 지정하면 클래스 내부에서 그 파라미터를 사용하는 방법을 제한한다<ul>\n<li>타입 안정성을 위해 항상 아웃(out) 위치에 있어야 한다. 클래스가 타입의 값을 생상할 수 있지만 값을 소비할 수 없다는 이야기이다.</li>\n</ul>\n</li>\n<li>클래스 맴버 선언 시, 타입 파라미터를 사용할 수 있는 지점은 out/in으로 나뉘며, out으로 선언할 경우 반환 타입(생산)에 쓰이며 in 으로 선언할 경우 값을 소비하는 역할로 한정이 된다. </li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Transformaer</span>&lt;<span class=\"type\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// t의 인자는 in 위치, 반환 타입 T는 out 위치</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">transform</span><span class=\"params\">(t: <span class=\"type\">T</span>)</span></span>: T</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>다시 정리하면, 공변성은 하위 타입 관계가 유지되며, 아웃 키워드를 통해 공변성을 표현하며 아웃으로 선언하게 되면 아웃 위치에서만 사용이 가능하다.</strong></li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Herd</span>&lt;<span class=\"type\">out T: Animal</span>&gt; </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">val</span> size: <span class=\"built_in\">Int</span></span><br><span class=\"line\">\t<span class=\"keyword\">get</span>() = ...</span><br><span class=\"line\"><span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get</span><span class=\"params\">(i: <span class=\"type\">Int</span>)</span></span>: T &#123; ... &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>위 클래스는 Herd 클래스에 Animal의 하위 타입을 받는 타입이며, 공변성을 표현하고 있고 타입 한정을 Animal로 지정하여 T타입은 자연스럽게 Animal 타입으로 취급된다. 또한 공변성을 표현하고 있기 때문에 반환 타입으로만 해당 타입을 지정하는 것이 가능하다.<br>또한, Animal뿐만 아니라 이를 상속하는 타입이 있다면 해당 타입을 타입 파라미터로 지정하는 것이 가능하다. 예를 들어 Cat이 Animal의 하위 타입이라면 get을 호출하는 부분에서 Cat을 반환해도 아무런 문제가 없게 된다.</p>\n</li>\n<li><p>타입 파라미터는 함수 파라미터 타입이나 반환 타입으로만 쓰이지 않고, 다른 타입 파라미터의 인자로도 사용할 수 있다.</p>\n</li>\n<li><p>생성자 파라미터는 인이나 아웃 어느 쪽도 아니며 타입 파라미터가 out 으로 선언되어 있어도 그 타입을 생성자 파라미터 선언에 사용할 수 있다. 생성자는 나중에 호출할 수 있는 메소드가 아니기 때문에 위험할 여지가 없다.</p>\n</li>\n<li><p><code>val</code>, <code>var</code> 키워드를 생성자 파라미터에 사용할 경우 게터 혹은 세터를 정의하는 것고 같기 때문에 읽기 전용 프로퍼티는 아웃 위치에 그리고 변경 가능 프로퍼티는 인 위치에 해당한다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Herd</span>&lt;<span class=\"type\">T: Animal</span>&gt;</span>(<span class=\"keyword\">var</span> leadAnimal: T, <span class=\"keyword\">vararg</span> animals: T) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>반공변성(<code>contravariance</code>)</strong></p>\n<ul>\n<li>타입 B가 A의 하위 타입인 경우, <code>Consumer&lt;A&gt;</code>가 <code>Consumer&lt;B&gt;</code>의 하위 타입인 관계가 성립하면 제네릭 클래스 <code>Consumer&lt;T&gt;</code>는 타입 인자 T에 대해 <code>반공변</code>을 표현한다고 할 수 있다.<ul>\n<li>Animal의 하위 타입인 Cat이 <code>Consumer&lt;Animal&gt;</code>가 <code>Consumer&lt;Cat&gt;</code>의 하위 타입 관계가 성립될 경우 이를 반공변 관계가 성립한다고 할 수 있다.</li>\n</ul>\n</li>\n<li>in이라는 키워드는 그 키워드가 붙은 타입이 이 클래스의 메소드 안으로 전달돼 메소드에 의해 소비된다는 뜻이다. 다시 말해, 오직 인 위치에서만 사용할 수 있다는 뜻이다.</li>\n</ul>\n</li>\n<li><p><strong>공변 vs 반공변 vs 무공변</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">공변성</th>\n<th align=\"left\">반공변성</th>\n<th align=\"left\">무공변성</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>Producer&lt;out T&gt;</code></td>\n<td align=\"left\"><code>Consumer&lt;in T&gt;</code></td>\n<td align=\"left\"><code>MutableList&lt;T&gt;</code></td>\n</tr>\n<tr>\n<td align=\"left\">타입 인자의 하위 타입 관계가 <br/>제네릭 타입에서도 유지된다.</td>\n<td align=\"left\">타입 인자의 하위 타입 관계가<br/>제네릭 타입에서 뒤집힌다.</td>\n<td align=\"left\">하위 타입 관계가 성립하지 않음</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Producer&lt;Cat&gt;</code>은 <code>Producer&lt;Animal&gt;</code>의 하위 타입이다.</td>\n<td align=\"left\"><code>Consumer&lt;Animal&gt;</code>은 <code>Consumer&lt;Cat&gt;</code>의   하위 타입이다.</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">T를 아웃 위치에서만 사용</td>\n<td align=\"left\">T를 인 위치에서만 사용</td>\n<td align=\"left\">T를 아무 위치에서나 사용 가능</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>아래 Function 인터페이스은 공변과 반공변을 설명하기 아주 좋은 예제이다. 인자로 받는 P 타입에 대해서는 반공변성을 유지하며, R 타입에 대해서는 공변성을 띄게 된다. </p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Function1</span>&lt;<span class=\"type\">in P, out R</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">invoke</span><span class=\"params\">(p: <span class=\"type\">P</span>)</span></span>: R</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Cat과 Animal의 예제를 위 Function1에 대입해보면 <code>(Cat) -&gt; Number</code>와 <code>(Animal) -&gt; Int</code>에서도 하위 타입 관계가 성립하게 된다. 위 Function1의 경우 코틀린의 표현으로 바꿔보자면 <code>(Cat) -&gt; Number</code>를 받는 인자에 <code>(Animal) -&gt; Int</code>의 함수 인스턴스를 넘기더라도 하위 타입 관계가 성립하기 때문에 호출에 문제가 없게 되는 것이다. </li>\n</ul>\n<blockquote>\n<p>다시 정리하면 반공변의 경우 타입의 하위 관계를 반대로, 공변의 경우 타입의 하위 관계를 그대로 유지, 무공변의 경우 타입 파라미터간의 하위 타입 관계가 전혀 없는 것으로 정리할 수 있다.</p>\n</blockquote>\n<ul>\n<li><p><strong>변성의 종류</strong></p>\n<ul>\n<li><code>선언 지점 변성(declaration site variance)</code>: 클래스 선언에 지정하는 것을 선언 지점 변성이라 부르며, 한번의 선언만으로 변성을 추가 지정할 필요가 없으므로 코드가 간결해진다. </li>\n<li><code>사용 지점 변성(use site variance)</code>: 자바에서처럼 타입 파라미터가 있는 타입을 사용할때 마다 해당 타입 파라미터를 하위 타입이나 상위 타입 중 어떤 타입으로 대치할 수 있는지 명시하는 방법을 사용 지점 변성이라고 한다. 자바의 <code>한정 와일드카드 타입(bounded wildcard)</code>을 사용하는 것을 생각하면 된다.(<code>? extends</code> , <code>? super</code>) 물론 <strong>코틀린도 자바에서처럼 사용 지점 변성을 지원한다.</strong> 공변적이거나 혹은 반공변적인지 선언할 수 없다면 사용 지점 변성을 사용하여 타입 파라미터가 나오는 지점에 변성을 정의하면 된다.</li>\n</ul>\n</li>\n<li><p>변성을 지정하지 않은 클래스를 사용할 때 변성에 대한 지정이 가능하다. 대표적인 예제로 MutableList가 있다. MutableList는 타입 파라미터로 넘어는 값을 생산할 수도 있고 소비할수도 있게 되는데, 변성에 대한 지정을 통하여 이를 제어할 수 있게 된다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">copyData</span><span class=\"params\">(source: <span class=\"type\">MutableList</span>&lt;<span class=\"type\">out</span> <span class=\"type\">T</span>&gt;, destination: <span class=\"type\">MutableList</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(item <span class=\"keyword\">in</span> source) &#123;</span><br><span class=\"line\">\t\tdestination.add(item)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>위 예제에서 <code>source</code>의 타입 선언을 <code>MutableList&lt;out T&gt;</code>로 지정해뒀는데, out 키워드를 붙임으로서 무공변인 MutableList에서 공변으로 제약을 붙인 타입으로 프로젝션을 시킬 수 있게 된다. 이럴 경우 값을 소비하는 add 함수등을 사용하게 될 경우 <code>Out-projected type ....</code>과 같은 에러를 만나게 될 수 있다. </li>\n<li><strong>정리하면, 타입 선언에서 [타입 파라미터를 사용하는 위치]라면 어디에나 [변성 변경자]를 붙일 수 있으며, [파라미터 타입, 로컬 변수 타입, 함수 반환 타입] 등에 타입 파라미터가 쓰이는 경우 in이나 out 변경자를 붙일 수 있다. 이를 가리켜 <code>타입 프로젝션(type projection)</code>이라 부른다.</strong><ul>\n<li><code>List&lt;out T&gt;</code>처럼 이미 변성 변경자가 붙어 있는 클래스에 out 프로젝션을 하는 것은 의미가 없으므로 컴파일러와 IDE가 친절하게(?) 경고를 하게 될 것이다.</li>\n</ul>\n</li>\n</ul>\n"},{"title":"리플리케이션","date":"2019-07-13T15:00:00.000Z","_content":"\n# 리플리케이션\n## 개요\n`\"2개의 데이터베이스에 저장되는 데이터가 같고, 이 데이터가에 가해진 변경도 같으면 결과도 같다\"` 마스터에 일어난 변경을 연속적으로 기록해서 같은 변경을 슬레이브에 전송하며 슬레이브에서는 마스터에서 보내온 변경 이력을 연속적으로 재생한다.\n\nMySQL에서는 이러한 리플리케이션을 실현하기 위해 아래와 같은 기능을 탑재하고 있다\n- 바이너리 로그\n- 슬레이브에 데이터를 전송하기 위한 마스터 스레드\n- 슬레이브 I/O 스레드\n- 릴레이 로그에서 데이터를 읽어 재생하기 위한 SQL 스레드\n\nMySQL은 비동기형 리플리케이션을 구현하고 있으며 마스터의 변경이 일어난 이후 변경 로그를 슬레이브에 전송하여 재생하게 되며 이러한 일련의 과정은 약간의 시차를 두고 따라가게 된다.\n\n### 바이너리 로그\n- MySQL 서버에서 발생한 모든 변경을 직렬화하여 기록한 파일\n- log_bin 옵션에서 지정한 명칭을 접두어로 하여 6자리 일련번호를 덧붙인 이름의 파일\n- 서버에서 보관 중인 바이너리 로그의 정보는 별도의 인덱스 파일에 저장하게 된다. 인덱스 파일의 명칭은 `log_bin에 지정한 파일명.index`이 된다.\n- 바이너리 로그 파일과 해당 로그의 인덱스 파일은 반드시 내용상 일치해야 한다.\n- MySQL 5버젼까지는 바이너리 로그에 실행하는 SQL문(SBR, Statement Based Replication)이 기록되었지만, 값의 결정성 문제(uuid()와 같은 함수를 사용했을 때 값이 매번 바뀌는 것이 가장 대표적인 예)때문에 이후 버젼에서는 RBR(Row Based Replication) 기준으로 값일 기록하게 되었다. RBR의 경우 변경이 가해지는 전후 값을 기록하는 형식이다. 이러한 SBR과 RBR의 장점을 모두 취합한 형식도 존재하는데 MBR(Mixed Based Replication) 방식이다.\n\n### 마스터 스레드\n- 바이너리 로그를 읽어 슬레이브에 전송하는 역할을 수행\n- 슬레이브가 여러 개인 경우, 슬레이브 숫자에 대응하는 숫자만큼의 마스터 스레드를 생성\n\n### 슬레이브 I/O 스레드\n- 마스터로부터 받은 로그를 릴레이 로그라는 로그파일에 보존하게 되는데 그 보존하는 작업을 수행하는 스레드\n- 릴레이 로그에도 인덱스 파일이 존재\n### 슬레이브 SQL 스레드\n- 릴레이 로그에 기록된 갱신 내용을 읽어들여서 슬레이브에서 재생할 때 사용하는 스레드\n- 처리량에 많아지게 되면 지연이 발생하게 되는데, MySQL 5.7에서는 이런 지연을 막아줄 수 있는 기능이 추가되었다.\n\n## Replication의 형태는?\n- 마스터/슬레이브(Master -> Slave)\n- 듀얼 마스터(Master <-> Master)\n- 다단 구성(Master -> Slave -> Slave)\n- 순환형(Master -> Master -> Master 순환참조)\n- 1:N(1 Master - N Slaves)\n- N:1(N Masters - 1 Slaves)\n\n하나의 마스터가 가질 수 있는 슬레이브의 수를 제한할 수 없으며 위 형태들 중 가장 인기있는 형태는 `1:N`의 형태(참조 부하를 줄여줄 수 있는 형태)이다. \n\n## 리플리케이션 구축\n### 마스터\n#### server_id 설정\n리플리케이션을 구성하는 모든 서버는 고유의 ID가 필요하게 되는데 이것이 바로 server_id이다. 32비트 Unsigned 정수이며 값이며, 중복 값을 절대 지정해서는 안된다. 해당 아이디 값은 바이너리 로그에도 기록되며, 해당 값은 리플리케이션 구조에서 값의 갱신 시 어떤 서버에서 발생한 변경인지 혹은 자기가 실행한 이벤트인지 확인하는 목적으로 사용하게 된다. \n\n#### 바이너리 로그 활성화\n`my.cnf`파일에 `log_bin`옵션을 활성화하자\n\n#### 슬레이브 접속용 계정 생성\n슬레이브가 여러 개 존재한다면 슬레이브의 수 만큼 계정을 만들어야 되는데 아래는 계정을 생성하는 간단한 SQL 스크립트이다.\n```sql\nCREATE USER 'repl'@'192.0.2.0/255.255.255.0' IDENTIFIED BY 'secret';\nGRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.0.2.0/255.255.255.0'\n```\n### 슬레이브\n#### 마스터의 데이터 복제\n현존하는 서버를 마스터로 하고 신규로 만들게 되는 서버를 슬레이브로하고 싶다면 마스터에서 데이터를 덤프를 받아 슬레이브에 적용시켜야 한다. 백업 시점은 마스터에서 바이너리 로그를 활성화한 이후여야 한다. `mysqldump` 사용 시, --master-data 옵션을 사용하여 바이너리 로그 위치 및 파일명을 가져올 수 있도록 지정할 수 있다.\n#### server_id 설정\n#### 리플리케이션 설정\n`CHANGE MASTER` 명령어를 사용\n```sql\nCHANGE MASTER TO\nMASTER_HOST = `마스터의 호스트`\nMASTER_PORT = `PORT`,\nMASTER_LOG_FILE = `mysql-bin.000777`,\nMASTER_LOG_POS = 12345678,\nMASTER_HEART_BEAT_PERIOD = 60\n```\n#### 리플리케이션 시작\n```sql\nSTART SLAVE USER = 'repl' PASSWORD = 'secret';\n```\n제대로 동작하는지 유무를 확인하려면 `SHOW SLAVE STATUS` 명령어를 사용하여 Slave_IO_Running, Slave_SQL_Running 항목의 값이 `YES`인지 확인하자\n\n## GTID(Global Transaction ID)\n바이너리 로그에 기록된 각각의 트랜잭션에 고유한 ID를 붙여주는 기능으로 아래와 같은 포맷을 가지게 된다\n\n`발신처 MySQL 서버의 ID: 트랜잭션 ID`\n\n발신처 서버의 ID는 최초 기동 시점에 UUID 값으로 생성되며 `auto.cnf` 파일 이름으로 저장된다. 기동 시 해당 파일이 존재하면 해당 파일의 값을 읽어서 해당 아이디 값을 사용하게 된다. 트랜잭션 ID의 값은 1부터 시작하여 단순히 증가하는 숫자 값이다.\n\nGTID는 1:N 형태의 리플리케이션 구조에서 슬레이브의 자동 마스터 승격에 사용된다. 미래에 승격 될 가능성이 있는 슬레이브에는 log-bin 옵션과 log_slave_update 옵션을 써서 바이너리 로그를 출력하도록 설정되어 있어야 한다. GTID가 존재하기 때문에 슬레이브에서는 본인이 생성한 GTID와 마스터에서 생성한 GTID를 구분할 수 있는 기준이 생기기 때문에 변경에 대한 전후 관계를 뚜렷하게 기록할 수 있게 된다. \n\n### GTID의 온라인 상태에서의 활성화/비활성화\n[TODO]: 활성화 과정 설명 추가\n\n## 준동기 리플리케이션\n### 개요\n준동기 리플리케이션은 MySQL 5.5에서 추가된 기능으로 마스터에서 일어난 변경이 슬레이브에 확실하게 전달되었지를 보장하는 것을 말한다. 마스터에서 트랜잭션이 실행되면 COMMIT을 완료하기 전 슬레이브 바이너리 로그를 전송하게 되는 형식으로 완벽하게 동기화 되는 시점이 동일하지 않기 때문에 동기라고 보증할 수 없다. 준동기 리플리케이션은 통상의 리플리케이션과 비교하여 커밋의 오버헤드가 큰 편이고 ACK에 대한 지연이 특히 문제로 이어 질 수 있으므로 주의해야 한다고 한다.\n\n> `2단계 커밋(Two-Phase-Commit)`\n> 커밋을 PREPARE와 COMMIT의 두 단계로 나눈 것을 말하는데, 만약 준동기 모델이 아닌 동기 모델에서 리플리케이션을 처리한다면 2단계 커밋 방식으로 처리해야 한다고 한다.\n#### 준동기 모델\n![MYSQL_리플리케이션_준동기](https://i.imgur.com/nMNx3kA.png)\n\n\n### 무손실 리플리케이션\nMySQL 5.6까지의 준동기 리플리케이션은 슬레이브가 ACK를 기다리는 시점이 클라이언트에게 응답을 반환하기 직전 타이밍이었다. 하지만, 이런 구조에서 마스터가 손상될 경우 마스터에만 존재하는 데이터가 있을 수 있는 치명적인 단점이 있다고 한다. \n\n**개선된 모델에서 기존 준동기 모델과 다른 점은 ACK를 기다리는 시점을 변경하는 것이다. MySQL 5.7에서는 COMMIT을 실행한 다음이 아니라 COMMIT을 실행하기 전 시점에 ACK를 기다리도록 변경했다.**\n#### 무손실 모델\n![MYSQL_리플리케이션_무손실](https://i.imgur.com/DVLNS6K.png)\n\n### 성능 개선\n- 기존 MySQL 5.6에서는 ACK를 수신하기까지 다른 이벤트를 송신할 수 없다는 단점이 존재했다. 5.7에서는 새로운 ACK를 처리하는 새로운 스레드를 도입함으로써 이러한 문제를 해결했는데, 말그래도 ACK 스레드라고 부른다. \n- ACK 스레드의 존재 여부는 `performance_schema.threads` 테이블에서 확인 할 수 있다.\n\n## 멀티 소스 리플리케이션\n- 여러 마스터로부터 동시에 변경을 받아들이는 구조로 MySQL 5.7부터 사용가능하다. 여러 마스터로부터 데이터를 수신할 때 `채널`이라는 개념을 도입하여 사용하는데 이는 마스터와 통신하는 것 자체를 가리키는 용어이다.\n- 멀티 소스 리플리케이션에서는 여러 마스터의 갱신에서 경합이 생기지 않도록 주의해야 한다. 특히 각각의 마스터에 같은 데이터를 포함되지 않아야 되고 바이너리 로그의 포맷도 SBR이 아닌 RBR을 사용하도록 해야 한다.\n- 데이터 갱신의 경우 비동기로 이뤄지기 때문에, 어떤 순간에 취한 데이터의 정합성이 반드시 맞기는 어려울 수 있다.\n\n## 마스터 성능 개선\n### 그룹 커밋\n- 리플리케이션 간 데이터 동기화를 하려면 위에서 설명한 것처럼 바이너리 로그를 사용해야 하는데, 바이너리 로그를 쓰고 동기화하는 것 자체도 트랜잭션이라고 볼 수 있기 때문에 이에 대한 비용도 크다고 할 수 있다.\n- MySQL 5.6부터는 이러한 바이너리 로그 트랜잭션에 대해 그룹단위로 커밋이 가능하도록 지원하기 시작했다.\n[TODO]: 그룹커밋 이미지 추가\n\n### 메모리 효율 개선\n- MySQL 5.6까지는 마스터 스레드에서 바이너리 로그에 대한 이벤트를 읽을 때마다 이벤트 크기 맞는 버퍼를 할당(malloc)하고 슬레이브에 송신 후 메모리를 해제(free)하는 방식을 사용했다.\n- 5.7에서 부터는 메모리 할당에 대한 성능 개선이 이뤄졌으며 매번 malloc과 free를 하지 않고 버퍼가 충분하면 그대로 사용하며 그렇지 않으면 다시 할당하여 사용하는 방식으로 변경했다. \n- 거대한 메모리 버퍼를 사용했을 경우, 해당 버퍼의 크기를 정기적으로 검토하여 남은 버퍼를 축소하는 기능를 탑재했다.\n\n### 마스터 스레드의 Mutex 경합 개선\n- 5.6 이후 도입된 그룹 커밋(`sync_binlog = 1`)으로 크게 성능이 향상 되었지만, 마스터의 손상 시 슬레이브에 기록되지 않은 데이터가 발생할 수 있는 문제가 생기가 되었다.\n\n- 그룹 커밋 시 바이너리 로그를 디스크로 `fsync`하기 전에 몇 개의 트랜잭션을 묶어 바이너리 로그에 쓰게 되는데, 이때 `fsync`가 끝나지 않아도 `write`가 되는 시점에 슬레이브로 로그 전송를 하게 된다. `fsync`가 끝나지 않은 상태에서 마스터 서버에 손상이 발생하게 되면 재기동 후 바이너리 로그가 없어지고 이에 따라 해당 트랜잭션의 데이터는 롤백 처리가 된다. 하지만, 슬레이브로는 데이터가 전송이 되었기 때문에 슬레이브와 마스터의 부정합이 발생하게 되는 것이다.\n\n![MYSQL_리플리케이션_부정합](https://i.imgur.com/CppQA6T.png)\n\n- 위 그림에서 Tx1~5까지 하나의 그룹으로 커밋되고 있는데, 바이너리 로그가 디스크에 `fsync`를 하지 않은 상태에서 손상이 진행되면 1~5까지 해당하는 트랜잭션은 모두 롤백이 되게 된다, 하지만, 1~3까지의 트랜잭션이 슬레이브로 전송이 된 상태이므로 1~3까지의 트랜잭션 데이터는 슬레이브에만 존재하게 되는 것이다.\n- 5.6에서 이러한 문제 때문에, `LOCK_log`라는 Mutex에 의해 보호받도록 수정했으나 그룹 커밋과 마스터 스레드가 Mutex를 얻기 위한 경합이 발생하면서 마스터 스레드에서 슬레이브로의 바이너리 로그 전송 효율이 떨어지게 되었다.\n- 5.7에서는 `LOCK_log`는 그대로 남아 있지만, 사용하지 않고 `LOG_binlog_end_pos`라는 Mutex를 도입하여 LOCK의 입자 크기를 미세하게 조정했다. 해당 Mutex는 마스터 스레드가 읽어 들이는 것이 가능한 최후의 바이너리 로그의 위치를 관리하게 된다. \n- 5.6에서는 EOF까지 바이너리 로그를 읽었으나 이럴 경우 `fsync` 처리 되지 않은 로그까지 읽게 된다. 이에 반해, 5.7에서는 마스터 스레드가 `fsync`된 데이터만 읽도록 읽기 가능한 로그의 포지션을 관리하게 했다. 마스터 스레드는 `fsync`가 된 로그만을 슬레이브로 전송하게 됨으로서 마스터가 손상되어도 슬레이브에도 동일한 데이터만 남게 되는 것이다.\n\n## 병렬 SQL 스레드\n### MTS의 LOGICAL_CLOCK 모드\n- 5.6부터 슬레이브의 SQL 스레드를 여러 개 생성하여 바이너리 로그의 재생을 병렬로 수행할 수 있게 되었다. 이러한 병렬로 처리하는 것을 MTS(Multi-Thread-Salve)라 부른다.\n- 리플리케이션 지연의 가장 큰 원인으로 SQL 스레드의 지연을 찾을 수 있는데, 이러한 지연은 마스터와 슬레이브 머신의 처리 차이에서 발생하게 된다. 마스터에서는 코어를 모두 사용하여 데이터를 갱신하는 반면, 슬레이브는 하나의 SQL 스레드가 하나하나 바이너리 로그를 재생하게 됨에 따라 이러한 지연이 발생하게 되는 것이다. \n**\"결국 마스터 머신의 코어 개수가 많아 짐에 따라 이러한 지연은 더 크게 발생하게 되는 것이라 볼 수 있다.\"**\n- 5.6에서는 이러한 병렬 SQL 스레드가 동일 데이터베이스에 활성화 시킬 수 없었기 때문에 대부분 이런 기능을 사용하지 않았지만, 5.7부터는 하나의 데이터베이스에도 병렬 SQL 스레드가 작업을 할수 있게 되었다.\n```bash\n[mysqld]\n# 병렬 스레드 개수\nslave_parallel_workers=32\n\n# 5.7 추가, 입자 크기 지정\nslave_parallel_type=LOGICAL_CLOCK\n\u001e\n# 5.7 추가, COMMIT 순서가 바뀌지 않도록 지정, 0일 경우 미보장\nslave_preserve_commit_order=1\nlog_bin=mysql-log\nlog_slave_updates=1\n```\n- 병렬로 실행 시, 동일한 데이터에 대한 트랜잭션인지 유무는 매우 중요하다. 만약 동일한 데이터에 대한 트랜잭션이 아닐 경우 내부적으로는(InnoDB에서는 바이너리 로그 동기화를 위하여 2-Phase-Commit을 내부적으로 사용한다.) 2-Phase-Commit에서 PREPARE 상태가 되었다는 것인데 해당 상태 값은 결국 동일한 트랜잭션에서 발생할 수 있는 LOCK으로 인한 경합이 발생하지 않았을 경우일뿐이다. \n- 마스터에서 슬레이브로 전달할 때 이러한 경합 혹은 순서에 대한 정보를 전달해줘야 하는데, 바이너리 로그에 `last_committed`와 `sequence_number`라는 항목으로 몇 번째 트랜잭션인지 카운터 값을 표기하고 있는 것을 볼수 있을 것이다.\n- 마스터에서 실행한 트랜잭션과 슬레이브가 실행한 트랜잭션이 달라질 수 있음은 위에서 설명한대로 병럴 SQL스레드의 처리 방식때문에 충분하게 의심을 해볼 수 있게 되는데, 이때 유용한 옵션이 바로 `slave_preserve_commit_order`이다. 명시적으로 1로 지정해줘야지 순서가 바뀌지 않게 되며 0으로 지정하게 되면 데이터 장합성을 보장받을 수 없게 되기 때문에 0으로 지정해서는 안된다.\n\n### 마스터 튜닝\n- LOGICAL_CLOCK 모드로 MTS를 사용하는 경우 마스터에서 그룹 커밋을 튜닝하여 보다 많은 트랜잭션이 하나의 그룹에 묶이도록 해야 한다. \n- `binlog_group_commit_sync_delay`, `binlog_group_commit_no_delay_count` 옵션을 조정하여 환경과 상황에 맞는 최적화를 진행하는 것이 중요하며, 마스터의 갱신 처리 성능에만 집중하는 것이 아니라 슬레이브에서의 지연 유무도 역시 주시해야 한다. ","source":"_posts/MYSQL/replication.md","raw":"---\ntitle: '리플리케이션'\ndate: 2019/7/14 00:00:00\ncategories:\n- MESSAGING\n---\n\n# 리플리케이션\n## 개요\n`\"2개의 데이터베이스에 저장되는 데이터가 같고, 이 데이터가에 가해진 변경도 같으면 결과도 같다\"` 마스터에 일어난 변경을 연속적으로 기록해서 같은 변경을 슬레이브에 전송하며 슬레이브에서는 마스터에서 보내온 변경 이력을 연속적으로 재생한다.\n\nMySQL에서는 이러한 리플리케이션을 실현하기 위해 아래와 같은 기능을 탑재하고 있다\n- 바이너리 로그\n- 슬레이브에 데이터를 전송하기 위한 마스터 스레드\n- 슬레이브 I/O 스레드\n- 릴레이 로그에서 데이터를 읽어 재생하기 위한 SQL 스레드\n\nMySQL은 비동기형 리플리케이션을 구현하고 있으며 마스터의 변경이 일어난 이후 변경 로그를 슬레이브에 전송하여 재생하게 되며 이러한 일련의 과정은 약간의 시차를 두고 따라가게 된다.\n\n### 바이너리 로그\n- MySQL 서버에서 발생한 모든 변경을 직렬화하여 기록한 파일\n- log_bin 옵션에서 지정한 명칭을 접두어로 하여 6자리 일련번호를 덧붙인 이름의 파일\n- 서버에서 보관 중인 바이너리 로그의 정보는 별도의 인덱스 파일에 저장하게 된다. 인덱스 파일의 명칭은 `log_bin에 지정한 파일명.index`이 된다.\n- 바이너리 로그 파일과 해당 로그의 인덱스 파일은 반드시 내용상 일치해야 한다.\n- MySQL 5버젼까지는 바이너리 로그에 실행하는 SQL문(SBR, Statement Based Replication)이 기록되었지만, 값의 결정성 문제(uuid()와 같은 함수를 사용했을 때 값이 매번 바뀌는 것이 가장 대표적인 예)때문에 이후 버젼에서는 RBR(Row Based Replication) 기준으로 값일 기록하게 되었다. RBR의 경우 변경이 가해지는 전후 값을 기록하는 형식이다. 이러한 SBR과 RBR의 장점을 모두 취합한 형식도 존재하는데 MBR(Mixed Based Replication) 방식이다.\n\n### 마스터 스레드\n- 바이너리 로그를 읽어 슬레이브에 전송하는 역할을 수행\n- 슬레이브가 여러 개인 경우, 슬레이브 숫자에 대응하는 숫자만큼의 마스터 스레드를 생성\n\n### 슬레이브 I/O 스레드\n- 마스터로부터 받은 로그를 릴레이 로그라는 로그파일에 보존하게 되는데 그 보존하는 작업을 수행하는 스레드\n- 릴레이 로그에도 인덱스 파일이 존재\n### 슬레이브 SQL 스레드\n- 릴레이 로그에 기록된 갱신 내용을 읽어들여서 슬레이브에서 재생할 때 사용하는 스레드\n- 처리량에 많아지게 되면 지연이 발생하게 되는데, MySQL 5.7에서는 이런 지연을 막아줄 수 있는 기능이 추가되었다.\n\n## Replication의 형태는?\n- 마스터/슬레이브(Master -> Slave)\n- 듀얼 마스터(Master <-> Master)\n- 다단 구성(Master -> Slave -> Slave)\n- 순환형(Master -> Master -> Master 순환참조)\n- 1:N(1 Master - N Slaves)\n- N:1(N Masters - 1 Slaves)\n\n하나의 마스터가 가질 수 있는 슬레이브의 수를 제한할 수 없으며 위 형태들 중 가장 인기있는 형태는 `1:N`의 형태(참조 부하를 줄여줄 수 있는 형태)이다. \n\n## 리플리케이션 구축\n### 마스터\n#### server_id 설정\n리플리케이션을 구성하는 모든 서버는 고유의 ID가 필요하게 되는데 이것이 바로 server_id이다. 32비트 Unsigned 정수이며 값이며, 중복 값을 절대 지정해서는 안된다. 해당 아이디 값은 바이너리 로그에도 기록되며, 해당 값은 리플리케이션 구조에서 값의 갱신 시 어떤 서버에서 발생한 변경인지 혹은 자기가 실행한 이벤트인지 확인하는 목적으로 사용하게 된다. \n\n#### 바이너리 로그 활성화\n`my.cnf`파일에 `log_bin`옵션을 활성화하자\n\n#### 슬레이브 접속용 계정 생성\n슬레이브가 여러 개 존재한다면 슬레이브의 수 만큼 계정을 만들어야 되는데 아래는 계정을 생성하는 간단한 SQL 스크립트이다.\n```sql\nCREATE USER 'repl'@'192.0.2.0/255.255.255.0' IDENTIFIED BY 'secret';\nGRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.0.2.0/255.255.255.0'\n```\n### 슬레이브\n#### 마스터의 데이터 복제\n현존하는 서버를 마스터로 하고 신규로 만들게 되는 서버를 슬레이브로하고 싶다면 마스터에서 데이터를 덤프를 받아 슬레이브에 적용시켜야 한다. 백업 시점은 마스터에서 바이너리 로그를 활성화한 이후여야 한다. `mysqldump` 사용 시, --master-data 옵션을 사용하여 바이너리 로그 위치 및 파일명을 가져올 수 있도록 지정할 수 있다.\n#### server_id 설정\n#### 리플리케이션 설정\n`CHANGE MASTER` 명령어를 사용\n```sql\nCHANGE MASTER TO\nMASTER_HOST = `마스터의 호스트`\nMASTER_PORT = `PORT`,\nMASTER_LOG_FILE = `mysql-bin.000777`,\nMASTER_LOG_POS = 12345678,\nMASTER_HEART_BEAT_PERIOD = 60\n```\n#### 리플리케이션 시작\n```sql\nSTART SLAVE USER = 'repl' PASSWORD = 'secret';\n```\n제대로 동작하는지 유무를 확인하려면 `SHOW SLAVE STATUS` 명령어를 사용하여 Slave_IO_Running, Slave_SQL_Running 항목의 값이 `YES`인지 확인하자\n\n## GTID(Global Transaction ID)\n바이너리 로그에 기록된 각각의 트랜잭션에 고유한 ID를 붙여주는 기능으로 아래와 같은 포맷을 가지게 된다\n\n`발신처 MySQL 서버의 ID: 트랜잭션 ID`\n\n발신처 서버의 ID는 최초 기동 시점에 UUID 값으로 생성되며 `auto.cnf` 파일 이름으로 저장된다. 기동 시 해당 파일이 존재하면 해당 파일의 값을 읽어서 해당 아이디 값을 사용하게 된다. 트랜잭션 ID의 값은 1부터 시작하여 단순히 증가하는 숫자 값이다.\n\nGTID는 1:N 형태의 리플리케이션 구조에서 슬레이브의 자동 마스터 승격에 사용된다. 미래에 승격 될 가능성이 있는 슬레이브에는 log-bin 옵션과 log_slave_update 옵션을 써서 바이너리 로그를 출력하도록 설정되어 있어야 한다. GTID가 존재하기 때문에 슬레이브에서는 본인이 생성한 GTID와 마스터에서 생성한 GTID를 구분할 수 있는 기준이 생기기 때문에 변경에 대한 전후 관계를 뚜렷하게 기록할 수 있게 된다. \n\n### GTID의 온라인 상태에서의 활성화/비활성화\n[TODO]: 활성화 과정 설명 추가\n\n## 준동기 리플리케이션\n### 개요\n준동기 리플리케이션은 MySQL 5.5에서 추가된 기능으로 마스터에서 일어난 변경이 슬레이브에 확실하게 전달되었지를 보장하는 것을 말한다. 마스터에서 트랜잭션이 실행되면 COMMIT을 완료하기 전 슬레이브 바이너리 로그를 전송하게 되는 형식으로 완벽하게 동기화 되는 시점이 동일하지 않기 때문에 동기라고 보증할 수 없다. 준동기 리플리케이션은 통상의 리플리케이션과 비교하여 커밋의 오버헤드가 큰 편이고 ACK에 대한 지연이 특히 문제로 이어 질 수 있으므로 주의해야 한다고 한다.\n\n> `2단계 커밋(Two-Phase-Commit)`\n> 커밋을 PREPARE와 COMMIT의 두 단계로 나눈 것을 말하는데, 만약 준동기 모델이 아닌 동기 모델에서 리플리케이션을 처리한다면 2단계 커밋 방식으로 처리해야 한다고 한다.\n#### 준동기 모델\n![MYSQL_리플리케이션_준동기](https://i.imgur.com/nMNx3kA.png)\n\n\n### 무손실 리플리케이션\nMySQL 5.6까지의 준동기 리플리케이션은 슬레이브가 ACK를 기다리는 시점이 클라이언트에게 응답을 반환하기 직전 타이밍이었다. 하지만, 이런 구조에서 마스터가 손상될 경우 마스터에만 존재하는 데이터가 있을 수 있는 치명적인 단점이 있다고 한다. \n\n**개선된 모델에서 기존 준동기 모델과 다른 점은 ACK를 기다리는 시점을 변경하는 것이다. MySQL 5.7에서는 COMMIT을 실행한 다음이 아니라 COMMIT을 실행하기 전 시점에 ACK를 기다리도록 변경했다.**\n#### 무손실 모델\n![MYSQL_리플리케이션_무손실](https://i.imgur.com/DVLNS6K.png)\n\n### 성능 개선\n- 기존 MySQL 5.6에서는 ACK를 수신하기까지 다른 이벤트를 송신할 수 없다는 단점이 존재했다. 5.7에서는 새로운 ACK를 처리하는 새로운 스레드를 도입함으로써 이러한 문제를 해결했는데, 말그래도 ACK 스레드라고 부른다. \n- ACK 스레드의 존재 여부는 `performance_schema.threads` 테이블에서 확인 할 수 있다.\n\n## 멀티 소스 리플리케이션\n- 여러 마스터로부터 동시에 변경을 받아들이는 구조로 MySQL 5.7부터 사용가능하다. 여러 마스터로부터 데이터를 수신할 때 `채널`이라는 개념을 도입하여 사용하는데 이는 마스터와 통신하는 것 자체를 가리키는 용어이다.\n- 멀티 소스 리플리케이션에서는 여러 마스터의 갱신에서 경합이 생기지 않도록 주의해야 한다. 특히 각각의 마스터에 같은 데이터를 포함되지 않아야 되고 바이너리 로그의 포맷도 SBR이 아닌 RBR을 사용하도록 해야 한다.\n- 데이터 갱신의 경우 비동기로 이뤄지기 때문에, 어떤 순간에 취한 데이터의 정합성이 반드시 맞기는 어려울 수 있다.\n\n## 마스터 성능 개선\n### 그룹 커밋\n- 리플리케이션 간 데이터 동기화를 하려면 위에서 설명한 것처럼 바이너리 로그를 사용해야 하는데, 바이너리 로그를 쓰고 동기화하는 것 자체도 트랜잭션이라고 볼 수 있기 때문에 이에 대한 비용도 크다고 할 수 있다.\n- MySQL 5.6부터는 이러한 바이너리 로그 트랜잭션에 대해 그룹단위로 커밋이 가능하도록 지원하기 시작했다.\n[TODO]: 그룹커밋 이미지 추가\n\n### 메모리 효율 개선\n- MySQL 5.6까지는 마스터 스레드에서 바이너리 로그에 대한 이벤트를 읽을 때마다 이벤트 크기 맞는 버퍼를 할당(malloc)하고 슬레이브에 송신 후 메모리를 해제(free)하는 방식을 사용했다.\n- 5.7에서 부터는 메모리 할당에 대한 성능 개선이 이뤄졌으며 매번 malloc과 free를 하지 않고 버퍼가 충분하면 그대로 사용하며 그렇지 않으면 다시 할당하여 사용하는 방식으로 변경했다. \n- 거대한 메모리 버퍼를 사용했을 경우, 해당 버퍼의 크기를 정기적으로 검토하여 남은 버퍼를 축소하는 기능를 탑재했다.\n\n### 마스터 스레드의 Mutex 경합 개선\n- 5.6 이후 도입된 그룹 커밋(`sync_binlog = 1`)으로 크게 성능이 향상 되었지만, 마스터의 손상 시 슬레이브에 기록되지 않은 데이터가 발생할 수 있는 문제가 생기가 되었다.\n\n- 그룹 커밋 시 바이너리 로그를 디스크로 `fsync`하기 전에 몇 개의 트랜잭션을 묶어 바이너리 로그에 쓰게 되는데, 이때 `fsync`가 끝나지 않아도 `write`가 되는 시점에 슬레이브로 로그 전송를 하게 된다. `fsync`가 끝나지 않은 상태에서 마스터 서버에 손상이 발생하게 되면 재기동 후 바이너리 로그가 없어지고 이에 따라 해당 트랜잭션의 데이터는 롤백 처리가 된다. 하지만, 슬레이브로는 데이터가 전송이 되었기 때문에 슬레이브와 마스터의 부정합이 발생하게 되는 것이다.\n\n![MYSQL_리플리케이션_부정합](https://i.imgur.com/CppQA6T.png)\n\n- 위 그림에서 Tx1~5까지 하나의 그룹으로 커밋되고 있는데, 바이너리 로그가 디스크에 `fsync`를 하지 않은 상태에서 손상이 진행되면 1~5까지 해당하는 트랜잭션은 모두 롤백이 되게 된다, 하지만, 1~3까지의 트랜잭션이 슬레이브로 전송이 된 상태이므로 1~3까지의 트랜잭션 데이터는 슬레이브에만 존재하게 되는 것이다.\n- 5.6에서 이러한 문제 때문에, `LOCK_log`라는 Mutex에 의해 보호받도록 수정했으나 그룹 커밋과 마스터 스레드가 Mutex를 얻기 위한 경합이 발생하면서 마스터 스레드에서 슬레이브로의 바이너리 로그 전송 효율이 떨어지게 되었다.\n- 5.7에서는 `LOCK_log`는 그대로 남아 있지만, 사용하지 않고 `LOG_binlog_end_pos`라는 Mutex를 도입하여 LOCK의 입자 크기를 미세하게 조정했다. 해당 Mutex는 마스터 스레드가 읽어 들이는 것이 가능한 최후의 바이너리 로그의 위치를 관리하게 된다. \n- 5.6에서는 EOF까지 바이너리 로그를 읽었으나 이럴 경우 `fsync` 처리 되지 않은 로그까지 읽게 된다. 이에 반해, 5.7에서는 마스터 스레드가 `fsync`된 데이터만 읽도록 읽기 가능한 로그의 포지션을 관리하게 했다. 마스터 스레드는 `fsync`가 된 로그만을 슬레이브로 전송하게 됨으로서 마스터가 손상되어도 슬레이브에도 동일한 데이터만 남게 되는 것이다.\n\n## 병렬 SQL 스레드\n### MTS의 LOGICAL_CLOCK 모드\n- 5.6부터 슬레이브의 SQL 스레드를 여러 개 생성하여 바이너리 로그의 재생을 병렬로 수행할 수 있게 되었다. 이러한 병렬로 처리하는 것을 MTS(Multi-Thread-Salve)라 부른다.\n- 리플리케이션 지연의 가장 큰 원인으로 SQL 스레드의 지연을 찾을 수 있는데, 이러한 지연은 마스터와 슬레이브 머신의 처리 차이에서 발생하게 된다. 마스터에서는 코어를 모두 사용하여 데이터를 갱신하는 반면, 슬레이브는 하나의 SQL 스레드가 하나하나 바이너리 로그를 재생하게 됨에 따라 이러한 지연이 발생하게 되는 것이다. \n**\"결국 마스터 머신의 코어 개수가 많아 짐에 따라 이러한 지연은 더 크게 발생하게 되는 것이라 볼 수 있다.\"**\n- 5.6에서는 이러한 병렬 SQL 스레드가 동일 데이터베이스에 활성화 시킬 수 없었기 때문에 대부분 이런 기능을 사용하지 않았지만, 5.7부터는 하나의 데이터베이스에도 병렬 SQL 스레드가 작업을 할수 있게 되었다.\n```bash\n[mysqld]\n# 병렬 스레드 개수\nslave_parallel_workers=32\n\n# 5.7 추가, 입자 크기 지정\nslave_parallel_type=LOGICAL_CLOCK\n\u001e\n# 5.7 추가, COMMIT 순서가 바뀌지 않도록 지정, 0일 경우 미보장\nslave_preserve_commit_order=1\nlog_bin=mysql-log\nlog_slave_updates=1\n```\n- 병렬로 실행 시, 동일한 데이터에 대한 트랜잭션인지 유무는 매우 중요하다. 만약 동일한 데이터에 대한 트랜잭션이 아닐 경우 내부적으로는(InnoDB에서는 바이너리 로그 동기화를 위하여 2-Phase-Commit을 내부적으로 사용한다.) 2-Phase-Commit에서 PREPARE 상태가 되었다는 것인데 해당 상태 값은 결국 동일한 트랜잭션에서 발생할 수 있는 LOCK으로 인한 경합이 발생하지 않았을 경우일뿐이다. \n- 마스터에서 슬레이브로 전달할 때 이러한 경합 혹은 순서에 대한 정보를 전달해줘야 하는데, 바이너리 로그에 `last_committed`와 `sequence_number`라는 항목으로 몇 번째 트랜잭션인지 카운터 값을 표기하고 있는 것을 볼수 있을 것이다.\n- 마스터에서 실행한 트랜잭션과 슬레이브가 실행한 트랜잭션이 달라질 수 있음은 위에서 설명한대로 병럴 SQL스레드의 처리 방식때문에 충분하게 의심을 해볼 수 있게 되는데, 이때 유용한 옵션이 바로 `slave_preserve_commit_order`이다. 명시적으로 1로 지정해줘야지 순서가 바뀌지 않게 되며 0으로 지정하게 되면 데이터 장합성을 보장받을 수 없게 되기 때문에 0으로 지정해서는 안된다.\n\n### 마스터 튜닝\n- LOGICAL_CLOCK 모드로 MTS를 사용하는 경우 마스터에서 그룹 커밋을 튜닝하여 보다 많은 트랜잭션이 하나의 그룹에 묶이도록 해야 한다. \n- `binlog_group_commit_sync_delay`, `binlog_group_commit_no_delay_count` 옵션을 조정하여 환경과 상황에 맞는 최적화를 진행하는 것이 중요하며, 마스터의 갱신 처리 성능에만 집중하는 것이 아니라 슬레이브에서의 지연 유무도 역시 주시해야 한다. ","slug":"MYSQL/replication","published":1,"updated":"2021-08-02T12:18:03.665Z","_id":"ckrsup51e0025tjhvc3mx2ivz","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"리플리케이션\"><a href=\"#리플리케이션\" class=\"headerlink\" title=\"리플리케이션\"></a>리플리케이션</h1><h2 id=\"개요\"><a href=\"#개요\" class=\"headerlink\" title=\"개요\"></a>개요</h2><p><code>&quot;2개의 데이터베이스에 저장되는 데이터가 같고, 이 데이터가에 가해진 변경도 같으면 결과도 같다&quot;</code> 마스터에 일어난 변경을 연속적으로 기록해서 같은 변경을 슬레이브에 전송하며 슬레이브에서는 마스터에서 보내온 변경 이력을 연속적으로 재생한다.</p>\n<p>MySQL에서는 이러한 리플리케이션을 실현하기 위해 아래와 같은 기능을 탑재하고 있다</p>\n<ul>\n<li>바이너리 로그</li>\n<li>슬레이브에 데이터를 전송하기 위한 마스터 스레드</li>\n<li>슬레이브 I/O 스레드</li>\n<li>릴레이 로그에서 데이터를 읽어 재생하기 위한 SQL 스레드</li>\n</ul>\n<p>MySQL은 비동기형 리플리케이션을 구현하고 있으며 마스터의 변경이 일어난 이후 변경 로그를 슬레이브에 전송하여 재생하게 되며 이러한 일련의 과정은 약간의 시차를 두고 따라가게 된다.</p>\n<h3 id=\"바이너리-로그\"><a href=\"#바이너리-로그\" class=\"headerlink\" title=\"바이너리 로그\"></a>바이너리 로그</h3><ul>\n<li>MySQL 서버에서 발생한 모든 변경을 직렬화하여 기록한 파일</li>\n<li>log_bin 옵션에서 지정한 명칭을 접두어로 하여 6자리 일련번호를 덧붙인 이름의 파일</li>\n<li>서버에서 보관 중인 바이너리 로그의 정보는 별도의 인덱스 파일에 저장하게 된다. 인덱스 파일의 명칭은 <code>log_bin에 지정한 파일명.index</code>이 된다.</li>\n<li>바이너리 로그 파일과 해당 로그의 인덱스 파일은 반드시 내용상 일치해야 한다.</li>\n<li>MySQL 5버젼까지는 바이너리 로그에 실행하는 SQL문(SBR, Statement Based Replication)이 기록되었지만, 값의 결정성 문제(uuid()와 같은 함수를 사용했을 때 값이 매번 바뀌는 것이 가장 대표적인 예)때문에 이후 버젼에서는 RBR(Row Based Replication) 기준으로 값일 기록하게 되었다. RBR의 경우 변경이 가해지는 전후 값을 기록하는 형식이다. 이러한 SBR과 RBR의 장점을 모두 취합한 형식도 존재하는데 MBR(Mixed Based Replication) 방식이다.</li>\n</ul>\n<h3 id=\"마스터-스레드\"><a href=\"#마스터-스레드\" class=\"headerlink\" title=\"마스터 스레드\"></a>마스터 스레드</h3><ul>\n<li>바이너리 로그를 읽어 슬레이브에 전송하는 역할을 수행</li>\n<li>슬레이브가 여러 개인 경우, 슬레이브 숫자에 대응하는 숫자만큼의 마스터 스레드를 생성</li>\n</ul>\n<h3 id=\"슬레이브-I-O-스레드\"><a href=\"#슬레이브-I-O-스레드\" class=\"headerlink\" title=\"슬레이브 I/O 스레드\"></a>슬레이브 I/O 스레드</h3><ul>\n<li>마스터로부터 받은 로그를 릴레이 로그라는 로그파일에 보존하게 되는데 그 보존하는 작업을 수행하는 스레드</li>\n<li>릴레이 로그에도 인덱스 파일이 존재<h3 id=\"슬레이브-SQL-스레드\"><a href=\"#슬레이브-SQL-스레드\" class=\"headerlink\" title=\"슬레이브 SQL 스레드\"></a>슬레이브 SQL 스레드</h3></li>\n<li>릴레이 로그에 기록된 갱신 내용을 읽어들여서 슬레이브에서 재생할 때 사용하는 스레드</li>\n<li>처리량에 많아지게 되면 지연이 발생하게 되는데, MySQL 5.7에서는 이런 지연을 막아줄 수 있는 기능이 추가되었다.</li>\n</ul>\n<h2 id=\"Replication의-형태는\"><a href=\"#Replication의-형태는\" class=\"headerlink\" title=\"Replication의 형태는?\"></a>Replication의 형태는?</h2><ul>\n<li>마스터/슬레이브(Master -&gt; Slave)</li>\n<li>듀얼 마스터(Master &lt;-&gt; Master)</li>\n<li>다단 구성(Master -&gt; Slave -&gt; Slave)</li>\n<li>순환형(Master -&gt; Master -&gt; Master 순환참조)</li>\n<li>1:N(1 Master - N Slaves)</li>\n<li>N:1(N Masters - 1 Slaves)</li>\n</ul>\n<p>하나의 마스터가 가질 수 있는 슬레이브의 수를 제한할 수 없으며 위 형태들 중 가장 인기있는 형태는 <code>1:N</code>의 형태(참조 부하를 줄여줄 수 있는 형태)이다. </p>\n<h2 id=\"리플리케이션-구축\"><a href=\"#리플리케이션-구축\" class=\"headerlink\" title=\"리플리케이션 구축\"></a>리플리케이션 구축</h2><h3 id=\"마스터\"><a href=\"#마스터\" class=\"headerlink\" title=\"마스터\"></a>마스터</h3><h4 id=\"server-id-설정\"><a href=\"#server-id-설정\" class=\"headerlink\" title=\"server_id 설정\"></a>server_id 설정</h4><p>리플리케이션을 구성하는 모든 서버는 고유의 ID가 필요하게 되는데 이것이 바로 server_id이다. 32비트 Unsigned 정수이며 값이며, 중복 값을 절대 지정해서는 안된다. 해당 아이디 값은 바이너리 로그에도 기록되며, 해당 값은 리플리케이션 구조에서 값의 갱신 시 어떤 서버에서 발생한 변경인지 혹은 자기가 실행한 이벤트인지 확인하는 목적으로 사용하게 된다. </p>\n<h4 id=\"바이너리-로그-활성화\"><a href=\"#바이너리-로그-활성화\" class=\"headerlink\" title=\"바이너리 로그 활성화\"></a>바이너리 로그 활성화</h4><p><code>my.cnf</code>파일에 <code>log_bin</code>옵션을 활성화하자</p>\n<h4 id=\"슬레이브-접속용-계정-생성\"><a href=\"#슬레이브-접속용-계정-생성\" class=\"headerlink\" title=\"슬레이브 접속용 계정 생성\"></a>슬레이브 접속용 계정 생성</h4><p>슬레이브가 여러 개 존재한다면 슬레이브의 수 만큼 계정을 만들어야 되는데 아래는 계정을 생성하는 간단한 SQL 스크립트이다.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> <span class=\"string\">&#x27;repl&#x27;</span>@<span class=\"string\">&#x27;192.0.2.0/255.255.255.0&#x27;</span> IDENTIFIED <span class=\"keyword\">BY</span> <span class=\"string\">&#x27;secret&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> REPLICATION SLAVE <span class=\"keyword\">ON</span> <span class=\"operator\">*</span>.<span class=\"operator\">*</span> <span class=\"keyword\">TO</span> <span class=\"string\">&#x27;repl&#x27;</span>@<span class=\"string\">&#x27;192.0.2.0/255.255.255.0&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"슬레이브\"><a href=\"#슬레이브\" class=\"headerlink\" title=\"슬레이브\"></a>슬레이브</h3><h4 id=\"마스터의-데이터-복제\"><a href=\"#마스터의-데이터-복제\" class=\"headerlink\" title=\"마스터의 데이터 복제\"></a>마스터의 데이터 복제</h4><p>현존하는 서버를 마스터로 하고 신규로 만들게 되는 서버를 슬레이브로하고 싶다면 마스터에서 데이터를 덤프를 받아 슬레이브에 적용시켜야 한다. 백업 시점은 마스터에서 바이너리 로그를 활성화한 이후여야 한다. <code>mysqldump</code> 사용 시, –master-data 옵션을 사용하여 바이너리 로그 위치 및 파일명을 가져올 수 있도록 지정할 수 있다.</p>\n<h4 id=\"server-id-설정-1\"><a href=\"#server-id-설정-1\" class=\"headerlink\" title=\"server_id 설정\"></a>server_id 설정</h4><h4 id=\"리플리케이션-설정\"><a href=\"#리플리케이션-설정\" class=\"headerlink\" title=\"리플리케이션 설정\"></a>리플리케이션 설정</h4><p><code>CHANGE MASTER</code> 명령어를 사용</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CHANGE MASTER <span class=\"keyword\">TO</span></span><br><span class=\"line\">MASTER_HOST <span class=\"operator\">=</span> `마스터의 호스트`</span><br><span class=\"line\">MASTER_PORT <span class=\"operator\">=</span> `PORT`,</span><br><span class=\"line\">MASTER_LOG_FILE <span class=\"operator\">=</span> `mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000777</span>`,</span><br><span class=\"line\">MASTER_LOG_POS <span class=\"operator\">=</span> <span class=\"number\">12345678</span>,</span><br><span class=\"line\">MASTER_HEART_BEAT_PERIOD <span class=\"operator\">=</span> <span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"리플리케이션-시작\"><a href=\"#리플리케이션-시작\" class=\"headerlink\" title=\"리플리케이션 시작\"></a>리플리케이션 시작</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">START</span> SLAVE <span class=\"keyword\">USER</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;repl&#x27;</span> PASSWORD <span class=\"operator\">=</span> <span class=\"string\">&#x27;secret&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>제대로 동작하는지 유무를 확인하려면 <code>SHOW SLAVE STATUS</code> 명령어를 사용하여 Slave_IO_Running, Slave_SQL_Running 항목의 값이 <code>YES</code>인지 확인하자</p>\n<h2 id=\"GTID-Global-Transaction-ID\"><a href=\"#GTID-Global-Transaction-ID\" class=\"headerlink\" title=\"GTID(Global Transaction ID)\"></a>GTID(Global Transaction ID)</h2><p>바이너리 로그에 기록된 각각의 트랜잭션에 고유한 ID를 붙여주는 기능으로 아래와 같은 포맷을 가지게 된다</p>\n<p><code>발신처 MySQL 서버의 ID: 트랜잭션 ID</code></p>\n<p>발신처 서버의 ID는 최초 기동 시점에 UUID 값으로 생성되며 <code>auto.cnf</code> 파일 이름으로 저장된다. 기동 시 해당 파일이 존재하면 해당 파일의 값을 읽어서 해당 아이디 값을 사용하게 된다. 트랜잭션 ID의 값은 1부터 시작하여 단순히 증가하는 숫자 값이다.</p>\n<p>GTID는 1:N 형태의 리플리케이션 구조에서 슬레이브의 자동 마스터 승격에 사용된다. 미래에 승격 될 가능성이 있는 슬레이브에는 log-bin 옵션과 log_slave_update 옵션을 써서 바이너리 로그를 출력하도록 설정되어 있어야 한다. GTID가 존재하기 때문에 슬레이브에서는 본인이 생성한 GTID와 마스터에서 생성한 GTID를 구분할 수 있는 기준이 생기기 때문에 변경에 대한 전후 관계를 뚜렷하게 기록할 수 있게 된다. </p>\n<h3 id=\"GTID의-온라인-상태에서의-활성화-비활성화\"><a href=\"#GTID의-온라인-상태에서의-활성화-비활성화\" class=\"headerlink\" title=\"GTID의 온라인 상태에서의 활성화/비활성화\"></a>GTID의 온라인 상태에서의 활성화/비활성화</h3><p>[TODO]: 활성화 과정 설명 추가</p>\n<h2 id=\"준동기-리플리케이션\"><a href=\"#준동기-리플리케이션\" class=\"headerlink\" title=\"준동기 리플리케이션\"></a>준동기 리플리케이션</h2><h3 id=\"개요-1\"><a href=\"#개요-1\" class=\"headerlink\" title=\"개요\"></a>개요</h3><p>준동기 리플리케이션은 MySQL 5.5에서 추가된 기능으로 마스터에서 일어난 변경이 슬레이브에 확실하게 전달되었지를 보장하는 것을 말한다. 마스터에서 트랜잭션이 실행되면 COMMIT을 완료하기 전 슬레이브 바이너리 로그를 전송하게 되는 형식으로 완벽하게 동기화 되는 시점이 동일하지 않기 때문에 동기라고 보증할 수 없다. 준동기 리플리케이션은 통상의 리플리케이션과 비교하여 커밋의 오버헤드가 큰 편이고 ACK에 대한 지연이 특히 문제로 이어 질 수 있으므로 주의해야 한다고 한다.</p>\n<blockquote>\n<p><code>2단계 커밋(Two-Phase-Commit)</code><br>커밋을 PREPARE와 COMMIT의 두 단계로 나눈 것을 말하는데, 만약 준동기 모델이 아닌 동기 모델에서 리플리케이션을 처리한다면 2단계 커밋 방식으로 처리해야 한다고 한다.</p>\n</blockquote>\n<h4 id=\"준동기-모델\"><a href=\"#준동기-모델\" class=\"headerlink\" title=\"준동기 모델\"></a>준동기 모델</h4><p><img src=\"https://i.imgur.com/nMNx3kA.png\" alt=\"MYSQL_리플리케이션_준동기\"></p>\n<h3 id=\"무손실-리플리케이션\"><a href=\"#무손실-리플리케이션\" class=\"headerlink\" title=\"무손실 리플리케이션\"></a>무손실 리플리케이션</h3><p>MySQL 5.6까지의 준동기 리플리케이션은 슬레이브가 ACK를 기다리는 시점이 클라이언트에게 응답을 반환하기 직전 타이밍이었다. 하지만, 이런 구조에서 마스터가 손상될 경우 마스터에만 존재하는 데이터가 있을 수 있는 치명적인 단점이 있다고 한다. </p>\n<p><strong>개선된 모델에서 기존 준동기 모델과 다른 점은 ACK를 기다리는 시점을 변경하는 것이다. MySQL 5.7에서는 COMMIT을 실행한 다음이 아니라 COMMIT을 실행하기 전 시점에 ACK를 기다리도록 변경했다.</strong></p>\n<h4 id=\"무손실-모델\"><a href=\"#무손실-모델\" class=\"headerlink\" title=\"무손실 모델\"></a>무손실 모델</h4><p><img src=\"https://i.imgur.com/DVLNS6K.png\" alt=\"MYSQL_리플리케이션_무손실\"></p>\n<h3 id=\"성능-개선\"><a href=\"#성능-개선\" class=\"headerlink\" title=\"성능 개선\"></a>성능 개선</h3><ul>\n<li>기존 MySQL 5.6에서는 ACK를 수신하기까지 다른 이벤트를 송신할 수 없다는 단점이 존재했다. 5.7에서는 새로운 ACK를 처리하는 새로운 스레드를 도입함으로써 이러한 문제를 해결했는데, 말그래도 ACK 스레드라고 부른다. </li>\n<li>ACK 스레드의 존재 여부는 <code>performance_schema.threads</code> 테이블에서 확인 할 수 있다.</li>\n</ul>\n<h2 id=\"멀티-소스-리플리케이션\"><a href=\"#멀티-소스-리플리케이션\" class=\"headerlink\" title=\"멀티 소스 리플리케이션\"></a>멀티 소스 리플리케이션</h2><ul>\n<li>여러 마스터로부터 동시에 변경을 받아들이는 구조로 MySQL 5.7부터 사용가능하다. 여러 마스터로부터 데이터를 수신할 때 <code>채널</code>이라는 개념을 도입하여 사용하는데 이는 마스터와 통신하는 것 자체를 가리키는 용어이다.</li>\n<li>멀티 소스 리플리케이션에서는 여러 마스터의 갱신에서 경합이 생기지 않도록 주의해야 한다. 특히 각각의 마스터에 같은 데이터를 포함되지 않아야 되고 바이너리 로그의 포맷도 SBR이 아닌 RBR을 사용하도록 해야 한다.</li>\n<li>데이터 갱신의 경우 비동기로 이뤄지기 때문에, 어떤 순간에 취한 데이터의 정합성이 반드시 맞기는 어려울 수 있다.</li>\n</ul>\n<h2 id=\"마스터-성능-개선\"><a href=\"#마스터-성능-개선\" class=\"headerlink\" title=\"마스터 성능 개선\"></a>마스터 성능 개선</h2><h3 id=\"그룹-커밋\"><a href=\"#그룹-커밋\" class=\"headerlink\" title=\"그룹 커밋\"></a>그룹 커밋</h3><ul>\n<li>리플리케이션 간 데이터 동기화를 하려면 위에서 설명한 것처럼 바이너리 로그를 사용해야 하는데, 바이너리 로그를 쓰고 동기화하는 것 자체도 트랜잭션이라고 볼 수 있기 때문에 이에 대한 비용도 크다고 할 수 있다.</li>\n<li>MySQL 5.6부터는 이러한 바이너리 로그 트랜잭션에 대해 그룹단위로 커밋이 가능하도록 지원하기 시작했다.<br>[TODO]: 그룹커밋 이미지 추가</li>\n</ul>\n<h3 id=\"메모리-효율-개선\"><a href=\"#메모리-효율-개선\" class=\"headerlink\" title=\"메모리 효율 개선\"></a>메모리 효율 개선</h3><ul>\n<li>MySQL 5.6까지는 마스터 스레드에서 바이너리 로그에 대한 이벤트를 읽을 때마다 이벤트 크기 맞는 버퍼를 할당(malloc)하고 슬레이브에 송신 후 메모리를 해제(free)하는 방식을 사용했다.</li>\n<li>5.7에서 부터는 메모리 할당에 대한 성능 개선이 이뤄졌으며 매번 malloc과 free를 하지 않고 버퍼가 충분하면 그대로 사용하며 그렇지 않으면 다시 할당하여 사용하는 방식으로 변경했다. </li>\n<li>거대한 메모리 버퍼를 사용했을 경우, 해당 버퍼의 크기를 정기적으로 검토하여 남은 버퍼를 축소하는 기능를 탑재했다.</li>\n</ul>\n<h3 id=\"마스터-스레드의-Mutex-경합-개선\"><a href=\"#마스터-스레드의-Mutex-경합-개선\" class=\"headerlink\" title=\"마스터 스레드의 Mutex 경합 개선\"></a>마스터 스레드의 Mutex 경합 개선</h3><ul>\n<li><p>5.6 이후 도입된 그룹 커밋(<code>sync_binlog = 1</code>)으로 크게 성능이 향상 되었지만, 마스터의 손상 시 슬레이브에 기록되지 않은 데이터가 발생할 수 있는 문제가 생기가 되었다.</p>\n</li>\n<li><p>그룹 커밋 시 바이너리 로그를 디스크로 <code>fsync</code>하기 전에 몇 개의 트랜잭션을 묶어 바이너리 로그에 쓰게 되는데, 이때 <code>fsync</code>가 끝나지 않아도 <code>write</code>가 되는 시점에 슬레이브로 로그 전송를 하게 된다. <code>fsync</code>가 끝나지 않은 상태에서 마스터 서버에 손상이 발생하게 되면 재기동 후 바이너리 로그가 없어지고 이에 따라 해당 트랜잭션의 데이터는 롤백 처리가 된다. 하지만, 슬레이브로는 데이터가 전송이 되었기 때문에 슬레이브와 마스터의 부정합이 발생하게 되는 것이다.</p>\n</li>\n</ul>\n<p><img src=\"https://i.imgur.com/CppQA6T.png\" alt=\"MYSQL_리플리케이션_부정합\"></p>\n<ul>\n<li>위 그림에서 Tx1<del>5까지 하나의 그룹으로 커밋되고 있는데, 바이너리 로그가 디스크에 <code>fsync</code>를 하지 않은 상태에서 손상이 진행되면 1</del>5까지 해당하는 트랜잭션은 모두 롤백이 되게 된다, 하지만, 1<del>3까지의 트랜잭션이 슬레이브로 전송이 된 상태이므로 1</del>3까지의 트랜잭션 데이터는 슬레이브에만 존재하게 되는 것이다.</li>\n<li>5.6에서 이러한 문제 때문에, <code>LOCK_log</code>라는 Mutex에 의해 보호받도록 수정했으나 그룹 커밋과 마스터 스레드가 Mutex를 얻기 위한 경합이 발생하면서 마스터 스레드에서 슬레이브로의 바이너리 로그 전송 효율이 떨어지게 되었다.</li>\n<li>5.7에서는 <code>LOCK_log</code>는 그대로 남아 있지만, 사용하지 않고 <code>LOG_binlog_end_pos</code>라는 Mutex를 도입하여 LOCK의 입자 크기를 미세하게 조정했다. 해당 Mutex는 마스터 스레드가 읽어 들이는 것이 가능한 최후의 바이너리 로그의 위치를 관리하게 된다. </li>\n<li>5.6에서는 EOF까지 바이너리 로그를 읽었으나 이럴 경우 <code>fsync</code> 처리 되지 않은 로그까지 읽게 된다. 이에 반해, 5.7에서는 마스터 스레드가 <code>fsync</code>된 데이터만 읽도록 읽기 가능한 로그의 포지션을 관리하게 했다. 마스터 스레드는 <code>fsync</code>가 된 로그만을 슬레이브로 전송하게 됨으로서 마스터가 손상되어도 슬레이브에도 동일한 데이터만 남게 되는 것이다.</li>\n</ul>\n<h2 id=\"병렬-SQL-스레드\"><a href=\"#병렬-SQL-스레드\" class=\"headerlink\" title=\"병렬 SQL 스레드\"></a>병렬 SQL 스레드</h2><h3 id=\"MTS의-LOGICAL-CLOCK-모드\"><a href=\"#MTS의-LOGICAL-CLOCK-모드\" class=\"headerlink\" title=\"MTS의 LOGICAL_CLOCK 모드\"></a>MTS의 LOGICAL_CLOCK 모드</h3><ul>\n<li>5.6부터 슬레이브의 SQL 스레드를 여러 개 생성하여 바이너리 로그의 재생을 병렬로 수행할 수 있게 되었다. 이러한 병렬로 처리하는 것을 MTS(Multi-Thread-Salve)라 부른다.</li>\n<li>리플리케이션 지연의 가장 큰 원인으로 SQL 스레드의 지연을 찾을 수 있는데, 이러한 지연은 마스터와 슬레이브 머신의 처리 차이에서 발생하게 된다. 마스터에서는 코어를 모두 사용하여 데이터를 갱신하는 반면, 슬레이브는 하나의 SQL 스레드가 하나하나 바이너리 로그를 재생하게 됨에 따라 이러한 지연이 발생하게 되는 것이다. </li>\n</ul>\n<p><strong>“결국 마스터 머신의 코어 개수가 많아 짐에 따라 이러한 지연은 더 크게 발생하게 되는 것이라 볼 수 있다.”</strong></p>\n<ul>\n<li>5.6에서는 이러한 병렬 SQL 스레드가 동일 데이터베이스에 활성화 시킬 수 없었기 때문에 대부분 이런 기능을 사용하지 않았지만, 5.7부터는 하나의 데이터베이스에도 병렬 SQL 스레드가 작업을 할수 있게 되었다.<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\"><span class=\"comment\"># 병렬 스레드 개수</span></span><br><span class=\"line\">slave_parallel_workers=32</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5.7 추가, 입자 크기 지정</span></span><br><span class=\"line\">slave_parallel_type=LOGICAL_CLOCK</span><br><span class=\"line\">\u001e</span><br><span class=\"line\"><span class=\"comment\"># 5.7 추가, COMMIT 순서가 바뀌지 않도록 지정, 0일 경우 미보장</span></span><br><span class=\"line\">slave_preserve_commit_order=1</span><br><span class=\"line\">log_bin=mysql-log</span><br><span class=\"line\">log_slave_updates=1</span><br></pre></td></tr></table></figure></li>\n<li>병렬로 실행 시, 동일한 데이터에 대한 트랜잭션인지 유무는 매우 중요하다. 만약 동일한 데이터에 대한 트랜잭션이 아닐 경우 내부적으로는(InnoDB에서는 바이너리 로그 동기화를 위하여 2-Phase-Commit을 내부적으로 사용한다.) 2-Phase-Commit에서 PREPARE 상태가 되었다는 것인데 해당 상태 값은 결국 동일한 트랜잭션에서 발생할 수 있는 LOCK으로 인한 경합이 발생하지 않았을 경우일뿐이다. </li>\n<li>마스터에서 슬레이브로 전달할 때 이러한 경합 혹은 순서에 대한 정보를 전달해줘야 하는데, 바이너리 로그에 <code>last_committed</code>와 <code>sequence_number</code>라는 항목으로 몇 번째 트랜잭션인지 카운터 값을 표기하고 있는 것을 볼수 있을 것이다.</li>\n<li>마스터에서 실행한 트랜잭션과 슬레이브가 실행한 트랜잭션이 달라질 수 있음은 위에서 설명한대로 병럴 SQL스레드의 처리 방식때문에 충분하게 의심을 해볼 수 있게 되는데, 이때 유용한 옵션이 바로 <code>slave_preserve_commit_order</code>이다. 명시적으로 1로 지정해줘야지 순서가 바뀌지 않게 되며 0으로 지정하게 되면 데이터 장합성을 보장받을 수 없게 되기 때문에 0으로 지정해서는 안된다.</li>\n</ul>\n<h3 id=\"마스터-튜닝\"><a href=\"#마스터-튜닝\" class=\"headerlink\" title=\"마스터 튜닝\"></a>마스터 튜닝</h3><ul>\n<li>LOGICAL_CLOCK 모드로 MTS를 사용하는 경우 마스터에서 그룹 커밋을 튜닝하여 보다 많은 트랜잭션이 하나의 그룹에 묶이도록 해야 한다. </li>\n<li><code>binlog_group_commit_sync_delay</code>, <code>binlog_group_commit_no_delay_count</code> 옵션을 조정하여 환경과 상황에 맞는 최적화를 진행하는 것이 중요하며, 마스터의 갱신 처리 성능에만 집중하는 것이 아니라 슬레이브에서의 지연 유무도 역시 주시해야 한다. </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"리플리케이션\"><a href=\"#리플리케이션\" class=\"headerlink\" title=\"리플리케이션\"></a>리플리케이션</h1><h2 id=\"개요\"><a href=\"#개요\" class=\"headerlink\" title=\"개요\"></a>개요</h2><p><code>&quot;2개의 데이터베이스에 저장되는 데이터가 같고, 이 데이터가에 가해진 변경도 같으면 결과도 같다&quot;</code> 마스터에 일어난 변경을 연속적으로 기록해서 같은 변경을 슬레이브에 전송하며 슬레이브에서는 마스터에서 보내온 변경 이력을 연속적으로 재생한다.</p>\n<p>MySQL에서는 이러한 리플리케이션을 실현하기 위해 아래와 같은 기능을 탑재하고 있다</p>\n<ul>\n<li>바이너리 로그</li>\n<li>슬레이브에 데이터를 전송하기 위한 마스터 스레드</li>\n<li>슬레이브 I/O 스레드</li>\n<li>릴레이 로그에서 데이터를 읽어 재생하기 위한 SQL 스레드</li>\n</ul>\n<p>MySQL은 비동기형 리플리케이션을 구현하고 있으며 마스터의 변경이 일어난 이후 변경 로그를 슬레이브에 전송하여 재생하게 되며 이러한 일련의 과정은 약간의 시차를 두고 따라가게 된다.</p>\n<h3 id=\"바이너리-로그\"><a href=\"#바이너리-로그\" class=\"headerlink\" title=\"바이너리 로그\"></a>바이너리 로그</h3><ul>\n<li>MySQL 서버에서 발생한 모든 변경을 직렬화하여 기록한 파일</li>\n<li>log_bin 옵션에서 지정한 명칭을 접두어로 하여 6자리 일련번호를 덧붙인 이름의 파일</li>\n<li>서버에서 보관 중인 바이너리 로그의 정보는 별도의 인덱스 파일에 저장하게 된다. 인덱스 파일의 명칭은 <code>log_bin에 지정한 파일명.index</code>이 된다.</li>\n<li>바이너리 로그 파일과 해당 로그의 인덱스 파일은 반드시 내용상 일치해야 한다.</li>\n<li>MySQL 5버젼까지는 바이너리 로그에 실행하는 SQL문(SBR, Statement Based Replication)이 기록되었지만, 값의 결정성 문제(uuid()와 같은 함수를 사용했을 때 값이 매번 바뀌는 것이 가장 대표적인 예)때문에 이후 버젼에서는 RBR(Row Based Replication) 기준으로 값일 기록하게 되었다. RBR의 경우 변경이 가해지는 전후 값을 기록하는 형식이다. 이러한 SBR과 RBR의 장점을 모두 취합한 형식도 존재하는데 MBR(Mixed Based Replication) 방식이다.</li>\n</ul>\n<h3 id=\"마스터-스레드\"><a href=\"#마스터-스레드\" class=\"headerlink\" title=\"마스터 스레드\"></a>마스터 스레드</h3><ul>\n<li>바이너리 로그를 읽어 슬레이브에 전송하는 역할을 수행</li>\n<li>슬레이브가 여러 개인 경우, 슬레이브 숫자에 대응하는 숫자만큼의 마스터 스레드를 생성</li>\n</ul>\n<h3 id=\"슬레이브-I-O-스레드\"><a href=\"#슬레이브-I-O-스레드\" class=\"headerlink\" title=\"슬레이브 I/O 스레드\"></a>슬레이브 I/O 스레드</h3><ul>\n<li>마스터로부터 받은 로그를 릴레이 로그라는 로그파일에 보존하게 되는데 그 보존하는 작업을 수행하는 스레드</li>\n<li>릴레이 로그에도 인덱스 파일이 존재<h3 id=\"슬레이브-SQL-스레드\"><a href=\"#슬레이브-SQL-스레드\" class=\"headerlink\" title=\"슬레이브 SQL 스레드\"></a>슬레이브 SQL 스레드</h3></li>\n<li>릴레이 로그에 기록된 갱신 내용을 읽어들여서 슬레이브에서 재생할 때 사용하는 스레드</li>\n<li>처리량에 많아지게 되면 지연이 발생하게 되는데, MySQL 5.7에서는 이런 지연을 막아줄 수 있는 기능이 추가되었다.</li>\n</ul>\n<h2 id=\"Replication의-형태는\"><a href=\"#Replication의-형태는\" class=\"headerlink\" title=\"Replication의 형태는?\"></a>Replication의 형태는?</h2><ul>\n<li>마스터/슬레이브(Master -&gt; Slave)</li>\n<li>듀얼 마스터(Master &lt;-&gt; Master)</li>\n<li>다단 구성(Master -&gt; Slave -&gt; Slave)</li>\n<li>순환형(Master -&gt; Master -&gt; Master 순환참조)</li>\n<li>1:N(1 Master - N Slaves)</li>\n<li>N:1(N Masters - 1 Slaves)</li>\n</ul>\n<p>하나의 마스터가 가질 수 있는 슬레이브의 수를 제한할 수 없으며 위 형태들 중 가장 인기있는 형태는 <code>1:N</code>의 형태(참조 부하를 줄여줄 수 있는 형태)이다. </p>\n<h2 id=\"리플리케이션-구축\"><a href=\"#리플리케이션-구축\" class=\"headerlink\" title=\"리플리케이션 구축\"></a>리플리케이션 구축</h2><h3 id=\"마스터\"><a href=\"#마스터\" class=\"headerlink\" title=\"마스터\"></a>마스터</h3><h4 id=\"server-id-설정\"><a href=\"#server-id-설정\" class=\"headerlink\" title=\"server_id 설정\"></a>server_id 설정</h4><p>리플리케이션을 구성하는 모든 서버는 고유의 ID가 필요하게 되는데 이것이 바로 server_id이다. 32비트 Unsigned 정수이며 값이며, 중복 값을 절대 지정해서는 안된다. 해당 아이디 값은 바이너리 로그에도 기록되며, 해당 값은 리플리케이션 구조에서 값의 갱신 시 어떤 서버에서 발생한 변경인지 혹은 자기가 실행한 이벤트인지 확인하는 목적으로 사용하게 된다. </p>\n<h4 id=\"바이너리-로그-활성화\"><a href=\"#바이너리-로그-활성화\" class=\"headerlink\" title=\"바이너리 로그 활성화\"></a>바이너리 로그 활성화</h4><p><code>my.cnf</code>파일에 <code>log_bin</code>옵션을 활성화하자</p>\n<h4 id=\"슬레이브-접속용-계정-생성\"><a href=\"#슬레이브-접속용-계정-생성\" class=\"headerlink\" title=\"슬레이브 접속용 계정 생성\"></a>슬레이브 접속용 계정 생성</h4><p>슬레이브가 여러 개 존재한다면 슬레이브의 수 만큼 계정을 만들어야 되는데 아래는 계정을 생성하는 간단한 SQL 스크립트이다.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> <span class=\"string\">&#x27;repl&#x27;</span>@<span class=\"string\">&#x27;192.0.2.0/255.255.255.0&#x27;</span> IDENTIFIED <span class=\"keyword\">BY</span> <span class=\"string\">&#x27;secret&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> REPLICATION SLAVE <span class=\"keyword\">ON</span> <span class=\"operator\">*</span>.<span class=\"operator\">*</span> <span class=\"keyword\">TO</span> <span class=\"string\">&#x27;repl&#x27;</span>@<span class=\"string\">&#x27;192.0.2.0/255.255.255.0&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"슬레이브\"><a href=\"#슬레이브\" class=\"headerlink\" title=\"슬레이브\"></a>슬레이브</h3><h4 id=\"마스터의-데이터-복제\"><a href=\"#마스터의-데이터-복제\" class=\"headerlink\" title=\"마스터의 데이터 복제\"></a>마스터의 데이터 복제</h4><p>현존하는 서버를 마스터로 하고 신규로 만들게 되는 서버를 슬레이브로하고 싶다면 마스터에서 데이터를 덤프를 받아 슬레이브에 적용시켜야 한다. 백업 시점은 마스터에서 바이너리 로그를 활성화한 이후여야 한다. <code>mysqldump</code> 사용 시, –master-data 옵션을 사용하여 바이너리 로그 위치 및 파일명을 가져올 수 있도록 지정할 수 있다.</p>\n<h4 id=\"server-id-설정-1\"><a href=\"#server-id-설정-1\" class=\"headerlink\" title=\"server_id 설정\"></a>server_id 설정</h4><h4 id=\"리플리케이션-설정\"><a href=\"#리플리케이션-설정\" class=\"headerlink\" title=\"리플리케이션 설정\"></a>리플리케이션 설정</h4><p><code>CHANGE MASTER</code> 명령어를 사용</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CHANGE MASTER <span class=\"keyword\">TO</span></span><br><span class=\"line\">MASTER_HOST <span class=\"operator\">=</span> `마스터의 호스트`</span><br><span class=\"line\">MASTER_PORT <span class=\"operator\">=</span> `PORT`,</span><br><span class=\"line\">MASTER_LOG_FILE <span class=\"operator\">=</span> `mysql<span class=\"operator\">-</span>bin<span class=\"number\">.000777</span>`,</span><br><span class=\"line\">MASTER_LOG_POS <span class=\"operator\">=</span> <span class=\"number\">12345678</span>,</span><br><span class=\"line\">MASTER_HEART_BEAT_PERIOD <span class=\"operator\">=</span> <span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"리플리케이션-시작\"><a href=\"#리플리케이션-시작\" class=\"headerlink\" title=\"리플리케이션 시작\"></a>리플리케이션 시작</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">START</span> SLAVE <span class=\"keyword\">USER</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;repl&#x27;</span> PASSWORD <span class=\"operator\">=</span> <span class=\"string\">&#x27;secret&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>제대로 동작하는지 유무를 확인하려면 <code>SHOW SLAVE STATUS</code> 명령어를 사용하여 Slave_IO_Running, Slave_SQL_Running 항목의 값이 <code>YES</code>인지 확인하자</p>\n<h2 id=\"GTID-Global-Transaction-ID\"><a href=\"#GTID-Global-Transaction-ID\" class=\"headerlink\" title=\"GTID(Global Transaction ID)\"></a>GTID(Global Transaction ID)</h2><p>바이너리 로그에 기록된 각각의 트랜잭션에 고유한 ID를 붙여주는 기능으로 아래와 같은 포맷을 가지게 된다</p>\n<p><code>발신처 MySQL 서버의 ID: 트랜잭션 ID</code></p>\n<p>발신처 서버의 ID는 최초 기동 시점에 UUID 값으로 생성되며 <code>auto.cnf</code> 파일 이름으로 저장된다. 기동 시 해당 파일이 존재하면 해당 파일의 값을 읽어서 해당 아이디 값을 사용하게 된다. 트랜잭션 ID의 값은 1부터 시작하여 단순히 증가하는 숫자 값이다.</p>\n<p>GTID는 1:N 형태의 리플리케이션 구조에서 슬레이브의 자동 마스터 승격에 사용된다. 미래에 승격 될 가능성이 있는 슬레이브에는 log-bin 옵션과 log_slave_update 옵션을 써서 바이너리 로그를 출력하도록 설정되어 있어야 한다. GTID가 존재하기 때문에 슬레이브에서는 본인이 생성한 GTID와 마스터에서 생성한 GTID를 구분할 수 있는 기준이 생기기 때문에 변경에 대한 전후 관계를 뚜렷하게 기록할 수 있게 된다. </p>\n<h3 id=\"GTID의-온라인-상태에서의-활성화-비활성화\"><a href=\"#GTID의-온라인-상태에서의-활성화-비활성화\" class=\"headerlink\" title=\"GTID의 온라인 상태에서의 활성화/비활성화\"></a>GTID의 온라인 상태에서의 활성화/비활성화</h3><p>[TODO]: 활성화 과정 설명 추가</p>\n<h2 id=\"준동기-리플리케이션\"><a href=\"#준동기-리플리케이션\" class=\"headerlink\" title=\"준동기 리플리케이션\"></a>준동기 리플리케이션</h2><h3 id=\"개요-1\"><a href=\"#개요-1\" class=\"headerlink\" title=\"개요\"></a>개요</h3><p>준동기 리플리케이션은 MySQL 5.5에서 추가된 기능으로 마스터에서 일어난 변경이 슬레이브에 확실하게 전달되었지를 보장하는 것을 말한다. 마스터에서 트랜잭션이 실행되면 COMMIT을 완료하기 전 슬레이브 바이너리 로그를 전송하게 되는 형식으로 완벽하게 동기화 되는 시점이 동일하지 않기 때문에 동기라고 보증할 수 없다. 준동기 리플리케이션은 통상의 리플리케이션과 비교하여 커밋의 오버헤드가 큰 편이고 ACK에 대한 지연이 특히 문제로 이어 질 수 있으므로 주의해야 한다고 한다.</p>\n<blockquote>\n<p><code>2단계 커밋(Two-Phase-Commit)</code><br>커밋을 PREPARE와 COMMIT의 두 단계로 나눈 것을 말하는데, 만약 준동기 모델이 아닌 동기 모델에서 리플리케이션을 처리한다면 2단계 커밋 방식으로 처리해야 한다고 한다.</p>\n</blockquote>\n<h4 id=\"준동기-모델\"><a href=\"#준동기-모델\" class=\"headerlink\" title=\"준동기 모델\"></a>준동기 모델</h4><p><img src=\"https://i.imgur.com/nMNx3kA.png\" alt=\"MYSQL_리플리케이션_준동기\"></p>\n<h3 id=\"무손실-리플리케이션\"><a href=\"#무손실-리플리케이션\" class=\"headerlink\" title=\"무손실 리플리케이션\"></a>무손실 리플리케이션</h3><p>MySQL 5.6까지의 준동기 리플리케이션은 슬레이브가 ACK를 기다리는 시점이 클라이언트에게 응답을 반환하기 직전 타이밍이었다. 하지만, 이런 구조에서 마스터가 손상될 경우 마스터에만 존재하는 데이터가 있을 수 있는 치명적인 단점이 있다고 한다. </p>\n<p><strong>개선된 모델에서 기존 준동기 모델과 다른 점은 ACK를 기다리는 시점을 변경하는 것이다. MySQL 5.7에서는 COMMIT을 실행한 다음이 아니라 COMMIT을 실행하기 전 시점에 ACK를 기다리도록 변경했다.</strong></p>\n<h4 id=\"무손실-모델\"><a href=\"#무손실-모델\" class=\"headerlink\" title=\"무손실 모델\"></a>무손실 모델</h4><p><img src=\"https://i.imgur.com/DVLNS6K.png\" alt=\"MYSQL_리플리케이션_무손실\"></p>\n<h3 id=\"성능-개선\"><a href=\"#성능-개선\" class=\"headerlink\" title=\"성능 개선\"></a>성능 개선</h3><ul>\n<li>기존 MySQL 5.6에서는 ACK를 수신하기까지 다른 이벤트를 송신할 수 없다는 단점이 존재했다. 5.7에서는 새로운 ACK를 처리하는 새로운 스레드를 도입함으로써 이러한 문제를 해결했는데, 말그래도 ACK 스레드라고 부른다. </li>\n<li>ACK 스레드의 존재 여부는 <code>performance_schema.threads</code> 테이블에서 확인 할 수 있다.</li>\n</ul>\n<h2 id=\"멀티-소스-리플리케이션\"><a href=\"#멀티-소스-리플리케이션\" class=\"headerlink\" title=\"멀티 소스 리플리케이션\"></a>멀티 소스 리플리케이션</h2><ul>\n<li>여러 마스터로부터 동시에 변경을 받아들이는 구조로 MySQL 5.7부터 사용가능하다. 여러 마스터로부터 데이터를 수신할 때 <code>채널</code>이라는 개념을 도입하여 사용하는데 이는 마스터와 통신하는 것 자체를 가리키는 용어이다.</li>\n<li>멀티 소스 리플리케이션에서는 여러 마스터의 갱신에서 경합이 생기지 않도록 주의해야 한다. 특히 각각의 마스터에 같은 데이터를 포함되지 않아야 되고 바이너리 로그의 포맷도 SBR이 아닌 RBR을 사용하도록 해야 한다.</li>\n<li>데이터 갱신의 경우 비동기로 이뤄지기 때문에, 어떤 순간에 취한 데이터의 정합성이 반드시 맞기는 어려울 수 있다.</li>\n</ul>\n<h2 id=\"마스터-성능-개선\"><a href=\"#마스터-성능-개선\" class=\"headerlink\" title=\"마스터 성능 개선\"></a>마스터 성능 개선</h2><h3 id=\"그룹-커밋\"><a href=\"#그룹-커밋\" class=\"headerlink\" title=\"그룹 커밋\"></a>그룹 커밋</h3><ul>\n<li>리플리케이션 간 데이터 동기화를 하려면 위에서 설명한 것처럼 바이너리 로그를 사용해야 하는데, 바이너리 로그를 쓰고 동기화하는 것 자체도 트랜잭션이라고 볼 수 있기 때문에 이에 대한 비용도 크다고 할 수 있다.</li>\n<li>MySQL 5.6부터는 이러한 바이너리 로그 트랜잭션에 대해 그룹단위로 커밋이 가능하도록 지원하기 시작했다.<br>[TODO]: 그룹커밋 이미지 추가</li>\n</ul>\n<h3 id=\"메모리-효율-개선\"><a href=\"#메모리-효율-개선\" class=\"headerlink\" title=\"메모리 효율 개선\"></a>메모리 효율 개선</h3><ul>\n<li>MySQL 5.6까지는 마스터 스레드에서 바이너리 로그에 대한 이벤트를 읽을 때마다 이벤트 크기 맞는 버퍼를 할당(malloc)하고 슬레이브에 송신 후 메모리를 해제(free)하는 방식을 사용했다.</li>\n<li>5.7에서 부터는 메모리 할당에 대한 성능 개선이 이뤄졌으며 매번 malloc과 free를 하지 않고 버퍼가 충분하면 그대로 사용하며 그렇지 않으면 다시 할당하여 사용하는 방식으로 변경했다. </li>\n<li>거대한 메모리 버퍼를 사용했을 경우, 해당 버퍼의 크기를 정기적으로 검토하여 남은 버퍼를 축소하는 기능를 탑재했다.</li>\n</ul>\n<h3 id=\"마스터-스레드의-Mutex-경합-개선\"><a href=\"#마스터-스레드의-Mutex-경합-개선\" class=\"headerlink\" title=\"마스터 스레드의 Mutex 경합 개선\"></a>마스터 스레드의 Mutex 경합 개선</h3><ul>\n<li><p>5.6 이후 도입된 그룹 커밋(<code>sync_binlog = 1</code>)으로 크게 성능이 향상 되었지만, 마스터의 손상 시 슬레이브에 기록되지 않은 데이터가 발생할 수 있는 문제가 생기가 되었다.</p>\n</li>\n<li><p>그룹 커밋 시 바이너리 로그를 디스크로 <code>fsync</code>하기 전에 몇 개의 트랜잭션을 묶어 바이너리 로그에 쓰게 되는데, 이때 <code>fsync</code>가 끝나지 않아도 <code>write</code>가 되는 시점에 슬레이브로 로그 전송를 하게 된다. <code>fsync</code>가 끝나지 않은 상태에서 마스터 서버에 손상이 발생하게 되면 재기동 후 바이너리 로그가 없어지고 이에 따라 해당 트랜잭션의 데이터는 롤백 처리가 된다. 하지만, 슬레이브로는 데이터가 전송이 되었기 때문에 슬레이브와 마스터의 부정합이 발생하게 되는 것이다.</p>\n</li>\n</ul>\n<p><img src=\"https://i.imgur.com/CppQA6T.png\" alt=\"MYSQL_리플리케이션_부정합\"></p>\n<ul>\n<li>위 그림에서 Tx1<del>5까지 하나의 그룹으로 커밋되고 있는데, 바이너리 로그가 디스크에 <code>fsync</code>를 하지 않은 상태에서 손상이 진행되면 1</del>5까지 해당하는 트랜잭션은 모두 롤백이 되게 된다, 하지만, 1<del>3까지의 트랜잭션이 슬레이브로 전송이 된 상태이므로 1</del>3까지의 트랜잭션 데이터는 슬레이브에만 존재하게 되는 것이다.</li>\n<li>5.6에서 이러한 문제 때문에, <code>LOCK_log</code>라는 Mutex에 의해 보호받도록 수정했으나 그룹 커밋과 마스터 스레드가 Mutex를 얻기 위한 경합이 발생하면서 마스터 스레드에서 슬레이브로의 바이너리 로그 전송 효율이 떨어지게 되었다.</li>\n<li>5.7에서는 <code>LOCK_log</code>는 그대로 남아 있지만, 사용하지 않고 <code>LOG_binlog_end_pos</code>라는 Mutex를 도입하여 LOCK의 입자 크기를 미세하게 조정했다. 해당 Mutex는 마스터 스레드가 읽어 들이는 것이 가능한 최후의 바이너리 로그의 위치를 관리하게 된다. </li>\n<li>5.6에서는 EOF까지 바이너리 로그를 읽었으나 이럴 경우 <code>fsync</code> 처리 되지 않은 로그까지 읽게 된다. 이에 반해, 5.7에서는 마스터 스레드가 <code>fsync</code>된 데이터만 읽도록 읽기 가능한 로그의 포지션을 관리하게 했다. 마스터 스레드는 <code>fsync</code>가 된 로그만을 슬레이브로 전송하게 됨으로서 마스터가 손상되어도 슬레이브에도 동일한 데이터만 남게 되는 것이다.</li>\n</ul>\n<h2 id=\"병렬-SQL-스레드\"><a href=\"#병렬-SQL-스레드\" class=\"headerlink\" title=\"병렬 SQL 스레드\"></a>병렬 SQL 스레드</h2><h3 id=\"MTS의-LOGICAL-CLOCK-모드\"><a href=\"#MTS의-LOGICAL-CLOCK-모드\" class=\"headerlink\" title=\"MTS의 LOGICAL_CLOCK 모드\"></a>MTS의 LOGICAL_CLOCK 모드</h3><ul>\n<li>5.6부터 슬레이브의 SQL 스레드를 여러 개 생성하여 바이너리 로그의 재생을 병렬로 수행할 수 있게 되었다. 이러한 병렬로 처리하는 것을 MTS(Multi-Thread-Salve)라 부른다.</li>\n<li>리플리케이션 지연의 가장 큰 원인으로 SQL 스레드의 지연을 찾을 수 있는데, 이러한 지연은 마스터와 슬레이브 머신의 처리 차이에서 발생하게 된다. 마스터에서는 코어를 모두 사용하여 데이터를 갱신하는 반면, 슬레이브는 하나의 SQL 스레드가 하나하나 바이너리 로그를 재생하게 됨에 따라 이러한 지연이 발생하게 되는 것이다. </li>\n</ul>\n<p><strong>“결국 마스터 머신의 코어 개수가 많아 짐에 따라 이러한 지연은 더 크게 발생하게 되는 것이라 볼 수 있다.”</strong></p>\n<ul>\n<li>5.6에서는 이러한 병렬 SQL 스레드가 동일 데이터베이스에 활성화 시킬 수 없었기 때문에 대부분 이런 기능을 사용하지 않았지만, 5.7부터는 하나의 데이터베이스에도 병렬 SQL 스레드가 작업을 할수 있게 되었다.<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\"><span class=\"comment\"># 병렬 스레드 개수</span></span><br><span class=\"line\">slave_parallel_workers=32</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5.7 추가, 입자 크기 지정</span></span><br><span class=\"line\">slave_parallel_type=LOGICAL_CLOCK</span><br><span class=\"line\">\u001e</span><br><span class=\"line\"><span class=\"comment\"># 5.7 추가, COMMIT 순서가 바뀌지 않도록 지정, 0일 경우 미보장</span></span><br><span class=\"line\">slave_preserve_commit_order=1</span><br><span class=\"line\">log_bin=mysql-log</span><br><span class=\"line\">log_slave_updates=1</span><br></pre></td></tr></table></figure></li>\n<li>병렬로 실행 시, 동일한 데이터에 대한 트랜잭션인지 유무는 매우 중요하다. 만약 동일한 데이터에 대한 트랜잭션이 아닐 경우 내부적으로는(InnoDB에서는 바이너리 로그 동기화를 위하여 2-Phase-Commit을 내부적으로 사용한다.) 2-Phase-Commit에서 PREPARE 상태가 되었다는 것인데 해당 상태 값은 결국 동일한 트랜잭션에서 발생할 수 있는 LOCK으로 인한 경합이 발생하지 않았을 경우일뿐이다. </li>\n<li>마스터에서 슬레이브로 전달할 때 이러한 경합 혹은 순서에 대한 정보를 전달해줘야 하는데, 바이너리 로그에 <code>last_committed</code>와 <code>sequence_number</code>라는 항목으로 몇 번째 트랜잭션인지 카운터 값을 표기하고 있는 것을 볼수 있을 것이다.</li>\n<li>마스터에서 실행한 트랜잭션과 슬레이브가 실행한 트랜잭션이 달라질 수 있음은 위에서 설명한대로 병럴 SQL스레드의 처리 방식때문에 충분하게 의심을 해볼 수 있게 되는데, 이때 유용한 옵션이 바로 <code>slave_preserve_commit_order</code>이다. 명시적으로 1로 지정해줘야지 순서가 바뀌지 않게 되며 0으로 지정하게 되면 데이터 장합성을 보장받을 수 없게 되기 때문에 0으로 지정해서는 안된다.</li>\n</ul>\n<h3 id=\"마스터-튜닝\"><a href=\"#마스터-튜닝\" class=\"headerlink\" title=\"마스터 튜닝\"></a>마스터 튜닝</h3><ul>\n<li>LOGICAL_CLOCK 모드로 MTS를 사용하는 경우 마스터에서 그룹 커밋을 튜닝하여 보다 많은 트랜잭션이 하나의 그룹에 묶이도록 해야 한다. </li>\n<li><code>binlog_group_commit_sync_delay</code>, <code>binlog_group_commit_no_delay_count</code> 옵션을 조정하여 환경과 상황에 맞는 최적화를 진행하는 것이 중요하며, 마스터의 갱신 처리 성능에만 집중하는 것이 아니라 슬레이브에서의 지연 유무도 역시 주시해야 한다. </li>\n</ul>\n"},{"title":"JPA 영속성 관리","date":"2019-08-31T11:09:00.000Z","_content":"\n# JPA 영속성 관리\n\n> 자바 ORM 표준 JPA 프로그래밍 13장 내용을 정리\n\n스프링과 같은 컨테이너 환경에서 JPA를 사용하게 되면, 컨테이너 레벨에서 트랜잭션과 영속성 컨텍스트를 관리해주므로 어플리케이션 개발이 쉬워지게 되는데, 문제가 되는 부분은 내부 동작에 대한 정확한 이해가 없을 때 생기는 트러블 슈팅이 어려워 지는 부분이다. 내부동작에 대한 이해, 스프링 컨테이너에서의 기본 전략, 지연로딩, OSIV에 대한 내용을 가볍게 정리하고자 한다.\n\n## 트랜잭션 범위의 영속성 컨텍스트\n### 스프링 컨테이너의 기본 전략\n![트랜잭션_범위_영속성_컨텍스트](https://i.imgur.com/lgR6GfA.png)\n- 스프링은 트랜잭션 범위의 영속성 컨텍스트를 기본 전략으로 사용한다. \n- 트랜잭션 범위와 영속성 컨텍스트의 생존 범위가 동일하며, 트랜잭션 종료 시, 영속성 컨텍스트도 동일하게 종료하게 된다.\n\n![트랜잭션_범위_영속성_컨텍스트_AOP](https://i.imgur.com/vZtbhUl.png)\n- 스프링 어플리케이션에서는 `@Transactional`을 사용하여 트랜잭션을 시작하게 되는데, 단순 호출처럼 보이는 부분도 사실 스프링의 트랜잭션 AOP가 먼저 작동하게 된다.\n  * 스프링 트랜잭션 AOP는 대상 메소드를 호출하기 직전에 트랜잭션을 시작하며, 호출이 정상적으로 종료되면 트랜잭션을 커밋하고 종료하게 된다.\n  * 트랜잭션 커밋 시, JPA는 영속성 컨텍스트를 플러시하여 변경 내용을 DB에 반영한 후 트랜잭션을 커밋하게 된다.\n  * 예외가 발생하게 되면, 트랜잭션을 롤백하고 종료하게 되는데, 이때는 영속성 컨텍스트를 플러시하지 않게 된다.\n\n![트랜잭션_영속성컨텍스트](https://i.imgur.com/t9RFewK.png)\n- **트랜잭션이 같을 경우, 같은 영속성 컨텍스트를 사용한다.**\n  * 다양한 위치에서 엔티티 매니저(EntityManager)를 주입받아 사용해도 트랜잭션이 같으면 항상 같은 영속성 컨텍스트를 사용하게 된다.\n\n![스레드_영속성컨텍스트](https://i.imgur.com/al1qaZQ.png)\n- **트랜잭션이 다를 경우, 다른 영속성 컨텍스트를 사용한다.**\n  * **여러 스레드에서 동시에 요청에 올 경우, 같은 엔티티 매니저를 사용한다고 하더라도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 달라진다.** \n  * 다시 말해, **스프링 컨테이너에서는 스레드별로 각기 다른 트랜잭션을 할당하게 되는데**, 따라서 같은 엔티티 매니저를 호출해도 접근하는 영속성 컨텍스트가 다르기 때문에 멀티스레드 환경에서도 안전하다.\n\n\n## 준영속/지연 로딩\n- 조회한 엔티티가 트랜잭션 범위인 서비스, 레파지토리 레이어에서는 영속성 컨텍스트에 의해 관리가 되기 때문에 영속 상태를 유지하지만, 이 밖의 레이어에서는 준영속 상태가 된다.\n- 영속성 컨텍스트의 관리 밖에서는 `지연 로딩` 및 `변경 감지`가 동작하지 않는다.\n  * 따라서, 비지니스 혹은 요구사항을 기반으로 한 변경에 대해서는 반드시 서비스/도메인 레이어에서 수행을 해야한다. 컨트롤러와 같은 영역에서 이를 수행하게 되면 레이어별로 책임이 모호해지고 어플리케이션의 유지보수성이 급격하게 떨어지게 된다.\n  * 지연 로딩 기능이 동작하지 않기 때문에, 생기는 이슈는 생각보다 크다. 만약 컨트롤러와 같은 레이어에서 지연 로딩 상태의 연관 엔티티나 밸류를 조회하게 될 경우, `LazyIntializationException` 예외가 발생하게 된다.\n- 지연 로딩을 해결할 수 있는 방법은 아래와 같다.\n  * 필요한 엔티티를 미리 로딩\n    1. 글로벌 페치 전략 수정\n    2. JPQL 페치 조인\n    3. 강제로 초기화\n  * OSIV(Open Sessin in View)를 사용하여 엔티티를 항상 영속 상태로 유지\n\nOSIV의 경우 별도로 정리하는걸로 하고, 먼저 필요 엔티티를 미리 로딩하는 방법에 대해 정리하고자 한다. 말 그대로, 뷰 혹은 컨트롤러 레이어에서 필요한 데이터를 영속성 컨텍스트 범위 내에서 미리 로딩을 하는 방법을 가리키며 위에서 정리한대로 3가지 방법이 존재한다.\n\n### 글로벌 페치 전략 수정 - 즉시 로딩\n주문 엔티티에서 주문 상품 벨류 목록을 담고 있는 예제로 주문 상품 벨류의 경우 별도의 식별자가 필요하지 않기 때문에 `@ElementCollection`을 이용하여 주문 엔티티에 매핑을 했으며 글로벌 페치 전략은 즉시 로딩으로 설정해주었다.\n\n```kotlin\n@Entity\n@Table(name = \"orders\")\nclass Order protected constructor() {\n\n\t@Id\n\t@GeneratedValue(strategy = GenerationType.IDENTITY)\n\tvar id: Long = 0L\n\t\tprotected set\n\n\t@Column(nullable = false, updatable = false)\n\tvar memberId: Long = 0L\n\t\tprotected set\n\n\t@Enumerated(value = EnumType.STRING)\n\t@Column(length = 20, nullable = false)\n\tvar status: OrderStatus = OrderStatus.PAYMENT_WAITING\n\t\tprotected set\n\n\t@ElementCollection(fetch = FetchType.EAGER)\n\t@CollectionTable(\n\t\tname = \"order_products\",\n\t\tjoinColumns = [\n\t\t\tJoinColumn(name = \"id\")\n\t\t]\n\t)\n\t@AttributeOverrides(\n\t\tvalue = [\n\t\t\tAttributeOverride(name = \"productId\", column = Column(name = \"product_id\")),\n\t\t\tAttributeOverride(name = \"price\", column = Column(name = \"price\")),\n\t\t\tAttributeOverride(name = \"quantity\", column = Column(name = \"quantity\")),\n\t\t\tAttributeOverride(name = \"amounts\", column = Column(name = \"amounts\")),\n\t\t\tAttributeOverride(name = \"line_idx\", column = Column(name = \"line_idx\"))\n\t\t]\n\t)\n\t@OrderBy(value = \"line_idx\")\n\tvar orderProducts: MutableList<OrderProduct> = mutableListOf()\n\t\tprotected set\n\n\t@CreationTimestamp\n\t@Column(nullable = false)\n\tvar createdAt: LocalDateTime = LocalDateTime.now()\n\t\tprotected set\n\n\t@UpdateTimestamp\n\t@Column(nullable = false)\n\tvar updatedAt: LocalDateTime = LocalDateTime.now()\n\t\tprotected set\n\n\tcompanion object {\n\t\tfun doOrder(\n\t\t\tmemberId: Long,\n\t\t\tstatus: OrderStatus,\n\t\t\tproducts: List<OrderProduct>\n\t\t): Order {\n\t\t\tif (status !in listOf(OrderStatus.PAYMENT_WAITING, OrderStatus.PATMENT_COMPLETED)) throw IllegalArgumentException(\"올바른 주문 상태 값이 아닙니다.\")\n\t\t\tif (products.isEmpty()) throw IllegalArgumentException(\"최소 한개 이상의 구매 상품을 포함해야 합니다.\")\n\t\t\treturn Order().also {\n\t\t\t\tit.memberId = memberId\n\t\t\t\tit.status = status\n\t\t\t\tit.orderProducts = products.toMutableList()\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n```kotlin\n@Service\n@Transactional(read)\nclass OrderService(\n\tprivate val orderRepository: OrderRepository\n) {\n\tfun getList(pageable: Pageable): Page<Order> {\n\t\tval list = orderRepository.findAll(pageable)\n\t\treturn list\n\t}\n\n\tfun get(id: Long): Order {\n\t\treturn orderRepository.findByIdOrNull(id)\n\t\t\t\t?: throw NotExistsOrderException(\"존재하지 않은 주문입니다.\")\n\t}\n}\n```\n\n서비스 레이어에서 주문 엔티티에 대한 조회를 목록/단건 조회할 수 있도록 가벼운 코드를 작성했다. 주문ID 기준의 단건 조회의 경우, 연관 콜렉션에 매핑 되어 있는 `order_products`테이블을 LEFT OUTER JOIN을 사용하여 바로 조회하는 것을 확인 할 수 있다.\n![EAGER_LEFT_OUTER_JOIN](https://i.imgur.com/4N4g15c.png)\n\n\n여기까지는 문제가 없다고 생각할 수 있다. 하지만, 문제는 목록 조회 부분에서 생기게 되는데, 바로 `N+1` 문제이다. \n![EAGER_N+1](https://i.imgur.com/oWSQpfD.png)\n\n단건만 조회하는 엔티티라면 문제가 없겠지만, 대부분의 어플리케이션에서 목록 조회는 기본으로 하기 때문에 즉시 로딩을 사용함으로써 아래와 같은 단점이 생길 수 밖에 없다.\n- **불필요한 벨류/엔티티 조회**\n주문 엔티티에서 목록이 필요하지 않은 경우에도 매번 목록 데이터를 조회하기 때문에 DB 레벨에서의 오버헤드가 발생한다.\n- **N+1 문제 발생**\n  * 위 이미지를 통하여 볼 수 있듯이, 디비에 질의하는 쿼리 개수가 목록에서 반환하는 데이터 개수만큼의 IO가 발생하게 된다. 불필요한 IO 발생은 서버 어플리케이션에서는 당연히 지양해야 한다. \n  * JPQL을 사용하게 될 경우(ex. JpaRepository.findAll()), JPA는 SQL을 생성할 때 글로벌 페치 전략을 참고하지 않고 오직 JPQL 자체만 사용하게 된다. 아래는 SQL문을 생성하는 과정을 설명하고 있다.\n    1. `select o from Order o` JPQL을 분석하여 `select * from Order` SQL을 실행\n    2. 데이터베이스에서 결과를 받아 `Order`엔티티 목록을 생성\n    3. `Order.orderProducts`의 글로벌 페치 전략이 즉시 로딩이므로 연관 벨류 콜렉션을 로딩해야 한다.\n    4. 연관 벨류/엔티티를 영속성 컨텍스트에서 찾는다.\n    5. 영속성 컨텍스트에 저장되어 있는 1차 캐싱 데이터가 없을 경우, DB에 질의하여 데이터를 가져온다. 이때, `Order`엔티티 목록의 개수만큼 DB에 질의를 하게 된다.\n\n### 글로벌 페치 전략 수정 - 지연 로딩\n- 위에서 겪었던 N+1 문제의 경우, 연관 벨류 콜렉션의 글로벌 페치 전략을 지연 로딩으로 변경하고, 이를 영속성 컨텍스트 범위 내에서 호출해주면 해결할 수 있다. \n```kotlin\n@Service\n@Transactional(readOnly = true)\nclass OrderService(\n\tprivate val orderRepository: OrderRepository\n) {\n\tfun getList(pageable: Pageable): Page<Order> {\n\t\tval list = orderRepository.findAll(pageable)\n\t\tfor (order in list) {\n\t\t\t// 실제 값을 사용할 때 프록시 객체가 초기화 된다.\n\t\t\torder.orderProducts.forEach { it.amounts }\n\t\t}\n\t\treturn list\n\t}\n\n\tfun get(id: Long): Order {\n\t\tval order = (orderRepository.findByIdOrNull(id)\n\t\t\t\t?: throw NotExistsOrderException(\"존재하지 않은 주문입니다.\"))\n\t\t// 실제 값을 사용할 때 프록시 객체가 초기화 된다.\n\t\torder.orderProducts.forEach { it.amounts }\n\t\treturn order\n\t}\n}\n```\n- **글로벌 페치 전략을 지연 로딩으로 변경하게 될 경우, 연관 벨류/엔티티를 실제가 아닌 프록시 객체를 대상으로 조회하게 된다.** \n프록시의 경우 실제 사용할 때 초기화가 진행되기 때문에, 위 코드처럼 **실제 값을 호출하는 코드를 넣어줘야지 초기화가 진행된다.**\n- 위 예제 코드의 경우, ID 기준의 조회 메소드인 get에서는 지연 로딩의 이점을 충분히 잘 살려냈다고 할 수 있지만, 목록 조회에서의 경우, 강제 초기화를 진행하더라도 즉시 로딩에서처럼 초기화 시 매번 매핑한 벨류 콜렉션을 조회하는 또 다른 의미의 `N+1`이 발생하게 된다.\n- 이와 같은 형태의 `N+1`을 피하기 위해서 사용할 수 있는 방법으로는 아래와 같다. \n  * 하이버네이트의 `@BatchSize`가 있다. `@BatchSize`를 사용할 경우, 프록시를 통하여 초기화 대상이 되는 연관 벨류/엔티티의 실제 값을 가져오는 DB 질의를 in절로 수정하여 N번의 DB 질의가 발생하지 않도록 해준다. 하지만, `@BatchSize`를 사용하더라도 실제 연관 벨류/엔티티를 초기화 해줘야 하는건 동일하기 때문에, 아래와 같이 기준을 나눠서 매핑하는 전략을 생각해볼 수 있다.\n  * JPQL fetch 조인을 사용하면 조회하면 시점에 SQL 조인을 사용하여 함께 로딩할 벨류/엔티티를 로딩할 수 있다. 하지만, JPQL의 페치 조인을 사용하게 되면 프레젠테이션 영역에 필요한 데이터에 맞춘 레파지토리 메소드가 늘어날 수 있다는 단점이 분명히 존재한다.\n  > 트레이드오프가 필요한 지점이다. 성능적인 최적화 혹은 높은 TPS를 처리해야 하는 어플리케이션에서 불필요한 IO는 병목지점이 될 수 밖에 없다. 연관 엔티티를 모두 조회하더라도 Cache를 적용하여 불필요하게 DB IO가 발생하지 않도록 하는 방법도 좋고, 필요한 DB IO만 발생하도록 JPQL을 사용하는 방법 모두 상황에 따라 맞는 방법이라고 생각한다.\n\n### 그래서 최선의 방법은?\n- 결국, **트랜잭션 경계 밖에서의 준영속 상태가 문제의 핵심이다.** \n이를 해결하기 위해서는 경계 밖에서도 영속성 컨텍스트가 살아있도록 해주는 방법을 사용하면 자연스럽게 지연로딩에서 발생할 수 있는 문제를 해결할 수 있다. 그것이 바로 `OSIV`이다.\n\n## OSIV\n- Open Session In View\n- 영속성 컨텍스트를 프레젠테이션 레이어까지 열어둔다는 뜻이다.\n- 하이버네이트에서는 `OSIV` 스프링에서는 `OEIV`라고 부르며, 관례상으로 OSIV라고 통칭하는 듯 하다.\n- 하이버네이트의 OSIV와 스프링에서의 OEIV는 비슷하지만 차이점이 분명하게 존재한다. 쉽게 생각하여 하이버네이트에서의 OSIV의 단점을 개선한 것이 OEIV라고 봐도 좋다.\n\n### 과거 OSIV: 요청 당 트랜잭션\n- 초창기 OSIV는 요청 당 트랜잭션을 지원했는데 아래 그림을 참고하자\n![OSIV_요청당트랜잭션](https://i.imgur.com/sFEvc8g.png)\n- 서블릿 필터 혹은 스프링 인터셉터에서 영속성 컨텍스트를 생성하며 이때부터 트랜잭션을 시작하고 요청이 끝날 때 트랜잭션과 영속성 컨텍스트를 함께 종료하게 된다.\n- 프레젠테이션 레이어도 트랜잭션 경계내에 존재하게 됨에 따라, 지연로딩을 처리하기 위해 프록시 객체를 초기화해야 하는 과정이 필요없게 된다. 하지만, 트랜잭션의 경계가 비즈니스 레이어가 아닌 프레젠테이션 레이어부터 시작함에 따라 **트랜잭션의 경계가 모호해지며 비즈니스 레이어가 아닌 곳에서 데이터 변경이 발생하는 문제가 생길 수 있다.**\n\n#### 요청 당 트랜잭션 모델의 문제점\n- JDBC 커넥션 보유 시간 증가\n  * JDBC 커넥션은 뷰의 렌더링이 모두 완료된 후에야 커넥션 풀로 반환된다. 따라서 뷰의 렌더링 시간이 길어지면 길어질수록 개별 요청을 처리하기 위한 스레드가 JDBC 커넥션을 보유하는 시간이 길어진다.\n- 모호한 트랜잭션 경계\n  * 예를 들어, 특정 컨트롤러에서 뷰에 표현하고자 하는 목적으로 엔티티를 변경한다면 요청에 마무리되는 시점에 해당 변경 사항이 영속성 컨텍스트에 변경 감지에 의해 반영이 되고 플러쉬됨에 따라 디비에 반영까지 되는 사이드 이펙트가 생기게 된다. 데이터의 변경이 도메인 계층이 아닌 이외 계층에서 이뤄진다면 유지보수성은 급격히 떨어지게 된다.\n    - 뷰/프레젠테이션 레이어에서 엔티티를 변경하지 못하도록 하는 방법을 생각해볼 수 있다.\n      * DTO 객체 반환\n      * 세터 지양\n      * 읽기 전용 인터페이스/메서드 제공\n  * 일반적으로 애플리케이션의 트랜잭션 경계는 애플리케이션 레이어 SERVICE 를 경계로 한다. 즉, SERVICE 메서드 호출 전에 바로 트랜잭션이 시작되고 SERVICE 메서드 호출이 종료될 때 트랜잭션이 커밋되거나 롤백되는 것이 일반적이다. 이에 비해 과거 OSIV 서블릿 필터의 트랜잭션 경계는 HTTP 요청 처리 시간의 거의 대부분을 아우른다. 결국 트랜잭션 경계에 대한 일관성 있는 뷰를 유지할 수 없으며 이로 인해 다양한 문제가 발생할 여지가 있다.\n\n### 스프링 OSIV: 비즈니스 계층 트랜잭션\n![OSIV_SPRING](https://i.imgur.com/OxibUm8.png)\n- `비즈니스 계층`에서 `트랜잭션`을 사용하는 OSIV\n- 뷰 렌더링 시점의 지연 로딩을 허용하면서도 일관성 있는 트랜잭션 경계를 유지하는 합리적인 절충안으로 서블릿 필터에서 Session 을 오픈하되 트랜잭션 경계는 애플리케이션 레이어 범위로 한정하는 것이다.\n- Spring 프레임워크에서는 `FlushMode` 와 `ConnectionReleaseMode` 의 조정을 통해 과거 OSIV 모델의 단점을 보완할 `OpenSessionInViewFliter`와 `OpenSessionInViewInterceptor`를 제공한다.\n- 자세한 내용은 아래 내용을 참조하도록 하자\n  1. 클라이언트의 요청 시, 서블릿 필터/인터셉터에서 영속성 컨텍스트를 생성한다. 단, 트랜잭션은 시작하지 않음\n  2. 도메인 계층에서 트랜잭션을 시작할 때, 1번에서 생성한 영속성 컨텍스트를 사용하여 트랜잭션을 시작\n  3. 도메인 계층의 서비스가 종료되면서 트랜잭션이 커밋하고 영속성 컨텍스트를 플러쉬한다. 트랜잭션은 종료가 되지만 영속성 컨텍스트를 종료하지 않는다.\n  4. 영속성 컨텍스트가 도메인 레이어가 아닌 프레젠테이션 레이어에서도 유지됨에 따라, 반환하는 엔티티는 영속 상태를 유지한다.\n  5. 필터/인터셉터로 돌아와서 영속성 컨텍스트를 종료한다. 이때는 영속성 컨텍스트를 플러쉬하지 않는다.\n\n#### 트랜잭션 없는 읽기\n- 트랜잭션 없이 영속성 컨텍스트를 플러쉬하게 되면 `javax.persistence.TransactionRequiredException` 예외가 발생\n- 변경은 반드시 트랜잭션 내에서 이뤄져야 하는데, 조회의 경우 트랜잭션 없이도 가능하다. 이것을 바로 `트랜잭션 없이 읽기(Nontransactional reads)`라고 한다.\n- **프록시 객체를 초기화하는 지연 로딩 역시 조회이므로 트랜잭션 없이 읽기가 가능하다.**\n- 결국 스프링 OSIV를 이용하게 되면 도메인 계층에서만 트랜잭션을 이용하여 변경이 가능하고, 이 밖의 레이어인 프레젠테이션 레이어에서는 엔티티를 변경한다고 하여도 영속성 컨텍스트를 플러쉬하지 않기 때문에 변경이 불가능하고 오직 읽기만 가능하게 되는 것이다. \n\n#### 스프링 OSIV 사용 시 주의점\n- 서비스 호출 후 컨트롤러에서 반환하는 엔티티가 있다고 가정해보자. \n이미 종료한 트랜잭션에서 반환한 엔티티이며 OSIV를 사용하고 있기 때문에 여전히 영속 상태를 유지하게 될 것이다. 요구사항에 의해 엔티티를 일부 값을 수정하며 바로 뷰를 반환하면 OSIV를 사용하기 때문에 문제가 전혀 없다. \n하지만, **바로 뷰로 데이터를 반환하지 않고 또 다른 서비스 메서드를 호출하여 트랜잭션을 시작할 경우 문제가 발생하게 된다.** \n왜냐하면, 스프링 OSIV에 의하여 영속성 컨텍스트를 살아 있는 상태를 유지하기 때문에, 이전에 변경한 값이 새로 시작한 트랜잭션 커밋에 의해, 영속성 컨텍스트를 플러쉬하게 되는데 플러쉬하는 시점에 이전에 변경한 엔티티의 변경사항이 그대로 실제 데이터베이스에 반영되기 때문이다.\n```puml\n@startuml\nactor User as U\nparticipant MemberController as A\nparticipant MemberService as B\nparticipant MemberRepository as C\nparticipant AnotherService as D\nautonumber\nU -> A: HTTP 요청\nA -> B: Member 조회 서비스 메서드 실행\\n - 트랜잭션 시작\nactivate B\nB <-> C: Member 엔티티 조회 후 반환\nB -> A: Member 엔티티 반환\\n - Transaction Commit 그리고 영속성 컨텍스트 플러쉬\ndeactivate B\nA -> A: Member 엔티티 수정\\n - member.setName(\"XXX\")\nalt 뷰를 반환하지 않고 별도의 트랜잭션을 시작하는 경우\n\tautonumber 6\n\tA -> D: 별도 서비스 메서드 실행\\n - 트랜잭션 시작\n\tactivate D\n\tD -> A: 메서드 반환\\n - 트랜잭션 커밋 그리고 영속성 컨텍스트 플러쉬\\n: 5번에서 member.setName(\"XXX\")를 실행한 내용이 \\n영속성 컨텍스트의 변경감지에 의하여 반영 그리고 \\n트랜잭션울 커밋하고 영속성 컨텍스트가 플러쉬되어 \\n실제 데이터베이스에 변경을 반영\n\tdeactivate D\t\nelse \nend\nA -> U: 뷰에 맞는 데이터 반환\n@enduml\n```\n- 위와 같은 문제는 같은 영속성 컨텍스트를 여러 트랜잭션에서 공유하기 때문에 발생하는 문제로 해결하는 단순한 방법은 **트랜잭션이 있는 비즈니스 로직을 모두 호출하고 나서 엔티티를 변경하면 쉽게 해결된다.** \n다시 말해, **선 트랜잭션 후 변경으로 요약할 수 있다.**\n\n### OSIV를 사용하는 것이 만능이 아니다.\n- 객체 그래프의 뎁스가 깊어진다면 OSIV를 사용했을 때, 성능적으로 신경써야 할 부분도 많아진다.\n- 도메인의 요구사항 단순 엔티티만을 반환하여 끝나는 경우는 생각보다 드물다. 특히 통계 성격의 데이터를 조회해야 하는 경우가 대표적인데, 이럴 경우 차리리 JPQL을 사용하여 데이터를 조회하고 이를 DTO 객체로 바인딩하여 반환하는 것이 생각보다 쉬운 해결책일 수도 있다. \n- 너무 복잡하거나 DB 종속적인 연산을 사용해야 할 경우도 생길 수 있는데, 이럴 경우 하이버네이트의 `@SubSelect`를 사용하여 별도로 조회 전용 도메인 객체를 만들어서 해결하는 방법도 존재한다. 물론 DB 종속적인 연산을 사용하게 됨에 따라 추후 DB 변경에 대한 대응이 어려워질 수 있는 부분도 분명 존재하지만, 일반적으로 사용하고 있는 데이터베이스를 변경하는 작업은 쉽게 일어나지도 않을 뿐더러 완벽하게 어플리케이션 레이어에서 변경을 쉽게 커버할 수 있는 경우 더 드물다고 생각한다. \n\n","source":"_posts/Persistence/JPA_영속성관리.md","raw":"---\ntitle: 'JPA 영속성 관리'\ndate: 2019.8.31. 20:09\ncategories:\n- Persistence\n---\n\n# JPA 영속성 관리\n\n> 자바 ORM 표준 JPA 프로그래밍 13장 내용을 정리\n\n스프링과 같은 컨테이너 환경에서 JPA를 사용하게 되면, 컨테이너 레벨에서 트랜잭션과 영속성 컨텍스트를 관리해주므로 어플리케이션 개발이 쉬워지게 되는데, 문제가 되는 부분은 내부 동작에 대한 정확한 이해가 없을 때 생기는 트러블 슈팅이 어려워 지는 부분이다. 내부동작에 대한 이해, 스프링 컨테이너에서의 기본 전략, 지연로딩, OSIV에 대한 내용을 가볍게 정리하고자 한다.\n\n## 트랜잭션 범위의 영속성 컨텍스트\n### 스프링 컨테이너의 기본 전략\n![트랜잭션_범위_영속성_컨텍스트](https://i.imgur.com/lgR6GfA.png)\n- 스프링은 트랜잭션 범위의 영속성 컨텍스트를 기본 전략으로 사용한다. \n- 트랜잭션 범위와 영속성 컨텍스트의 생존 범위가 동일하며, 트랜잭션 종료 시, 영속성 컨텍스트도 동일하게 종료하게 된다.\n\n![트랜잭션_범위_영속성_컨텍스트_AOP](https://i.imgur.com/vZtbhUl.png)\n- 스프링 어플리케이션에서는 `@Transactional`을 사용하여 트랜잭션을 시작하게 되는데, 단순 호출처럼 보이는 부분도 사실 스프링의 트랜잭션 AOP가 먼저 작동하게 된다.\n  * 스프링 트랜잭션 AOP는 대상 메소드를 호출하기 직전에 트랜잭션을 시작하며, 호출이 정상적으로 종료되면 트랜잭션을 커밋하고 종료하게 된다.\n  * 트랜잭션 커밋 시, JPA는 영속성 컨텍스트를 플러시하여 변경 내용을 DB에 반영한 후 트랜잭션을 커밋하게 된다.\n  * 예외가 발생하게 되면, 트랜잭션을 롤백하고 종료하게 되는데, 이때는 영속성 컨텍스트를 플러시하지 않게 된다.\n\n![트랜잭션_영속성컨텍스트](https://i.imgur.com/t9RFewK.png)\n- **트랜잭션이 같을 경우, 같은 영속성 컨텍스트를 사용한다.**\n  * 다양한 위치에서 엔티티 매니저(EntityManager)를 주입받아 사용해도 트랜잭션이 같으면 항상 같은 영속성 컨텍스트를 사용하게 된다.\n\n![스레드_영속성컨텍스트](https://i.imgur.com/al1qaZQ.png)\n- **트랜잭션이 다를 경우, 다른 영속성 컨텍스트를 사용한다.**\n  * **여러 스레드에서 동시에 요청에 올 경우, 같은 엔티티 매니저를 사용한다고 하더라도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 달라진다.** \n  * 다시 말해, **스프링 컨테이너에서는 스레드별로 각기 다른 트랜잭션을 할당하게 되는데**, 따라서 같은 엔티티 매니저를 호출해도 접근하는 영속성 컨텍스트가 다르기 때문에 멀티스레드 환경에서도 안전하다.\n\n\n## 준영속/지연 로딩\n- 조회한 엔티티가 트랜잭션 범위인 서비스, 레파지토리 레이어에서는 영속성 컨텍스트에 의해 관리가 되기 때문에 영속 상태를 유지하지만, 이 밖의 레이어에서는 준영속 상태가 된다.\n- 영속성 컨텍스트의 관리 밖에서는 `지연 로딩` 및 `변경 감지`가 동작하지 않는다.\n  * 따라서, 비지니스 혹은 요구사항을 기반으로 한 변경에 대해서는 반드시 서비스/도메인 레이어에서 수행을 해야한다. 컨트롤러와 같은 영역에서 이를 수행하게 되면 레이어별로 책임이 모호해지고 어플리케이션의 유지보수성이 급격하게 떨어지게 된다.\n  * 지연 로딩 기능이 동작하지 않기 때문에, 생기는 이슈는 생각보다 크다. 만약 컨트롤러와 같은 레이어에서 지연 로딩 상태의 연관 엔티티나 밸류를 조회하게 될 경우, `LazyIntializationException` 예외가 발생하게 된다.\n- 지연 로딩을 해결할 수 있는 방법은 아래와 같다.\n  * 필요한 엔티티를 미리 로딩\n    1. 글로벌 페치 전략 수정\n    2. JPQL 페치 조인\n    3. 강제로 초기화\n  * OSIV(Open Sessin in View)를 사용하여 엔티티를 항상 영속 상태로 유지\n\nOSIV의 경우 별도로 정리하는걸로 하고, 먼저 필요 엔티티를 미리 로딩하는 방법에 대해 정리하고자 한다. 말 그대로, 뷰 혹은 컨트롤러 레이어에서 필요한 데이터를 영속성 컨텍스트 범위 내에서 미리 로딩을 하는 방법을 가리키며 위에서 정리한대로 3가지 방법이 존재한다.\n\n### 글로벌 페치 전략 수정 - 즉시 로딩\n주문 엔티티에서 주문 상품 벨류 목록을 담고 있는 예제로 주문 상품 벨류의 경우 별도의 식별자가 필요하지 않기 때문에 `@ElementCollection`을 이용하여 주문 엔티티에 매핑을 했으며 글로벌 페치 전략은 즉시 로딩으로 설정해주었다.\n\n```kotlin\n@Entity\n@Table(name = \"orders\")\nclass Order protected constructor() {\n\n\t@Id\n\t@GeneratedValue(strategy = GenerationType.IDENTITY)\n\tvar id: Long = 0L\n\t\tprotected set\n\n\t@Column(nullable = false, updatable = false)\n\tvar memberId: Long = 0L\n\t\tprotected set\n\n\t@Enumerated(value = EnumType.STRING)\n\t@Column(length = 20, nullable = false)\n\tvar status: OrderStatus = OrderStatus.PAYMENT_WAITING\n\t\tprotected set\n\n\t@ElementCollection(fetch = FetchType.EAGER)\n\t@CollectionTable(\n\t\tname = \"order_products\",\n\t\tjoinColumns = [\n\t\t\tJoinColumn(name = \"id\")\n\t\t]\n\t)\n\t@AttributeOverrides(\n\t\tvalue = [\n\t\t\tAttributeOverride(name = \"productId\", column = Column(name = \"product_id\")),\n\t\t\tAttributeOverride(name = \"price\", column = Column(name = \"price\")),\n\t\t\tAttributeOverride(name = \"quantity\", column = Column(name = \"quantity\")),\n\t\t\tAttributeOverride(name = \"amounts\", column = Column(name = \"amounts\")),\n\t\t\tAttributeOverride(name = \"line_idx\", column = Column(name = \"line_idx\"))\n\t\t]\n\t)\n\t@OrderBy(value = \"line_idx\")\n\tvar orderProducts: MutableList<OrderProduct> = mutableListOf()\n\t\tprotected set\n\n\t@CreationTimestamp\n\t@Column(nullable = false)\n\tvar createdAt: LocalDateTime = LocalDateTime.now()\n\t\tprotected set\n\n\t@UpdateTimestamp\n\t@Column(nullable = false)\n\tvar updatedAt: LocalDateTime = LocalDateTime.now()\n\t\tprotected set\n\n\tcompanion object {\n\t\tfun doOrder(\n\t\t\tmemberId: Long,\n\t\t\tstatus: OrderStatus,\n\t\t\tproducts: List<OrderProduct>\n\t\t): Order {\n\t\t\tif (status !in listOf(OrderStatus.PAYMENT_WAITING, OrderStatus.PATMENT_COMPLETED)) throw IllegalArgumentException(\"올바른 주문 상태 값이 아닙니다.\")\n\t\t\tif (products.isEmpty()) throw IllegalArgumentException(\"최소 한개 이상의 구매 상품을 포함해야 합니다.\")\n\t\t\treturn Order().also {\n\t\t\t\tit.memberId = memberId\n\t\t\t\tit.status = status\n\t\t\t\tit.orderProducts = products.toMutableList()\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n```kotlin\n@Service\n@Transactional(read)\nclass OrderService(\n\tprivate val orderRepository: OrderRepository\n) {\n\tfun getList(pageable: Pageable): Page<Order> {\n\t\tval list = orderRepository.findAll(pageable)\n\t\treturn list\n\t}\n\n\tfun get(id: Long): Order {\n\t\treturn orderRepository.findByIdOrNull(id)\n\t\t\t\t?: throw NotExistsOrderException(\"존재하지 않은 주문입니다.\")\n\t}\n}\n```\n\n서비스 레이어에서 주문 엔티티에 대한 조회를 목록/단건 조회할 수 있도록 가벼운 코드를 작성했다. 주문ID 기준의 단건 조회의 경우, 연관 콜렉션에 매핑 되어 있는 `order_products`테이블을 LEFT OUTER JOIN을 사용하여 바로 조회하는 것을 확인 할 수 있다.\n![EAGER_LEFT_OUTER_JOIN](https://i.imgur.com/4N4g15c.png)\n\n\n여기까지는 문제가 없다고 생각할 수 있다. 하지만, 문제는 목록 조회 부분에서 생기게 되는데, 바로 `N+1` 문제이다. \n![EAGER_N+1](https://i.imgur.com/oWSQpfD.png)\n\n단건만 조회하는 엔티티라면 문제가 없겠지만, 대부분의 어플리케이션에서 목록 조회는 기본으로 하기 때문에 즉시 로딩을 사용함으로써 아래와 같은 단점이 생길 수 밖에 없다.\n- **불필요한 벨류/엔티티 조회**\n주문 엔티티에서 목록이 필요하지 않은 경우에도 매번 목록 데이터를 조회하기 때문에 DB 레벨에서의 오버헤드가 발생한다.\n- **N+1 문제 발생**\n  * 위 이미지를 통하여 볼 수 있듯이, 디비에 질의하는 쿼리 개수가 목록에서 반환하는 데이터 개수만큼의 IO가 발생하게 된다. 불필요한 IO 발생은 서버 어플리케이션에서는 당연히 지양해야 한다. \n  * JPQL을 사용하게 될 경우(ex. JpaRepository.findAll()), JPA는 SQL을 생성할 때 글로벌 페치 전략을 참고하지 않고 오직 JPQL 자체만 사용하게 된다. 아래는 SQL문을 생성하는 과정을 설명하고 있다.\n    1. `select o from Order o` JPQL을 분석하여 `select * from Order` SQL을 실행\n    2. 데이터베이스에서 결과를 받아 `Order`엔티티 목록을 생성\n    3. `Order.orderProducts`의 글로벌 페치 전략이 즉시 로딩이므로 연관 벨류 콜렉션을 로딩해야 한다.\n    4. 연관 벨류/엔티티를 영속성 컨텍스트에서 찾는다.\n    5. 영속성 컨텍스트에 저장되어 있는 1차 캐싱 데이터가 없을 경우, DB에 질의하여 데이터를 가져온다. 이때, `Order`엔티티 목록의 개수만큼 DB에 질의를 하게 된다.\n\n### 글로벌 페치 전략 수정 - 지연 로딩\n- 위에서 겪었던 N+1 문제의 경우, 연관 벨류 콜렉션의 글로벌 페치 전략을 지연 로딩으로 변경하고, 이를 영속성 컨텍스트 범위 내에서 호출해주면 해결할 수 있다. \n```kotlin\n@Service\n@Transactional(readOnly = true)\nclass OrderService(\n\tprivate val orderRepository: OrderRepository\n) {\n\tfun getList(pageable: Pageable): Page<Order> {\n\t\tval list = orderRepository.findAll(pageable)\n\t\tfor (order in list) {\n\t\t\t// 실제 값을 사용할 때 프록시 객체가 초기화 된다.\n\t\t\torder.orderProducts.forEach { it.amounts }\n\t\t}\n\t\treturn list\n\t}\n\n\tfun get(id: Long): Order {\n\t\tval order = (orderRepository.findByIdOrNull(id)\n\t\t\t\t?: throw NotExistsOrderException(\"존재하지 않은 주문입니다.\"))\n\t\t// 실제 값을 사용할 때 프록시 객체가 초기화 된다.\n\t\torder.orderProducts.forEach { it.amounts }\n\t\treturn order\n\t}\n}\n```\n- **글로벌 페치 전략을 지연 로딩으로 변경하게 될 경우, 연관 벨류/엔티티를 실제가 아닌 프록시 객체를 대상으로 조회하게 된다.** \n프록시의 경우 실제 사용할 때 초기화가 진행되기 때문에, 위 코드처럼 **실제 값을 호출하는 코드를 넣어줘야지 초기화가 진행된다.**\n- 위 예제 코드의 경우, ID 기준의 조회 메소드인 get에서는 지연 로딩의 이점을 충분히 잘 살려냈다고 할 수 있지만, 목록 조회에서의 경우, 강제 초기화를 진행하더라도 즉시 로딩에서처럼 초기화 시 매번 매핑한 벨류 콜렉션을 조회하는 또 다른 의미의 `N+1`이 발생하게 된다.\n- 이와 같은 형태의 `N+1`을 피하기 위해서 사용할 수 있는 방법으로는 아래와 같다. \n  * 하이버네이트의 `@BatchSize`가 있다. `@BatchSize`를 사용할 경우, 프록시를 통하여 초기화 대상이 되는 연관 벨류/엔티티의 실제 값을 가져오는 DB 질의를 in절로 수정하여 N번의 DB 질의가 발생하지 않도록 해준다. 하지만, `@BatchSize`를 사용하더라도 실제 연관 벨류/엔티티를 초기화 해줘야 하는건 동일하기 때문에, 아래와 같이 기준을 나눠서 매핑하는 전략을 생각해볼 수 있다.\n  * JPQL fetch 조인을 사용하면 조회하면 시점에 SQL 조인을 사용하여 함께 로딩할 벨류/엔티티를 로딩할 수 있다. 하지만, JPQL의 페치 조인을 사용하게 되면 프레젠테이션 영역에 필요한 데이터에 맞춘 레파지토리 메소드가 늘어날 수 있다는 단점이 분명히 존재한다.\n  > 트레이드오프가 필요한 지점이다. 성능적인 최적화 혹은 높은 TPS를 처리해야 하는 어플리케이션에서 불필요한 IO는 병목지점이 될 수 밖에 없다. 연관 엔티티를 모두 조회하더라도 Cache를 적용하여 불필요하게 DB IO가 발생하지 않도록 하는 방법도 좋고, 필요한 DB IO만 발생하도록 JPQL을 사용하는 방법 모두 상황에 따라 맞는 방법이라고 생각한다.\n\n### 그래서 최선의 방법은?\n- 결국, **트랜잭션 경계 밖에서의 준영속 상태가 문제의 핵심이다.** \n이를 해결하기 위해서는 경계 밖에서도 영속성 컨텍스트가 살아있도록 해주는 방법을 사용하면 자연스럽게 지연로딩에서 발생할 수 있는 문제를 해결할 수 있다. 그것이 바로 `OSIV`이다.\n\n## OSIV\n- Open Session In View\n- 영속성 컨텍스트를 프레젠테이션 레이어까지 열어둔다는 뜻이다.\n- 하이버네이트에서는 `OSIV` 스프링에서는 `OEIV`라고 부르며, 관례상으로 OSIV라고 통칭하는 듯 하다.\n- 하이버네이트의 OSIV와 스프링에서의 OEIV는 비슷하지만 차이점이 분명하게 존재한다. 쉽게 생각하여 하이버네이트에서의 OSIV의 단점을 개선한 것이 OEIV라고 봐도 좋다.\n\n### 과거 OSIV: 요청 당 트랜잭션\n- 초창기 OSIV는 요청 당 트랜잭션을 지원했는데 아래 그림을 참고하자\n![OSIV_요청당트랜잭션](https://i.imgur.com/sFEvc8g.png)\n- 서블릿 필터 혹은 스프링 인터셉터에서 영속성 컨텍스트를 생성하며 이때부터 트랜잭션을 시작하고 요청이 끝날 때 트랜잭션과 영속성 컨텍스트를 함께 종료하게 된다.\n- 프레젠테이션 레이어도 트랜잭션 경계내에 존재하게 됨에 따라, 지연로딩을 처리하기 위해 프록시 객체를 초기화해야 하는 과정이 필요없게 된다. 하지만, 트랜잭션의 경계가 비즈니스 레이어가 아닌 프레젠테이션 레이어부터 시작함에 따라 **트랜잭션의 경계가 모호해지며 비즈니스 레이어가 아닌 곳에서 데이터 변경이 발생하는 문제가 생길 수 있다.**\n\n#### 요청 당 트랜잭션 모델의 문제점\n- JDBC 커넥션 보유 시간 증가\n  * JDBC 커넥션은 뷰의 렌더링이 모두 완료된 후에야 커넥션 풀로 반환된다. 따라서 뷰의 렌더링 시간이 길어지면 길어질수록 개별 요청을 처리하기 위한 스레드가 JDBC 커넥션을 보유하는 시간이 길어진다.\n- 모호한 트랜잭션 경계\n  * 예를 들어, 특정 컨트롤러에서 뷰에 표현하고자 하는 목적으로 엔티티를 변경한다면 요청에 마무리되는 시점에 해당 변경 사항이 영속성 컨텍스트에 변경 감지에 의해 반영이 되고 플러쉬됨에 따라 디비에 반영까지 되는 사이드 이펙트가 생기게 된다. 데이터의 변경이 도메인 계층이 아닌 이외 계층에서 이뤄진다면 유지보수성은 급격히 떨어지게 된다.\n    - 뷰/프레젠테이션 레이어에서 엔티티를 변경하지 못하도록 하는 방법을 생각해볼 수 있다.\n      * DTO 객체 반환\n      * 세터 지양\n      * 읽기 전용 인터페이스/메서드 제공\n  * 일반적으로 애플리케이션의 트랜잭션 경계는 애플리케이션 레이어 SERVICE 를 경계로 한다. 즉, SERVICE 메서드 호출 전에 바로 트랜잭션이 시작되고 SERVICE 메서드 호출이 종료될 때 트랜잭션이 커밋되거나 롤백되는 것이 일반적이다. 이에 비해 과거 OSIV 서블릿 필터의 트랜잭션 경계는 HTTP 요청 처리 시간의 거의 대부분을 아우른다. 결국 트랜잭션 경계에 대한 일관성 있는 뷰를 유지할 수 없으며 이로 인해 다양한 문제가 발생할 여지가 있다.\n\n### 스프링 OSIV: 비즈니스 계층 트랜잭션\n![OSIV_SPRING](https://i.imgur.com/OxibUm8.png)\n- `비즈니스 계층`에서 `트랜잭션`을 사용하는 OSIV\n- 뷰 렌더링 시점의 지연 로딩을 허용하면서도 일관성 있는 트랜잭션 경계를 유지하는 합리적인 절충안으로 서블릿 필터에서 Session 을 오픈하되 트랜잭션 경계는 애플리케이션 레이어 범위로 한정하는 것이다.\n- Spring 프레임워크에서는 `FlushMode` 와 `ConnectionReleaseMode` 의 조정을 통해 과거 OSIV 모델의 단점을 보완할 `OpenSessionInViewFliter`와 `OpenSessionInViewInterceptor`를 제공한다.\n- 자세한 내용은 아래 내용을 참조하도록 하자\n  1. 클라이언트의 요청 시, 서블릿 필터/인터셉터에서 영속성 컨텍스트를 생성한다. 단, 트랜잭션은 시작하지 않음\n  2. 도메인 계층에서 트랜잭션을 시작할 때, 1번에서 생성한 영속성 컨텍스트를 사용하여 트랜잭션을 시작\n  3. 도메인 계층의 서비스가 종료되면서 트랜잭션이 커밋하고 영속성 컨텍스트를 플러쉬한다. 트랜잭션은 종료가 되지만 영속성 컨텍스트를 종료하지 않는다.\n  4. 영속성 컨텍스트가 도메인 레이어가 아닌 프레젠테이션 레이어에서도 유지됨에 따라, 반환하는 엔티티는 영속 상태를 유지한다.\n  5. 필터/인터셉터로 돌아와서 영속성 컨텍스트를 종료한다. 이때는 영속성 컨텍스트를 플러쉬하지 않는다.\n\n#### 트랜잭션 없는 읽기\n- 트랜잭션 없이 영속성 컨텍스트를 플러쉬하게 되면 `javax.persistence.TransactionRequiredException` 예외가 발생\n- 변경은 반드시 트랜잭션 내에서 이뤄져야 하는데, 조회의 경우 트랜잭션 없이도 가능하다. 이것을 바로 `트랜잭션 없이 읽기(Nontransactional reads)`라고 한다.\n- **프록시 객체를 초기화하는 지연 로딩 역시 조회이므로 트랜잭션 없이 읽기가 가능하다.**\n- 결국 스프링 OSIV를 이용하게 되면 도메인 계층에서만 트랜잭션을 이용하여 변경이 가능하고, 이 밖의 레이어인 프레젠테이션 레이어에서는 엔티티를 변경한다고 하여도 영속성 컨텍스트를 플러쉬하지 않기 때문에 변경이 불가능하고 오직 읽기만 가능하게 되는 것이다. \n\n#### 스프링 OSIV 사용 시 주의점\n- 서비스 호출 후 컨트롤러에서 반환하는 엔티티가 있다고 가정해보자. \n이미 종료한 트랜잭션에서 반환한 엔티티이며 OSIV를 사용하고 있기 때문에 여전히 영속 상태를 유지하게 될 것이다. 요구사항에 의해 엔티티를 일부 값을 수정하며 바로 뷰를 반환하면 OSIV를 사용하기 때문에 문제가 전혀 없다. \n하지만, **바로 뷰로 데이터를 반환하지 않고 또 다른 서비스 메서드를 호출하여 트랜잭션을 시작할 경우 문제가 발생하게 된다.** \n왜냐하면, 스프링 OSIV에 의하여 영속성 컨텍스트를 살아 있는 상태를 유지하기 때문에, 이전에 변경한 값이 새로 시작한 트랜잭션 커밋에 의해, 영속성 컨텍스트를 플러쉬하게 되는데 플러쉬하는 시점에 이전에 변경한 엔티티의 변경사항이 그대로 실제 데이터베이스에 반영되기 때문이다.\n```puml\n@startuml\nactor User as U\nparticipant MemberController as A\nparticipant MemberService as B\nparticipant MemberRepository as C\nparticipant AnotherService as D\nautonumber\nU -> A: HTTP 요청\nA -> B: Member 조회 서비스 메서드 실행\\n - 트랜잭션 시작\nactivate B\nB <-> C: Member 엔티티 조회 후 반환\nB -> A: Member 엔티티 반환\\n - Transaction Commit 그리고 영속성 컨텍스트 플러쉬\ndeactivate B\nA -> A: Member 엔티티 수정\\n - member.setName(\"XXX\")\nalt 뷰를 반환하지 않고 별도의 트랜잭션을 시작하는 경우\n\tautonumber 6\n\tA -> D: 별도 서비스 메서드 실행\\n - 트랜잭션 시작\n\tactivate D\n\tD -> A: 메서드 반환\\n - 트랜잭션 커밋 그리고 영속성 컨텍스트 플러쉬\\n: 5번에서 member.setName(\"XXX\")를 실행한 내용이 \\n영속성 컨텍스트의 변경감지에 의하여 반영 그리고 \\n트랜잭션울 커밋하고 영속성 컨텍스트가 플러쉬되어 \\n실제 데이터베이스에 변경을 반영\n\tdeactivate D\t\nelse \nend\nA -> U: 뷰에 맞는 데이터 반환\n@enduml\n```\n- 위와 같은 문제는 같은 영속성 컨텍스트를 여러 트랜잭션에서 공유하기 때문에 발생하는 문제로 해결하는 단순한 방법은 **트랜잭션이 있는 비즈니스 로직을 모두 호출하고 나서 엔티티를 변경하면 쉽게 해결된다.** \n다시 말해, **선 트랜잭션 후 변경으로 요약할 수 있다.**\n\n### OSIV를 사용하는 것이 만능이 아니다.\n- 객체 그래프의 뎁스가 깊어진다면 OSIV를 사용했을 때, 성능적으로 신경써야 할 부분도 많아진다.\n- 도메인의 요구사항 단순 엔티티만을 반환하여 끝나는 경우는 생각보다 드물다. 특히 통계 성격의 데이터를 조회해야 하는 경우가 대표적인데, 이럴 경우 차리리 JPQL을 사용하여 데이터를 조회하고 이를 DTO 객체로 바인딩하여 반환하는 것이 생각보다 쉬운 해결책일 수도 있다. \n- 너무 복잡하거나 DB 종속적인 연산을 사용해야 할 경우도 생길 수 있는데, 이럴 경우 하이버네이트의 `@SubSelect`를 사용하여 별도로 조회 전용 도메인 객체를 만들어서 해결하는 방법도 존재한다. 물론 DB 종속적인 연산을 사용하게 됨에 따라 추후 DB 변경에 대한 대응이 어려워질 수 있는 부분도 분명 존재하지만, 일반적으로 사용하고 있는 데이터베이스를 변경하는 작업은 쉽게 일어나지도 않을 뿐더러 완벽하게 어플리케이션 레이어에서 변경을 쉽게 커버할 수 있는 경우 더 드물다고 생각한다. \n\n","slug":"Persistence/JPA_영속성관리","published":1,"updated":"2021-08-02T12:29:15.036Z","_id":"ckrsup51e0026tjhv0kr0dfr4","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"JPA-영속성-관리\"><a href=\"#JPA-영속성-관리\" class=\"headerlink\" title=\"JPA 영속성 관리\"></a>JPA 영속성 관리</h1><blockquote>\n<p>자바 ORM 표준 JPA 프로그래밍 13장 내용을 정리</p>\n</blockquote>\n<p>스프링과 같은 컨테이너 환경에서 JPA를 사용하게 되면, 컨테이너 레벨에서 트랜잭션과 영속성 컨텍스트를 관리해주므로 어플리케이션 개발이 쉬워지게 되는데, 문제가 되는 부분은 내부 동작에 대한 정확한 이해가 없을 때 생기는 트러블 슈팅이 어려워 지는 부분이다. 내부동작에 대한 이해, 스프링 컨테이너에서의 기본 전략, 지연로딩, OSIV에 대한 내용을 가볍게 정리하고자 한다.</p>\n<h2 id=\"트랜잭션-범위의-영속성-컨텍스트\"><a href=\"#트랜잭션-범위의-영속성-컨텍스트\" class=\"headerlink\" title=\"트랜잭션 범위의 영속성 컨텍스트\"></a>트랜잭션 범위의 영속성 컨텍스트</h2><h3 id=\"스프링-컨테이너의-기본-전략\"><a href=\"#스프링-컨테이너의-기본-전략\" class=\"headerlink\" title=\"스프링 컨테이너의 기본 전략\"></a>스프링 컨테이너의 기본 전략</h3><p><img src=\"https://i.imgur.com/lgR6GfA.png\" alt=\"트랜잭션_범위_영속성_컨텍스트\"></p>\n<ul>\n<li>스프링은 트랜잭션 범위의 영속성 컨텍스트를 기본 전략으로 사용한다. </li>\n<li>트랜잭션 범위와 영속성 컨텍스트의 생존 범위가 동일하며, 트랜잭션 종료 시, 영속성 컨텍스트도 동일하게 종료하게 된다.</li>\n</ul>\n<p><img src=\"https://i.imgur.com/vZtbhUl.png\" alt=\"트랜잭션_범위_영속성_컨텍스트_AOP\"></p>\n<ul>\n<li>스프링 어플리케이션에서는 <code>@Transactional</code>을 사용하여 트랜잭션을 시작하게 되는데, 단순 호출처럼 보이는 부분도 사실 스프링의 트랜잭션 AOP가 먼저 작동하게 된다.<ul>\n<li>스프링 트랜잭션 AOP는 대상 메소드를 호출하기 직전에 트랜잭션을 시작하며, 호출이 정상적으로 종료되면 트랜잭션을 커밋하고 종료하게 된다.</li>\n<li>트랜잭션 커밋 시, JPA는 영속성 컨텍스트를 플러시하여 변경 내용을 DB에 반영한 후 트랜잭션을 커밋하게 된다.</li>\n<li>예외가 발생하게 되면, 트랜잭션을 롤백하고 종료하게 되는데, 이때는 영속성 컨텍스트를 플러시하지 않게 된다.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://i.imgur.com/t9RFewK.png\" alt=\"트랜잭션_영속성컨텍스트\"></p>\n<ul>\n<li><strong>트랜잭션이 같을 경우, 같은 영속성 컨텍스트를 사용한다.</strong><ul>\n<li>다양한 위치에서 엔티티 매니저(EntityManager)를 주입받아 사용해도 트랜잭션이 같으면 항상 같은 영속성 컨텍스트를 사용하게 된다.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://i.imgur.com/al1qaZQ.png\" alt=\"스레드_영속성컨텍스트\"></p>\n<ul>\n<li><strong>트랜잭션이 다를 경우, 다른 영속성 컨텍스트를 사용한다.</strong><ul>\n<li><strong>여러 스레드에서 동시에 요청에 올 경우, 같은 엔티티 매니저를 사용한다고 하더라도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 달라진다.</strong> </li>\n<li>다시 말해, <strong>스프링 컨테이너에서는 스레드별로 각기 다른 트랜잭션을 할당하게 되는데</strong>, 따라서 같은 엔티티 매니저를 호출해도 접근하는 영속성 컨텍스트가 다르기 때문에 멀티스레드 환경에서도 안전하다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"준영속-지연-로딩\"><a href=\"#준영속-지연-로딩\" class=\"headerlink\" title=\"준영속/지연 로딩\"></a>준영속/지연 로딩</h2><ul>\n<li>조회한 엔티티가 트랜잭션 범위인 서비스, 레파지토리 레이어에서는 영속성 컨텍스트에 의해 관리가 되기 때문에 영속 상태를 유지하지만, 이 밖의 레이어에서는 준영속 상태가 된다.</li>\n<li>영속성 컨텍스트의 관리 밖에서는 <code>지연 로딩</code> 및 <code>변경 감지</code>가 동작하지 않는다.<ul>\n<li>따라서, 비지니스 혹은 요구사항을 기반으로 한 변경에 대해서는 반드시 서비스/도메인 레이어에서 수행을 해야한다. 컨트롤러와 같은 영역에서 이를 수행하게 되면 레이어별로 책임이 모호해지고 어플리케이션의 유지보수성이 급격하게 떨어지게 된다.</li>\n<li>지연 로딩 기능이 동작하지 않기 때문에, 생기는 이슈는 생각보다 크다. 만약 컨트롤러와 같은 레이어에서 지연 로딩 상태의 연관 엔티티나 밸류를 조회하게 될 경우, <code>LazyIntializationException</code> 예외가 발생하게 된다.</li>\n</ul>\n</li>\n<li>지연 로딩을 해결할 수 있는 방법은 아래와 같다.<ul>\n<li>필요한 엔티티를 미리 로딩<ol>\n<li>글로벌 페치 전략 수정</li>\n<li>JPQL 페치 조인</li>\n<li>강제로 초기화</li>\n</ol>\n</li>\n<li>OSIV(Open Sessin in View)를 사용하여 엔티티를 항상 영속 상태로 유지</li>\n</ul>\n</li>\n</ul>\n<p>OSIV의 경우 별도로 정리하는걸로 하고, 먼저 필요 엔티티를 미리 로딩하는 방법에 대해 정리하고자 한다. 말 그대로, 뷰 혹은 컨트롤러 레이어에서 필요한 데이터를 영속성 컨텍스트 범위 내에서 미리 로딩을 하는 방법을 가리키며 위에서 정리한대로 3가지 방법이 존재한다.</p>\n<h3 id=\"글로벌-페치-전략-수정-즉시-로딩\"><a href=\"#글로벌-페치-전략-수정-즉시-로딩\" class=\"headerlink\" title=\"글로벌 페치 전략 수정 - 즉시 로딩\"></a>글로벌 페치 전략 수정 - 즉시 로딩</h3><p>주문 엔티티에서 주문 상품 벨류 목록을 담고 있는 예제로 주문 상품 벨류의 경우 별도의 식별자가 필요하지 않기 때문에 <code>@ElementCollection</code>을 이용하여 주문 엔티티에 매핑을 했으며 글로벌 페치 전략은 즉시 로딩으로 설정해주었다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table(name = <span class=\"meta-string\">&quot;orders&quot;</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">constructor</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Id</span></span><br><span class=\"line\">\t<span class=\"meta\">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> id: <span class=\"built_in\">Long</span> = <span class=\"number\">0L</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Column(nullable = false, updatable = false)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> memberId: <span class=\"built_in\">Long</span> = <span class=\"number\">0L</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Enumerated(value = EnumType.STRING)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Column(length = 20, nullable = false)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> status: OrderStatus = OrderStatus.PAYMENT_WAITING</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@ElementCollection(fetch = FetchType.EAGER)</span></span><br><span class=\"line\">\t<span class=\"meta\">@CollectionTable(</span></span><br><span class=\"line\"><span class=\"meta\">\t\tname = <span class=\"meta-string\">&quot;order_products&quot;</span>,</span></span><br><span class=\"line\"><span class=\"meta\">\t\tjoinColumns = [</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\tJoinColumn(name = <span class=\"meta-string\">&quot;id&quot;</span>)</span></span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"meta\">@AttributeOverrides(</span></span><br><span class=\"line\"><span class=\"meta\">\t\tvalue = [</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\tAttributeOverride(name = <span class=\"meta-string\">&quot;productId&quot;</span>, column = Column(name = <span class=\"meta-string\">&quot;product_id&quot;</span>)</span>),</span><br><span class=\"line\">\t\t\tAttributeOverride(name = <span class=\"string\">&quot;price&quot;</span>, column = Column(name = <span class=\"string\">&quot;price&quot;</span>)),</span><br><span class=\"line\">\t\t\tAttributeOverride(name = <span class=\"string\">&quot;quantity&quot;</span>, column = Column(name = <span class=\"string\">&quot;quantity&quot;</span>)),</span><br><span class=\"line\">\t\t\tAttributeOverride(name = <span class=\"string\">&quot;amounts&quot;</span>, column = Column(name = <span class=\"string\">&quot;amounts&quot;</span>)),</span><br><span class=\"line\">\t\t\tAttributeOverride(name = <span class=\"string\">&quot;line_idx&quot;</span>, column = Column(name = <span class=\"string\">&quot;line_idx&quot;</span>))</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"meta\">@OrderBy(value = <span class=\"meta-string\">&quot;line_idx&quot;</span>)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> orderProducts: MutableList&lt;OrderProduct&gt; = mutableListOf()</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@CreationTimestamp</span></span><br><span class=\"line\">\t<span class=\"meta\">@Column(nullable = false)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> createdAt: LocalDateTime = LocalDateTime.now()</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@UpdateTimestamp</span></span><br><span class=\"line\">\t<span class=\"meta\">@Column(nullable = false)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> updatedAt: LocalDateTime = LocalDateTime.now()</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doOrder</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\tmemberId: <span class=\"type\">Long</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\tstatus: <span class=\"type\">OrderStatus</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\tproducts: <span class=\"type\">List</span>&lt;<span class=\"type\">OrderProduct</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t)</span></span>: Order &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (status !<span class=\"keyword\">in</span> listOf(OrderStatus.PAYMENT_WAITING, OrderStatus.PATMENT_COMPLETED)) <span class=\"keyword\">throw</span> IllegalArgumentException(<span class=\"string\">&quot;올바른 주문 상태 값이 아닙니다.&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (products.isEmpty()) <span class=\"keyword\">throw</span> IllegalArgumentException(<span class=\"string\">&quot;최소 한개 이상의 구매 상품을 포함해야 합니다.&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Order().also &#123;</span><br><span class=\"line\">\t\t\t\tit.memberId = memberId</span><br><span class=\"line\">\t\t\t\tit.status = status</span><br><span class=\"line\">\t\t\t\tit.orderProducts = products.toMutableList()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional(read)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderService</span></span>(</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> orderRepository: OrderRepository</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getList</span><span class=\"params\">(pageable: <span class=\"type\">Pageable</span>)</span></span>: Page&lt;Order&gt; &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">val</span> list = orderRepository.findAll(pageable)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> list</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get</span><span class=\"params\">(id: <span class=\"type\">Long</span>)</span></span>: Order &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> orderRepository.findByIdOrNull(id)</span><br><span class=\"line\">\t\t\t\t?: <span class=\"keyword\">throw</span> NotExistsOrderException(<span class=\"string\">&quot;존재하지 않은 주문입니다.&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>서비스 레이어에서 주문 엔티티에 대한 조회를 목록/단건 조회할 수 있도록 가벼운 코드를 작성했다. 주문ID 기준의 단건 조회의 경우, 연관 콜렉션에 매핑 되어 있는 <code>order_products</code>테이블을 LEFT OUTER JOIN을 사용하여 바로 조회하는 것을 확인 할 수 있다.<br><img src=\"https://i.imgur.com/4N4g15c.png\" alt=\"EAGER_LEFT_OUTER_JOIN\"></p>\n<p>여기까지는 문제가 없다고 생각할 수 있다. 하지만, 문제는 목록 조회 부분에서 생기게 되는데, 바로 <code>N+1</code> 문제이다.<br><img src=\"https://i.imgur.com/oWSQpfD.png\" alt=\"EAGER_N+1\"></p>\n<p>단건만 조회하는 엔티티라면 문제가 없겠지만, 대부분의 어플리케이션에서 목록 조회는 기본으로 하기 때문에 즉시 로딩을 사용함으로써 아래와 같은 단점이 생길 수 밖에 없다.</p>\n<ul>\n<li><strong>불필요한 벨류/엔티티 조회</strong><br>주문 엔티티에서 목록이 필요하지 않은 경우에도 매번 목록 데이터를 조회하기 때문에 DB 레벨에서의 오버헤드가 발생한다.</li>\n<li><strong>N+1 문제 발생</strong><ul>\n<li>위 이미지를 통하여 볼 수 있듯이, 디비에 질의하는 쿼리 개수가 목록에서 반환하는 데이터 개수만큼의 IO가 발생하게 된다. 불필요한 IO 발생은 서버 어플리케이션에서는 당연히 지양해야 한다. </li>\n<li>JPQL을 사용하게 될 경우(ex. JpaRepository.findAll()), JPA는 SQL을 생성할 때 글로벌 페치 전략을 참고하지 않고 오직 JPQL 자체만 사용하게 된다. 아래는 SQL문을 생성하는 과정을 설명하고 있다.<ol>\n<li><code>select o from Order o</code> JPQL을 분석하여 <code>select * from Order</code> SQL을 실행</li>\n<li>데이터베이스에서 결과를 받아 <code>Order</code>엔티티 목록을 생성</li>\n<li><code>Order.orderProducts</code>의 글로벌 페치 전략이 즉시 로딩이므로 연관 벨류 콜렉션을 로딩해야 한다.</li>\n<li>연관 벨류/엔티티를 영속성 컨텍스트에서 찾는다.</li>\n<li>영속성 컨텍스트에 저장되어 있는 1차 캐싱 데이터가 없을 경우, DB에 질의하여 데이터를 가져온다. 이때, <code>Order</code>엔티티 목록의 개수만큼 DB에 질의를 하게 된다.</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"글로벌-페치-전략-수정-지연-로딩\"><a href=\"#글로벌-페치-전략-수정-지연-로딩\" class=\"headerlink\" title=\"글로벌 페치 전략 수정 - 지연 로딩\"></a>글로벌 페치 전략 수정 - 지연 로딩</h3><ul>\n<li>위에서 겪었던 N+1 문제의 경우, 연관 벨류 콜렉션의 글로벌 페치 전략을 지연 로딩으로 변경하고, 이를 영속성 컨텍스트 범위 내에서 호출해주면 해결할 수 있다. <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional(readOnly = true)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderService</span></span>(</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> orderRepository: OrderRepository</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getList</span><span class=\"params\">(pageable: <span class=\"type\">Pageable</span>)</span></span>: Page&lt;Order&gt; &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">val</span> list = orderRepository.findAll(pageable)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (order <span class=\"keyword\">in</span> list) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 실제 값을 사용할 때 프록시 객체가 초기화 된다.</span></span><br><span class=\"line\">\t\t\torder.orderProducts.forEach &#123; it.amounts &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> list</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get</span><span class=\"params\">(id: <span class=\"type\">Long</span>)</span></span>: Order &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">val</span> order = (orderRepository.findByIdOrNull(id)</span><br><span class=\"line\">\t\t\t\t?: <span class=\"keyword\">throw</span> NotExistsOrderException(<span class=\"string\">&quot;존재하지 않은 주문입니다.&quot;</span>))</span><br><span class=\"line\">\t\t<span class=\"comment\">// 실제 값을 사용할 때 프록시 객체가 초기화 된다.</span></span><br><span class=\"line\">\t\torder.orderProducts.forEach &#123; it.amounts &#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> order</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>글로벌 페치 전략을 지연 로딩으로 변경하게 될 경우, 연관 벨류/엔티티를 실제가 아닌 프록시 객체를 대상으로 조회하게 된다.</strong><br>프록시의 경우 실제 사용할 때 초기화가 진행되기 때문에, 위 코드처럼 <strong>실제 값을 호출하는 코드를 넣어줘야지 초기화가 진행된다.</strong></li>\n<li>위 예제 코드의 경우, ID 기준의 조회 메소드인 get에서는 지연 로딩의 이점을 충분히 잘 살려냈다고 할 수 있지만, 목록 조회에서의 경우, 강제 초기화를 진행하더라도 즉시 로딩에서처럼 초기화 시 매번 매핑한 벨류 콜렉션을 조회하는 또 다른 의미의 <code>N+1</code>이 발생하게 된다.</li>\n<li>이와 같은 형태의 <code>N+1</code>을 피하기 위해서 사용할 수 있는 방법으로는 아래와 같다. <ul>\n<li>하이버네이트의 <code>@BatchSize</code>가 있다. <code>@BatchSize</code>를 사용할 경우, 프록시를 통하여 초기화 대상이 되는 연관 벨류/엔티티의 실제 값을 가져오는 DB 질의를 in절로 수정하여 N번의 DB 질의가 발생하지 않도록 해준다. 하지만, <code>@BatchSize</code>를 사용하더라도 실제 연관 벨류/엔티티를 초기화 해줘야 하는건 동일하기 때문에, 아래와 같이 기준을 나눠서 매핑하는 전략을 생각해볼 수 있다.</li>\n<li>JPQL fetch 조인을 사용하면 조회하면 시점에 SQL 조인을 사용하여 함께 로딩할 벨류/엔티티를 로딩할 수 있다. 하지만, JPQL의 페치 조인을 사용하게 되면 프레젠테이션 영역에 필요한 데이터에 맞춘 레파지토리 메소드가 늘어날 수 있다는 단점이 분명히 존재한다.<blockquote>\n<p>트레이드오프가 필요한 지점이다. 성능적인 최적화 혹은 높은 TPS를 처리해야 하는 어플리케이션에서 불필요한 IO는 병목지점이 될 수 밖에 없다. 연관 엔티티를 모두 조회하더라도 Cache를 적용하여 불필요하게 DB IO가 발생하지 않도록 하는 방법도 좋고, 필요한 DB IO만 발생하도록 JPQL을 사용하는 방법 모두 상황에 따라 맞는 방법이라고 생각한다.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"그래서-최선의-방법은\"><a href=\"#그래서-최선의-방법은\" class=\"headerlink\" title=\"그래서 최선의 방법은?\"></a>그래서 최선의 방법은?</h3><ul>\n<li>결국, <strong>트랜잭션 경계 밖에서의 준영속 상태가 문제의 핵심이다.</strong><br>이를 해결하기 위해서는 경계 밖에서도 영속성 컨텍스트가 살아있도록 해주는 방법을 사용하면 자연스럽게 지연로딩에서 발생할 수 있는 문제를 해결할 수 있다. 그것이 바로 <code>OSIV</code>이다.</li>\n</ul>\n<h2 id=\"OSIV\"><a href=\"#OSIV\" class=\"headerlink\" title=\"OSIV\"></a>OSIV</h2><ul>\n<li>Open Session In View</li>\n<li>영속성 컨텍스트를 프레젠테이션 레이어까지 열어둔다는 뜻이다.</li>\n<li>하이버네이트에서는 <code>OSIV</code> 스프링에서는 <code>OEIV</code>라고 부르며, 관례상으로 OSIV라고 통칭하는 듯 하다.</li>\n<li>하이버네이트의 OSIV와 스프링에서의 OEIV는 비슷하지만 차이점이 분명하게 존재한다. 쉽게 생각하여 하이버네이트에서의 OSIV의 단점을 개선한 것이 OEIV라고 봐도 좋다.</li>\n</ul>\n<h3 id=\"과거-OSIV-요청-당-트랜잭션\"><a href=\"#과거-OSIV-요청-당-트랜잭션\" class=\"headerlink\" title=\"과거 OSIV: 요청 당 트랜잭션\"></a>과거 OSIV: 요청 당 트랜잭션</h3><ul>\n<li>초창기 OSIV는 요청 당 트랜잭션을 지원했는데 아래 그림을 참고하자<br><img src=\"https://i.imgur.com/sFEvc8g.png\" alt=\"OSIV_요청당트랜잭션\"></li>\n<li>서블릿 필터 혹은 스프링 인터셉터에서 영속성 컨텍스트를 생성하며 이때부터 트랜잭션을 시작하고 요청이 끝날 때 트랜잭션과 영속성 컨텍스트를 함께 종료하게 된다.</li>\n<li>프레젠테이션 레이어도 트랜잭션 경계내에 존재하게 됨에 따라, 지연로딩을 처리하기 위해 프록시 객체를 초기화해야 하는 과정이 필요없게 된다. 하지만, 트랜잭션의 경계가 비즈니스 레이어가 아닌 프레젠테이션 레이어부터 시작함에 따라 <strong>트랜잭션의 경계가 모호해지며 비즈니스 레이어가 아닌 곳에서 데이터 변경이 발생하는 문제가 생길 수 있다.</strong></li>\n</ul>\n<h4 id=\"요청-당-트랜잭션-모델의-문제점\"><a href=\"#요청-당-트랜잭션-모델의-문제점\" class=\"headerlink\" title=\"요청 당 트랜잭션 모델의 문제점\"></a>요청 당 트랜잭션 모델의 문제점</h4><ul>\n<li>JDBC 커넥션 보유 시간 증가<ul>\n<li>JDBC 커넥션은 뷰의 렌더링이 모두 완료된 후에야 커넥션 풀로 반환된다. 따라서 뷰의 렌더링 시간이 길어지면 길어질수록 개별 요청을 처리하기 위한 스레드가 JDBC 커넥션을 보유하는 시간이 길어진다.</li>\n</ul>\n</li>\n<li>모호한 트랜잭션 경계<ul>\n<li>예를 들어, 특정 컨트롤러에서 뷰에 표현하고자 하는 목적으로 엔티티를 변경한다면 요청에 마무리되는 시점에 해당 변경 사항이 영속성 컨텍스트에 변경 감지에 의해 반영이 되고 플러쉬됨에 따라 디비에 반영까지 되는 사이드 이펙트가 생기게 된다. 데이터의 변경이 도메인 계층이 아닌 이외 계층에서 이뤄진다면 유지보수성은 급격히 떨어지게 된다.<ul>\n<li>뷰/프레젠테이션 레이어에서 엔티티를 변경하지 못하도록 하는 방법을 생각해볼 수 있다.<ul>\n<li>DTO 객체 반환</li>\n<li>세터 지양</li>\n<li>읽기 전용 인터페이스/메서드 제공</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>일반적으로 애플리케이션의 트랜잭션 경계는 애플리케이션 레이어 SERVICE 를 경계로 한다. 즉, SERVICE 메서드 호출 전에 바로 트랜잭션이 시작되고 SERVICE 메서드 호출이 종료될 때 트랜잭션이 커밋되거나 롤백되는 것이 일반적이다. 이에 비해 과거 OSIV 서블릿 필터의 트랜잭션 경계는 HTTP 요청 처리 시간의 거의 대부분을 아우른다. 결국 트랜잭션 경계에 대한 일관성 있는 뷰를 유지할 수 없으며 이로 인해 다양한 문제가 발생할 여지가 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"스프링-OSIV-비즈니스-계층-트랜잭션\"><a href=\"#스프링-OSIV-비즈니스-계층-트랜잭션\" class=\"headerlink\" title=\"스프링 OSIV: 비즈니스 계층 트랜잭션\"></a>스프링 OSIV: 비즈니스 계층 트랜잭션</h3><p><img src=\"https://i.imgur.com/OxibUm8.png\" alt=\"OSIV_SPRING\"></p>\n<ul>\n<li><code>비즈니스 계층</code>에서 <code>트랜잭션</code>을 사용하는 OSIV</li>\n<li>뷰 렌더링 시점의 지연 로딩을 허용하면서도 일관성 있는 트랜잭션 경계를 유지하는 합리적인 절충안으로 서블릿 필터에서 Session 을 오픈하되 트랜잭션 경계는 애플리케이션 레이어 범위로 한정하는 것이다.</li>\n<li>Spring 프레임워크에서는 <code>FlushMode</code> 와 <code>ConnectionReleaseMode</code> 의 조정을 통해 과거 OSIV 모델의 단점을 보완할 <code>OpenSessionInViewFliter</code>와 <code>OpenSessionInViewInterceptor</code>를 제공한다.</li>\n<li>자세한 내용은 아래 내용을 참조하도록 하자<ol>\n<li>클라이언트의 요청 시, 서블릿 필터/인터셉터에서 영속성 컨텍스트를 생성한다. 단, 트랜잭션은 시작하지 않음</li>\n<li>도메인 계층에서 트랜잭션을 시작할 때, 1번에서 생성한 영속성 컨텍스트를 사용하여 트랜잭션을 시작</li>\n<li>도메인 계층의 서비스가 종료되면서 트랜잭션이 커밋하고 영속성 컨텍스트를 플러쉬한다. 트랜잭션은 종료가 되지만 영속성 컨텍스트를 종료하지 않는다.</li>\n<li>영속성 컨텍스트가 도메인 레이어가 아닌 프레젠테이션 레이어에서도 유지됨에 따라, 반환하는 엔티티는 영속 상태를 유지한다.</li>\n<li>필터/인터셉터로 돌아와서 영속성 컨텍스트를 종료한다. 이때는 영속성 컨텍스트를 플러쉬하지 않는다.</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"트랜잭션-없는-읽기\"><a href=\"#트랜잭션-없는-읽기\" class=\"headerlink\" title=\"트랜잭션 없는 읽기\"></a>트랜잭션 없는 읽기</h4><ul>\n<li>트랜잭션 없이 영속성 컨텍스트를 플러쉬하게 되면 <code>javax.persistence.TransactionRequiredException</code> 예외가 발생</li>\n<li>변경은 반드시 트랜잭션 내에서 이뤄져야 하는데, 조회의 경우 트랜잭션 없이도 가능하다. 이것을 바로 <code>트랜잭션 없이 읽기(Nontransactional reads)</code>라고 한다.</li>\n<li><strong>프록시 객체를 초기화하는 지연 로딩 역시 조회이므로 트랜잭션 없이 읽기가 가능하다.</strong></li>\n<li>결국 스프링 OSIV를 이용하게 되면 도메인 계층에서만 트랜잭션을 이용하여 변경이 가능하고, 이 밖의 레이어인 프레젠테이션 레이어에서는 엔티티를 변경한다고 하여도 영속성 컨텍스트를 플러쉬하지 않기 때문에 변경이 불가능하고 오직 읽기만 가능하게 되는 것이다. </li>\n</ul>\n<h4 id=\"스프링-OSIV-사용-시-주의점\"><a href=\"#스프링-OSIV-사용-시-주의점\" class=\"headerlink\" title=\"스프링 OSIV 사용 시 주의점\"></a>스프링 OSIV 사용 시 주의점</h4><ul>\n<li>서비스 호출 후 컨트롤러에서 반환하는 엔티티가 있다고 가정해보자.<br>이미 종료한 트랜잭션에서 반환한 엔티티이며 OSIV를 사용하고 있기 때문에 여전히 영속 상태를 유지하게 될 것이다. 요구사항에 의해 엔티티를 일부 값을 수정하며 바로 뷰를 반환하면 OSIV를 사용하기 때문에 문제가 전혀 없다.<br>하지만, <strong>바로 뷰로 데이터를 반환하지 않고 또 다른 서비스 메서드를 호출하여 트랜잭션을 시작할 경우 문제가 발생하게 된다.</strong><br>왜냐하면, 스프링 OSIV에 의하여 영속성 컨텍스트를 살아 있는 상태를 유지하기 때문에, 이전에 변경한 값이 새로 시작한 트랜잭션 커밋에 의해, 영속성 컨텍스트를 플러쉬하게 되는데 플러쉬하는 시점에 이전에 변경한 엔티티의 변경사항이 그대로 실제 데이터베이스에 반영되기 때문이다.<img src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U2NyaXB0VHlwZT0iYXBwbGljYXRpb24vZWNtYXNjcmlwdCIgY29udGVudFN0eWxlVHlwZT0idGV4dC9jc3MiIGhlaWdodD0iNjA3cHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDoxMDE1cHg7aGVpZ2h0OjYwN3B4O2JhY2tncm91bmQ6I0ZGRkZGRjsiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDEwMTUgNjA3IiB3aWR0aD0iMTAxNXB4IiB6b29tQW5kUGFuPSJtYWduaWZ5Ij48ZGVmcz48ZmlsdGVyIGhlaWdodD0iMzAwJSIgaWQ9ImYxOG5peWl3OGw3NTg0IiB3aWR0aD0iMzAwJSIgeD0iLTEiIHk9Ii0xIj48ZmVHYXVzc2lhbkJsdXIgcmVzdWx0PSJibHVyT3V0IiBzdGREZXZpYXRpb249IjIuMCIvPjxmZUNvbG9yTWF0cml4IGluPSJibHVyT3V0IiByZXN1bHQ9ImJsdXJPdXQyIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgLjQgMCIvPjxmZU9mZnNldCBkeD0iNC4wIiBkeT0iNC4wIiBpbj0iYmx1ck91dDIiIHJlc3VsdD0iYmx1ck91dDMiLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJibHVyT3V0MyIgbW9kZT0ibm9ybWFsIi8+PC9maWx0ZXI+PC9kZWZzPjxnPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGZpbHRlcj0idXJsKCNmMThuaXlpdzhsNzU4NCkiIGhlaWdodD0iNzMuMzk4NCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB3aWR0aD0iMTAiIHg9IjU1NC41IiB5PSIxNjMuNjk1MyIvPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGZpbHRlcj0idXJsKCNmMThuaXlpdzhsNzU4NCkiIGhlaWdodD0iMTA0Ljc5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgd2lkdGg9IjEwIiB4PSI5MjEiIHk9IjM2Mi43NTc4Ii8+PHJlY3QgZmlsbD0iI0ZGRkZGRiIgZmlsdGVyPSJ1cmwoI2YxOG5peWl3OGw3NTg0KSIgaGVpZ2h0PSIxNjguMTk1MyIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjA7IiB3aWR0aD0iODk3IiB4PSIxMDQiIHk9IjMwOS4zNTk0Ii8+PHJlY3QgZmlsbD0iI0ZGRkZGRiIgaGVpZ2h0PSIyIiBzdHlsZT0ic3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjEuMDsiIHdpZHRoPSI4OTciIHg9IjEwNCIgeT0iNDc1LjU1NDciLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjUuMCw1LjA7IiB4MT0iMjMiIHgyPSIyMyIgeTE9Ijg4LjI5NjkiIHkyPSI1MjMuNjg3NSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6NS4wLDUuMDsiIHgxPSIxODkiIHgyPSIxODkiIHkxPSI4OC4yOTY5IiB5Mj0iNTIzLjY4NzUiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjUuMCw1LjA7IiB4MT0iNTU5IiB4Mj0iNTU5IiB5MT0iODguMjk2OSIgeTI9IjUyMy42ODc1Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9Ijc3MiIgeDI9Ijc3MiIgeTE9Ijg4LjI5NjkiIHkyPSI1MjMuNjg3NSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6NS4wLDUuMDsiIHgxPSI5MjYiIHgyPSI5MjYiIHkxPSI4OC4yOTY5IiB5Mj0iNTIzLjY4NzUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIzMSIgeD0iNSIgeT0iODQuOTk1MSI+VXNlcjwvdGV4dD48ZWxsaXBzZSBjeD0iMjMuNSIgY3k9IjE1IiBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjE4bml5aXc4bDc1ODQpIiByeD0iOCIgcnk9IjgiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6Mi4wOyIvPjxwYXRoIGQ9Ik0yMy41LDIzIEwyMy41LDUwIE0xMC41LDMxIEwzNi41LDMxIE0yMy41LDUwIEwxMC41LDY1IE0yMy41LDUwIEwzNi41LDY1ICIgZmlsbD0ibm9uZSIgZmlsdGVyPSJ1cmwoI2YxOG5peWl3OGw3NTg0KSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzEiIHg9IjUiIHk9IjUzNS42ODI2Ij5Vc2VyPC90ZXh0PjxlbGxpcHNlIGN4PSIyMy41IiBjeT0iNTQ4Ljk4NDQiIGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMThuaXlpdzhsNzU4NCkiIHJ4PSI4IiByeT0iOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHBhdGggZD0iTTIzLjUsNTU2Ljk4NDQgTDIzLjUsNTgzLjk4NDQgTTEwLjUsNTY0Ljk4NDQgTDM2LjUsNTY0Ljk4NDQgTTIzLjUsNTgzLjk4NDQgTDEwLjUsNTk4Ljk4NDQgTTIzLjUsNTgzLjk4NDQgTDM2LjUsNTk4Ljk4NDQgIiBmaWxsPSJub25lIiBmaWx0ZXI9InVybCgjZjE4bml5aXc4bDc1ODQpIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjE4bml5aXc4bDc1ODQpIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjE0NyIgeD0iMTE0IiB5PSI1MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEzMyIgeD0iMTIxIiB5PSI3Mi45OTUxIj5NZW1iZXJDb250cm9sbGVyPC90ZXh0PjxyZWN0IGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMThuaXlpdzhsNzU4NCkiIGhlaWdodD0iMzAuMjk2OSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTQ3IiB4PSIxMTQiIHk9IjUyMi42ODc1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTMzIiB4PSIxMjEiIHk9IjU0Mi42ODI2Ij5NZW1iZXJDb250cm9sbGVyPC90ZXh0PjxyZWN0IGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMThuaXlpdzhsNzU4NCkiIGhlaWdodD0iMzAuMjk2OSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTI3IiB4PSI0OTQiIHk9IjUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTEzIiB4PSI1MDEiIHk9IjcyLjk5NTEiPk1lbWJlclNlcnZpY2U8L3RleHQ+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxOG5peWl3OGw3NTg0KSIgaGVpZ2h0PSIzMC4yOTY5IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMjciIHg9IjQ5NCIgeT0iNTIyLjY4NzUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMTMiIHg9IjUwMSIgeT0iNTQyLjY4MjYiPk1lbWJlclNlcnZpY2U8L3RleHQ+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxOG5peWl3OGw3NTg0KSIgaGVpZ2h0PSIzMC4yOTY5IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNTMiIHg9IjY5NCIgeT0iNTMiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMzkiIHg9IjcwMSIgeT0iNzIuOTk1MSI+TWVtYmVyUmVwb3NpdG9yeTwvdGV4dD48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjE4bml5aXc4bDc1ODQpIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjE1MyIgeD0iNjk0IiB5PSI1MjIuNjg3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEzOSIgeD0iNzAxIiB5PSI1NDIuNjgyNiI+TWVtYmVyUmVwb3NpdG9yeTwvdGV4dD48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjE4bml5aXc4bDc1ODQpIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEyNiIgeD0iODYxIiB5PSI1MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjExMiIgeD0iODY4IiB5PSI3Mi45OTUxIj5Bbm90aGVyU2VydmljZTwvdGV4dD48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjE4bml5aXc4bDc1ODQpIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEyNiIgeD0iODYxIiB5PSI1MjIuNjg3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjExMiIgeD0iODY4IiB5PSI1NDIuNjgyNiI+QW5vdGhlclNlcnZpY2U8L3RleHQ+PHJlY3QgZmlsbD0iI0ZGRkZGRiIgZmlsdGVyPSJ1cmwoI2YxOG5peWl3OGw3NTg0KSIgaGVpZ2h0PSI3My4zOTg0IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHdpZHRoPSIxMCIgeD0iNTU0LjUiIHk9IjE2My42OTUzIi8+PHJlY3QgZmlsbD0iI0ZGRkZGRiIgZmlsdGVyPSJ1cmwoI2YxOG5peWl3OGw3NTg0KSIgaGVpZ2h0PSIxMDQuNzk2OSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB3aWR0aD0iMTAiIHg9IjkyMSIgeT0iMzYyLjc1NzgiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjE3Ny41LDExNS40Mjk3LDE4Ny41LDExOS40Mjk3LDE3Ny41LDEyMy40Mjk3LDE4MS41LDExOS40Mjk3IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIyMy41IiB4Mj0iMTgzLjUiIHkxPSIxMTkuNDI5NyIgeTI9IjExOS40Mjk3Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkiIHg9IjMwLjUiIHk9IjExNC4zNjM4Ij4xPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjYzIiB4PSI0My41IiB5PSIxMTQuMzYzOCI+SFRUUCDsmpTssq08L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSI1NDIuNSwxNTkuNjk1Myw1NTIuNSwxNjMuNjk1Myw1NDIuNSwxNjcuNjk1Myw1NDYuNSwxNjMuNjk1MyIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMTg5LjUiIHgyPSI1NDguNSIgeTE9IjE2My42OTUzIiB5Mj0iMTYzLjY5NTMiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iMTk2LjUiIHk9IjE1MS4wNjMiPjI8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTk4IiB4PSIyMDkuNSIgeT0iMTQzLjQ5NjYiPk1lbWJlciDsobDtmowg7ISc67mE7IqkIOuplOyEnOuTnCDsi6Ttlok8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTEiIHg9IjIxMy41IiB5PSIxNTguNjI5NCI+LSDtirjrnpzsnq3shZgg7Iuc7J6RPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNTc1LjUsMTg4LjgyODEsNTY1LjUsMTkyLjgyODEsNTc1LjUsMTk2LjgyODEsNTcxLjUsMTkyLjgyODEiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNzYwLjUsMTg4LjgyODEsNzcwLjUsMTkyLjgyODEsNzYwLjUsMTk2LjgyODEsNzY0LjUsMTkyLjgyODEiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjU2OS41IiB4Mj0iNzY2LjUiIHkxPSIxOTIuODI4MSIgeTI9IjE5Mi44MjgxIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgiIHg9IjU4MS41IiB5PSIxODcuNzYyMiI+MzwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNzIiIHg9IjU5My41IiB5PSIxODcuNzYyMiI+TWVtYmVyIOyXlO2LsO2LsCDsobDtmowg7ZuEIOuwmO2ZmDwvdGV4dD48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjIwMC41LDIzMy4wOTM4LDE5MC41LDIzNy4wOTM4LDIwMC41LDI0MS4wOTM4LDE5Ni41LDIzNy4wOTM4IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIxOTQuNSIgeDI9IjU1OC41IiB5MT0iMjM3LjA5MzgiIHkyPSIyMzcuMDkzOCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5IiB4PSIyMDYuNSIgeT0iMjI0LjQ2MTQiPjQ8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTI1IiB4PSIyMTkuNSIgeT0iMjE2Ljg5NSI+TWVtYmVyIOyXlO2LsO2LsCDrsJjtmZg8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzI0IiB4PSIyMjMuNSIgeT0iMjMyLjAyNzgiPi0gVHJhbnNhY3Rpb24gQ29tbWl0IOq3uOumrOqzoCDsmIHsho3shLEg7Luo7YWN7Iqk7Yq4IO2UjOufrOyJrDwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIxODkuNSIgeDI9IjIzMS41IiB5MT0iMjgxLjM1OTQiIHkyPSIyODEuMzU5NCIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjIzMS41IiB4Mj0iMjMxLjUiIHkxPSIyODEuMzU5NCIgeTI9IjI5NC4zNTk0Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMTkwLjUiIHgyPSIyMzEuNSIgeTE9IjI5NC4zNTk0IiB5Mj0iMjk0LjM1OTQiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjIwMC41LDI5MC4zNTk0LDE5MC41LDI5NC4zNTk0LDIwMC41LDI5OC4zNTk0LDE5Ni41LDI5NC4zNTk0IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iMTk2LjUiIHk9IjI2OC43MjcxIj41PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyNSIgeD0iMjA5LjUiIHk9IjI2MS4xNjA2Ij5NZW1iZXIg7JeU7Yuw7YuwIOyImOyglTwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNzMiIHg9IjIxMy41IiB5PSIyNzYuMjkzNSI+LSBtZW1iZXIuc2V0TmFtZSgiWFhYIik8L3RleHQ+PHBhdGggZD0iTTEwNCwzMDkuMzU5NCBMMTcwLDMwOS4zNTk0IEwxNzAsMzE2LjM1OTQgTDE2MCwzMjYuMzU5NCBMMTA0LDMyNi4zNTk0IEwxMDQsMzA5LjM1OTQgIiBmaWxsPSIjRUVFRUVFIiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSJub25lIiBoZWlnaHQ9IjE2OC4xOTUzIiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjIuMDsiIHdpZHRoPSI4OTciIHg9IjEwNCIgeT0iMzA5LjM1OTQiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjEiIHg9IjExOSIgeT0iMzIyLjQyNjMiPmFsdDwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMSIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjc2IiB4PSIxODUiIHk9IjMyMS41Njk4Ij5b67ew66W8IOuwmO2ZmO2VmOyngCDslYrqs6Ag67OE64+E7J2YIO2KuOuenOyereyFmOydhCDsi5zsnpHtlZjripQg6rK97JqwXTwvdGV4dD48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjkwOSwzNTguNzU3OCw5MTksMzYyLjc1NzgsOTA5LDM2Ni43NTc4LDkxMywzNjIuNzU3OCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMTg5LjUiIHgyPSI5MTUiIHkxPSIzNjIuNzU3OCIgeTI9IjM2Mi43NTc4Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkiIHg9IjE5Ni41IiB5PSIzNTAuMTI1NSI+NjwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNDIiIHg9IjIwOS41IiB5PSIzNDIuNTU5MSI+67OE64+EIOyEnOu5hOyKpCDrqZTshJzrk5wg7Iuk7ZaJPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkxIiB4PSIyMTMuNSIgeT0iMzU3LjY5MTkiPi0g7Yq4656c7J6t7IWYIOyLnOyekTwvdGV4dD48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjIwMC41LDQ2My41NTQ3LDE5MC41LDQ2Ny41NTQ3LDIwMC41LDQ3MS41NTQ3LDE5Ni41LDQ2Ny41NTQ3IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIxOTQuNSIgeDI9IjkyNSIgeTE9IjQ2Ny41NTQ3IiB5Mj0iNDY3LjU1NDciLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iMjA2LjUiIHk9IjQyNC42NTY3Ij43PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5IiB4PSIyMTkuNSIgeT0iMzg2LjgyNDciPuuplOyEnOuTnCDrsJjtmZg8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjc2IiB4PSIyMjMuNSIgeT0iNDAxLjk1NzUiPi0g7Yq4656c7J6t7IWYIOy7pOuwiyDqt7jrpqzqs6Ag7JiB7IaN7ISxIOy7qO2FjeyKpO2KuCDtlIzrn6zsiaw8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzIzIiB4PSIyMTkuNSIgeT0iNDE3LjA5MDMiPjogNeuyiOyXkOyEnCBtZW1iZXIuc2V0TmFtZSgiWFhYIinrpbwg7Iuk7ZaJ7ZWcIOuCtOyaqeydtDwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyOTMiIHg9IjIxOS41IiB5PSI0MzIuMjIzMSI+7JiB7IaN7ISxIOy7qO2FjeyKpO2KuOydmCDrs4Dqsr3qsJDsp4Dsl5Ag7J2Y7ZWY7JesIOuwmOyYgSDqt7jrpqzqs6A8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzAyIiB4PSIyMTkuNSIgeT0iNDQ3LjM1NiI+7Yq4656c7J6t7IWY7Jq4IOy7pOuwi+2VmOqzoCDsmIHsho3shLEg7Luo7YWN7Iqk7Yq46rCAIO2UjOufrOyJrOuQmOyWtDwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxOTQiIHg9IjIxOS41IiB5PSI0NjIuNDg4OCI+7Iuk7KCcIOuNsOydtO2EsOuyoOydtOyKpOyXkCDrs4Dqsr3snYQg67CY7JiBPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6Mi4wLDIuMDsiIHgxPSIxMDQiIHgyPSIxMDAxIiB5MT0iNDc2LjU1NDciIHkyPSI0NzYuNTU0NyIvPjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMzQuNSw1MDEuNjg3NSwyNC41LDUwNS42ODc1LDM0LjUsNTA5LjY4NzUsMzAuNSw1MDUuNjg3NSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMjguNSIgeDI9IjE4OC41IiB5MT0iNTA1LjY4NzUiIHkyPSI1MDUuNjg3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5IiB4PSI0MC41IiB5PSI1MDAuNjIxNiI+ODwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMjkiIHg9IjUzLjUiIHk9IjUwMC42MjE2Ij7rt7Dsl5Ag66ee64qUIOuNsOydtO2EsCDrsJjtmZg8L3RleHQ+PCEtLU1ENT1bNDZlZmQxOGVjMTY5MjczZWIxMzk0NjY0MDE1YThhNDhdCkBzdGFydHVtbA0KYWN0b3IgVXNlciBhcyBVDQpwYXJ0aWNpcGFudCBNZW1iZXJDb250cm9sbGVyIGFzIEENCnBhcnRpY2lwYW50IE1lbWJlclNlcnZpY2UgYXMgQg0KcGFydGljaXBhbnQgTWVtYmVyUmVwb3NpdG9yeSBhcyBDDQpwYXJ0aWNpcGFudCBBbm90aGVyU2VydmljZSBhcyBEDQphdXRvbnVtYmVyDQpVIC0+IEE6IEhUVFAg7JqU7LKtDQpBIC0+IEI6IE1lbWJlciDsobDtmowg7ISc67mE7IqkIOuplOyEnOuTnCDsi6TtlolcbiAtIO2KuOuenOyereyFmCDsi5zsnpENCmFjdGl2YXRlIEINCkIgPC0+IEM6IE1lbWJlciDsl5Tti7Dti7Ag7KGw7ZqMIO2bhCDrsJjtmZgNCkIgLT4gQTogTWVtYmVyIOyXlO2LsO2LsCDrsJjtmZhcbiAtIFRyYW5zYWN0aW9uIENvbW1pdCDqt7jrpqzqs6Ag7JiB7IaN7ISxIOy7qO2FjeyKpO2KuCDtlIzrn6zsiawNCmRlYWN0aXZhdGUgQg0KQSAtPiBBOiBNZW1iZXIg7JeU7Yuw7YuwIOyImOyglVxuIC0gbWVtYmVyLnNldE5hbWUoIlhYWCIpDQphbHQg67ew66W8IOuwmO2ZmO2VmOyngCDslYrqs6Ag67OE64+E7J2YIO2KuOuenOyereyFmOydhCDsi5zsnpHtlZjripQg6rK97JqwDQoJYXV0b251bWJlciA2DQoJQSAtPiBEOiDrs4Trj4Qg7ISc67mE7IqkIOuplOyEnOuTnCDsi6TtlolcbiAtIO2KuOuenOyereyFmCDsi5zsnpENCglhY3RpdmF0ZSBEDQoJRCAtPiBBOiDrqZTshJzrk5wg67CY7ZmYXG4gLSDtirjrnpzsnq3shZgg7Luk67CLIOq3uOumrOqzoCDsmIHsho3shLEg7Luo7YWN7Iqk7Yq4IO2UjOufrOyJrFxuOiA167KI7JeQ7IScIG1lbWJlci5zZXROYW1lKCJYWFgiKeulvCDsi6TtlontlZwg64K07Jqp7J20IFxu7JiB7IaN7ISxIOy7qO2FjeyKpO2KuOydmCDrs4Dqsr3qsJDsp4Dsl5Ag7J2Y7ZWY7JesIOuwmOyYgSDqt7jrpqzqs6AgXG7tirjrnpzsnq3shZjsmrgg7Luk67CL7ZWY6rOgIOyYgeyGjeyEsSDsu6jthY3siqTtirjqsIAg7ZSM65+s7Ims65CY7Ja0IFxu7Iuk7KCcIOuNsOydtO2EsOuyoOydtOyKpOyXkCDrs4Dqsr3snYQg67CY7JiBDQoJZGVhY3RpdmF0ZSBECQ0KZWxzZSANCmVuZA0KQSAtPiBVOiDrt7Dsl5Ag66ee64qUIOuNsOydtO2EsCDrsJjtmZgNCkBlbmR1bWwNCgpQbGFudFVNTCB2ZXJzaW9uIDEuMjAyMS4xMGJldGEyKFVua25vd24gY29tcGlsZSB0aW1lKQooR1BMIHNvdXJjZSBkaXN0cmlidXRpb24pCkphdmEgUnVudGltZTogSmF2YShUTSkgU0UgUnVudGltZSBFbnZpcm9ubWVudApKVk06IEphdmEgSG90U3BvdChUTSkgNjQtQml0IFNlcnZlciBWTQpEZWZhdWx0IEVuY29kaW5nOiBVVEYtOApMYW5ndWFnZTogZW4KQ291bnRyeTogVVMKLS0+PC9nPjwvc3ZnPg=='></li>\n<li>위와 같은 문제는 같은 영속성 컨텍스트를 여러 트랜잭션에서 공유하기 때문에 발생하는 문제로 해결하는 단순한 방법은 <strong>트랜잭션이 있는 비즈니스 로직을 모두 호출하고 나서 엔티티를 변경하면 쉽게 해결된다.</strong><br>다시 말해, <strong>선 트랜잭션 후 변경으로 요약할 수 있다.</strong></li>\n</ul>\n<h3 id=\"OSIV를-사용하는-것이-만능이-아니다\"><a href=\"#OSIV를-사용하는-것이-만능이-아니다\" class=\"headerlink\" title=\"OSIV를 사용하는 것이 만능이 아니다.\"></a>OSIV를 사용하는 것이 만능이 아니다.</h3><ul>\n<li>객체 그래프의 뎁스가 깊어진다면 OSIV를 사용했을 때, 성능적으로 신경써야 할 부분도 많아진다.</li>\n<li>도메인의 요구사항 단순 엔티티만을 반환하여 끝나는 경우는 생각보다 드물다. 특히 통계 성격의 데이터를 조회해야 하는 경우가 대표적인데, 이럴 경우 차리리 JPQL을 사용하여 데이터를 조회하고 이를 DTO 객체로 바인딩하여 반환하는 것이 생각보다 쉬운 해결책일 수도 있다. </li>\n<li>너무 복잡하거나 DB 종속적인 연산을 사용해야 할 경우도 생길 수 있는데, 이럴 경우 하이버네이트의 <code>@SubSelect</code>를 사용하여 별도로 조회 전용 도메인 객체를 만들어서 해결하는 방법도 존재한다. 물론 DB 종속적인 연산을 사용하게 됨에 따라 추후 DB 변경에 대한 대응이 어려워질 수 있는 부분도 분명 존재하지만, 일반적으로 사용하고 있는 데이터베이스를 변경하는 작업은 쉽게 일어나지도 않을 뿐더러 완벽하게 어플리케이션 레이어에서 변경을 쉽게 커버할 수 있는 경우 더 드물다고 생각한다. </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JPA-영속성-관리\"><a href=\"#JPA-영속성-관리\" class=\"headerlink\" title=\"JPA 영속성 관리\"></a>JPA 영속성 관리</h1><blockquote>\n<p>자바 ORM 표준 JPA 프로그래밍 13장 내용을 정리</p>\n</blockquote>\n<p>스프링과 같은 컨테이너 환경에서 JPA를 사용하게 되면, 컨테이너 레벨에서 트랜잭션과 영속성 컨텍스트를 관리해주므로 어플리케이션 개발이 쉬워지게 되는데, 문제가 되는 부분은 내부 동작에 대한 정확한 이해가 없을 때 생기는 트러블 슈팅이 어려워 지는 부분이다. 내부동작에 대한 이해, 스프링 컨테이너에서의 기본 전략, 지연로딩, OSIV에 대한 내용을 가볍게 정리하고자 한다.</p>\n<h2 id=\"트랜잭션-범위의-영속성-컨텍스트\"><a href=\"#트랜잭션-범위의-영속성-컨텍스트\" class=\"headerlink\" title=\"트랜잭션 범위의 영속성 컨텍스트\"></a>트랜잭션 범위의 영속성 컨텍스트</h2><h3 id=\"스프링-컨테이너의-기본-전략\"><a href=\"#스프링-컨테이너의-기본-전략\" class=\"headerlink\" title=\"스프링 컨테이너의 기본 전략\"></a>스프링 컨테이너의 기본 전략</h3><p><img src=\"https://i.imgur.com/lgR6GfA.png\" alt=\"트랜잭션_범위_영속성_컨텍스트\"></p>\n<ul>\n<li>스프링은 트랜잭션 범위의 영속성 컨텍스트를 기본 전략으로 사용한다. </li>\n<li>트랜잭션 범위와 영속성 컨텍스트의 생존 범위가 동일하며, 트랜잭션 종료 시, 영속성 컨텍스트도 동일하게 종료하게 된다.</li>\n</ul>\n<p><img src=\"https://i.imgur.com/vZtbhUl.png\" alt=\"트랜잭션_범위_영속성_컨텍스트_AOP\"></p>\n<ul>\n<li>스프링 어플리케이션에서는 <code>@Transactional</code>을 사용하여 트랜잭션을 시작하게 되는데, 단순 호출처럼 보이는 부분도 사실 스프링의 트랜잭션 AOP가 먼저 작동하게 된다.<ul>\n<li>스프링 트랜잭션 AOP는 대상 메소드를 호출하기 직전에 트랜잭션을 시작하며, 호출이 정상적으로 종료되면 트랜잭션을 커밋하고 종료하게 된다.</li>\n<li>트랜잭션 커밋 시, JPA는 영속성 컨텍스트를 플러시하여 변경 내용을 DB에 반영한 후 트랜잭션을 커밋하게 된다.</li>\n<li>예외가 발생하게 되면, 트랜잭션을 롤백하고 종료하게 되는데, 이때는 영속성 컨텍스트를 플러시하지 않게 된다.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://i.imgur.com/t9RFewK.png\" alt=\"트랜잭션_영속성컨텍스트\"></p>\n<ul>\n<li><strong>트랜잭션이 같을 경우, 같은 영속성 컨텍스트를 사용한다.</strong><ul>\n<li>다양한 위치에서 엔티티 매니저(EntityManager)를 주입받아 사용해도 트랜잭션이 같으면 항상 같은 영속성 컨텍스트를 사용하게 된다.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://i.imgur.com/al1qaZQ.png\" alt=\"스레드_영속성컨텍스트\"></p>\n<ul>\n<li><strong>트랜잭션이 다를 경우, 다른 영속성 컨텍스트를 사용한다.</strong><ul>\n<li><strong>여러 스레드에서 동시에 요청에 올 경우, 같은 엔티티 매니저를 사용한다고 하더라도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 달라진다.</strong> </li>\n<li>다시 말해, <strong>스프링 컨테이너에서는 스레드별로 각기 다른 트랜잭션을 할당하게 되는데</strong>, 따라서 같은 엔티티 매니저를 호출해도 접근하는 영속성 컨텍스트가 다르기 때문에 멀티스레드 환경에서도 안전하다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"준영속-지연-로딩\"><a href=\"#준영속-지연-로딩\" class=\"headerlink\" title=\"준영속/지연 로딩\"></a>준영속/지연 로딩</h2><ul>\n<li>조회한 엔티티가 트랜잭션 범위인 서비스, 레파지토리 레이어에서는 영속성 컨텍스트에 의해 관리가 되기 때문에 영속 상태를 유지하지만, 이 밖의 레이어에서는 준영속 상태가 된다.</li>\n<li>영속성 컨텍스트의 관리 밖에서는 <code>지연 로딩</code> 및 <code>변경 감지</code>가 동작하지 않는다.<ul>\n<li>따라서, 비지니스 혹은 요구사항을 기반으로 한 변경에 대해서는 반드시 서비스/도메인 레이어에서 수행을 해야한다. 컨트롤러와 같은 영역에서 이를 수행하게 되면 레이어별로 책임이 모호해지고 어플리케이션의 유지보수성이 급격하게 떨어지게 된다.</li>\n<li>지연 로딩 기능이 동작하지 않기 때문에, 생기는 이슈는 생각보다 크다. 만약 컨트롤러와 같은 레이어에서 지연 로딩 상태의 연관 엔티티나 밸류를 조회하게 될 경우, <code>LazyIntializationException</code> 예외가 발생하게 된다.</li>\n</ul>\n</li>\n<li>지연 로딩을 해결할 수 있는 방법은 아래와 같다.<ul>\n<li>필요한 엔티티를 미리 로딩<ol>\n<li>글로벌 페치 전략 수정</li>\n<li>JPQL 페치 조인</li>\n<li>강제로 초기화</li>\n</ol>\n</li>\n<li>OSIV(Open Sessin in View)를 사용하여 엔티티를 항상 영속 상태로 유지</li>\n</ul>\n</li>\n</ul>\n<p>OSIV의 경우 별도로 정리하는걸로 하고, 먼저 필요 엔티티를 미리 로딩하는 방법에 대해 정리하고자 한다. 말 그대로, 뷰 혹은 컨트롤러 레이어에서 필요한 데이터를 영속성 컨텍스트 범위 내에서 미리 로딩을 하는 방법을 가리키며 위에서 정리한대로 3가지 방법이 존재한다.</p>\n<h3 id=\"글로벌-페치-전략-수정-즉시-로딩\"><a href=\"#글로벌-페치-전략-수정-즉시-로딩\" class=\"headerlink\" title=\"글로벌 페치 전략 수정 - 즉시 로딩\"></a>글로벌 페치 전략 수정 - 즉시 로딩</h3><p>주문 엔티티에서 주문 상품 벨류 목록을 담고 있는 예제로 주문 상품 벨류의 경우 별도의 식별자가 필요하지 않기 때문에 <code>@ElementCollection</code>을 이용하여 주문 엔티티에 매핑을 했으며 글로벌 페치 전략은 즉시 로딩으로 설정해주었다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table(name = <span class=\"meta-string\">&quot;orders&quot;</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">constructor</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Id</span></span><br><span class=\"line\">\t<span class=\"meta\">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> id: <span class=\"built_in\">Long</span> = <span class=\"number\">0L</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Column(nullable = false, updatable = false)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> memberId: <span class=\"built_in\">Long</span> = <span class=\"number\">0L</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Enumerated(value = EnumType.STRING)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Column(length = 20, nullable = false)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> status: OrderStatus = OrderStatus.PAYMENT_WAITING</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@ElementCollection(fetch = FetchType.EAGER)</span></span><br><span class=\"line\">\t<span class=\"meta\">@CollectionTable(</span></span><br><span class=\"line\"><span class=\"meta\">\t\tname = <span class=\"meta-string\">&quot;order_products&quot;</span>,</span></span><br><span class=\"line\"><span class=\"meta\">\t\tjoinColumns = [</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\tJoinColumn(name = <span class=\"meta-string\">&quot;id&quot;</span>)</span></span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"meta\">@AttributeOverrides(</span></span><br><span class=\"line\"><span class=\"meta\">\t\tvalue = [</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\tAttributeOverride(name = <span class=\"meta-string\">&quot;productId&quot;</span>, column = Column(name = <span class=\"meta-string\">&quot;product_id&quot;</span>)</span>),</span><br><span class=\"line\">\t\t\tAttributeOverride(name = <span class=\"string\">&quot;price&quot;</span>, column = Column(name = <span class=\"string\">&quot;price&quot;</span>)),</span><br><span class=\"line\">\t\t\tAttributeOverride(name = <span class=\"string\">&quot;quantity&quot;</span>, column = Column(name = <span class=\"string\">&quot;quantity&quot;</span>)),</span><br><span class=\"line\">\t\t\tAttributeOverride(name = <span class=\"string\">&quot;amounts&quot;</span>, column = Column(name = <span class=\"string\">&quot;amounts&quot;</span>)),</span><br><span class=\"line\">\t\t\tAttributeOverride(name = <span class=\"string\">&quot;line_idx&quot;</span>, column = Column(name = <span class=\"string\">&quot;line_idx&quot;</span>))</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"meta\">@OrderBy(value = <span class=\"meta-string\">&quot;line_idx&quot;</span>)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> orderProducts: MutableList&lt;OrderProduct&gt; = mutableListOf()</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@CreationTimestamp</span></span><br><span class=\"line\">\t<span class=\"meta\">@Column(nullable = false)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> createdAt: LocalDateTime = LocalDateTime.now()</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@UpdateTimestamp</span></span><br><span class=\"line\">\t<span class=\"meta\">@Column(nullable = false)</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> updatedAt: LocalDateTime = LocalDateTime.now()</span><br><span class=\"line\">\t\t<span class=\"keyword\">protected</span> <span class=\"keyword\">set</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doOrder</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\tmemberId: <span class=\"type\">Long</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\tstatus: <span class=\"type\">OrderStatus</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\tproducts: <span class=\"type\">List</span>&lt;<span class=\"type\">OrderProduct</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t)</span></span>: Order &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (status !<span class=\"keyword\">in</span> listOf(OrderStatus.PAYMENT_WAITING, OrderStatus.PATMENT_COMPLETED)) <span class=\"keyword\">throw</span> IllegalArgumentException(<span class=\"string\">&quot;올바른 주문 상태 값이 아닙니다.&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (products.isEmpty()) <span class=\"keyword\">throw</span> IllegalArgumentException(<span class=\"string\">&quot;최소 한개 이상의 구매 상품을 포함해야 합니다.&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Order().also &#123;</span><br><span class=\"line\">\t\t\t\tit.memberId = memberId</span><br><span class=\"line\">\t\t\t\tit.status = status</span><br><span class=\"line\">\t\t\t\tit.orderProducts = products.toMutableList()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional(read)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderService</span></span>(</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> orderRepository: OrderRepository</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getList</span><span class=\"params\">(pageable: <span class=\"type\">Pageable</span>)</span></span>: Page&lt;Order&gt; &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">val</span> list = orderRepository.findAll(pageable)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> list</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get</span><span class=\"params\">(id: <span class=\"type\">Long</span>)</span></span>: Order &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> orderRepository.findByIdOrNull(id)</span><br><span class=\"line\">\t\t\t\t?: <span class=\"keyword\">throw</span> NotExistsOrderException(<span class=\"string\">&quot;존재하지 않은 주문입니다.&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>서비스 레이어에서 주문 엔티티에 대한 조회를 목록/단건 조회할 수 있도록 가벼운 코드를 작성했다. 주문ID 기준의 단건 조회의 경우, 연관 콜렉션에 매핑 되어 있는 <code>order_products</code>테이블을 LEFT OUTER JOIN을 사용하여 바로 조회하는 것을 확인 할 수 있다.<br><img src=\"https://i.imgur.com/4N4g15c.png\" alt=\"EAGER_LEFT_OUTER_JOIN\"></p>\n<p>여기까지는 문제가 없다고 생각할 수 있다. 하지만, 문제는 목록 조회 부분에서 생기게 되는데, 바로 <code>N+1</code> 문제이다.<br><img src=\"https://i.imgur.com/oWSQpfD.png\" alt=\"EAGER_N+1\"></p>\n<p>단건만 조회하는 엔티티라면 문제가 없겠지만, 대부분의 어플리케이션에서 목록 조회는 기본으로 하기 때문에 즉시 로딩을 사용함으로써 아래와 같은 단점이 생길 수 밖에 없다.</p>\n<ul>\n<li><strong>불필요한 벨류/엔티티 조회</strong><br>주문 엔티티에서 목록이 필요하지 않은 경우에도 매번 목록 데이터를 조회하기 때문에 DB 레벨에서의 오버헤드가 발생한다.</li>\n<li><strong>N+1 문제 발생</strong><ul>\n<li>위 이미지를 통하여 볼 수 있듯이, 디비에 질의하는 쿼리 개수가 목록에서 반환하는 데이터 개수만큼의 IO가 발생하게 된다. 불필요한 IO 발생은 서버 어플리케이션에서는 당연히 지양해야 한다. </li>\n<li>JPQL을 사용하게 될 경우(ex. JpaRepository.findAll()), JPA는 SQL을 생성할 때 글로벌 페치 전략을 참고하지 않고 오직 JPQL 자체만 사용하게 된다. 아래는 SQL문을 생성하는 과정을 설명하고 있다.<ol>\n<li><code>select o from Order o</code> JPQL을 분석하여 <code>select * from Order</code> SQL을 실행</li>\n<li>데이터베이스에서 결과를 받아 <code>Order</code>엔티티 목록을 생성</li>\n<li><code>Order.orderProducts</code>의 글로벌 페치 전략이 즉시 로딩이므로 연관 벨류 콜렉션을 로딩해야 한다.</li>\n<li>연관 벨류/엔티티를 영속성 컨텍스트에서 찾는다.</li>\n<li>영속성 컨텍스트에 저장되어 있는 1차 캐싱 데이터가 없을 경우, DB에 질의하여 데이터를 가져온다. 이때, <code>Order</code>엔티티 목록의 개수만큼 DB에 질의를 하게 된다.</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"글로벌-페치-전략-수정-지연-로딩\"><a href=\"#글로벌-페치-전략-수정-지연-로딩\" class=\"headerlink\" title=\"글로벌 페치 전략 수정 - 지연 로딩\"></a>글로벌 페치 전략 수정 - 지연 로딩</h3><ul>\n<li>위에서 겪었던 N+1 문제의 경우, 연관 벨류 콜렉션의 글로벌 페치 전략을 지연 로딩으로 변경하고, 이를 영속성 컨텍스트 범위 내에서 호출해주면 해결할 수 있다. <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional(readOnly = true)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderService</span></span>(</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> orderRepository: OrderRepository</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getList</span><span class=\"params\">(pageable: <span class=\"type\">Pageable</span>)</span></span>: Page&lt;Order&gt; &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">val</span> list = orderRepository.findAll(pageable)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (order <span class=\"keyword\">in</span> list) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 실제 값을 사용할 때 프록시 객체가 초기화 된다.</span></span><br><span class=\"line\">\t\t\torder.orderProducts.forEach &#123; it.amounts &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> list</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get</span><span class=\"params\">(id: <span class=\"type\">Long</span>)</span></span>: Order &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">val</span> order = (orderRepository.findByIdOrNull(id)</span><br><span class=\"line\">\t\t\t\t?: <span class=\"keyword\">throw</span> NotExistsOrderException(<span class=\"string\">&quot;존재하지 않은 주문입니다.&quot;</span>))</span><br><span class=\"line\">\t\t<span class=\"comment\">// 실제 값을 사용할 때 프록시 객체가 초기화 된다.</span></span><br><span class=\"line\">\t\torder.orderProducts.forEach &#123; it.amounts &#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> order</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>글로벌 페치 전략을 지연 로딩으로 변경하게 될 경우, 연관 벨류/엔티티를 실제가 아닌 프록시 객체를 대상으로 조회하게 된다.</strong><br>프록시의 경우 실제 사용할 때 초기화가 진행되기 때문에, 위 코드처럼 <strong>실제 값을 호출하는 코드를 넣어줘야지 초기화가 진행된다.</strong></li>\n<li>위 예제 코드의 경우, ID 기준의 조회 메소드인 get에서는 지연 로딩의 이점을 충분히 잘 살려냈다고 할 수 있지만, 목록 조회에서의 경우, 강제 초기화를 진행하더라도 즉시 로딩에서처럼 초기화 시 매번 매핑한 벨류 콜렉션을 조회하는 또 다른 의미의 <code>N+1</code>이 발생하게 된다.</li>\n<li>이와 같은 형태의 <code>N+1</code>을 피하기 위해서 사용할 수 있는 방법으로는 아래와 같다. <ul>\n<li>하이버네이트의 <code>@BatchSize</code>가 있다. <code>@BatchSize</code>를 사용할 경우, 프록시를 통하여 초기화 대상이 되는 연관 벨류/엔티티의 실제 값을 가져오는 DB 질의를 in절로 수정하여 N번의 DB 질의가 발생하지 않도록 해준다. 하지만, <code>@BatchSize</code>를 사용하더라도 실제 연관 벨류/엔티티를 초기화 해줘야 하는건 동일하기 때문에, 아래와 같이 기준을 나눠서 매핑하는 전략을 생각해볼 수 있다.</li>\n<li>JPQL fetch 조인을 사용하면 조회하면 시점에 SQL 조인을 사용하여 함께 로딩할 벨류/엔티티를 로딩할 수 있다. 하지만, JPQL의 페치 조인을 사용하게 되면 프레젠테이션 영역에 필요한 데이터에 맞춘 레파지토리 메소드가 늘어날 수 있다는 단점이 분명히 존재한다.<blockquote>\n<p>트레이드오프가 필요한 지점이다. 성능적인 최적화 혹은 높은 TPS를 처리해야 하는 어플리케이션에서 불필요한 IO는 병목지점이 될 수 밖에 없다. 연관 엔티티를 모두 조회하더라도 Cache를 적용하여 불필요하게 DB IO가 발생하지 않도록 하는 방법도 좋고, 필요한 DB IO만 발생하도록 JPQL을 사용하는 방법 모두 상황에 따라 맞는 방법이라고 생각한다.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"그래서-최선의-방법은\"><a href=\"#그래서-최선의-방법은\" class=\"headerlink\" title=\"그래서 최선의 방법은?\"></a>그래서 최선의 방법은?</h3><ul>\n<li>결국, <strong>트랜잭션 경계 밖에서의 준영속 상태가 문제의 핵심이다.</strong><br>이를 해결하기 위해서는 경계 밖에서도 영속성 컨텍스트가 살아있도록 해주는 방법을 사용하면 자연스럽게 지연로딩에서 발생할 수 있는 문제를 해결할 수 있다. 그것이 바로 <code>OSIV</code>이다.</li>\n</ul>\n<h2 id=\"OSIV\"><a href=\"#OSIV\" class=\"headerlink\" title=\"OSIV\"></a>OSIV</h2><ul>\n<li>Open Session In View</li>\n<li>영속성 컨텍스트를 프레젠테이션 레이어까지 열어둔다는 뜻이다.</li>\n<li>하이버네이트에서는 <code>OSIV</code> 스프링에서는 <code>OEIV</code>라고 부르며, 관례상으로 OSIV라고 통칭하는 듯 하다.</li>\n<li>하이버네이트의 OSIV와 스프링에서의 OEIV는 비슷하지만 차이점이 분명하게 존재한다. 쉽게 생각하여 하이버네이트에서의 OSIV의 단점을 개선한 것이 OEIV라고 봐도 좋다.</li>\n</ul>\n<h3 id=\"과거-OSIV-요청-당-트랜잭션\"><a href=\"#과거-OSIV-요청-당-트랜잭션\" class=\"headerlink\" title=\"과거 OSIV: 요청 당 트랜잭션\"></a>과거 OSIV: 요청 당 트랜잭션</h3><ul>\n<li>초창기 OSIV는 요청 당 트랜잭션을 지원했는데 아래 그림을 참고하자<br><img src=\"https://i.imgur.com/sFEvc8g.png\" alt=\"OSIV_요청당트랜잭션\"></li>\n<li>서블릿 필터 혹은 스프링 인터셉터에서 영속성 컨텍스트를 생성하며 이때부터 트랜잭션을 시작하고 요청이 끝날 때 트랜잭션과 영속성 컨텍스트를 함께 종료하게 된다.</li>\n<li>프레젠테이션 레이어도 트랜잭션 경계내에 존재하게 됨에 따라, 지연로딩을 처리하기 위해 프록시 객체를 초기화해야 하는 과정이 필요없게 된다. 하지만, 트랜잭션의 경계가 비즈니스 레이어가 아닌 프레젠테이션 레이어부터 시작함에 따라 <strong>트랜잭션의 경계가 모호해지며 비즈니스 레이어가 아닌 곳에서 데이터 변경이 발생하는 문제가 생길 수 있다.</strong></li>\n</ul>\n<h4 id=\"요청-당-트랜잭션-모델의-문제점\"><a href=\"#요청-당-트랜잭션-모델의-문제점\" class=\"headerlink\" title=\"요청 당 트랜잭션 모델의 문제점\"></a>요청 당 트랜잭션 모델의 문제점</h4><ul>\n<li>JDBC 커넥션 보유 시간 증가<ul>\n<li>JDBC 커넥션은 뷰의 렌더링이 모두 완료된 후에야 커넥션 풀로 반환된다. 따라서 뷰의 렌더링 시간이 길어지면 길어질수록 개별 요청을 처리하기 위한 스레드가 JDBC 커넥션을 보유하는 시간이 길어진다.</li>\n</ul>\n</li>\n<li>모호한 트랜잭션 경계<ul>\n<li>예를 들어, 특정 컨트롤러에서 뷰에 표현하고자 하는 목적으로 엔티티를 변경한다면 요청에 마무리되는 시점에 해당 변경 사항이 영속성 컨텍스트에 변경 감지에 의해 반영이 되고 플러쉬됨에 따라 디비에 반영까지 되는 사이드 이펙트가 생기게 된다. 데이터의 변경이 도메인 계층이 아닌 이외 계층에서 이뤄진다면 유지보수성은 급격히 떨어지게 된다.<ul>\n<li>뷰/프레젠테이션 레이어에서 엔티티를 변경하지 못하도록 하는 방법을 생각해볼 수 있다.<ul>\n<li>DTO 객체 반환</li>\n<li>세터 지양</li>\n<li>읽기 전용 인터페이스/메서드 제공</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>일반적으로 애플리케이션의 트랜잭션 경계는 애플리케이션 레이어 SERVICE 를 경계로 한다. 즉, SERVICE 메서드 호출 전에 바로 트랜잭션이 시작되고 SERVICE 메서드 호출이 종료될 때 트랜잭션이 커밋되거나 롤백되는 것이 일반적이다. 이에 비해 과거 OSIV 서블릿 필터의 트랜잭션 경계는 HTTP 요청 처리 시간의 거의 대부분을 아우른다. 결국 트랜잭션 경계에 대한 일관성 있는 뷰를 유지할 수 없으며 이로 인해 다양한 문제가 발생할 여지가 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"스프링-OSIV-비즈니스-계층-트랜잭션\"><a href=\"#스프링-OSIV-비즈니스-계층-트랜잭션\" class=\"headerlink\" title=\"스프링 OSIV: 비즈니스 계층 트랜잭션\"></a>스프링 OSIV: 비즈니스 계층 트랜잭션</h3><p><img src=\"https://i.imgur.com/OxibUm8.png\" alt=\"OSIV_SPRING\"></p>\n<ul>\n<li><code>비즈니스 계층</code>에서 <code>트랜잭션</code>을 사용하는 OSIV</li>\n<li>뷰 렌더링 시점의 지연 로딩을 허용하면서도 일관성 있는 트랜잭션 경계를 유지하는 합리적인 절충안으로 서블릿 필터에서 Session 을 오픈하되 트랜잭션 경계는 애플리케이션 레이어 범위로 한정하는 것이다.</li>\n<li>Spring 프레임워크에서는 <code>FlushMode</code> 와 <code>ConnectionReleaseMode</code> 의 조정을 통해 과거 OSIV 모델의 단점을 보완할 <code>OpenSessionInViewFliter</code>와 <code>OpenSessionInViewInterceptor</code>를 제공한다.</li>\n<li>자세한 내용은 아래 내용을 참조하도록 하자<ol>\n<li>클라이언트의 요청 시, 서블릿 필터/인터셉터에서 영속성 컨텍스트를 생성한다. 단, 트랜잭션은 시작하지 않음</li>\n<li>도메인 계층에서 트랜잭션을 시작할 때, 1번에서 생성한 영속성 컨텍스트를 사용하여 트랜잭션을 시작</li>\n<li>도메인 계층의 서비스가 종료되면서 트랜잭션이 커밋하고 영속성 컨텍스트를 플러쉬한다. 트랜잭션은 종료가 되지만 영속성 컨텍스트를 종료하지 않는다.</li>\n<li>영속성 컨텍스트가 도메인 레이어가 아닌 프레젠테이션 레이어에서도 유지됨에 따라, 반환하는 엔티티는 영속 상태를 유지한다.</li>\n<li>필터/인터셉터로 돌아와서 영속성 컨텍스트를 종료한다. 이때는 영속성 컨텍스트를 플러쉬하지 않는다.</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"트랜잭션-없는-읽기\"><a href=\"#트랜잭션-없는-읽기\" class=\"headerlink\" title=\"트랜잭션 없는 읽기\"></a>트랜잭션 없는 읽기</h4><ul>\n<li>트랜잭션 없이 영속성 컨텍스트를 플러쉬하게 되면 <code>javax.persistence.TransactionRequiredException</code> 예외가 발생</li>\n<li>변경은 반드시 트랜잭션 내에서 이뤄져야 하는데, 조회의 경우 트랜잭션 없이도 가능하다. 이것을 바로 <code>트랜잭션 없이 읽기(Nontransactional reads)</code>라고 한다.</li>\n<li><strong>프록시 객체를 초기화하는 지연 로딩 역시 조회이므로 트랜잭션 없이 읽기가 가능하다.</strong></li>\n<li>결국 스프링 OSIV를 이용하게 되면 도메인 계층에서만 트랜잭션을 이용하여 변경이 가능하고, 이 밖의 레이어인 프레젠테이션 레이어에서는 엔티티를 변경한다고 하여도 영속성 컨텍스트를 플러쉬하지 않기 때문에 변경이 불가능하고 오직 읽기만 가능하게 되는 것이다. </li>\n</ul>\n<h4 id=\"스프링-OSIV-사용-시-주의점\"><a href=\"#스프링-OSIV-사용-시-주의점\" class=\"headerlink\" title=\"스프링 OSIV 사용 시 주의점\"></a>스프링 OSIV 사용 시 주의점</h4><ul>\n<li>서비스 호출 후 컨트롤러에서 반환하는 엔티티가 있다고 가정해보자.<br>이미 종료한 트랜잭션에서 반환한 엔티티이며 OSIV를 사용하고 있기 때문에 여전히 영속 상태를 유지하게 될 것이다. 요구사항에 의해 엔티티를 일부 값을 수정하며 바로 뷰를 반환하면 OSIV를 사용하기 때문에 문제가 전혀 없다.<br>하지만, <strong>바로 뷰로 데이터를 반환하지 않고 또 다른 서비스 메서드를 호출하여 트랜잭션을 시작할 경우 문제가 발생하게 된다.</strong><br>왜냐하면, 스프링 OSIV에 의하여 영속성 컨텍스트를 살아 있는 상태를 유지하기 때문에, 이전에 변경한 값이 새로 시작한 트랜잭션 커밋에 의해, 영속성 컨텍스트를 플러쉬하게 되는데 플러쉬하는 시점에 이전에 변경한 엔티티의 변경사항이 그대로 실제 데이터베이스에 반영되기 때문이다.<img src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U2NyaXB0VHlwZT0iYXBwbGljYXRpb24vZWNtYXNjcmlwdCIgY29udGVudFN0eWxlVHlwZT0idGV4dC9jc3MiIGhlaWdodD0iNjA3cHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDoxMDE1cHg7aGVpZ2h0OjYwN3B4O2JhY2tncm91bmQ6I0ZGRkZGRjsiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDEwMTUgNjA3IiB3aWR0aD0iMTAxNXB4IiB6b29tQW5kUGFuPSJtYWduaWZ5Ij48ZGVmcz48ZmlsdGVyIGhlaWdodD0iMzAwJSIgaWQ9ImYxOG5peWl3OGw3NTg0IiB3aWR0aD0iMzAwJSIgeD0iLTEiIHk9Ii0xIj48ZmVHYXVzc2lhbkJsdXIgcmVzdWx0PSJibHVyT3V0IiBzdGREZXZpYXRpb249IjIuMCIvPjxmZUNvbG9yTWF0cml4IGluPSJibHVyT3V0IiByZXN1bHQ9ImJsdXJPdXQyIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgLjQgMCIvPjxmZU9mZnNldCBkeD0iNC4wIiBkeT0iNC4wIiBpbj0iYmx1ck91dDIiIHJlc3VsdD0iYmx1ck91dDMiLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJibHVyT3V0MyIgbW9kZT0ibm9ybWFsIi8+PC9maWx0ZXI+PC9kZWZzPjxnPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGZpbHRlcj0idXJsKCNmMThuaXlpdzhsNzU4NCkiIGhlaWdodD0iNzMuMzk4NCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB3aWR0aD0iMTAiIHg9IjU1NC41IiB5PSIxNjMuNjk1MyIvPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGZpbHRlcj0idXJsKCNmMThuaXlpdzhsNzU4NCkiIGhlaWdodD0iMTA0Ljc5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgd2lkdGg9IjEwIiB4PSI5MjEiIHk9IjM2Mi43NTc4Ii8+PHJlY3QgZmlsbD0iI0ZGRkZGRiIgZmlsdGVyPSJ1cmwoI2YxOG5peWl3OGw3NTg0KSIgaGVpZ2h0PSIxNjguMTk1MyIgc3R5bGU9InN0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjA7IiB3aWR0aD0iODk3IiB4PSIxMDQiIHk9IjMwOS4zNTk0Ii8+PHJlY3QgZmlsbD0iI0ZGRkZGRiIgaGVpZ2h0PSIyIiBzdHlsZT0ic3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjEuMDsiIHdpZHRoPSI4OTciIHg9IjEwNCIgeT0iNDc1LjU1NDciLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjUuMCw1LjA7IiB4MT0iMjMiIHgyPSIyMyIgeTE9Ijg4LjI5NjkiIHkyPSI1MjMuNjg3NSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6NS4wLDUuMDsiIHgxPSIxODkiIHgyPSIxODkiIHkxPSI4OC4yOTY5IiB5Mj0iNTIzLjY4NzUiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjUuMCw1LjA7IiB4MT0iNTU5IiB4Mj0iNTU5IiB5MT0iODguMjk2OSIgeTI9IjUyMy42ODc1Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9Ijc3MiIgeDI9Ijc3MiIgeTE9Ijg4LjI5NjkiIHkyPSI1MjMuNjg3NSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6NS4wLDUuMDsiIHgxPSI5MjYiIHgyPSI5MjYiIHkxPSI4OC4yOTY5IiB5Mj0iNTIzLjY4NzUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIzMSIgeD0iNSIgeT0iODQuOTk1MSI+VXNlcjwvdGV4dD48ZWxsaXBzZSBjeD0iMjMuNSIgY3k9IjE1IiBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjE4bml5aXc4bDc1ODQpIiByeD0iOCIgcnk9IjgiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6Mi4wOyIvPjxwYXRoIGQ9Ik0yMy41LDIzIEwyMy41LDUwIE0xMC41LDMxIEwzNi41LDMxIE0yMy41LDUwIEwxMC41LDY1IE0yMy41LDUwIEwzNi41LDY1ICIgZmlsbD0ibm9uZSIgZmlsdGVyPSJ1cmwoI2YxOG5peWl3OGw3NTg0KSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzEiIHg9IjUiIHk9IjUzNS42ODI2Ij5Vc2VyPC90ZXh0PjxlbGxpcHNlIGN4PSIyMy41IiBjeT0iNTQ4Ljk4NDQiIGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMThuaXlpdzhsNzU4NCkiIHJ4PSI4IiByeT0iOCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoyLjA7Ii8+PHBhdGggZD0iTTIzLjUsNTU2Ljk4NDQgTDIzLjUsNTgzLjk4NDQgTTEwLjUsNTY0Ljk4NDQgTDM2LjUsNTY0Ljk4NDQgTTIzLjUsNTgzLjk4NDQgTDEwLjUsNTk4Ljk4NDQgTTIzLjUsNTgzLjk4NDQgTDM2LjUsNTk4Ljk4NDQgIiBmaWxsPSJub25lIiBmaWx0ZXI9InVybCgjZjE4bml5aXc4bDc1ODQpIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjIuMDsiLz48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjE4bml5aXc4bDc1ODQpIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjE0NyIgeD0iMTE0IiB5PSI1MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEzMyIgeD0iMTIxIiB5PSI3Mi45OTUxIj5NZW1iZXJDb250cm9sbGVyPC90ZXh0PjxyZWN0IGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMThuaXlpdzhsNzU4NCkiIGhlaWdodD0iMzAuMjk2OSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTQ3IiB4PSIxMTQiIHk9IjUyMi42ODc1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTMzIiB4PSIxMjEiIHk9IjU0Mi42ODI2Ij5NZW1iZXJDb250cm9sbGVyPC90ZXh0PjxyZWN0IGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMThuaXlpdzhsNzU4NCkiIGhlaWdodD0iMzAuMjk2OSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTI3IiB4PSI0OTQiIHk9IjUzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTEzIiB4PSI1MDEiIHk9IjcyLjk5NTEiPk1lbWJlclNlcnZpY2U8L3RleHQ+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxOG5peWl3OGw3NTg0KSIgaGVpZ2h0PSIzMC4yOTY5IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMjciIHg9IjQ5NCIgeT0iNTIyLjY4NzUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMTMiIHg9IjUwMSIgeT0iNTQyLjY4MjYiPk1lbWJlclNlcnZpY2U8L3RleHQ+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2YxOG5peWl3OGw3NTg0KSIgaGVpZ2h0PSIzMC4yOTY5IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNTMiIHg9IjY5NCIgeT0iNTMiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMzkiIHg9IjcwMSIgeT0iNzIuOTk1MSI+TWVtYmVyUmVwb3NpdG9yeTwvdGV4dD48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjE4bml5aXc4bDc1ODQpIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjE1MyIgeD0iNjk0IiB5PSI1MjIuNjg3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEzOSIgeD0iNzAxIiB5PSI1NDIuNjgyNiI+TWVtYmVyUmVwb3NpdG9yeTwvdGV4dD48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjE4bml5aXc4bDc1ODQpIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEyNiIgeD0iODYxIiB5PSI1MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjExMiIgeD0iODY4IiB5PSI3Mi45OTUxIj5Bbm90aGVyU2VydmljZTwvdGV4dD48cmVjdCBmaWxsPSIjRkVGRUNFIiBmaWx0ZXI9InVybCgjZjE4bml5aXc4bDc1ODQpIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEyNiIgeD0iODYxIiB5PSI1MjIuNjg3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjExMiIgeD0iODY4IiB5PSI1NDIuNjgyNiI+QW5vdGhlclNlcnZpY2U8L3RleHQ+PHJlY3QgZmlsbD0iI0ZGRkZGRiIgZmlsdGVyPSJ1cmwoI2YxOG5peWl3OGw3NTg0KSIgaGVpZ2h0PSI3My4zOTg0IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHdpZHRoPSIxMCIgeD0iNTU0LjUiIHk9IjE2My42OTUzIi8+PHJlY3QgZmlsbD0iI0ZGRkZGRiIgZmlsdGVyPSJ1cmwoI2YxOG5peWl3OGw3NTg0KSIgaGVpZ2h0PSIxMDQuNzk2OSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB3aWR0aD0iMTAiIHg9IjkyMSIgeT0iMzYyLjc1NzgiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjE3Ny41LDExNS40Mjk3LDE4Ny41LDExOS40Mjk3LDE3Ny41LDEyMy40Mjk3LDE4MS41LDExOS40Mjk3IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIyMy41IiB4Mj0iMTgzLjUiIHkxPSIxMTkuNDI5NyIgeTI9IjExOS40Mjk3Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkiIHg9IjMwLjUiIHk9IjExNC4zNjM4Ij4xPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjYzIiB4PSI0My41IiB5PSIxMTQuMzYzOCI+SFRUUCDsmpTssq08L3RleHQ+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSI1NDIuNSwxNTkuNjk1Myw1NTIuNSwxNjMuNjk1Myw1NDIuNSwxNjcuNjk1Myw1NDYuNSwxNjMuNjk1MyIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMTg5LjUiIHgyPSI1NDguNSIgeTE9IjE2My42OTUzIiB5Mj0iMTYzLjY5NTMiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iMTk2LjUiIHk9IjE1MS4wNjMiPjI8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTk4IiB4PSIyMDkuNSIgeT0iMTQzLjQ5NjYiPk1lbWJlciDsobDtmowg7ISc67mE7IqkIOuplOyEnOuTnCDsi6Ttlok8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTEiIHg9IjIxMy41IiB5PSIxNTguNjI5NCI+LSDtirjrnpzsnq3shZgg7Iuc7J6RPC90ZXh0Pjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNTc1LjUsMTg4LjgyODEsNTY1LjUsMTkyLjgyODEsNTc1LjUsMTk2LjgyODEsNTcxLjUsMTkyLjgyODEiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iNzYwLjUsMTg4LjgyODEsNzcwLjUsMTkyLjgyODEsNzYwLjUsMTk2LjgyODEsNzY0LjUsMTkyLjgyODEiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjU2OS41IiB4Mj0iNzY2LjUiIHkxPSIxOTIuODI4MSIgeTI9IjE5Mi44MjgxIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgiIHg9IjU4MS41IiB5PSIxODcuNzYyMiI+MzwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNzIiIHg9IjU5My41IiB5PSIxODcuNzYyMiI+TWVtYmVyIOyXlO2LsO2LsCDsobDtmowg7ZuEIOuwmO2ZmDwvdGV4dD48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjIwMC41LDIzMy4wOTM4LDE5MC41LDIzNy4wOTM4LDIwMC41LDI0MS4wOTM4LDE5Ni41LDIzNy4wOTM4IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIxOTQuNSIgeDI9IjU1OC41IiB5MT0iMjM3LjA5MzgiIHkyPSIyMzcuMDkzOCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5IiB4PSIyMDYuNSIgeT0iMjI0LjQ2MTQiPjQ8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTI1IiB4PSIyMTkuNSIgeT0iMjE2Ljg5NSI+TWVtYmVyIOyXlO2LsO2LsCDrsJjtmZg8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzI0IiB4PSIyMjMuNSIgeT0iMjMyLjAyNzgiPi0gVHJhbnNhY3Rpb24gQ29tbWl0IOq3uOumrOqzoCDsmIHsho3shLEg7Luo7YWN7Iqk7Yq4IO2UjOufrOyJrDwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIxODkuNSIgeDI9IjIzMS41IiB5MT0iMjgxLjM1OTQiIHkyPSIyODEuMzU5NCIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIgeDE9IjIzMS41IiB4Mj0iMjMxLjUiIHkxPSIyODEuMzU5NCIgeTI9IjI5NC4zNTk0Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMTkwLjUiIHgyPSIyMzEuNSIgeTE9IjI5NC4zNTk0IiB5Mj0iMjk0LjM1OTQiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjIwMC41LDI5MC4zNTk0LDE5MC41LDI5NC4zNTk0LDIwMC41LDI5OC4zNTk0LDE5Ni41LDI5NC4zNTk0IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iMTk2LjUiIHk9IjI2OC43MjcxIj41PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyNSIgeD0iMjA5LjUiIHk9IjI2MS4xNjA2Ij5NZW1iZXIg7JeU7Yuw7YuwIOyImOyglTwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNzMiIHg9IjIxMy41IiB5PSIyNzYuMjkzNSI+LSBtZW1iZXIuc2V0TmFtZSgiWFhYIik8L3RleHQ+PHBhdGggZD0iTTEwNCwzMDkuMzU5NCBMMTcwLDMwOS4zNTk0IEwxNzAsMzE2LjM1OTQgTDE2MCwzMjYuMzU5NCBMMTA0LDMyNi4zNTk0IEwxMDQsMzA5LjM1OTQgIiBmaWxsPSIjRUVFRUVFIiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSJub25lIiBoZWlnaHQ9IjE2OC4xOTUzIiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjIuMDsiIHdpZHRoPSI4OTciIHg9IjEwNCIgeT0iMzA5LjM1OTQiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjEiIHg9IjExOSIgeT0iMzIyLjQyNjMiPmFsdDwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMSIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjc2IiB4PSIxODUiIHk9IjMyMS41Njk4Ij5b67ew66W8IOuwmO2ZmO2VmOyngCDslYrqs6Ag67OE64+E7J2YIO2KuOuenOyereyFmOydhCDsi5zsnpHtlZjripQg6rK97JqwXTwvdGV4dD48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjkwOSwzNTguNzU3OCw5MTksMzYyLjc1NzgsOTA5LDM2Ni43NTc4LDkxMywzNjIuNzU3OCIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMTg5LjUiIHgyPSI5MTUiIHkxPSIzNjIuNzU3OCIgeTI9IjM2Mi43NTc4Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkiIHg9IjE5Ni41IiB5PSIzNTAuMTI1NSI+NjwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNDIiIHg9IjIwOS41IiB5PSIzNDIuNTU5MSI+67OE64+EIOyEnOu5hOyKpCDrqZTshJzrk5wg7Iuk7ZaJPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkxIiB4PSIyMTMuNSIgeT0iMzU3LjY5MTkiPi0g7Yq4656c7J6t7IWYIOyLnOyekTwvdGV4dD48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjIwMC41LDQ2My41NTQ3LDE5MC41LDQ2Ny41NTQ3LDIwMC41LDQ3MS41NTQ3LDE5Ni41LDQ2Ny41NTQ3IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiIHgxPSIxOTQuNSIgeDI9IjkyNSIgeTE9IjQ2Ny41NTQ3IiB5Mj0iNDY3LjU1NDciLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOSIgeD0iMjA2LjUiIHk9IjQyNC42NTY3Ij43PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5IiB4PSIyMTkuNSIgeT0iMzg2LjgyNDciPuuplOyEnOuTnCDrsJjtmZg8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjc2IiB4PSIyMjMuNSIgeT0iNDAxLjk1NzUiPi0g7Yq4656c7J6t7IWYIOy7pOuwiyDqt7jrpqzqs6Ag7JiB7IaN7ISxIOy7qO2FjeyKpO2KuCDtlIzrn6zsiaw8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzIzIiB4PSIyMTkuNSIgeT0iNDE3LjA5MDMiPjogNeuyiOyXkOyEnCBtZW1iZXIuc2V0TmFtZSgiWFhYIinrpbwg7Iuk7ZaJ7ZWcIOuCtOyaqeydtDwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyOTMiIHg9IjIxOS41IiB5PSI0MzIuMjIzMSI+7JiB7IaN7ISxIOy7qO2FjeyKpO2KuOydmCDrs4Dqsr3qsJDsp4Dsl5Ag7J2Y7ZWY7JesIOuwmOyYgSDqt7jrpqzqs6A8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzAyIiB4PSIyMTkuNSIgeT0iNDQ3LjM1NiI+7Yq4656c7J6t7IWY7Jq4IOy7pOuwi+2VmOqzoCDsmIHsho3shLEg7Luo7YWN7Iqk7Yq46rCAIO2UjOufrOyJrOuQmOyWtDwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxOTQiIHg9IjIxOS41IiB5PSI0NjIuNDg4OCI+7Iuk7KCcIOuNsOydtO2EsOuyoOydtOyKpOyXkCDrs4Dqsr3snYQg67CY7JiBPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6Mi4wLDIuMDsiIHgxPSIxMDQiIHgyPSIxMDAxIiB5MT0iNDc2LjU1NDciIHkyPSI0NzYuNTU0NyIvPjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMzQuNSw1MDEuNjg3NSwyNC41LDUwNS42ODc1LDM0LjUsNTA5LjY4NzUsMzAuNSw1MDUuNjg3NSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7IiB4MT0iMjguNSIgeDI9IjE4OC41IiB5MT0iNTA1LjY4NzUiIHkyPSI1MDUuNjg3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5IiB4PSI0MC41IiB5PSI1MDAuNjIxNiI+ODwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMjkiIHg9IjUzLjUiIHk9IjUwMC42MjE2Ij7rt7Dsl5Ag66ee64qUIOuNsOydtO2EsCDrsJjtmZg8L3RleHQ+PCEtLU1ENT1bNDZlZmQxOGVjMTY5MjczZWIxMzk0NjY0MDE1YThhNDhdCkBzdGFydHVtbA0KYWN0b3IgVXNlciBhcyBVDQpwYXJ0aWNpcGFudCBNZW1iZXJDb250cm9sbGVyIGFzIEENCnBhcnRpY2lwYW50IE1lbWJlclNlcnZpY2UgYXMgQg0KcGFydGljaXBhbnQgTWVtYmVyUmVwb3NpdG9yeSBhcyBDDQpwYXJ0aWNpcGFudCBBbm90aGVyU2VydmljZSBhcyBEDQphdXRvbnVtYmVyDQpVIC0+IEE6IEhUVFAg7JqU7LKtDQpBIC0+IEI6IE1lbWJlciDsobDtmowg7ISc67mE7IqkIOuplOyEnOuTnCDsi6TtlolcbiAtIO2KuOuenOyereyFmCDsi5zsnpENCmFjdGl2YXRlIEINCkIgPC0+IEM6IE1lbWJlciDsl5Tti7Dti7Ag7KGw7ZqMIO2bhCDrsJjtmZgNCkIgLT4gQTogTWVtYmVyIOyXlO2LsO2LsCDrsJjtmZhcbiAtIFRyYW5zYWN0aW9uIENvbW1pdCDqt7jrpqzqs6Ag7JiB7IaN7ISxIOy7qO2FjeyKpO2KuCDtlIzrn6zsiawNCmRlYWN0aXZhdGUgQg0KQSAtPiBBOiBNZW1iZXIg7JeU7Yuw7YuwIOyImOyglVxuIC0gbWVtYmVyLnNldE5hbWUoIlhYWCIpDQphbHQg67ew66W8IOuwmO2ZmO2VmOyngCDslYrqs6Ag67OE64+E7J2YIO2KuOuenOyereyFmOydhCDsi5zsnpHtlZjripQg6rK97JqwDQoJYXV0b251bWJlciA2DQoJQSAtPiBEOiDrs4Trj4Qg7ISc67mE7IqkIOuplOyEnOuTnCDsi6TtlolcbiAtIO2KuOuenOyereyFmCDsi5zsnpENCglhY3RpdmF0ZSBEDQoJRCAtPiBBOiDrqZTshJzrk5wg67CY7ZmYXG4gLSDtirjrnpzsnq3shZgg7Luk67CLIOq3uOumrOqzoCDsmIHsho3shLEg7Luo7YWN7Iqk7Yq4IO2UjOufrOyJrFxuOiA167KI7JeQ7IScIG1lbWJlci5zZXROYW1lKCJYWFgiKeulvCDsi6TtlontlZwg64K07Jqp7J20IFxu7JiB7IaN7ISxIOy7qO2FjeyKpO2KuOydmCDrs4Dqsr3qsJDsp4Dsl5Ag7J2Y7ZWY7JesIOuwmOyYgSDqt7jrpqzqs6AgXG7tirjrnpzsnq3shZjsmrgg7Luk67CL7ZWY6rOgIOyYgeyGjeyEsSDsu6jthY3siqTtirjqsIAg7ZSM65+s7Ims65CY7Ja0IFxu7Iuk7KCcIOuNsOydtO2EsOuyoOydtOyKpOyXkCDrs4Dqsr3snYQg67CY7JiBDQoJZGVhY3RpdmF0ZSBECQ0KZWxzZSANCmVuZA0KQSAtPiBVOiDrt7Dsl5Ag66ee64qUIOuNsOydtO2EsCDrsJjtmZgNCkBlbmR1bWwNCgpQbGFudFVNTCB2ZXJzaW9uIDEuMjAyMS4xMGJldGEyKFVua25vd24gY29tcGlsZSB0aW1lKQooR1BMIHNvdXJjZSBkaXN0cmlidXRpb24pCkphdmEgUnVudGltZTogSmF2YShUTSkgU0UgUnVudGltZSBFbnZpcm9ubWVudApKVk06IEphdmEgSG90U3BvdChUTSkgNjQtQml0IFNlcnZlciBWTQpEZWZhdWx0IEVuY29kaW5nOiBVVEYtOApMYW5ndWFnZTogZW4KQ291bnRyeTogVVMKLS0+PC9nPjwvc3ZnPg=='></li>\n<li>위와 같은 문제는 같은 영속성 컨텍스트를 여러 트랜잭션에서 공유하기 때문에 발생하는 문제로 해결하는 단순한 방법은 <strong>트랜잭션이 있는 비즈니스 로직을 모두 호출하고 나서 엔티티를 변경하면 쉽게 해결된다.</strong><br>다시 말해, <strong>선 트랜잭션 후 변경으로 요약할 수 있다.</strong></li>\n</ul>\n<h3 id=\"OSIV를-사용하는-것이-만능이-아니다\"><a href=\"#OSIV를-사용하는-것이-만능이-아니다\" class=\"headerlink\" title=\"OSIV를 사용하는 것이 만능이 아니다.\"></a>OSIV를 사용하는 것이 만능이 아니다.</h3><ul>\n<li>객체 그래프의 뎁스가 깊어진다면 OSIV를 사용했을 때, 성능적으로 신경써야 할 부분도 많아진다.</li>\n<li>도메인의 요구사항 단순 엔티티만을 반환하여 끝나는 경우는 생각보다 드물다. 특히 통계 성격의 데이터를 조회해야 하는 경우가 대표적인데, 이럴 경우 차리리 JPQL을 사용하여 데이터를 조회하고 이를 DTO 객체로 바인딩하여 반환하는 것이 생각보다 쉬운 해결책일 수도 있다. </li>\n<li>너무 복잡하거나 DB 종속적인 연산을 사용해야 할 경우도 생길 수 있는데, 이럴 경우 하이버네이트의 <code>@SubSelect</code>를 사용하여 별도로 조회 전용 도메인 객체를 만들어서 해결하는 방법도 존재한다. 물론 DB 종속적인 연산을 사용하게 됨에 따라 추후 DB 변경에 대한 대응이 어려워질 수 있는 부분도 분명 존재하지만, 일반적으로 사용하고 있는 데이터베이스를 변경하는 작업은 쉽게 일어나지도 않을 뿐더러 완벽하게 어플리케이션 레이어에서 변경을 쉽게 커버할 수 있는 경우 더 드물다고 생각한다. </li>\n</ul>\n"},{"title":"AWS ETC","date":"2019-07-11T15:00:00.000Z","_content":"\n# 기타\n\n## Tool\n[aws-shell](https://github.com/awslabs/aws-shell)\n\n## PIP 설치 시 삽질 내용\n- [](https://beomi.github.io/2018/02/12/Add-packages-installed-with-pip-usermode/)\n\n## DevOps를 위한 AWS CLI 활용팁\n[doc](https://aws.amazon.com/ko/blogs/korea/tips-aws-cli/)\n\n## 참고자료\n1. [무료 서버로 웹서비스 이중화하기](https://brunch.co.kr/)\n2. [AWS에서 도메인 구매하기](https://brunch.co.kr/@topasvga/292)\n3. [AWS VPC Basic](https://blog.2dal.com/2017/09/12/aws-vpc-basic/)","source":"_posts/AWS/ETC.md","raw":"---\ntitle: AWS ETC\ndate: 2019/7/12 00:00:00\ncategories:\n- AWS\n---\n\n# 기타\n\n## Tool\n[aws-shell](https://github.com/awslabs/aws-shell)\n\n## PIP 설치 시 삽질 내용\n- [](https://beomi.github.io/2018/02/12/Add-packages-installed-with-pip-usermode/)\n\n## DevOps를 위한 AWS CLI 활용팁\n[doc](https://aws.amazon.com/ko/blogs/korea/tips-aws-cli/)\n\n## 참고자료\n1. [무료 서버로 웹서비스 이중화하기](https://brunch.co.kr/)\n2. [AWS에서 도메인 구매하기](https://brunch.co.kr/@topasvga/292)\n3. [AWS VPC Basic](https://blog.2dal.com/2017/09/12/aws-vpc-basic/)","slug":"AWS/ETC","published":1,"updated":"2021-08-02T12:19:45.880Z","_id":"ckrswb3jx000526hvgdcmennv","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"기타\"><a href=\"#기타\" class=\"headerlink\" title=\"기타\"></a>기타</h1><h2 id=\"Tool\"><a href=\"#Tool\" class=\"headerlink\" title=\"Tool\"></a>Tool</h2><p><a href=\"https://github.com/awslabs/aws-shell\">aws-shell</a></p>\n<h2 id=\"PIP-설치-시-삽질-내용\"><a href=\"#PIP-설치-시-삽질-내용\" class=\"headerlink\" title=\"PIP 설치 시 삽질 내용\"></a>PIP 설치 시 삽질 내용</h2><ul>\n<li><a href=\"https://beomi.github.io/2018/02/12/Add-packages-installed-with-pip-usermode/\"></a></li>\n</ul>\n<h2 id=\"DevOps를-위한-AWS-CLI-활용팁\"><a href=\"#DevOps를-위한-AWS-CLI-활용팁\" class=\"headerlink\" title=\"DevOps를 위한 AWS CLI 활용팁\"></a>DevOps를 위한 AWS CLI 활용팁</h2><p><a href=\"https://aws.amazon.com/ko/blogs/korea/tips-aws-cli/\">doc</a></p>\n<h2 id=\"참고자료\"><a href=\"#참고자료\" class=\"headerlink\" title=\"참고자료\"></a>참고자료</h2><ol>\n<li><a href=\"https://brunch.co.kr/\">무료 서버로 웹서비스 이중화하기</a></li>\n<li><a href=\"https://brunch.co.kr/@topasvga/292\">AWS에서 도메인 구매하기</a></li>\n<li><a href=\"https://blog.2dal.com/2017/09/12/aws-vpc-basic/\">AWS VPC Basic</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"기타\"><a href=\"#기타\" class=\"headerlink\" title=\"기타\"></a>기타</h1><h2 id=\"Tool\"><a href=\"#Tool\" class=\"headerlink\" title=\"Tool\"></a>Tool</h2><p><a href=\"https://github.com/awslabs/aws-shell\">aws-shell</a></p>\n<h2 id=\"PIP-설치-시-삽질-내용\"><a href=\"#PIP-설치-시-삽질-내용\" class=\"headerlink\" title=\"PIP 설치 시 삽질 내용\"></a>PIP 설치 시 삽질 내용</h2><ul>\n<li><a href=\"https://beomi.github.io/2018/02/12/Add-packages-installed-with-pip-usermode/\"></a></li>\n</ul>\n<h2 id=\"DevOps를-위한-AWS-CLI-활용팁\"><a href=\"#DevOps를-위한-AWS-CLI-활용팁\" class=\"headerlink\" title=\"DevOps를 위한 AWS CLI 활용팁\"></a>DevOps를 위한 AWS CLI 활용팁</h2><p><a href=\"https://aws.amazon.com/ko/blogs/korea/tips-aws-cli/\">doc</a></p>\n<h2 id=\"참고자료\"><a href=\"#참고자료\" class=\"headerlink\" title=\"참고자료\"></a>참고자료</h2><ol>\n<li><a href=\"https://brunch.co.kr/\">무료 서버로 웹서비스 이중화하기</a></li>\n<li><a href=\"https://brunch.co.kr/@topasvga/292\">AWS에서 도메인 구매하기</a></li>\n<li><a href=\"https://blog.2dal.com/2017/09/12/aws-vpc-basic/\">AWS VPC Basic</a></li>\n</ol>\n"},{"title":"Kotlin Cookbook","date":"2021-03-02T15:00:00.000Z","_content":"\n# Kotlin Cookbook\n\n## 10장\n#### 레시피 10.1 - use로 리소스 관리하기\n- 코틀린에서는 자바의 `try-with-resources` 구조를 지원하지 않음\n- 대신, `Closeable` 인터페이스의 확장함수 `use`를 제공하며, `Reader`와 `File`에는 `useLine` 확장함수를 추가\n- `useLine`의 경우, `BufferedReader.use`에게 처리를 위임하며, 해당 확장함수는 `try-catch-finally`로 예외처리를 하는 전형적인 구조를 확장함수로 만들어놓았음\n\n```kotlin\n@InlineOnly\n@RequireKotlin(\"1.2\", versionKind = RequireKotlinVersionKind.COMPILER_VERSION, message = \"Requires newer compiler version to be inlined correctly.\")\npublic inline fun <T : Closeable?, R> T.use(block: (T) -> R): R {\n    var exception: Throwable? = null\n    try {\n        return block(this)\n    } catch (e: Throwable) {\n        exception = e\n    throw e\n    } finally {\n        when {\n            apiVersionIsAtLeast(1, 1, 0) -> this.closeFinally(exception)\n            this == null -> {}\n            exception == null -> close()\n            else ->\n                try {\n                    close()\n                } catch (closeException: Throwable) {\n                    // cause.addSuppressed(closeException) // ignored here\n                }\n        }\n    }\n}\n```\n\n```kotlin\nfun get10LongestWordsInDictionary() = File(\"/usr/share/dict/words\").useLines { line ->\n    // line type Kotlin Sequence\n    line.filter { it.length > 20 }\n        .sortedByDescending { it.length }\n        .take(10)\n        .toList()\n}\n```\n\n#### 레시피 10.2 - 파일에 기록하기\n- 본문 전체를 다시 쓰고 싶다면 `writeText`, 붙여쓰고 싶다면 `appendText`\n- 위 확장함수도 역시, `FileOutputStream(this).use { it.write(array) }` 확장함수에게 처리를 위임\n```kotlin\nval file = File(\"./myfile.txt\")\nfile.writeText(\"Data\")\nfile.appendText(\"\\nHello\")\nfile.appendText(\"\\nWorld\")\n```\n\n----\n## 11장\n#### 레시피 11.1 - 코틀린 버전 알아내기\n- `KotlinVersion.CURRENT`을 참조하면 시멘틱버져닝 형태의 코틀린 버젼 값을 알아낼 수 있음.\n- `KotlinVersion`의 구현을 살펴보면 쉽게 알 수 있지만, Comparable 인터페이스를 구현하고 있으므로 비교가 가능\n```kotlin\nprintln(\"version = ${KotlinVersion.CURRENT}\")\nprintln(\"${KotlinVersion.CURRENT < KotlinVersion(major = 1, minor = 2)}\")\nprintln(\"${KotlinVersion.CURRENT < KotlinVersion(major = 1, minor = 2, patch = 41)}\")\n```\n\n#### 레시피 11.2 - 반복적으로 람다 실행하기\n- `repeat` 확장함수를 사용하면, 인자로 넘어가는 람다 구문이 지정한 횟수만큼 실행됨.\n- `contract`: 컴파일러에게 함수의 호출횟수와 타입캐스팅을 도와주기위해 도입\n- `@InlineOnly`: 자바 상호 운용을 할때, 자바쪽에서 해당 구현을 참조하지 못하도록 마킹 역할 수행\n\n```kotlin\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n```\n\n#### 레시피 11.3 - 완벽한 When 강제하기\n- 코틀린에서의 `When`절은 문과 식의 역할을 모두 할 수 있다.\n- 식으로 사용하는 경우, `else`까지 붙여 완벽한 형태로 사용해야 함.\n- 문으로 사용할 경우, 완벽하게 else까지 붙여서 사용할 수 있도록 강제도 할 수 있음. `exhaustive` 확장 속성을 추가하면 가능하다.\n  * *TODO: Kotlin 1.3.72 환경에서 구문 에러가 발생.*\n```kotlin\nfun printMod3(n: Int) {\n    when (n % 3) {\n        1 -> println(\"$n % 3 = 0\")\n        2 -> println(\"$n % 3 = 1\")\n        3 -> println(\"$n % 3 = 2\")\n    }\n}\n\nfun printMod3SingleStatement(n: Int) = when (n % 3) {\n    1 -> println(\"$n % 3 = 0\")\n    2 -> println(\"$n % 3 = 1\")\n    3 -> println(\"$n % 3 = 2\")\n    else -> println(\"problems\")\n}\n```\n\n\n#### 레시피 11.4 - 정규표현식과 함께 replace 함수 사용하기\n- 문자열 중 부분 문자열을 수정하고 싶을 경우 `replace`함수를 사용.\n```kotlin\n// 1)\nfun String.replace(\n    oldValue: String,\n    newValue: String,\n    ignroeCase: Boolean = false\n): String\n\n\n// 2)\nfun CharSequence.replace(\n    regex: Regex,\n    replacement: String\n): String\n```\n\n- 1)의 `replace`의 경우 자바의 replaceAll과 동일\n- 2)의 `replace`의 경우 첫 번째 인자의 타입의 Regex를 받기 때문에 1)과는 전혀 다른 메소드\n- 아래는 간단한 회문(Palindrome) 예제\n```kotlin\nfun isPal(string: String): Boolean {\n    val testString = string\n            .toLowerCase()\n            .replace(\"\"\"[\\W+]\"\"\".toRegex(), \"\")\n    return testString == testString.reversed()\n}\n\nfun String.isPalindrome() = this.toLowerCase()\n        .replace(\"\"\"[\\W+]\"\"\".toRegex(), \"\")\n        .let { it == it.reversed() }\n```\n\n#### 레시피 11.5 - 바이너리 문자열로 변환하고 되돌리기\n- 숫자를 바이너리 문자열로, 바이너리 문자열을 다시 숫자로 파싱할때 `toString(radix = 2)`, `toInt(radix = 2)`와 같은 함수를 사용하면 쉽게 가능\n```kotlin\n    @Test\n    internal fun `paddedBinaryString`() {\n        val strings = (0..15)\n                .map { it.toString(radix = 2)\n                .padStart(4, '0') }\n        assertEquals(strings, listOf(\n                \"0000\", \"0001\", \"0010\", \"0011\", \"0100\", \"0101\", \"0110\", \"0111\", \"1000\", \"1001\", \"1010\", \"1011\", \"1100\", \"1101\", \"1110\", \"1111\"\n        ))\n\n        assertEquals(strings.map { it.toInt(2) }, listOf(\n                0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15\n        ))\n    }\n```\n\n#### 레시피 11.6 - 실행 가능한 클래스 만들기\n- 클래스에서 `invoke` 연산자를 오버로딩 한다.\n- 코틀린은 연산자 오버로딩을 기본으로 지원하고 있으며, 지원하는 [링크](https://kotlinlang.org/docs/reference/operator-overloading.html) 참고하면 된다.\n- 아래는 오픈 API를 호출하여 JSON 응답을 Gson을 통하여 역직렬화 하는 예제이며, 이에 대한 실행은 `invoke` 연산자를 통하여 실행한다.\n- 아래 코드를 보면 잘 알겠지만, 클래스를 인스턴스화하면 invoke 함수를 바로 호출하는 것이 가능하며, 필요하다면 메소드에 인자를 추가하는 것도 가능하다.\n\n```kotlin\ndata class AstroResult (\n    val message: String,\n    val number: Number,\n    val people: List<Assignment>\n)\n\ndata class Assignment(\n    val craft: String,\n    val name: String\n)\n\nclass AstroRequest {\n    private val gson = Gson()\n\n    operator fun invoke(): AstroResult = (\n        gson.fromJson(URL(\"http://api.open-notify.org/astros.json\")\n            .readText(), AstroResult::class.java)\n    )\n}\n\n@Test\ninternal fun `AstroRequest Test`() {\n    val result = AstroRequest()()\n    assertThat(result.message, `is`(\"success\"))\n    assertThat(result.number.toInt(), greaterThanOrEqualTo(0))\n    assertThat(result.people.size, `is`(result.number.toInt()))\n}\n```\n\n#### 레시피 11.7 - 경과 시간 측정하기\n- `measureTimeMills` 혹은 `measureNanoTime`를 사용한다.\n- 위 함수들은 람다를 인자로 받기 때문에 고차 함수이며 `inline`으로 선언 되어 있다. 실제 실행은 `System.currentTimeMillis` 메소드에게 위임한다.\n```kotlin\npublic inline fun measureTimeMillis(block: () -> Unit): Long {\n    val start = System.currentTimeMillis()\n    block()\n    return System.currentTimeMillis() - start\n}\n```\n\n```kotlin\nfun doubleIt(x: Int): Int {\n    Thread.sleep(100L)\n    println(\"doubling $x with on thread ${Thread.currentThread().name}\")\n    return x * 2;\n}\n\n\nfun exec() {\n    println(\"${Runtime.getRuntime().availableProcessors()} processors\")\n    var time = measureTimeMillis {\n        IntStream.rangeClosed(1, 6)\n                .map { doubleIt(it) }\n                .sum()\n    }\n    println(\"Sequential stream took ${time}ms\")\n\n    time = measureTimeMillis {\n        IntStream.rangeClosed(1, 6)\n                .parallel()\n                .map { doubleIt(it) }\n                .sum()\n    }\n    println(\"Parallel stream took ${time}ms\")\n}\n```\n\n- `IntStream`을 사용하여 sum을 구하는 예제이며, Parallel로 돌렸을때와 Sequential로 돌렸을 때의 경과 시간 측정을 위해 작성했다.\n\n\n#### 레시피 11.8 - 스레드 시작하기\n```kotlin\npublic fun thread(\n    start: Boolean = true,\n    isDaemon: Boolean = false,\n    contextClassLoader: ClassLoader? = null,\n    name: String? = null,\n    priority: Int = -1,\n    block: () -> Unit\n): Thread\n```\n\n- 코틀린은 스레드를 쉽게 생성하고 시작할 수 있도록 확장 함수를 제공함.\n- 잔여 스레드가 모두 데몬 스레드일 경우, 어플리케이션은 종료된다.\n\n```kotlin\nfun threadStart(isDaemon: Boolean = false, isJoin: Boolean = false) = (0..5).forEach {\n    val sleepTime = Random.nextLong(0..1000L)\n    val thread = thread(isDaemon = isDaemon) {\n        Thread.sleep(sleepTime)\n        println(\"${Thread.currentThread().name} for $it after $sleepTime\")\n    }\n    if (isJoin) thread.join()\n}\n```\n- 5개의 스레드를 생성하는 예제이며, 데몬스레드 유무에 따라 바로 종료될수도 아닐수도 있는 코드이다.\n- 순차 실행을 원한다면 `join()` 메소드를 사용\n\n#### 레시피 11.9 - TODO로 완성 강제하기\n- 함수 구현을 완성하지 않으면 예외를 던지는 TODO 함수를 사용하면 된다.\n```kotlin\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n```\n- 함수의 시그니처는 위와 같으며, `reason`에는 미구현에 대한 사유를 넣어주면 되고, 발생하는 예외는 `NotImplementedError`가 발생하며 해당 클래스의 상위 클래스와 인터페이스는 `Error - Throwable` 이다.\n\n\n#### 레시피 11.10 - Random의 무작위 동작 이해하기\n- 난수 생성은 자바와 같이 Random 클래스를 활용\n```kotlin\n@Test\nfun `nextInt with no args gives any int`() {\n    val value = Random.nextInt()\n    assertTrue(value in Int.MIN_VALUE..Int.MAX_VALUE)\n}\n\n@Test\nfun `nextInt with range gives value between 0 and limit`() {\n    val value = Random.nextInt(10)\n    assertTrue(value in 0..10)\n}\n\n@Test\nfun `nextInt with min and max gives value between them`() {\n    val value = Random.nextInt(5, 10)\n    assertTrue(value in 5..10)\n}\n\n@Test\nfun `nextInt with range returns value in range`() {\n    val value = Random.nextInt(7..12)\n    assertTrue(value in 7..12)\n}\n```\n- `nextInt()`의 구현 부분을 살펴보면, 동반 객체에서 추상 클래스에 선언된 모든 메서드를 defaultPlatformRandom에 위임하고 있으며, 해당 defaultPlatformRandom은 internal로 선언되어 있음을 확인할 수 있다. \n- [코틀린 문서](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.random/-random/-default/)를 확인해보면 `On JVM this generator is thread-safe, its methods can be invoked from multiple threads.` 난수 생성 시 스레드 세이프한 성격을 보장한다고 나와 있다.\n\n#### 레시피 11.11 - 함수 이름에 특수 문자 사용하기\n- 작명하기 아주 어려운 상황 혹은 테스트에서만 사용하는 것을 권한다.\n- 함수명을 백틱(``)으로 감싸 놓으면 특수 문자 등을 활용할 수 있다.\n```kotlin\nclass TestClass {\n    @Test\n    fun `nextInt with min and max gives value between them`() { ... }\n}\n```\n\n#### 레시피 11.12 - 자바에게 예외 알리기\n- 코틀린의 모든 예외는 기본적으로 Unchecked Exception이다. 코틀린 컴파일러가 예외를 강제하지 않으며 굳이 잡는다면 try catch finally로 잡는 방법도 있지만 강제 사항은 아니다.\n- 자바에서처럼 `throws`키워드를 사용하여 예외가 발생할 수 있음을 알릴 수 없기 때문에 자바에서 만약 코틀린 코드를 사용한다면 이를 알릴 수 있는 장치가 필요하게 된다. `@Throws` 어노테이션을 활용하면 이것이 가능하다.\n```kotlin\n@Throws(IOException::class)\nfun houstonWeHaveAProblem() {\n    throw IOException(\"File or resource not found\")\n}\n```\n- 위와 같이 어노테이션을 사용하게 되면, 자바 컴파일러는 IOException에 대비해야 하는 내용을 알게 된다.\n- 어노테이션을 명시하지 않고, 만약 자바코드에서 예외를 캐치하려고 한다면 컴파일이 실패하거나 불필요한 코드가 존재한다는 컴파일러 워닝을 만나게 될 것이다.\n- `@Throws` 어노테이션의 역할을 다시 정리하자면, 자바/코틀린의 통합을 위해 그리고 코틀린 코드에서 발생하는 예외를 자바 코드에서 대비하기 위해 존재하는 것이다.\n\n\n----\n## 12장\n#### 레시피 12.1 - 확장을 위해 스프링 관리 빈 클래스 오픈하기\n- 스프링에서는 빈으로 관리되는 클래스들 대부분이 프록시 기반으로 작동하게 된다.\n- 코틀린 클래스는 기본적으로 `final` 식별자를 달고 나오기 때문에 프록시를 동작이 안되게 된다. 이를 해결하기 위해서는 별도로 `kotlin-spring` 빌드 플러그인을 사용하여 스프링에서 관리하는 `@Component`, \n `@Service`으로 마킹된 클래스들이 확장 가능한 클래스 식별자인 `open`로 컴파일리 되도록 설정해줘야 한다.\n   * `all-open` 플러그인을 사용해도 되지만, 대부분 `kotlin-spring`플러그인이 커버한다.\n- 프록시는 실제 컴포넌트 메소드 호출을 가로채 호출 전후로 많은 일을 수행하게 된다. 인자에 대한 유효값 체크와 트랜잭션 등이 아주 대표적인 케이스이다. \n\n```kotlin\n@org.springframework.stereotype.Service \npublic open class UserService public constructor() {\n    public open fun join(): kotlin.Unit { /* compiled code */ }\n}\n```\n- 플러그인을 적용하여 코드를 컴파일 결과이다.\n- `@Component`, `@Async`, `@Transactional`, `@Cacheable`, `@SpringBootTest` 들이 open이 되는 마킹 어노테이션들이며 사실상 대부분을 커버한다고 보면 된다. `@Component`의 경우 이를 사용하는 하위 어노테이션중에 친숙한 `@Configuration`, `@Controller`, `@RestController`, `@Service`, `@Repository` 들이 있다.\n\n\n\n#### 레시피 12.2 - 코틀린 data 클래스로 퍼시스턴스 구현하기\n- JPA 관점에서 코틀린 `data class`는 두 가지 문제가 존재함\n  * `data class`는 기본 생성자를 만들지 않음.\n  * 불변 속성(`val`)을 강조하는 data class의 성격\n- 기본 생성자를 만드는 부분에 대한 해결책은 `no-arg` 플러그인을 사용하는 방법이 존재한다.\n  > no-arg 플러그인으로 만든 기본 생성자의 접근 제어자는 `public`이고, 실제 코드에서는 접근이 불가능하며 리플렉션을 통한 접근만 가능하다고 한다.\n```kotlin\nplugins {\n  id \"org.jetbrains.kotlin.plugin.noarg\" version \"1.4.10\"\n}\n\nnoArg {\n    annotation(\"com.my.Annotation\")\n}\n```\n- `no-arg` 플러그인을 활용하는 방법도 좋지만, 빌드 설정에 마킹 어노테이션등을 명시해야 하는 불편함이 존재한다. 이를 개선하여 사용할 수 있는 플러그인이 바로 `kotlin-jpa` 플러그인이다.\n  * `@Entity`\n  * `@Embeddable`\n  * `@MappedSuperClass`\n- `data class`는 기본적으로 `hashCode`, `equals`, `toString`을 자동생성한다. JPA의 엔티티로 자동생성한 값을 사용하게 될 경우 발생할 수 있는 문제와 아래와 같다.\n  * 양방향 엔티티 바인딩을 사용할 경우, 경우에 따라 순환 참조를 만나게 될 수 있다.\n  * 불변 프로퍼티 사용을 권하는 data class와 다르게 필드 값을 계속 변경해야 하기 때문에 var로 선언해두고 사용해야 하는 JPA의 성격이 매우 상이함.\n- 이러한 부분 때문에 차라리 class를 그대로 사용하는 것이 나을 수 있다. 하지만, class도 코틀린에서는 기본적으로 상속이 불가능한 형태인 final 키워드가 붙어져 있는 형태기 때문에, 프록시를 사용하는 JPA-하이버네이트의 상황상 이를 `open` 클래스로 바꿔줘야 하는 불편함이 생긴다.\n```kotlin\nplugins {\n    id 'org.springframework.boot' version '2.3.1.RELEASE'\n    id 'io.spring.dependency-management' version '1.0.9.RELEASE'\n    id 'org.jetbrains.kotlin.plugin.spring' version '1.3.72'\n    id 'org.jetbrains.kotlin.plugin.jpa' version '1.3.72'\n}\n\nallOpen {\n    annotation(\"javax.persistence.Entity\")\n    annotation(\"javax.persistence.MappedSuperclass\")\n    annotation(\"javax.persistence.Embeddable\")\n}\n```\n\n- 위와 같이, kotlin-jpa 플러그인을 선언하고 open을 할 마킹 어노테이션을 지정해주면 실제로 컴파일한 클래스는 아래와 같다.\n\n```kotlin\n// IntelliJ API Decompiler stub source generated from a class file\n// Implementation of methods is not available\n\npackage me.daniel.kotlin_in_action\n\n@javax.persistence.Entity \npublic open class User public constructor() {\n    public open var age: kotlin.Long? /* compiled code */\n\n    @field:javax.persistence.Id @field:javax.persistence.GeneratedValue public open var id: kotlin.Long? /* compiled code */\n\n    public open var name: kotlin.String /* compiled code */\n}\n```\n\n#### 레시피 12.3 - 의존성 주입하기\n- 스프링에서는 복잡한 의존성 주입 과정 그리고 빈과 빈의 연결을 컨테이너에서 처리해준다.\n- 코틀린에서는 필드 레벨 빈 의존성 주입을 할 경우 `lateinit var` 구조를 활용해야 한다. 생성자 기반의 주입도 가능하다.\n- 생성자 방식의 의존성 주입이 스프링에서 선호하는 의존성 주입 방식이긴 하나, 경우에 따라 필드 레벨의 주입이 필요한 경우도 있다. \n\n```kotlin\n// 1)\n@Service\nclass UserServiceByConstructorInjection(val contentService: ContentService)\n\n// 2)\n@Service\nclass UserServiceByConstructorInjectionWithFieldAutowired(@Autowired val contentService: ContentService)\n\n// 3)\n@Service\nclass UserServiceByConstructorInjectionWithAutowired @Autowired constructor(val contentService: ContentService)\n\n// 4)\n@Service\nclass UserServiceByFieldLevelInjection {\n    @Autowired private lateinit var contentService: ContentService\n}\n```\n- 위와 같이 다양한 형태로 의존성 주입을 받는 것이 가능하다. `@Autowired`를 굳이 안붙여서도 사용 가능한 1번의 형태가 가장 간편한 방법이고 스프링에서 추천하는 의존성 주입 방식이다.\n\n\n----\n## 13장 - 코루틴과 구조적 동시성\n#### 레시피 13.1 - 코루틴 빌더 선택하기\n- `GlobalScope`의 `async`와 `launch`는 사용하지 말자\n  - 취소되지 않으면 어플리케이션 전체 수명주기에 걸쳐 실행됨.\n\n- `runBlocking` 빌더\n    ```kotlin\n    public fun <T> runBlocking(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -> T): T    \n    ```\n    * 블록 내 모든 코루틴이 종료될 때까지 현재 스레드를 블록\n    * `suspend` 키워드가 붙은 함수가 아니기 때문에, 일반 함수에서도 호출 가능\n\n\n- `launch` 빌더\n    ```kotlin\n    public fun CoroutineScope.launch(\n        context: CoroutineContext = EmptyCoroutineContext,\n        start: CoroutineStart = CoroutineStart.DEFAULT,\n        block: suspend CoroutineScope.() -> Unit\n    ): Job\n    ```\n    * 해당값에서 리턴값을 받을 필요가 없을 때 사용\n    * `Job`을 리턴, 취소 가능\n    * 코루틴 컨텍스트(`context`)를 지정하여 다른 코루틴과 상태 공유가 가능\n    * `start` 인자의 열거형으로 `DEFAULT`, `LAZY`, `ATOMIC`, `UNDISPATCHED` 값을 사용할 수 있다.\n\n- `async` 빌더\n    ```kotlin\n    public fun <T> CoroutineScope.async(\n        context: CoroutineContext = EmptyCoroutineContext,\n        start: CoroutineStart = CoroutineStart.DEFAULT,\n        block: suspend CoroutineScope.() -> T\n    ): Deferred<T>    \n    ```\n    * 값을 리턴해야 할 경우 사용\n    * `launch` 빌더처럼 CoroutineContext와 CoroutineStart 파라미터를 받을 수 있으며, 기본값이 설정되어 있다.\n    ```kotlin\n    suspend fun add(x: Int, y: Int): Int {\n        delay(Random.nextLong(1000L))\n        return x + y\n    }\n\n    suspend fun main() = coroutineScope {\n        val firstSum = async {\n            println(Thread.currentThread().name)\n            add(2, 2)\n        }\n        val secondSum = async {\n            println(Thread.currentThread().name)\n            add(3, 4)\n        }\n        println(\"Awaiting concurrent sums...\")\n        val total = firstSum.await() + secondSum.await()\n        println(\"Total is $total\")\n\n    }    \n    ```\n    ```\n    DefaultDispatcher-worker-1\n    Awaiting concurrent sums...\n    DefaultDispatcher-worker-2\n    Total is 11\n    ```\n    - 위 예제의 실행 결과를 보면 `async` 빌더는 기본 디스패처를 사용하는 것을 확인할 수 있다.\n    - `delay` 함수는 코루틴 실행 스레드를 블록하지 않고 대기 상태로 만든다.\n\n- `coroutineScope` 빌더\n    ```kotlin\n    public suspend fun <R> coroutineScope(block: suspend CoroutineScope.() -> R): R {\n        contract {\n            callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n        }\n        return suspendCoroutineUninterceptedOrReturn { uCont ->\n            val coroutine = ScopeCoroutine(uCont.context, uCont)\n            coroutine.startUndispatchedOrReturn(coroutine, block)\n        }\n    }    \n    ```\n\n    * `coroutineScope` 빌더는 함수 종료 전 모든 코루틴이 완료될때까지 기다리는 일수 중단 함수이다. 굳이 코루틴의 완료 유무를 확인할 필요가 없다.\n    * 메인 스레드를 블록하지 않지만, 반드시 다른 일시 중단 함수의 일부로서 호출해야 된다.\n    * 코루틴이 하나라도 실패하면 나머지 코루틴을 취소하며, 완료 유무를 확인하지 않고 균형 있는 제어와 에러 처리를 달성하고 루틴이 실패하는 경우를 처리하지 않는 것을 방지한다.\n\n\n\n#### 레시피 13.2 - async/await를 withContext로 변경하기\n```kotlin\npublic suspend fun <T> withContext(\n    context: CoroutineContext,\n    block: suspend CoroutineScope.() -> T\n): T    \n```\n\n- `async` 코루틴을 시작하고 `await`로 기다리는 코드를 간소화하고 싶다면 `withContext`로 대체가 가능하다.\n- 공식 문서에서는 **주어진 코루틴 컨텍스트와 함께 명시한 일시정지 블록을 호출하고, 완료될 떄까지 일시정지한 후에 그 결과를 리턴한다.** 라고 나와 있다. 다시 말해, `async ~ await`의 호출 구조를 `withContext`로 단순화하는 것이 가능하다.\n\n```kotlin\nsuspend fun retrieve1(url: String) = coroutineScope {\n    async(Dispatchers.IO) {\n        println(\"Retrieving data on ${Thread.currentThread().name}\")\n        delay(100L)\n        \"asyncResults\"\n    }.await()\n}\n\nsuspend fun retrieve2(url: String) = withContext(Dispatchers.IO) {\n    println(\"Retrieving data on ${Thread.currentThread().name}\")\n    delay(100L)\n    \"asyncResults\"\n}\n\nfun main() = runBlocking<Unit> {\n    val result1 = retrieve1(\"www.mysite.com\")\n    val result2 = retrieve2(\"www.mysite.com\")\n    println(\"printing result on ${Thread.currentThread().name} $result1\")\n    println(\"printing result on ${Thread.currentThread().name} $result2\")\n}\n```\n\n```\nRetrieving data on DefaultDispatcher-worker-1\nRetrieving data on DefaultDispatcher-worker-1\nprinting result on main asyncResults\nprinting result on main asyncResults\n```\n\n\n- `retrieve1`과 같이 메소드를 작성하게 되면 Intellij에서 `merge call chain to 'withContext'`라는 문구와 함께 withContext로 대체 할 것을 제안하는 것을 확인할 수 있다.\n\n- 각 suspend 함수는 기본 디스패처에서 호출이 되며, 메인 스레드 메인 함수에서 `await` 호출 없이 결과를 받아 오는 것을 확인할 수 있다.\n\n\n#### 레시피 13.3 - 디스패처 사용하기\n- IO 혹은 다른 작업을 위한 전용 스레드풀을 이용할 때는 `Dispatchers` 클래스의 적당한 디스패처를 골라 사용하면 된다.\n- 코루틴은 `CorutineContext` 컨텍스트 내에서 실행되며 코루틴 컨텍스트에는 `CoroutineDispatcher` 클래스의 인스턴스가 포함되어 있다. \n- **디스패처의 역할은 코루틴이 어떤 스레드에서 혹은 어떤 스레드풀에서 실행할지를 결정한다.** 디스패처의 종류는 아래와 같다.\n  * IO:  File IO 혹은 Network IO와 같은 IO Intensive 작업을 위해 디자인된 디스패처이며, On-Demand 공유 풀을 사용한다.\n  * Default:  공유 백그라운드 스레드풀을 사용하며, CPU Bound 상황에 어울린다.\n  * Unconfined\n- 디스패처의 명시는 `async`, `launch`, `withContext`의 호출 인자에 넘겨서 지정하는 것이 가능하다.\n\n#### 레시피 13.4 - 자바 스레드 풀에서 코루틴 실행하기\n- 자바의 `ExecutorService`의 `asCoroutineDispatcher` 확장 함수 호출을 통해 코루틴의 스레드풀 생성이 가능하다. \n- `asCoroutineDispatcher` 함수는 `ExecutorService`의 인스턴스를 `ExecutorCoroutineDispatcher`의 구현으로 변환한다. \n\n```kotlin\npublic abstract class ExecutorCoroutineDispatcher: CoroutineDispatcher(), Closeable {\n    /** @suppress */\n    @ExperimentalStdlibApi\n    public companion object Key : AbstractCoroutineContextKey<CoroutineDispatcher, ExecutorCoroutineDispatcher>(\n        CoroutineDispatcher,\n        { it as? ExecutorCoroutineDispatcher })\n\n    public abstract val executor: Executor\n\n    public abstract override fun close()\n}\n```\n\n- `ExecutorCoroutineDispatcher`는 `close` 함수를 호출하지 않으면 계속 실행되기 때문에, 해당 함수 호출은 필수다. `ExecutorCoroutineDispatcher` 클래스는 추상 클래스로 구현 클래스인 `ThreadPoolDispatcher`의 `close` 메소드를 살펴보면 ExecutorService의 `shutdown` 메소드를 호출하는 것을 확인할 수 있다.\n- `Closeable` 인터페이스를 구현하여 `close` 혹은 `shutdown` 호출에 대한 부분은 해당 인터페이스 구현에 맡겼으며 코틀린에서는 `use` 블록을 사용하여 사용 후 쉽게 종료가 가능하다. \n> 자바와 같이 try~with~resource 구문이 없는 코틀린에서는 Closeable 인터페이스 use를 사용하여 자원 해제를 하게 된다. [링크](#10장) 참고\n\n\n#### 레시피 13.5 - 코루틴 취소하기\n```kotlin\nprivate fun jobCancelExec() {\n    runBlocking {\n        val job = launch {\n            repeat(100) {\n                println(\"Job: I'm waiting $it...\")\n                delay(100L)\n            }\n        }\n        delay(500L)\n        println(\"main: That's enough waiting\")\n        job.cancel()\n        job.join()\n        println(\"main: Done\")\n    }\n}\n```\n- `launch`, `async` 빌더 함수는 공통적으로 Job 타입을 리턴하게 되는데, 해당 타입의 cancel 메소드를 호출하면 해당 잡을 취소하는 것이 가능하다.\n\n```kotlin\nprivate fun jobTimeout() {\n    runBlocking {\n        withTimeout(1000L) {\n            repeat(50) {\n                println(\"Job: I'm waiting $it...\")\n                delay(100L)\n            }\n        }\n    }\n}\n```\n\n```kotlin\npublic suspend fun <T> withTimeout(timeMillis: Long, block: suspend CoroutineScope.() -> T): T\n```\n- `withTimeout` 혹은 `withTimeoutOrNull`과 같은 메소드를 호출하여 취소하는 것도 가능하며, 타임아웃이 초과하면 `TimeoutCancellationException`이 발생한다.\n```\nJob: I'm waiting 0...\nJob: I'm waiting 1...\n...(생략)\nException in thread \"main\" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1000 ms\n\tat kotlinx.coroutines.TimeoutKt.TimeoutCancellationException(Timeout.kt:158)\n\tat kotlinx.coroutines.TimeoutCoroutine.run(Timeout.kt:128)\n\tat kotlinx.coroutines.EventLoopImplBase$DelayedRunnableTask.run(EventLoop.common.kt:497)\n\tat kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:274)\n\tat kotlinx.coroutines.DefaultExecutor.run(DefaultExecutor.kt:68)\n\tat java.lang.Thread.run(Thread.java:745)\n```\n#### 레시피 13.6 - 코루틴 디버깅\n- JVM의 실행 플래그(`-Dkotlinx.coroutines.debug`)를 추가하면 코루틴 이름등과 같은 실행정보를 확인할 수 있다. Intelli에서는 VM Options에 해당 플래그 값을 추가하면 된다.\n\n```kotlin\nsuspend fun retrieve1(url: String) = coroutineScope {\n    async(Dispatchers.IO) {\n        println(\"Retrieving data on ${Thread.currentThread().name}\")\n        delay(100L)\n        \"asyncResults\"\n    }.await()\n}\n\nsuspend fun retrieve2(url: String) = withContext(Dispatchers.IO) {\n    println(\"Retrieving data on ${Thread.currentThread().name}\")\n    delay(100L)\n    \"asyncResults\"\n}\n\nfun main() = runBlocking {\n    val result1 = retrieve1(\"www.mysite.com\")\n    val result2 = retrieve2(\"www.mysite.com\")\n    println(\"printing result on ${Thread.currentThread().name} $result1\")\n    println(\"printing result on ${Thread.currentThread().name} $result2\")\n}\n```\n\n```\nRetrieving data on DefaultDispatcher-worker-1 @coroutine#2\nRetrieving data on DefaultDispatcher-worker-1 @coroutine#1\nprinting result on main @coroutine#1 asyncResults\nprinting result on main @coroutine#1 asyncResults\n```\n- 스레드 이름 뒤에 `@coroutine#2`가 붙은 것을 확인할 수 있는데, `CoroutineName` 클래스를 사용하여 직접 이름을 붙이는 것도 가능하다. 위 코드에서 `retrieve1`, `retrieve2`의 컨텍스트를 인자 부분을 아래와 같이 수정하면 된다.\n```kotlin\nsuspend fun retrieve1(url: String) = coroutineScope {\n    async(Dispatchers.IO + CoroutineName(name = \"async\")) {\n        println(\"Retrieving data on ${Thread.currentThread().name}\")\n        delay(100L)\n        \"asyncResults\"\n    }.await()\n}\n\nsuspend fun retrieve2(url: String) = withContext(Dispatchers.IO + CoroutineName(name = \"withContext\")) {\n    println(\"Retrieving data on ${Thread.currentThread().name}\")\n    delay(100L)\n    \"asyncResults\"\n}\n```\n\n```\n// coroutine이라는 이름 대신 지정한 이름을 노출\nRetrieving data on DefaultDispatcher-worker-1 @async#2\nRetrieving data on DefaultDispatcher-worker-1 @withContext#1\nprinting result on main @coroutine#1 asyncResults\nprinting result on main @coroutine#1 asyncResults\n```\n","source":"_posts/Kotlin/Kotlin_CookBook.md","raw":"---\ntitle: 'Kotlin Cookbook'\ndate: 2021/3/3 00:00:00\ncategories:\n- Kotlin\n---\n\n# Kotlin Cookbook\n\n## 10장\n#### 레시피 10.1 - use로 리소스 관리하기\n- 코틀린에서는 자바의 `try-with-resources` 구조를 지원하지 않음\n- 대신, `Closeable` 인터페이스의 확장함수 `use`를 제공하며, `Reader`와 `File`에는 `useLine` 확장함수를 추가\n- `useLine`의 경우, `BufferedReader.use`에게 처리를 위임하며, 해당 확장함수는 `try-catch-finally`로 예외처리를 하는 전형적인 구조를 확장함수로 만들어놓았음\n\n```kotlin\n@InlineOnly\n@RequireKotlin(\"1.2\", versionKind = RequireKotlinVersionKind.COMPILER_VERSION, message = \"Requires newer compiler version to be inlined correctly.\")\npublic inline fun <T : Closeable?, R> T.use(block: (T) -> R): R {\n    var exception: Throwable? = null\n    try {\n        return block(this)\n    } catch (e: Throwable) {\n        exception = e\n    throw e\n    } finally {\n        when {\n            apiVersionIsAtLeast(1, 1, 0) -> this.closeFinally(exception)\n            this == null -> {}\n            exception == null -> close()\n            else ->\n                try {\n                    close()\n                } catch (closeException: Throwable) {\n                    // cause.addSuppressed(closeException) // ignored here\n                }\n        }\n    }\n}\n```\n\n```kotlin\nfun get10LongestWordsInDictionary() = File(\"/usr/share/dict/words\").useLines { line ->\n    // line type Kotlin Sequence\n    line.filter { it.length > 20 }\n        .sortedByDescending { it.length }\n        .take(10)\n        .toList()\n}\n```\n\n#### 레시피 10.2 - 파일에 기록하기\n- 본문 전체를 다시 쓰고 싶다면 `writeText`, 붙여쓰고 싶다면 `appendText`\n- 위 확장함수도 역시, `FileOutputStream(this).use { it.write(array) }` 확장함수에게 처리를 위임\n```kotlin\nval file = File(\"./myfile.txt\")\nfile.writeText(\"Data\")\nfile.appendText(\"\\nHello\")\nfile.appendText(\"\\nWorld\")\n```\n\n----\n## 11장\n#### 레시피 11.1 - 코틀린 버전 알아내기\n- `KotlinVersion.CURRENT`을 참조하면 시멘틱버져닝 형태의 코틀린 버젼 값을 알아낼 수 있음.\n- `KotlinVersion`의 구현을 살펴보면 쉽게 알 수 있지만, Comparable 인터페이스를 구현하고 있으므로 비교가 가능\n```kotlin\nprintln(\"version = ${KotlinVersion.CURRENT}\")\nprintln(\"${KotlinVersion.CURRENT < KotlinVersion(major = 1, minor = 2)}\")\nprintln(\"${KotlinVersion.CURRENT < KotlinVersion(major = 1, minor = 2, patch = 41)}\")\n```\n\n#### 레시피 11.2 - 반복적으로 람다 실행하기\n- `repeat` 확장함수를 사용하면, 인자로 넘어가는 람다 구문이 지정한 횟수만큼 실행됨.\n- `contract`: 컴파일러에게 함수의 호출횟수와 타입캐스팅을 도와주기위해 도입\n- `@InlineOnly`: 자바 상호 운용을 할때, 자바쪽에서 해당 구현을 참조하지 못하도록 마킹 역할 수행\n\n```kotlin\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n```\n\n#### 레시피 11.3 - 완벽한 When 강제하기\n- 코틀린에서의 `When`절은 문과 식의 역할을 모두 할 수 있다.\n- 식으로 사용하는 경우, `else`까지 붙여 완벽한 형태로 사용해야 함.\n- 문으로 사용할 경우, 완벽하게 else까지 붙여서 사용할 수 있도록 강제도 할 수 있음. `exhaustive` 확장 속성을 추가하면 가능하다.\n  * *TODO: Kotlin 1.3.72 환경에서 구문 에러가 발생.*\n```kotlin\nfun printMod3(n: Int) {\n    when (n % 3) {\n        1 -> println(\"$n % 3 = 0\")\n        2 -> println(\"$n % 3 = 1\")\n        3 -> println(\"$n % 3 = 2\")\n    }\n}\n\nfun printMod3SingleStatement(n: Int) = when (n % 3) {\n    1 -> println(\"$n % 3 = 0\")\n    2 -> println(\"$n % 3 = 1\")\n    3 -> println(\"$n % 3 = 2\")\n    else -> println(\"problems\")\n}\n```\n\n\n#### 레시피 11.4 - 정규표현식과 함께 replace 함수 사용하기\n- 문자열 중 부분 문자열을 수정하고 싶을 경우 `replace`함수를 사용.\n```kotlin\n// 1)\nfun String.replace(\n    oldValue: String,\n    newValue: String,\n    ignroeCase: Boolean = false\n): String\n\n\n// 2)\nfun CharSequence.replace(\n    regex: Regex,\n    replacement: String\n): String\n```\n\n- 1)의 `replace`의 경우 자바의 replaceAll과 동일\n- 2)의 `replace`의 경우 첫 번째 인자의 타입의 Regex를 받기 때문에 1)과는 전혀 다른 메소드\n- 아래는 간단한 회문(Palindrome) 예제\n```kotlin\nfun isPal(string: String): Boolean {\n    val testString = string\n            .toLowerCase()\n            .replace(\"\"\"[\\W+]\"\"\".toRegex(), \"\")\n    return testString == testString.reversed()\n}\n\nfun String.isPalindrome() = this.toLowerCase()\n        .replace(\"\"\"[\\W+]\"\"\".toRegex(), \"\")\n        .let { it == it.reversed() }\n```\n\n#### 레시피 11.5 - 바이너리 문자열로 변환하고 되돌리기\n- 숫자를 바이너리 문자열로, 바이너리 문자열을 다시 숫자로 파싱할때 `toString(radix = 2)`, `toInt(radix = 2)`와 같은 함수를 사용하면 쉽게 가능\n```kotlin\n    @Test\n    internal fun `paddedBinaryString`() {\n        val strings = (0..15)\n                .map { it.toString(radix = 2)\n                .padStart(4, '0') }\n        assertEquals(strings, listOf(\n                \"0000\", \"0001\", \"0010\", \"0011\", \"0100\", \"0101\", \"0110\", \"0111\", \"1000\", \"1001\", \"1010\", \"1011\", \"1100\", \"1101\", \"1110\", \"1111\"\n        ))\n\n        assertEquals(strings.map { it.toInt(2) }, listOf(\n                0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15\n        ))\n    }\n```\n\n#### 레시피 11.6 - 실행 가능한 클래스 만들기\n- 클래스에서 `invoke` 연산자를 오버로딩 한다.\n- 코틀린은 연산자 오버로딩을 기본으로 지원하고 있으며, 지원하는 [링크](https://kotlinlang.org/docs/reference/operator-overloading.html) 참고하면 된다.\n- 아래는 오픈 API를 호출하여 JSON 응답을 Gson을 통하여 역직렬화 하는 예제이며, 이에 대한 실행은 `invoke` 연산자를 통하여 실행한다.\n- 아래 코드를 보면 잘 알겠지만, 클래스를 인스턴스화하면 invoke 함수를 바로 호출하는 것이 가능하며, 필요하다면 메소드에 인자를 추가하는 것도 가능하다.\n\n```kotlin\ndata class AstroResult (\n    val message: String,\n    val number: Number,\n    val people: List<Assignment>\n)\n\ndata class Assignment(\n    val craft: String,\n    val name: String\n)\n\nclass AstroRequest {\n    private val gson = Gson()\n\n    operator fun invoke(): AstroResult = (\n        gson.fromJson(URL(\"http://api.open-notify.org/astros.json\")\n            .readText(), AstroResult::class.java)\n    )\n}\n\n@Test\ninternal fun `AstroRequest Test`() {\n    val result = AstroRequest()()\n    assertThat(result.message, `is`(\"success\"))\n    assertThat(result.number.toInt(), greaterThanOrEqualTo(0))\n    assertThat(result.people.size, `is`(result.number.toInt()))\n}\n```\n\n#### 레시피 11.7 - 경과 시간 측정하기\n- `measureTimeMills` 혹은 `measureNanoTime`를 사용한다.\n- 위 함수들은 람다를 인자로 받기 때문에 고차 함수이며 `inline`으로 선언 되어 있다. 실제 실행은 `System.currentTimeMillis` 메소드에게 위임한다.\n```kotlin\npublic inline fun measureTimeMillis(block: () -> Unit): Long {\n    val start = System.currentTimeMillis()\n    block()\n    return System.currentTimeMillis() - start\n}\n```\n\n```kotlin\nfun doubleIt(x: Int): Int {\n    Thread.sleep(100L)\n    println(\"doubling $x with on thread ${Thread.currentThread().name}\")\n    return x * 2;\n}\n\n\nfun exec() {\n    println(\"${Runtime.getRuntime().availableProcessors()} processors\")\n    var time = measureTimeMillis {\n        IntStream.rangeClosed(1, 6)\n                .map { doubleIt(it) }\n                .sum()\n    }\n    println(\"Sequential stream took ${time}ms\")\n\n    time = measureTimeMillis {\n        IntStream.rangeClosed(1, 6)\n                .parallel()\n                .map { doubleIt(it) }\n                .sum()\n    }\n    println(\"Parallel stream took ${time}ms\")\n}\n```\n\n- `IntStream`을 사용하여 sum을 구하는 예제이며, Parallel로 돌렸을때와 Sequential로 돌렸을 때의 경과 시간 측정을 위해 작성했다.\n\n\n#### 레시피 11.8 - 스레드 시작하기\n```kotlin\npublic fun thread(\n    start: Boolean = true,\n    isDaemon: Boolean = false,\n    contextClassLoader: ClassLoader? = null,\n    name: String? = null,\n    priority: Int = -1,\n    block: () -> Unit\n): Thread\n```\n\n- 코틀린은 스레드를 쉽게 생성하고 시작할 수 있도록 확장 함수를 제공함.\n- 잔여 스레드가 모두 데몬 스레드일 경우, 어플리케이션은 종료된다.\n\n```kotlin\nfun threadStart(isDaemon: Boolean = false, isJoin: Boolean = false) = (0..5).forEach {\n    val sleepTime = Random.nextLong(0..1000L)\n    val thread = thread(isDaemon = isDaemon) {\n        Thread.sleep(sleepTime)\n        println(\"${Thread.currentThread().name} for $it after $sleepTime\")\n    }\n    if (isJoin) thread.join()\n}\n```\n- 5개의 스레드를 생성하는 예제이며, 데몬스레드 유무에 따라 바로 종료될수도 아닐수도 있는 코드이다.\n- 순차 실행을 원한다면 `join()` 메소드를 사용\n\n#### 레시피 11.9 - TODO로 완성 강제하기\n- 함수 구현을 완성하지 않으면 예외를 던지는 TODO 함수를 사용하면 된다.\n```kotlin\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n```\n- 함수의 시그니처는 위와 같으며, `reason`에는 미구현에 대한 사유를 넣어주면 되고, 발생하는 예외는 `NotImplementedError`가 발생하며 해당 클래스의 상위 클래스와 인터페이스는 `Error - Throwable` 이다.\n\n\n#### 레시피 11.10 - Random의 무작위 동작 이해하기\n- 난수 생성은 자바와 같이 Random 클래스를 활용\n```kotlin\n@Test\nfun `nextInt with no args gives any int`() {\n    val value = Random.nextInt()\n    assertTrue(value in Int.MIN_VALUE..Int.MAX_VALUE)\n}\n\n@Test\nfun `nextInt with range gives value between 0 and limit`() {\n    val value = Random.nextInt(10)\n    assertTrue(value in 0..10)\n}\n\n@Test\nfun `nextInt with min and max gives value between them`() {\n    val value = Random.nextInt(5, 10)\n    assertTrue(value in 5..10)\n}\n\n@Test\nfun `nextInt with range returns value in range`() {\n    val value = Random.nextInt(7..12)\n    assertTrue(value in 7..12)\n}\n```\n- `nextInt()`의 구현 부분을 살펴보면, 동반 객체에서 추상 클래스에 선언된 모든 메서드를 defaultPlatformRandom에 위임하고 있으며, 해당 defaultPlatformRandom은 internal로 선언되어 있음을 확인할 수 있다. \n- [코틀린 문서](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.random/-random/-default/)를 확인해보면 `On JVM this generator is thread-safe, its methods can be invoked from multiple threads.` 난수 생성 시 스레드 세이프한 성격을 보장한다고 나와 있다.\n\n#### 레시피 11.11 - 함수 이름에 특수 문자 사용하기\n- 작명하기 아주 어려운 상황 혹은 테스트에서만 사용하는 것을 권한다.\n- 함수명을 백틱(``)으로 감싸 놓으면 특수 문자 등을 활용할 수 있다.\n```kotlin\nclass TestClass {\n    @Test\n    fun `nextInt with min and max gives value between them`() { ... }\n}\n```\n\n#### 레시피 11.12 - 자바에게 예외 알리기\n- 코틀린의 모든 예외는 기본적으로 Unchecked Exception이다. 코틀린 컴파일러가 예외를 강제하지 않으며 굳이 잡는다면 try catch finally로 잡는 방법도 있지만 강제 사항은 아니다.\n- 자바에서처럼 `throws`키워드를 사용하여 예외가 발생할 수 있음을 알릴 수 없기 때문에 자바에서 만약 코틀린 코드를 사용한다면 이를 알릴 수 있는 장치가 필요하게 된다. `@Throws` 어노테이션을 활용하면 이것이 가능하다.\n```kotlin\n@Throws(IOException::class)\nfun houstonWeHaveAProblem() {\n    throw IOException(\"File or resource not found\")\n}\n```\n- 위와 같이 어노테이션을 사용하게 되면, 자바 컴파일러는 IOException에 대비해야 하는 내용을 알게 된다.\n- 어노테이션을 명시하지 않고, 만약 자바코드에서 예외를 캐치하려고 한다면 컴파일이 실패하거나 불필요한 코드가 존재한다는 컴파일러 워닝을 만나게 될 것이다.\n- `@Throws` 어노테이션의 역할을 다시 정리하자면, 자바/코틀린의 통합을 위해 그리고 코틀린 코드에서 발생하는 예외를 자바 코드에서 대비하기 위해 존재하는 것이다.\n\n\n----\n## 12장\n#### 레시피 12.1 - 확장을 위해 스프링 관리 빈 클래스 오픈하기\n- 스프링에서는 빈으로 관리되는 클래스들 대부분이 프록시 기반으로 작동하게 된다.\n- 코틀린 클래스는 기본적으로 `final` 식별자를 달고 나오기 때문에 프록시를 동작이 안되게 된다. 이를 해결하기 위해서는 별도로 `kotlin-spring` 빌드 플러그인을 사용하여 스프링에서 관리하는 `@Component`, \n `@Service`으로 마킹된 클래스들이 확장 가능한 클래스 식별자인 `open`로 컴파일리 되도록 설정해줘야 한다.\n   * `all-open` 플러그인을 사용해도 되지만, 대부분 `kotlin-spring`플러그인이 커버한다.\n- 프록시는 실제 컴포넌트 메소드 호출을 가로채 호출 전후로 많은 일을 수행하게 된다. 인자에 대한 유효값 체크와 트랜잭션 등이 아주 대표적인 케이스이다. \n\n```kotlin\n@org.springframework.stereotype.Service \npublic open class UserService public constructor() {\n    public open fun join(): kotlin.Unit { /* compiled code */ }\n}\n```\n- 플러그인을 적용하여 코드를 컴파일 결과이다.\n- `@Component`, `@Async`, `@Transactional`, `@Cacheable`, `@SpringBootTest` 들이 open이 되는 마킹 어노테이션들이며 사실상 대부분을 커버한다고 보면 된다. `@Component`의 경우 이를 사용하는 하위 어노테이션중에 친숙한 `@Configuration`, `@Controller`, `@RestController`, `@Service`, `@Repository` 들이 있다.\n\n\n\n#### 레시피 12.2 - 코틀린 data 클래스로 퍼시스턴스 구현하기\n- JPA 관점에서 코틀린 `data class`는 두 가지 문제가 존재함\n  * `data class`는 기본 생성자를 만들지 않음.\n  * 불변 속성(`val`)을 강조하는 data class의 성격\n- 기본 생성자를 만드는 부분에 대한 해결책은 `no-arg` 플러그인을 사용하는 방법이 존재한다.\n  > no-arg 플러그인으로 만든 기본 생성자의 접근 제어자는 `public`이고, 실제 코드에서는 접근이 불가능하며 리플렉션을 통한 접근만 가능하다고 한다.\n```kotlin\nplugins {\n  id \"org.jetbrains.kotlin.plugin.noarg\" version \"1.4.10\"\n}\n\nnoArg {\n    annotation(\"com.my.Annotation\")\n}\n```\n- `no-arg` 플러그인을 활용하는 방법도 좋지만, 빌드 설정에 마킹 어노테이션등을 명시해야 하는 불편함이 존재한다. 이를 개선하여 사용할 수 있는 플러그인이 바로 `kotlin-jpa` 플러그인이다.\n  * `@Entity`\n  * `@Embeddable`\n  * `@MappedSuperClass`\n- `data class`는 기본적으로 `hashCode`, `equals`, `toString`을 자동생성한다. JPA의 엔티티로 자동생성한 값을 사용하게 될 경우 발생할 수 있는 문제와 아래와 같다.\n  * 양방향 엔티티 바인딩을 사용할 경우, 경우에 따라 순환 참조를 만나게 될 수 있다.\n  * 불변 프로퍼티 사용을 권하는 data class와 다르게 필드 값을 계속 변경해야 하기 때문에 var로 선언해두고 사용해야 하는 JPA의 성격이 매우 상이함.\n- 이러한 부분 때문에 차라리 class를 그대로 사용하는 것이 나을 수 있다. 하지만, class도 코틀린에서는 기본적으로 상속이 불가능한 형태인 final 키워드가 붙어져 있는 형태기 때문에, 프록시를 사용하는 JPA-하이버네이트의 상황상 이를 `open` 클래스로 바꿔줘야 하는 불편함이 생긴다.\n```kotlin\nplugins {\n    id 'org.springframework.boot' version '2.3.1.RELEASE'\n    id 'io.spring.dependency-management' version '1.0.9.RELEASE'\n    id 'org.jetbrains.kotlin.plugin.spring' version '1.3.72'\n    id 'org.jetbrains.kotlin.plugin.jpa' version '1.3.72'\n}\n\nallOpen {\n    annotation(\"javax.persistence.Entity\")\n    annotation(\"javax.persistence.MappedSuperclass\")\n    annotation(\"javax.persistence.Embeddable\")\n}\n```\n\n- 위와 같이, kotlin-jpa 플러그인을 선언하고 open을 할 마킹 어노테이션을 지정해주면 실제로 컴파일한 클래스는 아래와 같다.\n\n```kotlin\n// IntelliJ API Decompiler stub source generated from a class file\n// Implementation of methods is not available\n\npackage me.daniel.kotlin_in_action\n\n@javax.persistence.Entity \npublic open class User public constructor() {\n    public open var age: kotlin.Long? /* compiled code */\n\n    @field:javax.persistence.Id @field:javax.persistence.GeneratedValue public open var id: kotlin.Long? /* compiled code */\n\n    public open var name: kotlin.String /* compiled code */\n}\n```\n\n#### 레시피 12.3 - 의존성 주입하기\n- 스프링에서는 복잡한 의존성 주입 과정 그리고 빈과 빈의 연결을 컨테이너에서 처리해준다.\n- 코틀린에서는 필드 레벨 빈 의존성 주입을 할 경우 `lateinit var` 구조를 활용해야 한다. 생성자 기반의 주입도 가능하다.\n- 생성자 방식의 의존성 주입이 스프링에서 선호하는 의존성 주입 방식이긴 하나, 경우에 따라 필드 레벨의 주입이 필요한 경우도 있다. \n\n```kotlin\n// 1)\n@Service\nclass UserServiceByConstructorInjection(val contentService: ContentService)\n\n// 2)\n@Service\nclass UserServiceByConstructorInjectionWithFieldAutowired(@Autowired val contentService: ContentService)\n\n// 3)\n@Service\nclass UserServiceByConstructorInjectionWithAutowired @Autowired constructor(val contentService: ContentService)\n\n// 4)\n@Service\nclass UserServiceByFieldLevelInjection {\n    @Autowired private lateinit var contentService: ContentService\n}\n```\n- 위와 같이 다양한 형태로 의존성 주입을 받는 것이 가능하다. `@Autowired`를 굳이 안붙여서도 사용 가능한 1번의 형태가 가장 간편한 방법이고 스프링에서 추천하는 의존성 주입 방식이다.\n\n\n----\n## 13장 - 코루틴과 구조적 동시성\n#### 레시피 13.1 - 코루틴 빌더 선택하기\n- `GlobalScope`의 `async`와 `launch`는 사용하지 말자\n  - 취소되지 않으면 어플리케이션 전체 수명주기에 걸쳐 실행됨.\n\n- `runBlocking` 빌더\n    ```kotlin\n    public fun <T> runBlocking(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -> T): T    \n    ```\n    * 블록 내 모든 코루틴이 종료될 때까지 현재 스레드를 블록\n    * `suspend` 키워드가 붙은 함수가 아니기 때문에, 일반 함수에서도 호출 가능\n\n\n- `launch` 빌더\n    ```kotlin\n    public fun CoroutineScope.launch(\n        context: CoroutineContext = EmptyCoroutineContext,\n        start: CoroutineStart = CoroutineStart.DEFAULT,\n        block: suspend CoroutineScope.() -> Unit\n    ): Job\n    ```\n    * 해당값에서 리턴값을 받을 필요가 없을 때 사용\n    * `Job`을 리턴, 취소 가능\n    * 코루틴 컨텍스트(`context`)를 지정하여 다른 코루틴과 상태 공유가 가능\n    * `start` 인자의 열거형으로 `DEFAULT`, `LAZY`, `ATOMIC`, `UNDISPATCHED` 값을 사용할 수 있다.\n\n- `async` 빌더\n    ```kotlin\n    public fun <T> CoroutineScope.async(\n        context: CoroutineContext = EmptyCoroutineContext,\n        start: CoroutineStart = CoroutineStart.DEFAULT,\n        block: suspend CoroutineScope.() -> T\n    ): Deferred<T>    \n    ```\n    * 값을 리턴해야 할 경우 사용\n    * `launch` 빌더처럼 CoroutineContext와 CoroutineStart 파라미터를 받을 수 있으며, 기본값이 설정되어 있다.\n    ```kotlin\n    suspend fun add(x: Int, y: Int): Int {\n        delay(Random.nextLong(1000L))\n        return x + y\n    }\n\n    suspend fun main() = coroutineScope {\n        val firstSum = async {\n            println(Thread.currentThread().name)\n            add(2, 2)\n        }\n        val secondSum = async {\n            println(Thread.currentThread().name)\n            add(3, 4)\n        }\n        println(\"Awaiting concurrent sums...\")\n        val total = firstSum.await() + secondSum.await()\n        println(\"Total is $total\")\n\n    }    \n    ```\n    ```\n    DefaultDispatcher-worker-1\n    Awaiting concurrent sums...\n    DefaultDispatcher-worker-2\n    Total is 11\n    ```\n    - 위 예제의 실행 결과를 보면 `async` 빌더는 기본 디스패처를 사용하는 것을 확인할 수 있다.\n    - `delay` 함수는 코루틴 실행 스레드를 블록하지 않고 대기 상태로 만든다.\n\n- `coroutineScope` 빌더\n    ```kotlin\n    public suspend fun <R> coroutineScope(block: suspend CoroutineScope.() -> R): R {\n        contract {\n            callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n        }\n        return suspendCoroutineUninterceptedOrReturn { uCont ->\n            val coroutine = ScopeCoroutine(uCont.context, uCont)\n            coroutine.startUndispatchedOrReturn(coroutine, block)\n        }\n    }    \n    ```\n\n    * `coroutineScope` 빌더는 함수 종료 전 모든 코루틴이 완료될때까지 기다리는 일수 중단 함수이다. 굳이 코루틴의 완료 유무를 확인할 필요가 없다.\n    * 메인 스레드를 블록하지 않지만, 반드시 다른 일시 중단 함수의 일부로서 호출해야 된다.\n    * 코루틴이 하나라도 실패하면 나머지 코루틴을 취소하며, 완료 유무를 확인하지 않고 균형 있는 제어와 에러 처리를 달성하고 루틴이 실패하는 경우를 처리하지 않는 것을 방지한다.\n\n\n\n#### 레시피 13.2 - async/await를 withContext로 변경하기\n```kotlin\npublic suspend fun <T> withContext(\n    context: CoroutineContext,\n    block: suspend CoroutineScope.() -> T\n): T    \n```\n\n- `async` 코루틴을 시작하고 `await`로 기다리는 코드를 간소화하고 싶다면 `withContext`로 대체가 가능하다.\n- 공식 문서에서는 **주어진 코루틴 컨텍스트와 함께 명시한 일시정지 블록을 호출하고, 완료될 떄까지 일시정지한 후에 그 결과를 리턴한다.** 라고 나와 있다. 다시 말해, `async ~ await`의 호출 구조를 `withContext`로 단순화하는 것이 가능하다.\n\n```kotlin\nsuspend fun retrieve1(url: String) = coroutineScope {\n    async(Dispatchers.IO) {\n        println(\"Retrieving data on ${Thread.currentThread().name}\")\n        delay(100L)\n        \"asyncResults\"\n    }.await()\n}\n\nsuspend fun retrieve2(url: String) = withContext(Dispatchers.IO) {\n    println(\"Retrieving data on ${Thread.currentThread().name}\")\n    delay(100L)\n    \"asyncResults\"\n}\n\nfun main() = runBlocking<Unit> {\n    val result1 = retrieve1(\"www.mysite.com\")\n    val result2 = retrieve2(\"www.mysite.com\")\n    println(\"printing result on ${Thread.currentThread().name} $result1\")\n    println(\"printing result on ${Thread.currentThread().name} $result2\")\n}\n```\n\n```\nRetrieving data on DefaultDispatcher-worker-1\nRetrieving data on DefaultDispatcher-worker-1\nprinting result on main asyncResults\nprinting result on main asyncResults\n```\n\n\n- `retrieve1`과 같이 메소드를 작성하게 되면 Intellij에서 `merge call chain to 'withContext'`라는 문구와 함께 withContext로 대체 할 것을 제안하는 것을 확인할 수 있다.\n\n- 각 suspend 함수는 기본 디스패처에서 호출이 되며, 메인 스레드 메인 함수에서 `await` 호출 없이 결과를 받아 오는 것을 확인할 수 있다.\n\n\n#### 레시피 13.3 - 디스패처 사용하기\n- IO 혹은 다른 작업을 위한 전용 스레드풀을 이용할 때는 `Dispatchers` 클래스의 적당한 디스패처를 골라 사용하면 된다.\n- 코루틴은 `CorutineContext` 컨텍스트 내에서 실행되며 코루틴 컨텍스트에는 `CoroutineDispatcher` 클래스의 인스턴스가 포함되어 있다. \n- **디스패처의 역할은 코루틴이 어떤 스레드에서 혹은 어떤 스레드풀에서 실행할지를 결정한다.** 디스패처의 종류는 아래와 같다.\n  * IO:  File IO 혹은 Network IO와 같은 IO Intensive 작업을 위해 디자인된 디스패처이며, On-Demand 공유 풀을 사용한다.\n  * Default:  공유 백그라운드 스레드풀을 사용하며, CPU Bound 상황에 어울린다.\n  * Unconfined\n- 디스패처의 명시는 `async`, `launch`, `withContext`의 호출 인자에 넘겨서 지정하는 것이 가능하다.\n\n#### 레시피 13.4 - 자바 스레드 풀에서 코루틴 실행하기\n- 자바의 `ExecutorService`의 `asCoroutineDispatcher` 확장 함수 호출을 통해 코루틴의 스레드풀 생성이 가능하다. \n- `asCoroutineDispatcher` 함수는 `ExecutorService`의 인스턴스를 `ExecutorCoroutineDispatcher`의 구현으로 변환한다. \n\n```kotlin\npublic abstract class ExecutorCoroutineDispatcher: CoroutineDispatcher(), Closeable {\n    /** @suppress */\n    @ExperimentalStdlibApi\n    public companion object Key : AbstractCoroutineContextKey<CoroutineDispatcher, ExecutorCoroutineDispatcher>(\n        CoroutineDispatcher,\n        { it as? ExecutorCoroutineDispatcher })\n\n    public abstract val executor: Executor\n\n    public abstract override fun close()\n}\n```\n\n- `ExecutorCoroutineDispatcher`는 `close` 함수를 호출하지 않으면 계속 실행되기 때문에, 해당 함수 호출은 필수다. `ExecutorCoroutineDispatcher` 클래스는 추상 클래스로 구현 클래스인 `ThreadPoolDispatcher`의 `close` 메소드를 살펴보면 ExecutorService의 `shutdown` 메소드를 호출하는 것을 확인할 수 있다.\n- `Closeable` 인터페이스를 구현하여 `close` 혹은 `shutdown` 호출에 대한 부분은 해당 인터페이스 구현에 맡겼으며 코틀린에서는 `use` 블록을 사용하여 사용 후 쉽게 종료가 가능하다. \n> 자바와 같이 try~with~resource 구문이 없는 코틀린에서는 Closeable 인터페이스 use를 사용하여 자원 해제를 하게 된다. [링크](#10장) 참고\n\n\n#### 레시피 13.5 - 코루틴 취소하기\n```kotlin\nprivate fun jobCancelExec() {\n    runBlocking {\n        val job = launch {\n            repeat(100) {\n                println(\"Job: I'm waiting $it...\")\n                delay(100L)\n            }\n        }\n        delay(500L)\n        println(\"main: That's enough waiting\")\n        job.cancel()\n        job.join()\n        println(\"main: Done\")\n    }\n}\n```\n- `launch`, `async` 빌더 함수는 공통적으로 Job 타입을 리턴하게 되는데, 해당 타입의 cancel 메소드를 호출하면 해당 잡을 취소하는 것이 가능하다.\n\n```kotlin\nprivate fun jobTimeout() {\n    runBlocking {\n        withTimeout(1000L) {\n            repeat(50) {\n                println(\"Job: I'm waiting $it...\")\n                delay(100L)\n            }\n        }\n    }\n}\n```\n\n```kotlin\npublic suspend fun <T> withTimeout(timeMillis: Long, block: suspend CoroutineScope.() -> T): T\n```\n- `withTimeout` 혹은 `withTimeoutOrNull`과 같은 메소드를 호출하여 취소하는 것도 가능하며, 타임아웃이 초과하면 `TimeoutCancellationException`이 발생한다.\n```\nJob: I'm waiting 0...\nJob: I'm waiting 1...\n...(생략)\nException in thread \"main\" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1000 ms\n\tat kotlinx.coroutines.TimeoutKt.TimeoutCancellationException(Timeout.kt:158)\n\tat kotlinx.coroutines.TimeoutCoroutine.run(Timeout.kt:128)\n\tat kotlinx.coroutines.EventLoopImplBase$DelayedRunnableTask.run(EventLoop.common.kt:497)\n\tat kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:274)\n\tat kotlinx.coroutines.DefaultExecutor.run(DefaultExecutor.kt:68)\n\tat java.lang.Thread.run(Thread.java:745)\n```\n#### 레시피 13.6 - 코루틴 디버깅\n- JVM의 실행 플래그(`-Dkotlinx.coroutines.debug`)를 추가하면 코루틴 이름등과 같은 실행정보를 확인할 수 있다. Intelli에서는 VM Options에 해당 플래그 값을 추가하면 된다.\n\n```kotlin\nsuspend fun retrieve1(url: String) = coroutineScope {\n    async(Dispatchers.IO) {\n        println(\"Retrieving data on ${Thread.currentThread().name}\")\n        delay(100L)\n        \"asyncResults\"\n    }.await()\n}\n\nsuspend fun retrieve2(url: String) = withContext(Dispatchers.IO) {\n    println(\"Retrieving data on ${Thread.currentThread().name}\")\n    delay(100L)\n    \"asyncResults\"\n}\n\nfun main() = runBlocking {\n    val result1 = retrieve1(\"www.mysite.com\")\n    val result2 = retrieve2(\"www.mysite.com\")\n    println(\"printing result on ${Thread.currentThread().name} $result1\")\n    println(\"printing result on ${Thread.currentThread().name} $result2\")\n}\n```\n\n```\nRetrieving data on DefaultDispatcher-worker-1 @coroutine#2\nRetrieving data on DefaultDispatcher-worker-1 @coroutine#1\nprinting result on main @coroutine#1 asyncResults\nprinting result on main @coroutine#1 asyncResults\n```\n- 스레드 이름 뒤에 `@coroutine#2`가 붙은 것을 확인할 수 있는데, `CoroutineName` 클래스를 사용하여 직접 이름을 붙이는 것도 가능하다. 위 코드에서 `retrieve1`, `retrieve2`의 컨텍스트를 인자 부분을 아래와 같이 수정하면 된다.\n```kotlin\nsuspend fun retrieve1(url: String) = coroutineScope {\n    async(Dispatchers.IO + CoroutineName(name = \"async\")) {\n        println(\"Retrieving data on ${Thread.currentThread().name}\")\n        delay(100L)\n        \"asyncResults\"\n    }.await()\n}\n\nsuspend fun retrieve2(url: String) = withContext(Dispatchers.IO + CoroutineName(name = \"withContext\")) {\n    println(\"Retrieving data on ${Thread.currentThread().name}\")\n    delay(100L)\n    \"asyncResults\"\n}\n```\n\n```\n// coroutine이라는 이름 대신 지정한 이름을 노출\nRetrieving data on DefaultDispatcher-worker-1 @async#2\nRetrieving data on DefaultDispatcher-worker-1 @withContext#1\nprinting result on main @coroutine#1 asyncResults\nprinting result on main @coroutine#1 asyncResults\n```\n","slug":"Kotlin/Kotlin_CookBook","published":1,"updated":"2021-08-02T12:25:36.175Z","_id":"ckrswtnm00008kxhv5jbe3ex7","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Kotlin-Cookbook\"><a href=\"#Kotlin-Cookbook\" class=\"headerlink\" title=\"Kotlin Cookbook\"></a>Kotlin Cookbook</h1><h2 id=\"10장\"><a href=\"#10장\" class=\"headerlink\" title=\"10장\"></a>10장</h2><h4 id=\"레시피-10-1-use로-리소스-관리하기\"><a href=\"#레시피-10-1-use로-리소스-관리하기\" class=\"headerlink\" title=\"레시피 10.1 - use로 리소스 관리하기\"></a>레시피 10.1 - use로 리소스 관리하기</h4><ul>\n<li>코틀린에서는 자바의 <code>try-with-resources</code> 구조를 지원하지 않음</li>\n<li>대신, <code>Closeable</code> 인터페이스의 확장함수 <code>use</code>를 제공하며, <code>Reader</code>와 <code>File</code>에는 <code>useLine</code> 확장함수를 추가</li>\n<li><code>useLine</code>의 경우, <code>BufferedReader.use</code>에게 처리를 위임하며, 해당 확장함수는 <code>try-catch-finally</code>로 예외처리를 하는 전형적인 구조를 확장함수로 만들어놓았음</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@InlineOnly</span></span><br><span class=\"line\"><span class=\"meta\">@RequireKotlin(<span class=\"meta-string\">&quot;1.2&quot;</span>, versionKind = RequireKotlinVersionKind.COMPILER_VERSION, message = <span class=\"meta-string\">&quot;Requires newer compiler version to be inlined correctly.&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T : Closeable?, R&gt;</span> T.<span class=\"title\">use</span><span class=\"params\">(block: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">R</span>)</span></span>: R &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> exception: Throwable? = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> block(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Throwable) &#123;</span><br><span class=\"line\">        exception = e</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">when</span> &#123;</span><br><span class=\"line\">            apiVersionIsAtLeast(<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>) -&gt; <span class=\"keyword\">this</span>.closeFinally(exception)</span><br><span class=\"line\">            <span class=\"keyword\">this</span> == <span class=\"literal\">null</span> -&gt; &#123;&#125;</span><br><span class=\"line\">            exception == <span class=\"literal\">null</span> -&gt; close()</span><br><span class=\"line\">            <span class=\"keyword\">else</span> -&gt;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    close()</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (closeException: Throwable) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// cause.addSuppressed(closeException) // ignored here</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get10LongestWordsInDictionary</span><span class=\"params\">()</span></span> = File(<span class=\"string\">&quot;/usr/share/dict/words&quot;</span>).useLines &#123; line -&gt;</span><br><span class=\"line\">    <span class=\"comment\">// line type Kotlin Sequence</span></span><br><span class=\"line\">    line.filter &#123; it.length &gt; <span class=\"number\">20</span> &#125;</span><br><span class=\"line\">        .sortedByDescending &#123; it.length &#125;</span><br><span class=\"line\">        .take(<span class=\"number\">10</span>)</span><br><span class=\"line\">        .toList()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"레시피-10-2-파일에-기록하기\"><a href=\"#레시피-10-2-파일에-기록하기\" class=\"headerlink\" title=\"레시피 10.2 - 파일에 기록하기\"></a>레시피 10.2 - 파일에 기록하기</h4><ul>\n<li>본문 전체를 다시 쓰고 싶다면 <code>writeText</code>, 붙여쓰고 싶다면 <code>appendText</code></li>\n<li>위 확장함수도 역시, <code>FileOutputStream(this).use &#123; it.write(array) &#125;</code> 확장함수에게 처리를 위임<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> file = File(<span class=\"string\">&quot;./myfile.txt&quot;</span>)</span><br><span class=\"line\">file.writeText(<span class=\"string\">&quot;Data&quot;</span>)</span><br><span class=\"line\">file.appendText(<span class=\"string\">&quot;\\nHello&quot;</span>)</span><br><span class=\"line\">file.appendText(<span class=\"string\">&quot;\\nWorld&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"11장\"><a href=\"#11장\" class=\"headerlink\" title=\"11장\"></a>11장</h2><h4 id=\"레시피-11-1-코틀린-버전-알아내기\"><a href=\"#레시피-11-1-코틀린-버전-알아내기\" class=\"headerlink\" title=\"레시피 11.1 - 코틀린 버전 알아내기\"></a>레시피 11.1 - 코틀린 버전 알아내기</h4><ul>\n<li><code>KotlinVersion.CURRENT</code>을 참조하면 시멘틱버져닝 형태의 코틀린 버젼 값을 알아낼 수 있음.</li>\n<li><code>KotlinVersion</code>의 구현을 살펴보면 쉽게 알 수 있지만, Comparable 인터페이스를 구현하고 있으므로 비교가 가능<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(<span class=\"string\">&quot;version = <span class=\"subst\">$&#123;KotlinVersion.CURRENT&#125;</span>&quot;</span>)</span><br><span class=\"line\">println(<span class=\"string\">&quot;<span class=\"subst\">$&#123;KotlinVersion.CURRENT &lt; KotlinVersion(major = <span class=\"number\">1</span>, minor = <span class=\"number\">2</span>)&#125;</span>&quot;</span>)</span><br><span class=\"line\">println(<span class=\"string\">&quot;<span class=\"subst\">$&#123;KotlinVersion.CURRENT &lt; KotlinVersion(major = <span class=\"number\">1</span>, minor = <span class=\"number\">2</span>, patch = <span class=\"number\">41</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"레시피-11-2-반복적으로-람다-실행하기\"><a href=\"#레시피-11-2-반복적으로-람다-실행하기\" class=\"headerlink\" title=\"레시피 11.2 - 반복적으로 람다 실행하기\"></a>레시피 11.2 - 반복적으로 람다 실행하기</h4><ul>\n<li><code>repeat</code> 확장함수를 사용하면, 인자로 넘어가는 람다 구문이 지정한 횟수만큼 실행됨.</li>\n<li><code>contract</code>: 컴파일러에게 함수의 호출횟수와 타입캐스팅을 도와주기위해 도입</li>\n<li><code>@InlineOnly</code>: 자바 상호 운용을 할때, 자바쪽에서 해당 구현을 참조하지 못하도록 마킹 역할 수행</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@kotlin</span>.<span class=\"keyword\">internal</span>.InlineOnly</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">repeat</span><span class=\"params\">(times: <span class=\"type\">Int</span>, action: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    contract &#123; callsInPlace(action) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (index <span class=\"keyword\">in</span> <span class=\"number\">0</span> until times) &#123;</span><br><span class=\"line\">        action(index)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"레시피-11-3-완벽한-When-강제하기\"><a href=\"#레시피-11-3-완벽한-When-강제하기\" class=\"headerlink\" title=\"레시피 11.3 - 완벽한 When 강제하기\"></a>레시피 11.3 - 완벽한 When 강제하기</h4><ul>\n<li>코틀린에서의 <code>When</code>절은 문과 식의 역할을 모두 할 수 있다.</li>\n<li>식으로 사용하는 경우, <code>else</code>까지 붙여 완벽한 형태로 사용해야 함.</li>\n<li>문으로 사용할 경우, 완벽하게 else까지 붙여서 사용할 수 있도록 강제도 할 수 있음. <code>exhaustive</code> 확장 속성을 추가하면 가능하다.<ul>\n<li><em>TODO: Kotlin 1.3.72 환경에서 구문 에러가 발생.</em><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">printMod3</span><span class=\"params\">(n: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">when</span> (n % <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        <span class=\"number\">1</span> -&gt; println(<span class=\"string\">&quot;<span class=\"variable\">$n</span> % 3 = 0&quot;</span>)</span><br><span class=\"line\">        <span class=\"number\">2</span> -&gt; println(<span class=\"string\">&quot;<span class=\"variable\">$n</span> % 3 = 1&quot;</span>)</span><br><span class=\"line\">        <span class=\"number\">3</span> -&gt; println(<span class=\"string\">&quot;<span class=\"variable\">$n</span> % 3 = 2&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">printMod3SingleStatement</span><span class=\"params\">(n: <span class=\"type\">Int</span>)</span></span> = <span class=\"keyword\">when</span> (n % <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span> -&gt; println(<span class=\"string\">&quot;<span class=\"variable\">$n</span> % 3 = 0&quot;</span>)</span><br><span class=\"line\">    <span class=\"number\">2</span> -&gt; println(<span class=\"string\">&quot;<span class=\"variable\">$n</span> % 3 = 1&quot;</span>)</span><br><span class=\"line\">    <span class=\"number\">3</span> -&gt; println(<span class=\"string\">&quot;<span class=\"variable\">$n</span> % 3 = 2&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span> -&gt; println(<span class=\"string\">&quot;problems&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"레시피-11-4-정규표현식과-함께-replace-함수-사용하기\"><a href=\"#레시피-11-4-정규표현식과-함께-replace-함수-사용하기\" class=\"headerlink\" title=\"레시피 11.4 - 정규표현식과 함께 replace 함수 사용하기\"></a>레시피 11.4 - 정규표현식과 함께 replace 함수 사용하기</h4><ul>\n<li><p>문자열 중 부분 문자열을 수정하고 싶을 경우 <code>replace</code>함수를 사용.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> String.<span class=\"title\">replace</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    oldValue: <span class=\"type\">String</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    newValue: <span class=\"type\">String</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    ignroeCase: <span class=\"type\">Boolean</span> = <span class=\"literal\">false</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: String</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> CharSequence.<span class=\"title\">replace</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    regex: <span class=\"type\">Regex</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    replacement: <span class=\"type\">String</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: String</span><br></pre></td></tr></table></figure></li>\n<li><p>1)의 <code>replace</code>의 경우 자바의 replaceAll과 동일</p>\n</li>\n<li><p>2)의 <code>replace</code>의 경우 첫 번째 인자의 타입의 Regex를 받기 때문에 1)과는 전혀 다른 메소드</p>\n</li>\n<li><p>아래는 간단한 회문(Palindrome) 예제</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isPal</span><span class=\"params\">(string: <span class=\"type\">String</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> testString = string</span><br><span class=\"line\">            .toLowerCase()</span><br><span class=\"line\">            .replace(<span class=\"string\">&quot;&quot;&quot;[\\W+]&quot;&quot;&quot;</span>.toRegex(), <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> testString == testString.reversed()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> String.<span class=\"title\">isPalindrome</span><span class=\"params\">()</span></span> = <span class=\"keyword\">this</span>.toLowerCase()</span><br><span class=\"line\">        .replace(<span class=\"string\">&quot;&quot;&quot;[\\W+]&quot;&quot;&quot;</span>.toRegex(), <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">        .let &#123; it == it.reversed() &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"레시피-11-5-바이너리-문자열로-변환하고-되돌리기\"><a href=\"#레시피-11-5-바이너리-문자열로-변환하고-되돌리기\" class=\"headerlink\" title=\"레시피 11.5 - 바이너리 문자열로 변환하고 되돌리기\"></a>레시피 11.5 - 바이너리 문자열로 변환하고 되돌리기</h4><ul>\n<li>숫자를 바이너리 문자열로, 바이너리 문자열을 다시 숫자로 파싱할때 <code>toString(radix = 2)</code>, <code>toInt(radix = 2)</code>와 같은 함수를 사용하면 쉽게 가능<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> `paddedBinaryString`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> strings = (<span class=\"number\">0.</span><span class=\"number\">.15</span>)</span><br><span class=\"line\">            .map &#123; it.toString(radix = <span class=\"number\">2</span>)</span><br><span class=\"line\">            .padStart(<span class=\"number\">4</span>, <span class=\"string\">&#x27;0&#x27;</span>) &#125;</span><br><span class=\"line\">    assertEquals(strings, listOf(</span><br><span class=\"line\">            <span class=\"string\">&quot;0000&quot;</span>, <span class=\"string\">&quot;0001&quot;</span>, <span class=\"string\">&quot;0010&quot;</span>, <span class=\"string\">&quot;0011&quot;</span>, <span class=\"string\">&quot;0100&quot;</span>, <span class=\"string\">&quot;0101&quot;</span>, <span class=\"string\">&quot;0110&quot;</span>, <span class=\"string\">&quot;0111&quot;</span>, <span class=\"string\">&quot;1000&quot;</span>, <span class=\"string\">&quot;1001&quot;</span>, <span class=\"string\">&quot;1010&quot;</span>, <span class=\"string\">&quot;1011&quot;</span>, <span class=\"string\">&quot;1100&quot;</span>, <span class=\"string\">&quot;1101&quot;</span>, <span class=\"string\">&quot;1110&quot;</span>, <span class=\"string\">&quot;1111&quot;</span></span><br><span class=\"line\">    ))</span><br><span class=\"line\"></span><br><span class=\"line\">    assertEquals(strings.map &#123; it.toInt(<span class=\"number\">2</span>) &#125;, listOf(</span><br><span class=\"line\">            <span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>,<span class=\"number\">14</span>,<span class=\"number\">15</span></span><br><span class=\"line\">    ))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"레시피-11-6-실행-가능한-클래스-만들기\"><a href=\"#레시피-11-6-실행-가능한-클래스-만들기\" class=\"headerlink\" title=\"레시피 11.6 - 실행 가능한 클래스 만들기\"></a>레시피 11.6 - 실행 가능한 클래스 만들기</h4><ul>\n<li>클래스에서 <code>invoke</code> 연산자를 오버로딩 한다.</li>\n<li>코틀린은 연산자 오버로딩을 기본으로 지원하고 있으며, 지원하는 <a href=\"https://kotlinlang.org/docs/reference/operator-overloading.html\">링크</a> 참고하면 된다.</li>\n<li>아래는 오픈 API를 호출하여 JSON 응답을 Gson을 통하여 역직렬화 하는 예제이며, 이에 대한 실행은 <code>invoke</code> 연산자를 통하여 실행한다.</li>\n<li>아래 코드를 보면 잘 알겠지만, 클래스를 인스턴스화하면 invoke 함수를 바로 호출하는 것이 가능하며, 필요하다면 메소드에 인자를 추가하는 것도 가능하다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AstroResult</span> </span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> message: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> number: Number,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> people: List&lt;Assignment&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Assignment</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> craft: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> name: String</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AstroRequest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> gson = Gson()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">invoke</span><span class=\"params\">()</span></span>: AstroResult = (</span><br><span class=\"line\">        gson.fromJson(URL(<span class=\"string\">&quot;http://api.open-notify.org/astros.json&quot;</span>)</span><br><span class=\"line\">            .readText(), AstroResult::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> `AstroRequest Test`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result = AstroRequest()()</span><br><span class=\"line\">    assertThat(result.message, `<span class=\"keyword\">is</span>`(<span class=\"string\">&quot;success&quot;</span>))</span><br><span class=\"line\">    assertThat(result.number.toInt(), greaterThanOrEqualTo(<span class=\"number\">0</span>))</span><br><span class=\"line\">    assertThat(result.people.size, `<span class=\"keyword\">is</span>`(result.number.toInt()))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"레시피-11-7-경과-시간-측정하기\"><a href=\"#레시피-11-7-경과-시간-측정하기\" class=\"headerlink\" title=\"레시피 11.7 - 경과 시간 측정하기\"></a>레시피 11.7 - 경과 시간 측정하기</h4><ul>\n<li><code>measureTimeMills</code> 혹은 <code>measureNanoTime</code>를 사용한다.</li>\n<li>위 함수들은 람다를 인자로 받기 때문에 고차 함수이며 <code>inline</code>으로 선언 되어 있다. 실제 실행은 <code>System.currentTimeMillis</code> 메소드에게 위임한다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">measureTimeMillis</span><span class=\"params\">(block: () -&gt; <span class=\"type\">Unit</span>)</span></span>: <span class=\"built_in\">Long</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> start = System.currentTimeMillis()</span><br><span class=\"line\">    block()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> System.currentTimeMillis() - start</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doubleIt</span><span class=\"params\">(x: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">100L</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;doubling <span class=\"variable\">$x</span> with on thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">exec</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;<span class=\"subst\">$&#123;Runtime.getRuntime().availableProcessors()&#125;</span> processors&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> time = measureTimeMillis &#123;</span><br><span class=\"line\">        IntStream.rangeClosed(<span class=\"number\">1</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">                .map &#123; doubleIt(it) &#125;</span><br><span class=\"line\">                .sum()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Sequential stream took <span class=\"subst\">$&#123;time&#125;</span>ms&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    time = measureTimeMillis &#123;</span><br><span class=\"line\">        IntStream.rangeClosed(<span class=\"number\">1</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">                .parallel()</span><br><span class=\"line\">                .map &#123; doubleIt(it) &#125;</span><br><span class=\"line\">                .sum()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Parallel stream took <span class=\"subst\">$&#123;time&#125;</span>ms&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>IntStream</code>을 사용하여 sum을 구하는 예제이며, Parallel로 돌렸을때와 Sequential로 돌렸을 때의 경과 시간 측정을 위해 작성했다.</li>\n</ul>\n<h4 id=\"레시피-11-8-스레드-시작하기\"><a href=\"#레시피-11-8-스레드-시작하기\" class=\"headerlink\" title=\"레시피 11.8 - 스레드 시작하기\"></a>레시피 11.8 - 스레드 시작하기</h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">thread</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    start: <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    isDaemon: <span class=\"type\">Boolean</span> = <span class=\"literal\">false</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    contextClassLoader: <span class=\"type\">ClassLoader</span>? = <span class=\"literal\">null</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    name: <span class=\"type\">String</span>? = <span class=\"literal\">null</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    priority: <span class=\"type\">Int</span> = <span class=\"number\">-1</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    block: () -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: Thread</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>코틀린은 스레드를 쉽게 생성하고 시작할 수 있도록 확장 함수를 제공함.</li>\n<li>잔여 스레드가 모두 데몬 스레드일 경우, 어플리케이션은 종료된다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">threadStart</span><span class=\"params\">(isDaemon: <span class=\"type\">Boolean</span> = <span class=\"literal\">false</span>, isJoin: <span class=\"type\">Boolean</span> = <span class=\"literal\">false</span>)</span></span> = (<span class=\"number\">0.</span><span class=\"number\">.5</span>).forEach &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sleepTime = Random.nextLong(<span class=\"number\">0.</span>.<span class=\"number\">1000L</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> thread = thread(isDaemon = isDaemon) &#123;</span><br><span class=\"line\">        Thread.sleep(sleepTime)</span><br><span class=\"line\">        println(<span class=\"string\">&quot;<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span> for <span class=\"variable\">$it</span> after <span class=\"variable\">$sleepTime</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isJoin) thread.join()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>5개의 스레드를 생성하는 예제이며, 데몬스레드 유무에 따라 바로 종료될수도 아닐수도 있는 코드이다.</li>\n<li>순차 실행을 원한다면 <code>join()</code> 메소드를 사용</li>\n</ul>\n<h4 id=\"레시피-11-9-TODO로-완성-강제하기\"><a href=\"#레시피-11-9-TODO로-완성-강제하기\" class=\"headerlink\" title=\"레시피 11.9 - TODO로 완성 강제하기\"></a>레시피 11.9 - TODO로 완성 강제하기</h4><ul>\n<li>함수 구현을 완성하지 않으면 예외를 던지는 TODO 함수를 사용하면 된다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@kotlin</span>.<span class=\"keyword\">internal</span>.InlineOnly</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">TODO</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Nothing</span> = <span class=\"keyword\">throw</span> NotImplementedError()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@kotlin</span>.<span class=\"keyword\">internal</span>.InlineOnly</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">TODO</span><span class=\"params\">(reason: <span class=\"type\">String</span>)</span></span>: <span class=\"built_in\">Nothing</span> = <span class=\"keyword\">throw</span> NotImplementedError(<span class=\"string\">&quot;An operation is not implemented: <span class=\"variable\">$reason</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n<li>함수의 시그니처는 위와 같으며, <code>reason</code>에는 미구현에 대한 사유를 넣어주면 되고, 발생하는 예외는 <code>NotImplementedError</code>가 발생하며 해당 클래스의 상위 클래스와 인터페이스는 <code>Error - Throwable</code> 이다.</li>\n</ul>\n<h4 id=\"레시피-11-10-Random의-무작위-동작-이해하기\"><a href=\"#레시피-11-10-Random의-무작위-동작-이해하기\" class=\"headerlink\" title=\"레시피 11.10 - Random의 무작위 동작 이해하기\"></a>레시피 11.10 - Random의 무작위 동작 이해하기</h4><ul>\n<li>난수 생성은 자바와 같이 Random 클래스를 활용<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> `nextInt with no args gives any int`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> value = Random.nextInt()</span><br><span class=\"line\">    assertTrue(value <span class=\"keyword\">in</span> <span class=\"built_in\">Int</span>.MIN_VALUE..<span class=\"built_in\">Int</span>.MAX_VALUE)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> `nextInt with range gives value between 0 and limit`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> value = Random.nextInt(<span class=\"number\">10</span>)</span><br><span class=\"line\">    assertTrue(value <span class=\"keyword\">in</span> <span class=\"number\">0.</span><span class=\"number\">.10</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> `nextInt with min and max gives value between them`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> value = Random.nextInt(<span class=\"number\">5</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">    assertTrue(value <span class=\"keyword\">in</span> <span class=\"number\">5.</span><span class=\"number\">.10</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> `nextInt with range returns value <span class=\"keyword\">in</span> range`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> value = Random.nextInt(<span class=\"number\">7.</span><span class=\"number\">.12</span>)</span><br><span class=\"line\">    assertTrue(value <span class=\"keyword\">in</span> <span class=\"number\">7.</span><span class=\"number\">.12</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>nextInt()</code>의 구현 부분을 살펴보면, 동반 객체에서 추상 클래스에 선언된 모든 메서드를 defaultPlatformRandom에 위임하고 있으며, 해당 defaultPlatformRandom은 internal로 선언되어 있음을 확인할 수 있다. </li>\n<li><a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.random/-random/-default/\">코틀린 문서</a>를 확인해보면 <code>On JVM this generator is thread-safe, its methods can be invoked from multiple threads.</code> 난수 생성 시 스레드 세이프한 성격을 보장한다고 나와 있다.</li>\n</ul>\n<h4 id=\"레시피-11-11-함수-이름에-특수-문자-사용하기\"><a href=\"#레시피-11-11-함수-이름에-특수-문자-사용하기\" class=\"headerlink\" title=\"레시피 11.11 - 함수 이름에 특수 문자 사용하기\"></a>레시피 11.11 - 함수 이름에 특수 문자 사용하기</h4><ul>\n<li>작명하기 아주 어려운 상황 혹은 테스트에서만 사용하는 것을 권한다.</li>\n<li>함수명을 백틱(``)으로 감싸 놓으면 특수 문자 등을 활용할 수 있다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> `nextInt with min and max gives value between them`<span class=\"params\">()</span></span> &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"레시피-11-12-자바에게-예외-알리기\"><a href=\"#레시피-11-12-자바에게-예외-알리기\" class=\"headerlink\" title=\"레시피 11.12 - 자바에게 예외 알리기\"></a>레시피 11.12 - 자바에게 예외 알리기</h4><ul>\n<li>코틀린의 모든 예외는 기본적으로 Unchecked Exception이다. 코틀린 컴파일러가 예외를 강제하지 않으며 굳이 잡는다면 try catch finally로 잡는 방법도 있지만 강제 사항은 아니다.</li>\n<li>자바에서처럼 <code>throws</code>키워드를 사용하여 예외가 발생할 수 있음을 알릴 수 없기 때문에 자바에서 만약 코틀린 코드를 사용한다면 이를 알릴 수 있는 장치가 필요하게 된다. <code>@Throws</code> 어노테이션을 활용하면 이것이 가능하다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Throws(IOException::class)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">houstonWeHaveAProblem</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> IOException(<span class=\"string\">&quot;File or resource not found&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>위와 같이 어노테이션을 사용하게 되면, 자바 컴파일러는 IOException에 대비해야 하는 내용을 알게 된다.</li>\n<li>어노테이션을 명시하지 않고, 만약 자바코드에서 예외를 캐치하려고 한다면 컴파일이 실패하거나 불필요한 코드가 존재한다는 컴파일러 워닝을 만나게 될 것이다.</li>\n<li><code>@Throws</code> 어노테이션의 역할을 다시 정리하자면, 자바/코틀린의 통합을 위해 그리고 코틀린 코드에서 발생하는 예외를 자바 코드에서 대비하기 위해 존재하는 것이다.</li>\n</ul>\n<hr>\n<h2 id=\"12장\"><a href=\"#12장\" class=\"headerlink\" title=\"12장\"></a>12장</h2><h4 id=\"레시피-12-1-확장을-위해-스프링-관리-빈-클래스-오픈하기\"><a href=\"#레시피-12-1-확장을-위해-스프링-관리-빈-클래스-오픈하기\" class=\"headerlink\" title=\"레시피 12.1 - 확장을 위해 스프링 관리 빈 클래스 오픈하기\"></a>레시피 12.1 - 확장을 위해 스프링 관리 빈 클래스 오픈하기</h4><ul>\n<li>스프링에서는 빈으로 관리되는 클래스들 대부분이 프록시 기반으로 작동하게 된다.</li>\n<li>코틀린 클래스는 기본적으로 <code>final</code> 식별자를 달고 나오기 때문에 프록시를 동작이 안되게 된다. 이를 해결하기 위해서는 별도로 <code>kotlin-spring</code> 빌드 플러그인을 사용하여 스프링에서 관리하는 <code>@Component</code>,<br><code>@Service</code>으로 마킹된 클래스들이 확장 가능한 클래스 식별자인 <code>open</code>로 컴파일리 되도록 설정해줘야 한다.<ul>\n<li><code>all-open</code> 플러그인을 사용해도 되지만, 대부분 <code>kotlin-spring</code>플러그인이 커버한다.</li>\n</ul>\n</li>\n<li>프록시는 실제 컴포넌트 메소드 호출을 가로채 호출 전후로 많은 일을 수행하게 된다. 인자에 대한 유효값 체크와 트랜잭션 등이 아주 대표적인 케이스이다. </li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@org</span>.springframework.stereotype.Service </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> <span class=\"keyword\">public</span> <span class=\"keyword\">constructor</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">join</span><span class=\"params\">()</span></span>: kotlin.<span class=\"built_in\">Unit</span> &#123; <span class=\"comment\">/* compiled code */</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>플러그인을 적용하여 코드를 컴파일 결과이다.</li>\n<li><code>@Component</code>, <code>@Async</code>, <code>@Transactional</code>, <code>@Cacheable</code>, <code>@SpringBootTest</code> 들이 open이 되는 마킹 어노테이션들이며 사실상 대부분을 커버한다고 보면 된다. <code>@Component</code>의 경우 이를 사용하는 하위 어노테이션중에 친숙한 <code>@Configuration</code>, <code>@Controller</code>, <code>@RestController</code>, <code>@Service</code>, <code>@Repository</code> 들이 있다.</li>\n</ul>\n<h4 id=\"레시피-12-2-코틀린-data-클래스로-퍼시스턴스-구현하기\"><a href=\"#레시피-12-2-코틀린-data-클래스로-퍼시스턴스-구현하기\" class=\"headerlink\" title=\"레시피 12.2 - 코틀린 data 클래스로 퍼시스턴스 구현하기\"></a>레시피 12.2 - 코틀린 data 클래스로 퍼시스턴스 구현하기</h4><ul>\n<li><p>JPA 관점에서 코틀린 <code>data class</code>는 두 가지 문제가 존재함</p>\n<ul>\n<li><code>data class</code>는 기본 생성자를 만들지 않음.</li>\n<li>불변 속성(<code>val</code>)을 강조하는 data class의 성격</li>\n</ul>\n</li>\n<li><p>기본 생성자를 만드는 부분에 대한 해결책은 <code>no-arg</code> 플러그인을 사용하는 방법이 존재한다.</p>\n<blockquote>\n<p>no-arg 플러그인으로 만든 기본 생성자의 접근 제어자는 <code>public</code>이고, 실제 코드에서는 접근이 불가능하며 리플렉션을 통한 접근만 가능하다고 한다.</p>\n</blockquote>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">  id <span class=\"string\">&quot;org.jetbrains.kotlin.plugin.noarg&quot;</span> version <span class=\"string\">&quot;1.4.10&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">noArg &#123;</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;com.my.Annotation&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>no-arg</code> 플러그인을 활용하는 방법도 좋지만, 빌드 설정에 마킹 어노테이션등을 명시해야 하는 불편함이 존재한다. 이를 개선하여 사용할 수 있는 플러그인이 바로 <code>kotlin-jpa</code> 플러그인이다.</p>\n<ul>\n<li><code>@Entity</code></li>\n<li><code>@Embeddable</code></li>\n<li><code>@MappedSuperClass</code></li>\n</ul>\n</li>\n<li><p><code>data class</code>는 기본적으로 <code>hashCode</code>, <code>equals</code>, <code>toString</code>을 자동생성한다. JPA의 엔티티로 자동생성한 값을 사용하게 될 경우 발생할 수 있는 문제와 아래와 같다.</p>\n<ul>\n<li>양방향 엔티티 바인딩을 사용할 경우, 경우에 따라 순환 참조를 만나게 될 수 있다.</li>\n<li>불변 프로퍼티 사용을 권하는 data class와 다르게 필드 값을 계속 변경해야 하기 때문에 var로 선언해두고 사용해야 하는 JPA의 성격이 매우 상이함.</li>\n</ul>\n</li>\n<li><p>이러한 부분 때문에 차라리 class를 그대로 사용하는 것이 나을 수 있다. 하지만, class도 코틀린에서는 기본적으로 상속이 불가능한 형태인 final 키워드가 붙어져 있는 형태기 때문에, 프록시를 사용하는 JPA-하이버네이트의 상황상 이를 <code>open</code> 클래스로 바꿔줘야 하는 불편함이 생긴다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id <span class=\"string\">&#x27;org.springframework.boot&#x27;</span> version <span class=\"string\">&#x27;2.3.1.RELEASE&#x27;</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;io.spring.dependency-management&#x27;</span> version <span class=\"string\">&#x27;1.0.9.RELEASE&#x27;</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;org.jetbrains.kotlin.plugin.spring&#x27;</span> version <span class=\"string\">&#x27;1.3.72&#x27;</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;org.jetbrains.kotlin.plugin.jpa&#x27;</span> version <span class=\"string\">&#x27;1.3.72&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">allOpen &#123;</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.Entity&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.MappedSuperclass&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.Embeddable&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>위와 같이, kotlin-jpa 플러그인을 선언하고 open을 할 마킹 어노테이션을 지정해주면 실제로 컴파일한 클래스는 아래와 같다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IntelliJ API Decompiler stub source generated from a class file</span></span><br><span class=\"line\"><span class=\"comment\">// Implementation of methods is not available</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> me.daniel.kotlin_in_action</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@javax</span>.persistence.Entity </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">public</span> <span class=\"keyword\">constructor</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">open</span> <span class=\"keyword\">var</span> age: kotlin.<span class=\"built_in\">Long</span>? <span class=\"comment\">/* compiled code */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@field:javax</span>.persistence.Id <span class=\"meta\">@field:javax</span>.persistence.GeneratedValue <span class=\"keyword\">public</span> <span class=\"keyword\">open</span> <span class=\"keyword\">var</span> id: kotlin.<span class=\"built_in\">Long</span>? <span class=\"comment\">/* compiled code */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">open</span> <span class=\"keyword\">var</span> name: kotlin.String <span class=\"comment\">/* compiled code */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"레시피-12-3-의존성-주입하기\"><a href=\"#레시피-12-3-의존성-주입하기\" class=\"headerlink\" title=\"레시피 12.3 - 의존성 주입하기\"></a>레시피 12.3 - 의존성 주입하기</h4><ul>\n<li>스프링에서는 복잡한 의존성 주입 과정 그리고 빈과 빈의 연결을 컨테이너에서 처리해준다.</li>\n<li>코틀린에서는 필드 레벨 빈 의존성 주입을 할 경우 <code>lateinit var</code> 구조를 활용해야 한다. 생성자 기반의 주입도 가능하다.</li>\n<li>생성자 방식의 의존성 주입이 스프링에서 선호하는 의존성 주입 방식이긴 하나, 경우에 따라 필드 레벨의 주입이 필요한 경우도 있다. </li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1)</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceByConstructorInjection</span></span>(<span class=\"keyword\">val</span> contentService: ContentService)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2)</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceByConstructorInjectionWithFieldAutowired</span></span>(<span class=\"meta\">@Autowired</span> <span class=\"keyword\">val</span> contentService: ContentService)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3)</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceByConstructorInjectionWithAutowired</span> <span class=\"meta\">@Autowired</span> <span class=\"keyword\">constructor</span></span>(<span class=\"keyword\">val</span> contentService: ContentService)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4)</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceByFieldLevelInjection</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> contentService: ContentService</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>위와 같이 다양한 형태로 의존성 주입을 받는 것이 가능하다. <code>@Autowired</code>를 굳이 안붙여서도 사용 가능한 1번의 형태가 가장 간편한 방법이고 스프링에서 추천하는 의존성 주입 방식이다.</li>\n</ul>\n<hr>\n<h2 id=\"13장-코루틴과-구조적-동시성\"><a href=\"#13장-코루틴과-구조적-동시성\" class=\"headerlink\" title=\"13장 - 코루틴과 구조적 동시성\"></a>13장 - 코루틴과 구조적 동시성</h2><h4 id=\"레시피-13-1-코루틴-빌더-선택하기\"><a href=\"#레시피-13-1-코루틴-빌더-선택하기\" class=\"headerlink\" title=\"레시피 13.1 - 코루틴 빌더 선택하기\"></a>레시피 13.1 - 코루틴 빌더 선택하기</h4><ul>\n<li><p><code>GlobalScope</code>의 <code>async</code>와 <code>launch</code>는 사용하지 말자</p>\n<ul>\n<li>취소되지 않으면 어플리케이션 전체 수명주기에 걸쳐 실행됨.</li>\n</ul>\n</li>\n<li><p><code>runBlocking</code> 빌더</p>\n  <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">runBlocking</span><span class=\"params\">(context: <span class=\"type\">CoroutineContext</span> = EmptyCoroutineContext, block: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">T</span>)</span></span>: T    </span><br></pre></td></tr></table></figure>\n<ul>\n<li>블록 내 모든 코루틴이 종료될 때까지 현재 스레드를 블록</li>\n<li><code>suspend</code> 키워드가 붙은 함수가 아니기 때문에, 일반 함수에서도 호출 가능</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><code>launch</code> 빌더</p>\n  <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> CoroutineScope.<span class=\"title\">launch</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    context: <span class=\"type\">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    start: <span class=\"type\">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    block: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: Job</span><br></pre></td></tr></table></figure>\n<ul>\n<li>해당값에서 리턴값을 받을 필요가 없을 때 사용</li>\n<li><code>Job</code>을 리턴, 취소 가능</li>\n<li>코루틴 컨텍스트(<code>context</code>)를 지정하여 다른 코루틴과 상태 공유가 가능</li>\n<li><code>start</code> 인자의 열거형으로 <code>DEFAULT</code>, <code>LAZY</code>, <code>ATOMIC</code>, <code>UNDISPATCHED</code> 값을 사용할 수 있다.</li>\n</ul>\n</li>\n<li><p><code>async</code> 빌더</p>\n  <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> CoroutineScope.<span class=\"title\">async</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    context: <span class=\"type\">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    start: <span class=\"type\">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    block: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">T</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: Deferred&lt;T&gt;    </span><br></pre></td></tr></table></figure>\n<ul>\n<li>값을 리턴해야 할 경우 사용</li>\n<li><code>launch</code> 빌더처럼 CoroutineContext와 CoroutineStart 파라미터를 받을 수 있으며, 기본값이 설정되어 있다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">add</span><span class=\"params\">(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(Random.nextLong(<span class=\"number\">1000L</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = coroutineScope &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> firstSum = async &#123;</span><br><span class=\"line\">        println(Thread.currentThread().name)</span><br><span class=\"line\">        add(<span class=\"number\">2</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> secondSum = async &#123;</span><br><span class=\"line\">        println(Thread.currentThread().name)</span><br><span class=\"line\">        add(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Awaiting concurrent sums...&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> total = firstSum.await() + secondSum.await()</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Total is <span class=\"variable\">$total</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DefaultDispatcher-worker-1</span><br><span class=\"line\">Awaiting concurrent sums...</span><br><span class=\"line\">DefaultDispatcher-worker-2</span><br><span class=\"line\">Total is 11</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li>위 예제의 실행 결과를 보면 <code>async</code> 빌더는 기본 디스패처를 사용하는 것을 확인할 수 있다.</li>\n<li><code>delay</code> 함수는 코루틴 실행 스레드를 블록하지 않고 대기 상태로 만든다.</li>\n</ul>\n</li>\n<li><p><code>coroutineScope</code> 빌더</p>\n  <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R&gt;</span> <span class=\"title\">coroutineScope</span><span class=\"params\">(block: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">R</span>)</span></span>: R &#123;</span><br><span class=\"line\">    contract &#123;</span><br><span class=\"line\">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> coroutine = ScopeCoroutine(uCont.context, uCont)</span><br><span class=\"line\">        coroutine.startUndispatchedOrReturn(coroutine, block)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>coroutineScope</code> 빌더는 함수 종료 전 모든 코루틴이 완료될때까지 기다리는 일수 중단 함수이다. 굳이 코루틴의 완료 유무를 확인할 필요가 없다.</li>\n<li>메인 스레드를 블록하지 않지만, 반드시 다른 일시 중단 함수의 일부로서 호출해야 된다.</li>\n<li>코루틴이 하나라도 실패하면 나머지 코루틴을 취소하며, 완료 유무를 확인하지 않고 균형 있는 제어와 에러 처리를 달성하고 루틴이 실패하는 경우를 처리하지 않는 것을 방지한다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"레시피-13-2-async-await를-withContext로-변경하기\"><a href=\"#레시피-13-2-async-await를-withContext로-변경하기\" class=\"headerlink\" title=\"레시피 13.2 - async/await를 withContext로 변경하기\"></a>레시피 13.2 - async/await를 withContext로 변경하기</h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">withContext</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    context: <span class=\"type\">CoroutineContext</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    block: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">T</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: T    </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>async</code> 코루틴을 시작하고 <code>await</code>로 기다리는 코드를 간소화하고 싶다면 <code>withContext</code>로 대체가 가능하다.</li>\n<li>공식 문서에서는 <strong>주어진 코루틴 컨텍스트와 함께 명시한 일시정지 블록을 호출하고, 완료될 떄까지 일시정지한 후에 그 결과를 리턴한다.</strong> 라고 나와 있다. 다시 말해, <code>async ~ await</code>의 호출 구조를 <code>withContext</code>로 단순화하는 것이 가능하다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">retrieve1</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span> = coroutineScope &#123;</span><br><span class=\"line\">    async(Dispatchers.IO) &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Retrieving data on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">        delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">        <span class=\"string\">&quot;asyncResults&quot;</span></span><br><span class=\"line\">    &#125;.await()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">retrieve2</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Retrieving data on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">    delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">    <span class=\"string\">&quot;asyncResults&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result1 = retrieve1(<span class=\"string\">&quot;www.mysite.com&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result2 = retrieve2(<span class=\"string\">&quot;www.mysite.com&quot;</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;printing result on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span> <span class=\"variable\">$result1</span>&quot;</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;printing result on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span> <span class=\"variable\">$result2</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrieving data on DefaultDispatcher-worker-1</span><br><span class=\"line\">Retrieving data on DefaultDispatcher-worker-1</span><br><span class=\"line\">printing result on main asyncResults</span><br><span class=\"line\">printing result on main asyncResults</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><p><code>retrieve1</code>과 같이 메소드를 작성하게 되면 Intellij에서 <code>merge call chain to &#39;withContext&#39;</code>라는 문구와 함께 withContext로 대체 할 것을 제안하는 것을 확인할 수 있다.</p>\n</li>\n<li><p>각 suspend 함수는 기본 디스패처에서 호출이 되며, 메인 스레드 메인 함수에서 <code>await</code> 호출 없이 결과를 받아 오는 것을 확인할 수 있다.</p>\n</li>\n</ul>\n<h4 id=\"레시피-13-3-디스패처-사용하기\"><a href=\"#레시피-13-3-디스패처-사용하기\" class=\"headerlink\" title=\"레시피 13.3 - 디스패처 사용하기\"></a>레시피 13.3 - 디스패처 사용하기</h4><ul>\n<li>IO 혹은 다른 작업을 위한 전용 스레드풀을 이용할 때는 <code>Dispatchers</code> 클래스의 적당한 디스패처를 골라 사용하면 된다.</li>\n<li>코루틴은 <code>CorutineContext</code> 컨텍스트 내에서 실행되며 코루틴 컨텍스트에는 <code>CoroutineDispatcher</code> 클래스의 인스턴스가 포함되어 있다. </li>\n<li><strong>디스패처의 역할은 코루틴이 어떤 스레드에서 혹은 어떤 스레드풀에서 실행할지를 결정한다.</strong> 디스패처의 종류는 아래와 같다.<ul>\n<li>IO:  File IO 혹은 Network IO와 같은 IO Intensive 작업을 위해 디자인된 디스패처이며, On-Demand 공유 풀을 사용한다.</li>\n<li>Default:  공유 백그라운드 스레드풀을 사용하며, CPU Bound 상황에 어울린다.</li>\n<li>Unconfined</li>\n</ul>\n</li>\n<li>디스패처의 명시는 <code>async</code>, <code>launch</code>, <code>withContext</code>의 호출 인자에 넘겨서 지정하는 것이 가능하다.</li>\n</ul>\n<h4 id=\"레시피-13-4-자바-스레드-풀에서-코루틴-실행하기\"><a href=\"#레시피-13-4-자바-스레드-풀에서-코루틴-실행하기\" class=\"headerlink\" title=\"레시피 13.4 - 자바 스레드 풀에서 코루틴 실행하기\"></a>레시피 13.4 - 자바 스레드 풀에서 코루틴 실행하기</h4><ul>\n<li>자바의 <code>ExecutorService</code>의 <code>asCoroutineDispatcher</code> 확장 함수 호출을 통해 코루틴의 스레드풀 생성이 가능하다. </li>\n<li><code>asCoroutineDispatcher</code> 함수는 <code>ExecutorService</code>의 인스턴스를 <code>ExecutorCoroutineDispatcher</code>의 구현으로 변환한다. </li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExecutorCoroutineDispatcher</span>: <span class=\"type\">CoroutineDispatcher</span></span>(), Closeable &#123;</span><br><span class=\"line\">    <span class=\"comment\">/** <span class=\"doctag\">@suppress</span> */</span></span><br><span class=\"line\">    <span class=\"meta\">@ExperimentalStdlibApi</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> Key : AbstractCoroutineContextKey&lt;CoroutineDispatcher, ExecutorCoroutineDispatcher&gt;(</span><br><span class=\"line\">        CoroutineDispatcher,</span><br><span class=\"line\">        &#123; it <span class=\"keyword\">as</span>? ExecutorCoroutineDispatcher &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">val</span> executor: Executor</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">close</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>ExecutorCoroutineDispatcher</code>는 <code>close</code> 함수를 호출하지 않으면 계속 실행되기 때문에, 해당 함수 호출은 필수다. <code>ExecutorCoroutineDispatcher</code> 클래스는 추상 클래스로 구현 클래스인 <code>ThreadPoolDispatcher</code>의 <code>close</code> 메소드를 살펴보면 ExecutorService의 <code>shutdown</code> 메소드를 호출하는 것을 확인할 수 있다.</li>\n<li><code>Closeable</code> 인터페이스를 구현하여 <code>close</code> 혹은 <code>shutdown</code> 호출에 대한 부분은 해당 인터페이스 구현에 맡겼으며 코틀린에서는 <code>use</code> 블록을 사용하여 사용 후 쉽게 종료가 가능하다. <blockquote>\n<p>자바와 같이 try<del>with</del>resource 구문이 없는 코틀린에서는 Closeable 인터페이스 use를 사용하여 자원 해제를 하게 된다. <a href=\"#10%EC%9E%A5\">링크</a> 참고</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"레시피-13-5-코루틴-취소하기\"><a href=\"#레시피-13-5-코루틴-취소하기\" class=\"headerlink\" title=\"레시피 13.5 - 코루틴 취소하기\"></a>레시피 13.5 - 코루틴 취소하기</h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">jobCancelExec</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    runBlocking &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> job = launch &#123;</span><br><span class=\"line\">            repeat(<span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                println(<span class=\"string\">&quot;Job: I&#x27;m waiting <span class=\"variable\">$it</span>...&quot;</span>)</span><br><span class=\"line\">                delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        delay(<span class=\"number\">500L</span>)</span><br><span class=\"line\">        println(<span class=\"string\">&quot;main: That&#x27;s enough waiting&quot;</span>)</span><br><span class=\"line\">        job.cancel()</span><br><span class=\"line\">        job.join()</span><br><span class=\"line\">        println(<span class=\"string\">&quot;main: Done&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>launch</code>, <code>async</code> 빌더 함수는 공통적으로 Job 타입을 리턴하게 되는데, 해당 타입의 cancel 메소드를 호출하면 해당 잡을 취소하는 것이 가능하다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">jobTimeout</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    runBlocking &#123;</span><br><span class=\"line\">        withTimeout(<span class=\"number\">1000L</span>) &#123;</span><br><span class=\"line\">            repeat(<span class=\"number\">50</span>) &#123;</span><br><span class=\"line\">                println(<span class=\"string\">&quot;Job: I&#x27;m waiting <span class=\"variable\">$it</span>...&quot;</span>)</span><br><span class=\"line\">                delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">withTimeout</span><span class=\"params\">(timeMillis: <span class=\"type\">Long</span>, block: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">T</span>)</span></span>: T</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>withTimeout</code> 혹은 <code>withTimeoutOrNull</code>과 같은 메소드를 호출하여 취소하는 것도 가능하며, 타임아웃이 초과하면 <code>TimeoutCancellationException</code>이 발생한다.<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Job: I&#x27;m waiting 0...</span><br><span class=\"line\">Job: I&#x27;m waiting 1...</span><br><span class=\"line\">...(생략)</span><br><span class=\"line\">Exception in thread &quot;main&quot; kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1000 ms</span><br><span class=\"line\">\tat kotlinx.coroutines.TimeoutKt.TimeoutCancellationException(Timeout.kt:158)</span><br><span class=\"line\">\tat kotlinx.coroutines.TimeoutCoroutine.run(Timeout.kt:128)</span><br><span class=\"line\">\tat kotlinx.coroutines.EventLoopImplBase$DelayedRunnableTask.run(EventLoop.common.kt:497)</span><br><span class=\"line\">\tat kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:274)</span><br><span class=\"line\">\tat kotlinx.coroutines.DefaultExecutor.run(DefaultExecutor.kt:68)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>\n<h4 id=\"레시피-13-6-코루틴-디버깅\"><a href=\"#레시피-13-6-코루틴-디버깅\" class=\"headerlink\" title=\"레시피 13.6 - 코루틴 디버깅\"></a>레시피 13.6 - 코루틴 디버깅</h4></li>\n<li>JVM의 실행 플래그(<code>-Dkotlinx.coroutines.debug</code>)를 추가하면 코루틴 이름등과 같은 실행정보를 확인할 수 있다. Intelli에서는 VM Options에 해당 플래그 값을 추가하면 된다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">retrieve1</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span> = coroutineScope &#123;</span><br><span class=\"line\">    async(Dispatchers.IO) &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Retrieving data on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">        delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">        <span class=\"string\">&quot;asyncResults&quot;</span></span><br><span class=\"line\">    &#125;.await()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">retrieve2</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Retrieving data on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">    delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">    <span class=\"string\">&quot;asyncResults&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result1 = retrieve1(<span class=\"string\">&quot;www.mysite.com&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result2 = retrieve2(<span class=\"string\">&quot;www.mysite.com&quot;</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;printing result on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span> <span class=\"variable\">$result1</span>&quot;</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;printing result on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span> <span class=\"variable\">$result2</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrieving data on DefaultDispatcher-worker-1 @coroutine#2</span><br><span class=\"line\">Retrieving data on DefaultDispatcher-worker-1 @coroutine#1</span><br><span class=\"line\">printing result on main @coroutine#1 asyncResults</span><br><span class=\"line\">printing result on main @coroutine#1 asyncResults</span><br></pre></td></tr></table></figure>\n<ul>\n<li>스레드 이름 뒤에 <code>@coroutine#2</code>가 붙은 것을 확인할 수 있는데, <code>CoroutineName</code> 클래스를 사용하여 직접 이름을 붙이는 것도 가능하다. 위 코드에서 <code>retrieve1</code>, <code>retrieve2</code>의 컨텍스트를 인자 부분을 아래와 같이 수정하면 된다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">retrieve1</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span> = coroutineScope &#123;</span><br><span class=\"line\">    async(Dispatchers.IO + CoroutineName(name = <span class=\"string\">&quot;async&quot;</span>)) &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Retrieving data on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">        delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">        <span class=\"string\">&quot;asyncResults&quot;</span></span><br><span class=\"line\">    &#125;.await()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">retrieve2</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span> = withContext(Dispatchers.IO + CoroutineName(name = <span class=\"string\">&quot;withContext&quot;</span>)) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Retrieving data on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">    delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">    <span class=\"string\">&quot;asyncResults&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// coroutine이라는 이름 대신 지정한 이름을 노출</span><br><span class=\"line\">Retrieving data on DefaultDispatcher-worker-1 @async#2</span><br><span class=\"line\">Retrieving data on DefaultDispatcher-worker-1 @withContext#1</span><br><span class=\"line\">printing result on main @coroutine#1 asyncResults</span><br><span class=\"line\">printing result on main @coroutine#1 asyncResults</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Kotlin-Cookbook\"><a href=\"#Kotlin-Cookbook\" class=\"headerlink\" title=\"Kotlin Cookbook\"></a>Kotlin Cookbook</h1><h2 id=\"10장\"><a href=\"#10장\" class=\"headerlink\" title=\"10장\"></a>10장</h2><h4 id=\"레시피-10-1-use로-리소스-관리하기\"><a href=\"#레시피-10-1-use로-리소스-관리하기\" class=\"headerlink\" title=\"레시피 10.1 - use로 리소스 관리하기\"></a>레시피 10.1 - use로 리소스 관리하기</h4><ul>\n<li>코틀린에서는 자바의 <code>try-with-resources</code> 구조를 지원하지 않음</li>\n<li>대신, <code>Closeable</code> 인터페이스의 확장함수 <code>use</code>를 제공하며, <code>Reader</code>와 <code>File</code>에는 <code>useLine</code> 확장함수를 추가</li>\n<li><code>useLine</code>의 경우, <code>BufferedReader.use</code>에게 처리를 위임하며, 해당 확장함수는 <code>try-catch-finally</code>로 예외처리를 하는 전형적인 구조를 확장함수로 만들어놓았음</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@InlineOnly</span></span><br><span class=\"line\"><span class=\"meta\">@RequireKotlin(<span class=\"meta-string\">&quot;1.2&quot;</span>, versionKind = RequireKotlinVersionKind.COMPILER_VERSION, message = <span class=\"meta-string\">&quot;Requires newer compiler version to be inlined correctly.&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T : Closeable?, R&gt;</span> T.<span class=\"title\">use</span><span class=\"params\">(block: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">R</span>)</span></span>: R &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> exception: Throwable? = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> block(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e: Throwable) &#123;</span><br><span class=\"line\">        exception = e</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">when</span> &#123;</span><br><span class=\"line\">            apiVersionIsAtLeast(<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>) -&gt; <span class=\"keyword\">this</span>.closeFinally(exception)</span><br><span class=\"line\">            <span class=\"keyword\">this</span> == <span class=\"literal\">null</span> -&gt; &#123;&#125;</span><br><span class=\"line\">            exception == <span class=\"literal\">null</span> -&gt; close()</span><br><span class=\"line\">            <span class=\"keyword\">else</span> -&gt;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    close()</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (closeException: Throwable) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// cause.addSuppressed(closeException) // ignored here</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get10LongestWordsInDictionary</span><span class=\"params\">()</span></span> = File(<span class=\"string\">&quot;/usr/share/dict/words&quot;</span>).useLines &#123; line -&gt;</span><br><span class=\"line\">    <span class=\"comment\">// line type Kotlin Sequence</span></span><br><span class=\"line\">    line.filter &#123; it.length &gt; <span class=\"number\">20</span> &#125;</span><br><span class=\"line\">        .sortedByDescending &#123; it.length &#125;</span><br><span class=\"line\">        .take(<span class=\"number\">10</span>)</span><br><span class=\"line\">        .toList()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"레시피-10-2-파일에-기록하기\"><a href=\"#레시피-10-2-파일에-기록하기\" class=\"headerlink\" title=\"레시피 10.2 - 파일에 기록하기\"></a>레시피 10.2 - 파일에 기록하기</h4><ul>\n<li>본문 전체를 다시 쓰고 싶다면 <code>writeText</code>, 붙여쓰고 싶다면 <code>appendText</code></li>\n<li>위 확장함수도 역시, <code>FileOutputStream(this).use &#123; it.write(array) &#125;</code> 확장함수에게 처리를 위임<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> file = File(<span class=\"string\">&quot;./myfile.txt&quot;</span>)</span><br><span class=\"line\">file.writeText(<span class=\"string\">&quot;Data&quot;</span>)</span><br><span class=\"line\">file.appendText(<span class=\"string\">&quot;\\nHello&quot;</span>)</span><br><span class=\"line\">file.appendText(<span class=\"string\">&quot;\\nWorld&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"11장\"><a href=\"#11장\" class=\"headerlink\" title=\"11장\"></a>11장</h2><h4 id=\"레시피-11-1-코틀린-버전-알아내기\"><a href=\"#레시피-11-1-코틀린-버전-알아내기\" class=\"headerlink\" title=\"레시피 11.1 - 코틀린 버전 알아내기\"></a>레시피 11.1 - 코틀린 버전 알아내기</h4><ul>\n<li><code>KotlinVersion.CURRENT</code>을 참조하면 시멘틱버져닝 형태의 코틀린 버젼 값을 알아낼 수 있음.</li>\n<li><code>KotlinVersion</code>의 구현을 살펴보면 쉽게 알 수 있지만, Comparable 인터페이스를 구현하고 있으므로 비교가 가능<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(<span class=\"string\">&quot;version = <span class=\"subst\">$&#123;KotlinVersion.CURRENT&#125;</span>&quot;</span>)</span><br><span class=\"line\">println(<span class=\"string\">&quot;<span class=\"subst\">$&#123;KotlinVersion.CURRENT &lt; KotlinVersion(major = <span class=\"number\">1</span>, minor = <span class=\"number\">2</span>)&#125;</span>&quot;</span>)</span><br><span class=\"line\">println(<span class=\"string\">&quot;<span class=\"subst\">$&#123;KotlinVersion.CURRENT &lt; KotlinVersion(major = <span class=\"number\">1</span>, minor = <span class=\"number\">2</span>, patch = <span class=\"number\">41</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"레시피-11-2-반복적으로-람다-실행하기\"><a href=\"#레시피-11-2-반복적으로-람다-실행하기\" class=\"headerlink\" title=\"레시피 11.2 - 반복적으로 람다 실행하기\"></a>레시피 11.2 - 반복적으로 람다 실행하기</h4><ul>\n<li><code>repeat</code> 확장함수를 사용하면, 인자로 넘어가는 람다 구문이 지정한 횟수만큼 실행됨.</li>\n<li><code>contract</code>: 컴파일러에게 함수의 호출횟수와 타입캐스팅을 도와주기위해 도입</li>\n<li><code>@InlineOnly</code>: 자바 상호 운용을 할때, 자바쪽에서 해당 구현을 참조하지 못하도록 마킹 역할 수행</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@kotlin</span>.<span class=\"keyword\">internal</span>.InlineOnly</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">repeat</span><span class=\"params\">(times: <span class=\"type\">Int</span>, action: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    contract &#123; callsInPlace(action) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (index <span class=\"keyword\">in</span> <span class=\"number\">0</span> until times) &#123;</span><br><span class=\"line\">        action(index)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"레시피-11-3-완벽한-When-강제하기\"><a href=\"#레시피-11-3-완벽한-When-강제하기\" class=\"headerlink\" title=\"레시피 11.3 - 완벽한 When 강제하기\"></a>레시피 11.3 - 완벽한 When 강제하기</h4><ul>\n<li>코틀린에서의 <code>When</code>절은 문과 식의 역할을 모두 할 수 있다.</li>\n<li>식으로 사용하는 경우, <code>else</code>까지 붙여 완벽한 형태로 사용해야 함.</li>\n<li>문으로 사용할 경우, 완벽하게 else까지 붙여서 사용할 수 있도록 강제도 할 수 있음. <code>exhaustive</code> 확장 속성을 추가하면 가능하다.<ul>\n<li><em>TODO: Kotlin 1.3.72 환경에서 구문 에러가 발생.</em><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">printMod3</span><span class=\"params\">(n: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">when</span> (n % <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        <span class=\"number\">1</span> -&gt; println(<span class=\"string\">&quot;<span class=\"variable\">$n</span> % 3 = 0&quot;</span>)</span><br><span class=\"line\">        <span class=\"number\">2</span> -&gt; println(<span class=\"string\">&quot;<span class=\"variable\">$n</span> % 3 = 1&quot;</span>)</span><br><span class=\"line\">        <span class=\"number\">3</span> -&gt; println(<span class=\"string\">&quot;<span class=\"variable\">$n</span> % 3 = 2&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">printMod3SingleStatement</span><span class=\"params\">(n: <span class=\"type\">Int</span>)</span></span> = <span class=\"keyword\">when</span> (n % <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span> -&gt; println(<span class=\"string\">&quot;<span class=\"variable\">$n</span> % 3 = 0&quot;</span>)</span><br><span class=\"line\">    <span class=\"number\">2</span> -&gt; println(<span class=\"string\">&quot;<span class=\"variable\">$n</span> % 3 = 1&quot;</span>)</span><br><span class=\"line\">    <span class=\"number\">3</span> -&gt; println(<span class=\"string\">&quot;<span class=\"variable\">$n</span> % 3 = 2&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span> -&gt; println(<span class=\"string\">&quot;problems&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"레시피-11-4-정규표현식과-함께-replace-함수-사용하기\"><a href=\"#레시피-11-4-정규표현식과-함께-replace-함수-사용하기\" class=\"headerlink\" title=\"레시피 11.4 - 정규표현식과 함께 replace 함수 사용하기\"></a>레시피 11.4 - 정규표현식과 함께 replace 함수 사용하기</h4><ul>\n<li><p>문자열 중 부분 문자열을 수정하고 싶을 경우 <code>replace</code>함수를 사용.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> String.<span class=\"title\">replace</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    oldValue: <span class=\"type\">String</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    newValue: <span class=\"type\">String</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    ignroeCase: <span class=\"type\">Boolean</span> = <span class=\"literal\">false</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: String</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> CharSequence.<span class=\"title\">replace</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    regex: <span class=\"type\">Regex</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    replacement: <span class=\"type\">String</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: String</span><br></pre></td></tr></table></figure></li>\n<li><p>1)의 <code>replace</code>의 경우 자바의 replaceAll과 동일</p>\n</li>\n<li><p>2)의 <code>replace</code>의 경우 첫 번째 인자의 타입의 Regex를 받기 때문에 1)과는 전혀 다른 메소드</p>\n</li>\n<li><p>아래는 간단한 회문(Palindrome) 예제</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isPal</span><span class=\"params\">(string: <span class=\"type\">String</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> testString = string</span><br><span class=\"line\">            .toLowerCase()</span><br><span class=\"line\">            .replace(<span class=\"string\">&quot;&quot;&quot;[\\W+]&quot;&quot;&quot;</span>.toRegex(), <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> testString == testString.reversed()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> String.<span class=\"title\">isPalindrome</span><span class=\"params\">()</span></span> = <span class=\"keyword\">this</span>.toLowerCase()</span><br><span class=\"line\">        .replace(<span class=\"string\">&quot;&quot;&quot;[\\W+]&quot;&quot;&quot;</span>.toRegex(), <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">        .let &#123; it == it.reversed() &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"레시피-11-5-바이너리-문자열로-변환하고-되돌리기\"><a href=\"#레시피-11-5-바이너리-문자열로-변환하고-되돌리기\" class=\"headerlink\" title=\"레시피 11.5 - 바이너리 문자열로 변환하고 되돌리기\"></a>레시피 11.5 - 바이너리 문자열로 변환하고 되돌리기</h4><ul>\n<li>숫자를 바이너리 문자열로, 바이너리 문자열을 다시 숫자로 파싱할때 <code>toString(radix = 2)</code>, <code>toInt(radix = 2)</code>와 같은 함수를 사용하면 쉽게 가능<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> `paddedBinaryString`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> strings = (<span class=\"number\">0.</span><span class=\"number\">.15</span>)</span><br><span class=\"line\">            .map &#123; it.toString(radix = <span class=\"number\">2</span>)</span><br><span class=\"line\">            .padStart(<span class=\"number\">4</span>, <span class=\"string\">&#x27;0&#x27;</span>) &#125;</span><br><span class=\"line\">    assertEquals(strings, listOf(</span><br><span class=\"line\">            <span class=\"string\">&quot;0000&quot;</span>, <span class=\"string\">&quot;0001&quot;</span>, <span class=\"string\">&quot;0010&quot;</span>, <span class=\"string\">&quot;0011&quot;</span>, <span class=\"string\">&quot;0100&quot;</span>, <span class=\"string\">&quot;0101&quot;</span>, <span class=\"string\">&quot;0110&quot;</span>, <span class=\"string\">&quot;0111&quot;</span>, <span class=\"string\">&quot;1000&quot;</span>, <span class=\"string\">&quot;1001&quot;</span>, <span class=\"string\">&quot;1010&quot;</span>, <span class=\"string\">&quot;1011&quot;</span>, <span class=\"string\">&quot;1100&quot;</span>, <span class=\"string\">&quot;1101&quot;</span>, <span class=\"string\">&quot;1110&quot;</span>, <span class=\"string\">&quot;1111&quot;</span></span><br><span class=\"line\">    ))</span><br><span class=\"line\"></span><br><span class=\"line\">    assertEquals(strings.map &#123; it.toInt(<span class=\"number\">2</span>) &#125;, listOf(</span><br><span class=\"line\">            <span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>,<span class=\"number\">14</span>,<span class=\"number\">15</span></span><br><span class=\"line\">    ))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"레시피-11-6-실행-가능한-클래스-만들기\"><a href=\"#레시피-11-6-실행-가능한-클래스-만들기\" class=\"headerlink\" title=\"레시피 11.6 - 실행 가능한 클래스 만들기\"></a>레시피 11.6 - 실행 가능한 클래스 만들기</h4><ul>\n<li>클래스에서 <code>invoke</code> 연산자를 오버로딩 한다.</li>\n<li>코틀린은 연산자 오버로딩을 기본으로 지원하고 있으며, 지원하는 <a href=\"https://kotlinlang.org/docs/reference/operator-overloading.html\">링크</a> 참고하면 된다.</li>\n<li>아래는 오픈 API를 호출하여 JSON 응답을 Gson을 통하여 역직렬화 하는 예제이며, 이에 대한 실행은 <code>invoke</code> 연산자를 통하여 실행한다.</li>\n<li>아래 코드를 보면 잘 알겠지만, 클래스를 인스턴스화하면 invoke 함수를 바로 호출하는 것이 가능하며, 필요하다면 메소드에 인자를 추가하는 것도 가능하다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AstroResult</span> </span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> message: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> number: Number,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> people: List&lt;Assignment&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Assignment</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> craft: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> name: String</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AstroRequest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> gson = Gson()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">operator</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">invoke</span><span class=\"params\">()</span></span>: AstroResult = (</span><br><span class=\"line\">        gson.fromJson(URL(<span class=\"string\">&quot;http://api.open-notify.org/astros.json&quot;</span>)</span><br><span class=\"line\">            .readText(), AstroResult::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> `AstroRequest Test`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result = AstroRequest()()</span><br><span class=\"line\">    assertThat(result.message, `<span class=\"keyword\">is</span>`(<span class=\"string\">&quot;success&quot;</span>))</span><br><span class=\"line\">    assertThat(result.number.toInt(), greaterThanOrEqualTo(<span class=\"number\">0</span>))</span><br><span class=\"line\">    assertThat(result.people.size, `<span class=\"keyword\">is</span>`(result.number.toInt()))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"레시피-11-7-경과-시간-측정하기\"><a href=\"#레시피-11-7-경과-시간-측정하기\" class=\"headerlink\" title=\"레시피 11.7 - 경과 시간 측정하기\"></a>레시피 11.7 - 경과 시간 측정하기</h4><ul>\n<li><code>measureTimeMills</code> 혹은 <code>measureNanoTime</code>를 사용한다.</li>\n<li>위 함수들은 람다를 인자로 받기 때문에 고차 함수이며 <code>inline</code>으로 선언 되어 있다. 실제 실행은 <code>System.currentTimeMillis</code> 메소드에게 위임한다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">measureTimeMillis</span><span class=\"params\">(block: () -&gt; <span class=\"type\">Unit</span>)</span></span>: <span class=\"built_in\">Long</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> start = System.currentTimeMillis()</span><br><span class=\"line\">    block()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> System.currentTimeMillis() - start</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doubleIt</span><span class=\"params\">(x: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">100L</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;doubling <span class=\"variable\">$x</span> with on thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">exec</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;<span class=\"subst\">$&#123;Runtime.getRuntime().availableProcessors()&#125;</span> processors&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> time = measureTimeMillis &#123;</span><br><span class=\"line\">        IntStream.rangeClosed(<span class=\"number\">1</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">                .map &#123; doubleIt(it) &#125;</span><br><span class=\"line\">                .sum()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Sequential stream took <span class=\"subst\">$&#123;time&#125;</span>ms&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    time = measureTimeMillis &#123;</span><br><span class=\"line\">        IntStream.rangeClosed(<span class=\"number\">1</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">                .parallel()</span><br><span class=\"line\">                .map &#123; doubleIt(it) &#125;</span><br><span class=\"line\">                .sum()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Parallel stream took <span class=\"subst\">$&#123;time&#125;</span>ms&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>IntStream</code>을 사용하여 sum을 구하는 예제이며, Parallel로 돌렸을때와 Sequential로 돌렸을 때의 경과 시간 측정을 위해 작성했다.</li>\n</ul>\n<h4 id=\"레시피-11-8-스레드-시작하기\"><a href=\"#레시피-11-8-스레드-시작하기\" class=\"headerlink\" title=\"레시피 11.8 - 스레드 시작하기\"></a>레시피 11.8 - 스레드 시작하기</h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">thread</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    start: <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    isDaemon: <span class=\"type\">Boolean</span> = <span class=\"literal\">false</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    contextClassLoader: <span class=\"type\">ClassLoader</span>? = <span class=\"literal\">null</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    name: <span class=\"type\">String</span>? = <span class=\"literal\">null</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    priority: <span class=\"type\">Int</span> = <span class=\"number\">-1</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    block: () -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: Thread</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>코틀린은 스레드를 쉽게 생성하고 시작할 수 있도록 확장 함수를 제공함.</li>\n<li>잔여 스레드가 모두 데몬 스레드일 경우, 어플리케이션은 종료된다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">threadStart</span><span class=\"params\">(isDaemon: <span class=\"type\">Boolean</span> = <span class=\"literal\">false</span>, isJoin: <span class=\"type\">Boolean</span> = <span class=\"literal\">false</span>)</span></span> = (<span class=\"number\">0.</span><span class=\"number\">.5</span>).forEach &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sleepTime = Random.nextLong(<span class=\"number\">0.</span>.<span class=\"number\">1000L</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> thread = thread(isDaemon = isDaemon) &#123;</span><br><span class=\"line\">        Thread.sleep(sleepTime)</span><br><span class=\"line\">        println(<span class=\"string\">&quot;<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span> for <span class=\"variable\">$it</span> after <span class=\"variable\">$sleepTime</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isJoin) thread.join()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>5개의 스레드를 생성하는 예제이며, 데몬스레드 유무에 따라 바로 종료될수도 아닐수도 있는 코드이다.</li>\n<li>순차 실행을 원한다면 <code>join()</code> 메소드를 사용</li>\n</ul>\n<h4 id=\"레시피-11-9-TODO로-완성-강제하기\"><a href=\"#레시피-11-9-TODO로-완성-강제하기\" class=\"headerlink\" title=\"레시피 11.9 - TODO로 완성 강제하기\"></a>레시피 11.9 - TODO로 완성 강제하기</h4><ul>\n<li>함수 구현을 완성하지 않으면 예외를 던지는 TODO 함수를 사용하면 된다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@kotlin</span>.<span class=\"keyword\">internal</span>.InlineOnly</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">TODO</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Nothing</span> = <span class=\"keyword\">throw</span> NotImplementedError()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@kotlin</span>.<span class=\"keyword\">internal</span>.InlineOnly</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">TODO</span><span class=\"params\">(reason: <span class=\"type\">String</span>)</span></span>: <span class=\"built_in\">Nothing</span> = <span class=\"keyword\">throw</span> NotImplementedError(<span class=\"string\">&quot;An operation is not implemented: <span class=\"variable\">$reason</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n<li>함수의 시그니처는 위와 같으며, <code>reason</code>에는 미구현에 대한 사유를 넣어주면 되고, 발생하는 예외는 <code>NotImplementedError</code>가 발생하며 해당 클래스의 상위 클래스와 인터페이스는 <code>Error - Throwable</code> 이다.</li>\n</ul>\n<h4 id=\"레시피-11-10-Random의-무작위-동작-이해하기\"><a href=\"#레시피-11-10-Random의-무작위-동작-이해하기\" class=\"headerlink\" title=\"레시피 11.10 - Random의 무작위 동작 이해하기\"></a>레시피 11.10 - Random의 무작위 동작 이해하기</h4><ul>\n<li>난수 생성은 자바와 같이 Random 클래스를 활용<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> `nextInt with no args gives any int`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> value = Random.nextInt()</span><br><span class=\"line\">    assertTrue(value <span class=\"keyword\">in</span> <span class=\"built_in\">Int</span>.MIN_VALUE..<span class=\"built_in\">Int</span>.MAX_VALUE)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> `nextInt with range gives value between 0 and limit`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> value = Random.nextInt(<span class=\"number\">10</span>)</span><br><span class=\"line\">    assertTrue(value <span class=\"keyword\">in</span> <span class=\"number\">0.</span><span class=\"number\">.10</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> `nextInt with min and max gives value between them`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> value = Random.nextInt(<span class=\"number\">5</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">    assertTrue(value <span class=\"keyword\">in</span> <span class=\"number\">5.</span><span class=\"number\">.10</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> `nextInt with range returns value <span class=\"keyword\">in</span> range`<span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> value = Random.nextInt(<span class=\"number\">7.</span><span class=\"number\">.12</span>)</span><br><span class=\"line\">    assertTrue(value <span class=\"keyword\">in</span> <span class=\"number\">7.</span><span class=\"number\">.12</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>nextInt()</code>의 구현 부분을 살펴보면, 동반 객체에서 추상 클래스에 선언된 모든 메서드를 defaultPlatformRandom에 위임하고 있으며, 해당 defaultPlatformRandom은 internal로 선언되어 있음을 확인할 수 있다. </li>\n<li><a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.random/-random/-default/\">코틀린 문서</a>를 확인해보면 <code>On JVM this generator is thread-safe, its methods can be invoked from multiple threads.</code> 난수 생성 시 스레드 세이프한 성격을 보장한다고 나와 있다.</li>\n</ul>\n<h4 id=\"레시피-11-11-함수-이름에-특수-문자-사용하기\"><a href=\"#레시피-11-11-함수-이름에-특수-문자-사용하기\" class=\"headerlink\" title=\"레시피 11.11 - 함수 이름에 특수 문자 사용하기\"></a>레시피 11.11 - 함수 이름에 특수 문자 사용하기</h4><ul>\n<li>작명하기 아주 어려운 상황 혹은 테스트에서만 사용하는 것을 권한다.</li>\n<li>함수명을 백틱(``)으로 감싸 놓으면 특수 문자 등을 활용할 수 있다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> `nextInt with min and max gives value between them`<span class=\"params\">()</span></span> &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"레시피-11-12-자바에게-예외-알리기\"><a href=\"#레시피-11-12-자바에게-예외-알리기\" class=\"headerlink\" title=\"레시피 11.12 - 자바에게 예외 알리기\"></a>레시피 11.12 - 자바에게 예외 알리기</h4><ul>\n<li>코틀린의 모든 예외는 기본적으로 Unchecked Exception이다. 코틀린 컴파일러가 예외를 강제하지 않으며 굳이 잡는다면 try catch finally로 잡는 방법도 있지만 강제 사항은 아니다.</li>\n<li>자바에서처럼 <code>throws</code>키워드를 사용하여 예외가 발생할 수 있음을 알릴 수 없기 때문에 자바에서 만약 코틀린 코드를 사용한다면 이를 알릴 수 있는 장치가 필요하게 된다. <code>@Throws</code> 어노테이션을 활용하면 이것이 가능하다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Throws(IOException::class)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">houstonWeHaveAProblem</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> IOException(<span class=\"string\">&quot;File or resource not found&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>위와 같이 어노테이션을 사용하게 되면, 자바 컴파일러는 IOException에 대비해야 하는 내용을 알게 된다.</li>\n<li>어노테이션을 명시하지 않고, 만약 자바코드에서 예외를 캐치하려고 한다면 컴파일이 실패하거나 불필요한 코드가 존재한다는 컴파일러 워닝을 만나게 될 것이다.</li>\n<li><code>@Throws</code> 어노테이션의 역할을 다시 정리하자면, 자바/코틀린의 통합을 위해 그리고 코틀린 코드에서 발생하는 예외를 자바 코드에서 대비하기 위해 존재하는 것이다.</li>\n</ul>\n<hr>\n<h2 id=\"12장\"><a href=\"#12장\" class=\"headerlink\" title=\"12장\"></a>12장</h2><h4 id=\"레시피-12-1-확장을-위해-스프링-관리-빈-클래스-오픈하기\"><a href=\"#레시피-12-1-확장을-위해-스프링-관리-빈-클래스-오픈하기\" class=\"headerlink\" title=\"레시피 12.1 - 확장을 위해 스프링 관리 빈 클래스 오픈하기\"></a>레시피 12.1 - 확장을 위해 스프링 관리 빈 클래스 오픈하기</h4><ul>\n<li>스프링에서는 빈으로 관리되는 클래스들 대부분이 프록시 기반으로 작동하게 된다.</li>\n<li>코틀린 클래스는 기본적으로 <code>final</code> 식별자를 달고 나오기 때문에 프록시를 동작이 안되게 된다. 이를 해결하기 위해서는 별도로 <code>kotlin-spring</code> 빌드 플러그인을 사용하여 스프링에서 관리하는 <code>@Component</code>,<br><code>@Service</code>으로 마킹된 클래스들이 확장 가능한 클래스 식별자인 <code>open</code>로 컴파일리 되도록 설정해줘야 한다.<ul>\n<li><code>all-open</code> 플러그인을 사용해도 되지만, 대부분 <code>kotlin-spring</code>플러그인이 커버한다.</li>\n</ul>\n</li>\n<li>프록시는 실제 컴포넌트 메소드 호출을 가로채 호출 전후로 많은 일을 수행하게 된다. 인자에 대한 유효값 체크와 트랜잭션 등이 아주 대표적인 케이스이다. </li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@org</span>.springframework.stereotype.Service </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> <span class=\"keyword\">public</span> <span class=\"keyword\">constructor</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">join</span><span class=\"params\">()</span></span>: kotlin.<span class=\"built_in\">Unit</span> &#123; <span class=\"comment\">/* compiled code */</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>플러그인을 적용하여 코드를 컴파일 결과이다.</li>\n<li><code>@Component</code>, <code>@Async</code>, <code>@Transactional</code>, <code>@Cacheable</code>, <code>@SpringBootTest</code> 들이 open이 되는 마킹 어노테이션들이며 사실상 대부분을 커버한다고 보면 된다. <code>@Component</code>의 경우 이를 사용하는 하위 어노테이션중에 친숙한 <code>@Configuration</code>, <code>@Controller</code>, <code>@RestController</code>, <code>@Service</code>, <code>@Repository</code> 들이 있다.</li>\n</ul>\n<h4 id=\"레시피-12-2-코틀린-data-클래스로-퍼시스턴스-구현하기\"><a href=\"#레시피-12-2-코틀린-data-클래스로-퍼시스턴스-구현하기\" class=\"headerlink\" title=\"레시피 12.2 - 코틀린 data 클래스로 퍼시스턴스 구현하기\"></a>레시피 12.2 - 코틀린 data 클래스로 퍼시스턴스 구현하기</h4><ul>\n<li><p>JPA 관점에서 코틀린 <code>data class</code>는 두 가지 문제가 존재함</p>\n<ul>\n<li><code>data class</code>는 기본 생성자를 만들지 않음.</li>\n<li>불변 속성(<code>val</code>)을 강조하는 data class의 성격</li>\n</ul>\n</li>\n<li><p>기본 생성자를 만드는 부분에 대한 해결책은 <code>no-arg</code> 플러그인을 사용하는 방법이 존재한다.</p>\n<blockquote>\n<p>no-arg 플러그인으로 만든 기본 생성자의 접근 제어자는 <code>public</code>이고, 실제 코드에서는 접근이 불가능하며 리플렉션을 통한 접근만 가능하다고 한다.</p>\n</blockquote>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">  id <span class=\"string\">&quot;org.jetbrains.kotlin.plugin.noarg&quot;</span> version <span class=\"string\">&quot;1.4.10&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">noArg &#123;</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;com.my.Annotation&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>no-arg</code> 플러그인을 활용하는 방법도 좋지만, 빌드 설정에 마킹 어노테이션등을 명시해야 하는 불편함이 존재한다. 이를 개선하여 사용할 수 있는 플러그인이 바로 <code>kotlin-jpa</code> 플러그인이다.</p>\n<ul>\n<li><code>@Entity</code></li>\n<li><code>@Embeddable</code></li>\n<li><code>@MappedSuperClass</code></li>\n</ul>\n</li>\n<li><p><code>data class</code>는 기본적으로 <code>hashCode</code>, <code>equals</code>, <code>toString</code>을 자동생성한다. JPA의 엔티티로 자동생성한 값을 사용하게 될 경우 발생할 수 있는 문제와 아래와 같다.</p>\n<ul>\n<li>양방향 엔티티 바인딩을 사용할 경우, 경우에 따라 순환 참조를 만나게 될 수 있다.</li>\n<li>불변 프로퍼티 사용을 권하는 data class와 다르게 필드 값을 계속 변경해야 하기 때문에 var로 선언해두고 사용해야 하는 JPA의 성격이 매우 상이함.</li>\n</ul>\n</li>\n<li><p>이러한 부분 때문에 차라리 class를 그대로 사용하는 것이 나을 수 있다. 하지만, class도 코틀린에서는 기본적으로 상속이 불가능한 형태인 final 키워드가 붙어져 있는 형태기 때문에, 프록시를 사용하는 JPA-하이버네이트의 상황상 이를 <code>open</code> 클래스로 바꿔줘야 하는 불편함이 생긴다.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id <span class=\"string\">&#x27;org.springframework.boot&#x27;</span> version <span class=\"string\">&#x27;2.3.1.RELEASE&#x27;</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;io.spring.dependency-management&#x27;</span> version <span class=\"string\">&#x27;1.0.9.RELEASE&#x27;</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;org.jetbrains.kotlin.plugin.spring&#x27;</span> version <span class=\"string\">&#x27;1.3.72&#x27;</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;org.jetbrains.kotlin.plugin.jpa&#x27;</span> version <span class=\"string\">&#x27;1.3.72&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">allOpen &#123;</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.Entity&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.MappedSuperclass&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">annotation</span>(<span class=\"string\">&quot;javax.persistence.Embeddable&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>위와 같이, kotlin-jpa 플러그인을 선언하고 open을 할 마킹 어노테이션을 지정해주면 실제로 컴파일한 클래스는 아래와 같다.</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IntelliJ API Decompiler stub source generated from a class file</span></span><br><span class=\"line\"><span class=\"comment\">// Implementation of methods is not available</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> me.daniel.kotlin_in_action</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@javax</span>.persistence.Entity </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">public</span> <span class=\"keyword\">constructor</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">open</span> <span class=\"keyword\">var</span> age: kotlin.<span class=\"built_in\">Long</span>? <span class=\"comment\">/* compiled code */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@field:javax</span>.persistence.Id <span class=\"meta\">@field:javax</span>.persistence.GeneratedValue <span class=\"keyword\">public</span> <span class=\"keyword\">open</span> <span class=\"keyword\">var</span> id: kotlin.<span class=\"built_in\">Long</span>? <span class=\"comment\">/* compiled code */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">open</span> <span class=\"keyword\">var</span> name: kotlin.String <span class=\"comment\">/* compiled code */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"레시피-12-3-의존성-주입하기\"><a href=\"#레시피-12-3-의존성-주입하기\" class=\"headerlink\" title=\"레시피 12.3 - 의존성 주입하기\"></a>레시피 12.3 - 의존성 주입하기</h4><ul>\n<li>스프링에서는 복잡한 의존성 주입 과정 그리고 빈과 빈의 연결을 컨테이너에서 처리해준다.</li>\n<li>코틀린에서는 필드 레벨 빈 의존성 주입을 할 경우 <code>lateinit var</code> 구조를 활용해야 한다. 생성자 기반의 주입도 가능하다.</li>\n<li>생성자 방식의 의존성 주입이 스프링에서 선호하는 의존성 주입 방식이긴 하나, 경우에 따라 필드 레벨의 주입이 필요한 경우도 있다. </li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1)</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceByConstructorInjection</span></span>(<span class=\"keyword\">val</span> contentService: ContentService)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2)</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceByConstructorInjectionWithFieldAutowired</span></span>(<span class=\"meta\">@Autowired</span> <span class=\"keyword\">val</span> contentService: ContentService)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3)</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceByConstructorInjectionWithAutowired</span> <span class=\"meta\">@Autowired</span> <span class=\"keyword\">constructor</span></span>(<span class=\"keyword\">val</span> contentService: ContentService)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4)</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceByFieldLevelInjection</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> contentService: ContentService</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>위와 같이 다양한 형태로 의존성 주입을 받는 것이 가능하다. <code>@Autowired</code>를 굳이 안붙여서도 사용 가능한 1번의 형태가 가장 간편한 방법이고 스프링에서 추천하는 의존성 주입 방식이다.</li>\n</ul>\n<hr>\n<h2 id=\"13장-코루틴과-구조적-동시성\"><a href=\"#13장-코루틴과-구조적-동시성\" class=\"headerlink\" title=\"13장 - 코루틴과 구조적 동시성\"></a>13장 - 코루틴과 구조적 동시성</h2><h4 id=\"레시피-13-1-코루틴-빌더-선택하기\"><a href=\"#레시피-13-1-코루틴-빌더-선택하기\" class=\"headerlink\" title=\"레시피 13.1 - 코루틴 빌더 선택하기\"></a>레시피 13.1 - 코루틴 빌더 선택하기</h4><ul>\n<li><p><code>GlobalScope</code>의 <code>async</code>와 <code>launch</code>는 사용하지 말자</p>\n<ul>\n<li>취소되지 않으면 어플리케이션 전체 수명주기에 걸쳐 실행됨.</li>\n</ul>\n</li>\n<li><p><code>runBlocking</code> 빌더</p>\n  <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">runBlocking</span><span class=\"params\">(context: <span class=\"type\">CoroutineContext</span> = EmptyCoroutineContext, block: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">T</span>)</span></span>: T    </span><br></pre></td></tr></table></figure>\n<ul>\n<li>블록 내 모든 코루틴이 종료될 때까지 현재 스레드를 블록</li>\n<li><code>suspend</code> 키워드가 붙은 함수가 아니기 때문에, 일반 함수에서도 호출 가능</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><code>launch</code> 빌더</p>\n  <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> CoroutineScope.<span class=\"title\">launch</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    context: <span class=\"type\">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    start: <span class=\"type\">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    block: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: Job</span><br></pre></td></tr></table></figure>\n<ul>\n<li>해당값에서 리턴값을 받을 필요가 없을 때 사용</li>\n<li><code>Job</code>을 리턴, 취소 가능</li>\n<li>코루틴 컨텍스트(<code>context</code>)를 지정하여 다른 코루틴과 상태 공유가 가능</li>\n<li><code>start</code> 인자의 열거형으로 <code>DEFAULT</code>, <code>LAZY</code>, <code>ATOMIC</code>, <code>UNDISPATCHED</code> 값을 사용할 수 있다.</li>\n</ul>\n</li>\n<li><p><code>async</code> 빌더</p>\n  <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> CoroutineScope.<span class=\"title\">async</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    context: <span class=\"type\">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    start: <span class=\"type\">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    block: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">T</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: Deferred&lt;T&gt;    </span><br></pre></td></tr></table></figure>\n<ul>\n<li>값을 리턴해야 할 경우 사용</li>\n<li><code>launch</code> 빌더처럼 CoroutineContext와 CoroutineStart 파라미터를 받을 수 있으며, 기본값이 설정되어 있다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">add</span><span class=\"params\">(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(Random.nextLong(<span class=\"number\">1000L</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = coroutineScope &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> firstSum = async &#123;</span><br><span class=\"line\">        println(Thread.currentThread().name)</span><br><span class=\"line\">        add(<span class=\"number\">2</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> secondSum = async &#123;</span><br><span class=\"line\">        println(Thread.currentThread().name)</span><br><span class=\"line\">        add(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Awaiting concurrent sums...&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> total = firstSum.await() + secondSum.await()</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Total is <span class=\"variable\">$total</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DefaultDispatcher-worker-1</span><br><span class=\"line\">Awaiting concurrent sums...</span><br><span class=\"line\">DefaultDispatcher-worker-2</span><br><span class=\"line\">Total is 11</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li>위 예제의 실행 결과를 보면 <code>async</code> 빌더는 기본 디스패처를 사용하는 것을 확인할 수 있다.</li>\n<li><code>delay</code> 함수는 코루틴 실행 스레드를 블록하지 않고 대기 상태로 만든다.</li>\n</ul>\n</li>\n<li><p><code>coroutineScope</code> 빌더</p>\n  <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;R&gt;</span> <span class=\"title\">coroutineScope</span><span class=\"params\">(block: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">R</span>)</span></span>: R &#123;</span><br><span class=\"line\">    contract &#123;</span><br><span class=\"line\">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> coroutine = ScopeCoroutine(uCont.context, uCont)</span><br><span class=\"line\">        coroutine.startUndispatchedOrReturn(coroutine, block)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>coroutineScope</code> 빌더는 함수 종료 전 모든 코루틴이 완료될때까지 기다리는 일수 중단 함수이다. 굳이 코루틴의 완료 유무를 확인할 필요가 없다.</li>\n<li>메인 스레드를 블록하지 않지만, 반드시 다른 일시 중단 함수의 일부로서 호출해야 된다.</li>\n<li>코루틴이 하나라도 실패하면 나머지 코루틴을 취소하며, 완료 유무를 확인하지 않고 균형 있는 제어와 에러 처리를 달성하고 루틴이 실패하는 경우를 처리하지 않는 것을 방지한다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"레시피-13-2-async-await를-withContext로-변경하기\"><a href=\"#레시피-13-2-async-await를-withContext로-변경하기\" class=\"headerlink\" title=\"레시피 13.2 - async/await를 withContext로 변경하기\"></a>레시피 13.2 - async/await를 withContext로 변경하기</h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">withContext</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    context: <span class=\"type\">CoroutineContext</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    block: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">T</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>: T    </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>async</code> 코루틴을 시작하고 <code>await</code>로 기다리는 코드를 간소화하고 싶다면 <code>withContext</code>로 대체가 가능하다.</li>\n<li>공식 문서에서는 <strong>주어진 코루틴 컨텍스트와 함께 명시한 일시정지 블록을 호출하고, 완료될 떄까지 일시정지한 후에 그 결과를 리턴한다.</strong> 라고 나와 있다. 다시 말해, <code>async ~ await</code>의 호출 구조를 <code>withContext</code>로 단순화하는 것이 가능하다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">retrieve1</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span> = coroutineScope &#123;</span><br><span class=\"line\">    async(Dispatchers.IO) &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Retrieving data on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">        delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">        <span class=\"string\">&quot;asyncResults&quot;</span></span><br><span class=\"line\">    &#125;.await()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">retrieve2</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Retrieving data on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">    delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">    <span class=\"string\">&quot;asyncResults&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result1 = retrieve1(<span class=\"string\">&quot;www.mysite.com&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result2 = retrieve2(<span class=\"string\">&quot;www.mysite.com&quot;</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;printing result on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span> <span class=\"variable\">$result1</span>&quot;</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;printing result on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span> <span class=\"variable\">$result2</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrieving data on DefaultDispatcher-worker-1</span><br><span class=\"line\">Retrieving data on DefaultDispatcher-worker-1</span><br><span class=\"line\">printing result on main asyncResults</span><br><span class=\"line\">printing result on main asyncResults</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><p><code>retrieve1</code>과 같이 메소드를 작성하게 되면 Intellij에서 <code>merge call chain to &#39;withContext&#39;</code>라는 문구와 함께 withContext로 대체 할 것을 제안하는 것을 확인할 수 있다.</p>\n</li>\n<li><p>각 suspend 함수는 기본 디스패처에서 호출이 되며, 메인 스레드 메인 함수에서 <code>await</code> 호출 없이 결과를 받아 오는 것을 확인할 수 있다.</p>\n</li>\n</ul>\n<h4 id=\"레시피-13-3-디스패처-사용하기\"><a href=\"#레시피-13-3-디스패처-사용하기\" class=\"headerlink\" title=\"레시피 13.3 - 디스패처 사용하기\"></a>레시피 13.3 - 디스패처 사용하기</h4><ul>\n<li>IO 혹은 다른 작업을 위한 전용 스레드풀을 이용할 때는 <code>Dispatchers</code> 클래스의 적당한 디스패처를 골라 사용하면 된다.</li>\n<li>코루틴은 <code>CorutineContext</code> 컨텍스트 내에서 실행되며 코루틴 컨텍스트에는 <code>CoroutineDispatcher</code> 클래스의 인스턴스가 포함되어 있다. </li>\n<li><strong>디스패처의 역할은 코루틴이 어떤 스레드에서 혹은 어떤 스레드풀에서 실행할지를 결정한다.</strong> 디스패처의 종류는 아래와 같다.<ul>\n<li>IO:  File IO 혹은 Network IO와 같은 IO Intensive 작업을 위해 디자인된 디스패처이며, On-Demand 공유 풀을 사용한다.</li>\n<li>Default:  공유 백그라운드 스레드풀을 사용하며, CPU Bound 상황에 어울린다.</li>\n<li>Unconfined</li>\n</ul>\n</li>\n<li>디스패처의 명시는 <code>async</code>, <code>launch</code>, <code>withContext</code>의 호출 인자에 넘겨서 지정하는 것이 가능하다.</li>\n</ul>\n<h4 id=\"레시피-13-4-자바-스레드-풀에서-코루틴-실행하기\"><a href=\"#레시피-13-4-자바-스레드-풀에서-코루틴-실행하기\" class=\"headerlink\" title=\"레시피 13.4 - 자바 스레드 풀에서 코루틴 실행하기\"></a>레시피 13.4 - 자바 스레드 풀에서 코루틴 실행하기</h4><ul>\n<li>자바의 <code>ExecutorService</code>의 <code>asCoroutineDispatcher</code> 확장 함수 호출을 통해 코루틴의 스레드풀 생성이 가능하다. </li>\n<li><code>asCoroutineDispatcher</code> 함수는 <code>ExecutorService</code>의 인스턴스를 <code>ExecutorCoroutineDispatcher</code>의 구현으로 변환한다. </li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExecutorCoroutineDispatcher</span>: <span class=\"type\">CoroutineDispatcher</span></span>(), Closeable &#123;</span><br><span class=\"line\">    <span class=\"comment\">/** <span class=\"doctag\">@suppress</span> */</span></span><br><span class=\"line\">    <span class=\"meta\">@ExperimentalStdlibApi</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> Key : AbstractCoroutineContextKey&lt;CoroutineDispatcher, ExecutorCoroutineDispatcher&gt;(</span><br><span class=\"line\">        CoroutineDispatcher,</span><br><span class=\"line\">        &#123; it <span class=\"keyword\">as</span>? ExecutorCoroutineDispatcher &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">val</span> executor: Executor</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">close</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>ExecutorCoroutineDispatcher</code>는 <code>close</code> 함수를 호출하지 않으면 계속 실행되기 때문에, 해당 함수 호출은 필수다. <code>ExecutorCoroutineDispatcher</code> 클래스는 추상 클래스로 구현 클래스인 <code>ThreadPoolDispatcher</code>의 <code>close</code> 메소드를 살펴보면 ExecutorService의 <code>shutdown</code> 메소드를 호출하는 것을 확인할 수 있다.</li>\n<li><code>Closeable</code> 인터페이스를 구현하여 <code>close</code> 혹은 <code>shutdown</code> 호출에 대한 부분은 해당 인터페이스 구현에 맡겼으며 코틀린에서는 <code>use</code> 블록을 사용하여 사용 후 쉽게 종료가 가능하다. <blockquote>\n<p>자바와 같이 try<del>with</del>resource 구문이 없는 코틀린에서는 Closeable 인터페이스 use를 사용하여 자원 해제를 하게 된다. <a href=\"#10%EC%9E%A5\">링크</a> 참고</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"레시피-13-5-코루틴-취소하기\"><a href=\"#레시피-13-5-코루틴-취소하기\" class=\"headerlink\" title=\"레시피 13.5 - 코루틴 취소하기\"></a>레시피 13.5 - 코루틴 취소하기</h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">jobCancelExec</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    runBlocking &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> job = launch &#123;</span><br><span class=\"line\">            repeat(<span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                println(<span class=\"string\">&quot;Job: I&#x27;m waiting <span class=\"variable\">$it</span>...&quot;</span>)</span><br><span class=\"line\">                delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        delay(<span class=\"number\">500L</span>)</span><br><span class=\"line\">        println(<span class=\"string\">&quot;main: That&#x27;s enough waiting&quot;</span>)</span><br><span class=\"line\">        job.cancel()</span><br><span class=\"line\">        job.join()</span><br><span class=\"line\">        println(<span class=\"string\">&quot;main: Done&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>launch</code>, <code>async</code> 빌더 함수는 공통적으로 Job 타입을 리턴하게 되는데, 해당 타입의 cancel 메소드를 호출하면 해당 잡을 취소하는 것이 가능하다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">jobTimeout</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    runBlocking &#123;</span><br><span class=\"line\">        withTimeout(<span class=\"number\">1000L</span>) &#123;</span><br><span class=\"line\">            repeat(<span class=\"number\">50</span>) &#123;</span><br><span class=\"line\">                println(<span class=\"string\">&quot;Job: I&#x27;m waiting <span class=\"variable\">$it</span>...&quot;</span>)</span><br><span class=\"line\">                delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">withTimeout</span><span class=\"params\">(timeMillis: <span class=\"type\">Long</span>, block: <span class=\"type\">suspend</span> <span class=\"type\">CoroutineScope</span>.() -&gt; <span class=\"type\">T</span>)</span></span>: T</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>withTimeout</code> 혹은 <code>withTimeoutOrNull</code>과 같은 메소드를 호출하여 취소하는 것도 가능하며, 타임아웃이 초과하면 <code>TimeoutCancellationException</code>이 발생한다.<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Job: I&#x27;m waiting 0...</span><br><span class=\"line\">Job: I&#x27;m waiting 1...</span><br><span class=\"line\">...(생략)</span><br><span class=\"line\">Exception in thread &quot;main&quot; kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1000 ms</span><br><span class=\"line\">\tat kotlinx.coroutines.TimeoutKt.TimeoutCancellationException(Timeout.kt:158)</span><br><span class=\"line\">\tat kotlinx.coroutines.TimeoutCoroutine.run(Timeout.kt:128)</span><br><span class=\"line\">\tat kotlinx.coroutines.EventLoopImplBase$DelayedRunnableTask.run(EventLoop.common.kt:497)</span><br><span class=\"line\">\tat kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:274)</span><br><span class=\"line\">\tat kotlinx.coroutines.DefaultExecutor.run(DefaultExecutor.kt:68)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>\n<h4 id=\"레시피-13-6-코루틴-디버깅\"><a href=\"#레시피-13-6-코루틴-디버깅\" class=\"headerlink\" title=\"레시피 13.6 - 코루틴 디버깅\"></a>레시피 13.6 - 코루틴 디버깅</h4></li>\n<li>JVM의 실행 플래그(<code>-Dkotlinx.coroutines.debug</code>)를 추가하면 코루틴 이름등과 같은 실행정보를 확인할 수 있다. Intelli에서는 VM Options에 해당 플래그 값을 추가하면 된다.</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">retrieve1</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span> = coroutineScope &#123;</span><br><span class=\"line\">    async(Dispatchers.IO) &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Retrieving data on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">        delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">        <span class=\"string\">&quot;asyncResults&quot;</span></span><br><span class=\"line\">    &#125;.await()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">retrieve2</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Retrieving data on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">    delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">    <span class=\"string\">&quot;asyncResults&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result1 = retrieve1(<span class=\"string\">&quot;www.mysite.com&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result2 = retrieve2(<span class=\"string\">&quot;www.mysite.com&quot;</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;printing result on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span> <span class=\"variable\">$result1</span>&quot;</span>)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;printing result on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span> <span class=\"variable\">$result2</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrieving data on DefaultDispatcher-worker-1 @coroutine#2</span><br><span class=\"line\">Retrieving data on DefaultDispatcher-worker-1 @coroutine#1</span><br><span class=\"line\">printing result on main @coroutine#1 asyncResults</span><br><span class=\"line\">printing result on main @coroutine#1 asyncResults</span><br></pre></td></tr></table></figure>\n<ul>\n<li>스레드 이름 뒤에 <code>@coroutine#2</code>가 붙은 것을 확인할 수 있는데, <code>CoroutineName</code> 클래스를 사용하여 직접 이름을 붙이는 것도 가능하다. 위 코드에서 <code>retrieve1</code>, <code>retrieve2</code>의 컨텍스트를 인자 부분을 아래와 같이 수정하면 된다.<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">retrieve1</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span> = coroutineScope &#123;</span><br><span class=\"line\">    async(Dispatchers.IO + CoroutineName(name = <span class=\"string\">&quot;async&quot;</span>)) &#123;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Retrieving data on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">        delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">        <span class=\"string\">&quot;asyncResults&quot;</span></span><br><span class=\"line\">    &#125;.await()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">retrieve2</span><span class=\"params\">(url: <span class=\"type\">String</span>)</span></span> = withContext(Dispatchers.IO + CoroutineName(name = <span class=\"string\">&quot;withContext&quot;</span>)) &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Retrieving data on <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">    delay(<span class=\"number\">100L</span>)</span><br><span class=\"line\">    <span class=\"string\">&quot;asyncResults&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// coroutine이라는 이름 대신 지정한 이름을 노출</span><br><span class=\"line\">Retrieving data on DefaultDispatcher-worker-1 @async#2</span><br><span class=\"line\">Retrieving data on DefaultDispatcher-worker-1 @withContext#1</span><br><span class=\"line\">printing result on main @coroutine#1 asyncResults</span><br><span class=\"line\">printing result on main @coroutine#1 asyncResults</span><br></pre></td></tr></table></figure>\n"},{"title":"멱등성과 HTTP에 대한 생각","date":"2020-02-04T15:00:00.000Z","_content":"\n## 멱등성과 HTTP에 대한 생각\n> [주의] 틀리다 맞다의 이야기를 하려고 쓰는 글은 아닙니다. \n\n수학 혹은 컴퓨터분야에서 쓰이는 용어라고 한다. 한문과 한글이 평생 부족한 나로서는 뭔말인가 싶어서 열심히 구글링을 해봤다. **\"연산을 여러번 하더라도 결과가 달라지지 않는 성질\"** 이라는 정의라고 한다. 대부분의 포스트에서 HTTP Method를 예를 들어 설명하는데 이해가 안가는 부분이 있었다. `HTTP GET, PUT, DELETE 등은 멱등성을 유지하는 반면 POST는 유지하지 못한다`라는 구절이었는데, 자세히 그 내막(?)을 살펴보고자 한다.\n\n**결과가 달라지지 않는다고?**\n\n예를 들어 상품을 조회하는 HTTP API가 있다고 가정하자\n```http\nHTTP GET /products\n200 OK\n{\n\t\"productName\": \"상품명\",\n\t\"price\": 25000,\n\t....\n}\n```\n\n위의 JSON 결과에서 상품명과 가격은 외부 요인에 의하여 얼마든지 바뀔 수 있는 결과이다. 그렇다면 한번 호출한 결과와 여러 번 호출한 결과가 다를 수도 있다는 이야기로 해석이 되는데, `결과적 일관성은 유지하지 못하는거 아닌가?`라는 생각이 들었다. 그렇다면 조금 다른 예로 생각을 해보려고 한다.\n\n특정 사용자를 조회하는 HTTP API가 있다고 가정해보자.\n```json\nGET /users/1 HTTP/1.1\n200 OK\n\n{\n\t\"userName\": \"Ryan\",\n\t\"tel\": 010-0000-1111,\n\t....\n}\n```\n사용자 키(`1`)를 기준으로 사용자의 프로필 비슷한 내용을 조회하는 API이다. 만약, 리소스에 대한 접근(변경,삭제)을 해당 키에 대한 리소스 오너만 할 수 있는 상황이라면 위에서 설명한 멱등성이 보장될 수 있다고 판단된다. \n그렇다면 멱등성이라는 성질을 HTTP API를 통하여 접근하는 리소스에 비춰 생각해봤을 때, 리소스에 접근할 수 있는 범위 혹은 스코프가 어떻게 되느냐에 따라서 결과적 멱등성 여부가 달라지지 않을지지 않을까 라는 조심스러운 생각이 들었다.\n\n**그렇다면 인터넷에 돌아다니는 여러 글과 포스트들은 잘못된 이야기를 하고 있는 것일까?**\n\n 아마 멱등성이라는 의미가 협의보다는 광의로서 `구조` 또는 `효과` 측면에서의 동일함을 가리키지 않나라는 생각이 들었다. 앞서 설명한 두 개의 API는 특별한 제약 조건이 없는 상황이라면 동일한 응답 스트럭쳐와 동일한 HTTP Response를 가지게 될 것이고, 서버에서도 동일한 상태를 유지하게 될 것이다. 결과적으로 세세한 응답 하나하나의 결과적 멱등성을 가리키는 용어가 아닌 `구조 혹은 효과`의 측면에서 동일함을 유지해야 한다 라고 정리할 수 있을거 같다. \n\n 여기까지 순전히 GET에 대한 이야기만 했다. 그렇다면 `리소스에 대한 추가/변경/삭제 오퍼레이션에 해당하는 POST, PUT, DELETE는 어떻게 이해하면 좋을까?` \n\n```json\nPOST /users HTTP/1.1\n\n{\n\t\"userName\": \"Ryan\",\n\t\"tel\": 010-0000-1111,\n}\n```\n\n이번에는 사용자 리소스를 생성하는 API로 설명해보려고 한다. 해당 API는 처음 호출한 결과와 두 번째 호출한 결과가 명확하게 달라져야 정상이다. \n\n첫 번째의 경우 응답은 201 Created 혹은 200 OK가 올 것이고 두 번째 호출 결과는 400 Bad Request(통신 자체는 성공했으니 2XX로 해석하는 것도 가능하다. 의견이 분분한 부분이다.) 혹은 200 OK의 응답은 오지만 첫 번째의 응답 결과와 결코 같을 수는 없을 것이다. 하지만, 세 번째 그리고 N번째 호출까지는 모든 응답이 두 번째 호출과 동일한 상황일 것이다. 이렇다면 위에서 말한 `구조 혹은 효과` 측면에서는 동일함을 유지하는 것이라고 생각할 수 있지 않을까? \n\n만약, 사용자를 등록하는 API가 아니라 매번 리소스를 생성하는 API가 있다고 하더라도 구조와 효과적인 측면에서 매번 동일할테니 이거 역시 멱등성을 유지한다고 봐도 무관하지 않을까? 라는 생각이 들었다.\n\n이 글을 혹시나 보는 사람은 `뭐 이런 억지...`라고 생각할지도 모르겠다. 하지만 HTTP RFC 명세를 살펴보면 아래와 같이 명시하고 있는 부분이 있다.\n![스크린샷 2020-03-05 오전 2.08.56](https://i.imgur.com/Ys17CKV.png)\n\n아마 스펙에서 말하는 멱등한 성격에 대해 정확한 이해가 부족하여 이런 일과 생각이 벌어지지 않았나 하는 생각이 든다. 하지만 스펙은 스펙일뿐 꼭 지켜야 하는 건 아니라고 생각한다.\n\n차라리 멱등성을 설명하는 좋은 예는 아마 함수형 프로그래밍에서 말하는 순수 함수 혹은 참조 투명성과 같은 개념이 더 어울리지 않나...하는 생각이 든다.\n\n### 참고 리소스\n- https://restfulapi.net/idempotent-rest-apis/\n- https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99\n- https://developer.mozilla.org/ko/docs/Glossary/Idempotent","source":"_posts/HTTP/Idempotent.md","raw":"---\ntitle: 멱등성과 HTTP에 대한 생각\ndate: 2020/2/5 00:00:00\ncategories:\n- HTTP\n---\n\n## 멱등성과 HTTP에 대한 생각\n> [주의] 틀리다 맞다의 이야기를 하려고 쓰는 글은 아닙니다. \n\n수학 혹은 컴퓨터분야에서 쓰이는 용어라고 한다. 한문과 한글이 평생 부족한 나로서는 뭔말인가 싶어서 열심히 구글링을 해봤다. **\"연산을 여러번 하더라도 결과가 달라지지 않는 성질\"** 이라는 정의라고 한다. 대부분의 포스트에서 HTTP Method를 예를 들어 설명하는데 이해가 안가는 부분이 있었다. `HTTP GET, PUT, DELETE 등은 멱등성을 유지하는 반면 POST는 유지하지 못한다`라는 구절이었는데, 자세히 그 내막(?)을 살펴보고자 한다.\n\n**결과가 달라지지 않는다고?**\n\n예를 들어 상품을 조회하는 HTTP API가 있다고 가정하자\n```http\nHTTP GET /products\n200 OK\n{\n\t\"productName\": \"상품명\",\n\t\"price\": 25000,\n\t....\n}\n```\n\n위의 JSON 결과에서 상품명과 가격은 외부 요인에 의하여 얼마든지 바뀔 수 있는 결과이다. 그렇다면 한번 호출한 결과와 여러 번 호출한 결과가 다를 수도 있다는 이야기로 해석이 되는데, `결과적 일관성은 유지하지 못하는거 아닌가?`라는 생각이 들었다. 그렇다면 조금 다른 예로 생각을 해보려고 한다.\n\n특정 사용자를 조회하는 HTTP API가 있다고 가정해보자.\n```json\nGET /users/1 HTTP/1.1\n200 OK\n\n{\n\t\"userName\": \"Ryan\",\n\t\"tel\": 010-0000-1111,\n\t....\n}\n```\n사용자 키(`1`)를 기준으로 사용자의 프로필 비슷한 내용을 조회하는 API이다. 만약, 리소스에 대한 접근(변경,삭제)을 해당 키에 대한 리소스 오너만 할 수 있는 상황이라면 위에서 설명한 멱등성이 보장될 수 있다고 판단된다. \n그렇다면 멱등성이라는 성질을 HTTP API를 통하여 접근하는 리소스에 비춰 생각해봤을 때, 리소스에 접근할 수 있는 범위 혹은 스코프가 어떻게 되느냐에 따라서 결과적 멱등성 여부가 달라지지 않을지지 않을까 라는 조심스러운 생각이 들었다.\n\n**그렇다면 인터넷에 돌아다니는 여러 글과 포스트들은 잘못된 이야기를 하고 있는 것일까?**\n\n 아마 멱등성이라는 의미가 협의보다는 광의로서 `구조` 또는 `효과` 측면에서의 동일함을 가리키지 않나라는 생각이 들었다. 앞서 설명한 두 개의 API는 특별한 제약 조건이 없는 상황이라면 동일한 응답 스트럭쳐와 동일한 HTTP Response를 가지게 될 것이고, 서버에서도 동일한 상태를 유지하게 될 것이다. 결과적으로 세세한 응답 하나하나의 결과적 멱등성을 가리키는 용어가 아닌 `구조 혹은 효과`의 측면에서 동일함을 유지해야 한다 라고 정리할 수 있을거 같다. \n\n 여기까지 순전히 GET에 대한 이야기만 했다. 그렇다면 `리소스에 대한 추가/변경/삭제 오퍼레이션에 해당하는 POST, PUT, DELETE는 어떻게 이해하면 좋을까?` \n\n```json\nPOST /users HTTP/1.1\n\n{\n\t\"userName\": \"Ryan\",\n\t\"tel\": 010-0000-1111,\n}\n```\n\n이번에는 사용자 리소스를 생성하는 API로 설명해보려고 한다. 해당 API는 처음 호출한 결과와 두 번째 호출한 결과가 명확하게 달라져야 정상이다. \n\n첫 번째의 경우 응답은 201 Created 혹은 200 OK가 올 것이고 두 번째 호출 결과는 400 Bad Request(통신 자체는 성공했으니 2XX로 해석하는 것도 가능하다. 의견이 분분한 부분이다.) 혹은 200 OK의 응답은 오지만 첫 번째의 응답 결과와 결코 같을 수는 없을 것이다. 하지만, 세 번째 그리고 N번째 호출까지는 모든 응답이 두 번째 호출과 동일한 상황일 것이다. 이렇다면 위에서 말한 `구조 혹은 효과` 측면에서는 동일함을 유지하는 것이라고 생각할 수 있지 않을까? \n\n만약, 사용자를 등록하는 API가 아니라 매번 리소스를 생성하는 API가 있다고 하더라도 구조와 효과적인 측면에서 매번 동일할테니 이거 역시 멱등성을 유지한다고 봐도 무관하지 않을까? 라는 생각이 들었다.\n\n이 글을 혹시나 보는 사람은 `뭐 이런 억지...`라고 생각할지도 모르겠다. 하지만 HTTP RFC 명세를 살펴보면 아래와 같이 명시하고 있는 부분이 있다.\n![스크린샷 2020-03-05 오전 2.08.56](https://i.imgur.com/Ys17CKV.png)\n\n아마 스펙에서 말하는 멱등한 성격에 대해 정확한 이해가 부족하여 이런 일과 생각이 벌어지지 않았나 하는 생각이 든다. 하지만 스펙은 스펙일뿐 꼭 지켜야 하는 건 아니라고 생각한다.\n\n차라리 멱등성을 설명하는 좋은 예는 아마 함수형 프로그래밍에서 말하는 순수 함수 혹은 참조 투명성과 같은 개념이 더 어울리지 않나...하는 생각이 든다.\n\n### 참고 리소스\n- https://restfulapi.net/idempotent-rest-apis/\n- https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99\n- https://developer.mozilla.org/ko/docs/Glossary/Idempotent","slug":"HTTP/Idempotent","published":1,"updated":"2021-08-02T12:11:09.273Z","_id":"ckrulcwlu0000wxhvd4ed1bt6","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"멱등성과-HTTP에-대한-생각\"><a href=\"#멱등성과-HTTP에-대한-생각\" class=\"headerlink\" title=\"멱등성과 HTTP에 대한 생각\"></a>멱등성과 HTTP에 대한 생각</h2><blockquote>\n<p>[주의] 틀리다 맞다의 이야기를 하려고 쓰는 글은 아닙니다. </p>\n</blockquote>\n<p>수학 혹은 컴퓨터분야에서 쓰이는 용어라고 한다. 한문과 한글이 평생 부족한 나로서는 뭔말인가 싶어서 열심히 구글링을 해봤다. <strong>“연산을 여러번 하더라도 결과가 달라지지 않는 성질”</strong> 이라는 정의라고 한다. 대부분의 포스트에서 HTTP Method를 예를 들어 설명하는데 이해가 안가는 부분이 있었다. <code>HTTP GET, PUT, DELETE 등은 멱등성을 유지하는 반면 POST는 유지하지 못한다</code>라는 구절이었는데, 자세히 그 내막(?)을 살펴보고자 한다.</p>\n<p><strong>결과가 달라지지 않는다고?</strong></p>\n<p>예를 들어 상품을 조회하는 HTTP API가 있다고 가정하자</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP GET /products</span><br><span class=\"line\">200 OK</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;productName&quot;: &quot;상품명&quot;,</span><br><span class=\"line\">\t&quot;price&quot;: 25000,</span><br><span class=\"line\">\t....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위의 JSON 결과에서 상품명과 가격은 외부 요인에 의하여 얼마든지 바뀔 수 있는 결과이다. 그렇다면 한번 호출한 결과와 여러 번 호출한 결과가 다를 수도 있다는 이야기로 해석이 되는데, <code>결과적 일관성은 유지하지 못하는거 아닌가?</code>라는 생각이 들었다. 그렇다면 조금 다른 예로 생각을 해보려고 한다.</p>\n<p>특정 사용자를 조회하는 HTTP API가 있다고 가정해보자.</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /users/<span class=\"number\">1</span> HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\"><span class=\"number\">200</span> OK</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">&quot;userName&quot;</span>: <span class=\"string\">&quot;Ryan&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">&quot;tel&quot;</span>: <span class=\"number\">010</span><span class=\"number\">-0000</span><span class=\"number\">-1111</span>,</span><br><span class=\"line\">\t....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>사용자 키(<code>1</code>)를 기준으로 사용자의 프로필 비슷한 내용을 조회하는 API이다. 만약, 리소스에 대한 접근(변경,삭제)을 해당 키에 대한 리소스 오너만 할 수 있는 상황이라면 위에서 설명한 멱등성이 보장될 수 있다고 판단된다.<br>그렇다면 멱등성이라는 성질을 HTTP API를 통하여 접근하는 리소스에 비춰 생각해봤을 때, 리소스에 접근할 수 있는 범위 혹은 스코프가 어떻게 되느냐에 따라서 결과적 멱등성 여부가 달라지지 않을지지 않을까 라는 조심스러운 생각이 들었다.</p>\n<p><strong>그렇다면 인터넷에 돌아다니는 여러 글과 포스트들은 잘못된 이야기를 하고 있는 것일까?</strong></p>\n<p> 아마 멱등성이라는 의미가 협의보다는 광의로서 <code>구조</code> 또는 <code>효과</code> 측면에서의 동일함을 가리키지 않나라는 생각이 들었다. 앞서 설명한 두 개의 API는 특별한 제약 조건이 없는 상황이라면 동일한 응답 스트럭쳐와 동일한 HTTP Response를 가지게 될 것이고, 서버에서도 동일한 상태를 유지하게 될 것이다. 결과적으로 세세한 응답 하나하나의 결과적 멱등성을 가리키는 용어가 아닌 <code>구조 혹은 효과</code>의 측면에서 동일함을 유지해야 한다 라고 정리할 수 있을거 같다. </p>\n<p> 여기까지 순전히 GET에 대한 이야기만 했다. 그렇다면 <code>리소스에 대한 추가/변경/삭제 오퍼레이션에 해당하는 POST, PUT, DELETE는 어떻게 이해하면 좋을까?</code> </p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /users HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">&quot;userName&quot;</span>: <span class=\"string\">&quot;Ryan&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">&quot;tel&quot;</span>: <span class=\"number\">010</span><span class=\"number\">-0000</span><span class=\"number\">-1111</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이번에는 사용자 리소스를 생성하는 API로 설명해보려고 한다. 해당 API는 처음 호출한 결과와 두 번째 호출한 결과가 명확하게 달라져야 정상이다. </p>\n<p>첫 번째의 경우 응답은 201 Created 혹은 200 OK가 올 것이고 두 번째 호출 결과는 400 Bad Request(통신 자체는 성공했으니 2XX로 해석하는 것도 가능하다. 의견이 분분한 부분이다.) 혹은 200 OK의 응답은 오지만 첫 번째의 응답 결과와 결코 같을 수는 없을 것이다. 하지만, 세 번째 그리고 N번째 호출까지는 모든 응답이 두 번째 호출과 동일한 상황일 것이다. 이렇다면 위에서 말한 <code>구조 혹은 효과</code> 측면에서는 동일함을 유지하는 것이라고 생각할 수 있지 않을까? </p>\n<p>만약, 사용자를 등록하는 API가 아니라 매번 리소스를 생성하는 API가 있다고 하더라도 구조와 효과적인 측면에서 매번 동일할테니 이거 역시 멱등성을 유지한다고 봐도 무관하지 않을까? 라는 생각이 들었다.</p>\n<p>이 글을 혹시나 보는 사람은 <code>뭐 이런 억지...</code>라고 생각할지도 모르겠다. 하지만 HTTP RFC 명세를 살펴보면 아래와 같이 명시하고 있는 부분이 있다.<br><img src=\"https://i.imgur.com/Ys17CKV.png\" alt=\"스크린샷 2020-03-05 오전 2.08.56\"></p>\n<p>아마 스펙에서 말하는 멱등한 성격에 대해 정확한 이해가 부족하여 이런 일과 생각이 벌어지지 않았나 하는 생각이 든다. 하지만 스펙은 스펙일뿐 꼭 지켜야 하는 건 아니라고 생각한다.</p>\n<p>차라리 멱등성을 설명하는 좋은 예는 아마 함수형 프로그래밍에서 말하는 순수 함수 혹은 참조 투명성과 같은 개념이 더 어울리지 않나…하는 생각이 든다.</p>\n<h3 id=\"참고-리소스\"><a href=\"#참고-리소스\" class=\"headerlink\" title=\"참고 리소스\"></a>참고 리소스</h3><ul>\n<li><a href=\"https://restfulapi.net/idempotent-rest-apis/\">https://restfulapi.net/idempotent-rest-apis/</a></li>\n<li><a href=\"https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99\">https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Glossary/Idempotent\">https://developer.mozilla.org/ko/docs/Glossary/Idempotent</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"멱등성과-HTTP에-대한-생각\"><a href=\"#멱등성과-HTTP에-대한-생각\" class=\"headerlink\" title=\"멱등성과 HTTP에 대한 생각\"></a>멱등성과 HTTP에 대한 생각</h2><blockquote>\n<p>[주의] 틀리다 맞다의 이야기를 하려고 쓰는 글은 아닙니다. </p>\n</blockquote>\n<p>수학 혹은 컴퓨터분야에서 쓰이는 용어라고 한다. 한문과 한글이 평생 부족한 나로서는 뭔말인가 싶어서 열심히 구글링을 해봤다. <strong>“연산을 여러번 하더라도 결과가 달라지지 않는 성질”</strong> 이라는 정의라고 한다. 대부분의 포스트에서 HTTP Method를 예를 들어 설명하는데 이해가 안가는 부분이 있었다. <code>HTTP GET, PUT, DELETE 등은 멱등성을 유지하는 반면 POST는 유지하지 못한다</code>라는 구절이었는데, 자세히 그 내막(?)을 살펴보고자 한다.</p>\n<p><strong>결과가 달라지지 않는다고?</strong></p>\n<p>예를 들어 상품을 조회하는 HTTP API가 있다고 가정하자</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP GET /products</span><br><span class=\"line\">200 OK</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;productName&quot;: &quot;상품명&quot;,</span><br><span class=\"line\">\t&quot;price&quot;: 25000,</span><br><span class=\"line\">\t....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위의 JSON 결과에서 상품명과 가격은 외부 요인에 의하여 얼마든지 바뀔 수 있는 결과이다. 그렇다면 한번 호출한 결과와 여러 번 호출한 결과가 다를 수도 있다는 이야기로 해석이 되는데, <code>결과적 일관성은 유지하지 못하는거 아닌가?</code>라는 생각이 들었다. 그렇다면 조금 다른 예로 생각을 해보려고 한다.</p>\n<p>특정 사용자를 조회하는 HTTP API가 있다고 가정해보자.</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /users/<span class=\"number\">1</span> HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\"><span class=\"number\">200</span> OK</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">&quot;userName&quot;</span>: <span class=\"string\">&quot;Ryan&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">&quot;tel&quot;</span>: <span class=\"number\">010</span><span class=\"number\">-0000</span><span class=\"number\">-1111</span>,</span><br><span class=\"line\">\t....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>사용자 키(<code>1</code>)를 기준으로 사용자의 프로필 비슷한 내용을 조회하는 API이다. 만약, 리소스에 대한 접근(변경,삭제)을 해당 키에 대한 리소스 오너만 할 수 있는 상황이라면 위에서 설명한 멱등성이 보장될 수 있다고 판단된다.<br>그렇다면 멱등성이라는 성질을 HTTP API를 통하여 접근하는 리소스에 비춰 생각해봤을 때, 리소스에 접근할 수 있는 범위 혹은 스코프가 어떻게 되느냐에 따라서 결과적 멱등성 여부가 달라지지 않을지지 않을까 라는 조심스러운 생각이 들었다.</p>\n<p><strong>그렇다면 인터넷에 돌아다니는 여러 글과 포스트들은 잘못된 이야기를 하고 있는 것일까?</strong></p>\n<p> 아마 멱등성이라는 의미가 협의보다는 광의로서 <code>구조</code> 또는 <code>효과</code> 측면에서의 동일함을 가리키지 않나라는 생각이 들었다. 앞서 설명한 두 개의 API는 특별한 제약 조건이 없는 상황이라면 동일한 응답 스트럭쳐와 동일한 HTTP Response를 가지게 될 것이고, 서버에서도 동일한 상태를 유지하게 될 것이다. 결과적으로 세세한 응답 하나하나의 결과적 멱등성을 가리키는 용어가 아닌 <code>구조 혹은 효과</code>의 측면에서 동일함을 유지해야 한다 라고 정리할 수 있을거 같다. </p>\n<p> 여기까지 순전히 GET에 대한 이야기만 했다. 그렇다면 <code>리소스에 대한 추가/변경/삭제 오퍼레이션에 해당하는 POST, PUT, DELETE는 어떻게 이해하면 좋을까?</code> </p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /users HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">&quot;userName&quot;</span>: <span class=\"string\">&quot;Ryan&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">&quot;tel&quot;</span>: <span class=\"number\">010</span><span class=\"number\">-0000</span><span class=\"number\">-1111</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이번에는 사용자 리소스를 생성하는 API로 설명해보려고 한다. 해당 API는 처음 호출한 결과와 두 번째 호출한 결과가 명확하게 달라져야 정상이다. </p>\n<p>첫 번째의 경우 응답은 201 Created 혹은 200 OK가 올 것이고 두 번째 호출 결과는 400 Bad Request(통신 자체는 성공했으니 2XX로 해석하는 것도 가능하다. 의견이 분분한 부분이다.) 혹은 200 OK의 응답은 오지만 첫 번째의 응답 결과와 결코 같을 수는 없을 것이다. 하지만, 세 번째 그리고 N번째 호출까지는 모든 응답이 두 번째 호출과 동일한 상황일 것이다. 이렇다면 위에서 말한 <code>구조 혹은 효과</code> 측면에서는 동일함을 유지하는 것이라고 생각할 수 있지 않을까? </p>\n<p>만약, 사용자를 등록하는 API가 아니라 매번 리소스를 생성하는 API가 있다고 하더라도 구조와 효과적인 측면에서 매번 동일할테니 이거 역시 멱등성을 유지한다고 봐도 무관하지 않을까? 라는 생각이 들었다.</p>\n<p>이 글을 혹시나 보는 사람은 <code>뭐 이런 억지...</code>라고 생각할지도 모르겠다. 하지만 HTTP RFC 명세를 살펴보면 아래와 같이 명시하고 있는 부분이 있다.<br><img src=\"https://i.imgur.com/Ys17CKV.png\" alt=\"스크린샷 2020-03-05 오전 2.08.56\"></p>\n<p>아마 스펙에서 말하는 멱등한 성격에 대해 정확한 이해가 부족하여 이런 일과 생각이 벌어지지 않았나 하는 생각이 든다. 하지만 스펙은 스펙일뿐 꼭 지켜야 하는 건 아니라고 생각한다.</p>\n<p>차라리 멱등성을 설명하는 좋은 예는 아마 함수형 프로그래밍에서 말하는 순수 함수 혹은 참조 투명성과 같은 개념이 더 어울리지 않나…하는 생각이 든다.</p>\n<h3 id=\"참고-리소스\"><a href=\"#참고-리소스\" class=\"headerlink\" title=\"참고 리소스\"></a>참고 리소스</h3><ul>\n<li><a href=\"https://restfulapi.net/idempotent-rest-apis/\">https://restfulapi.net/idempotent-rest-apis/</a></li>\n<li><a href=\"https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99\">https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Glossary/Idempotent\">https://developer.mozilla.org/ko/docs/Glossary/Idempotent</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckrsup4zr0005tjhvhkiod5h4","category_id":"ckrsw4lpt0000rthv74dl5eo5","_id":"ckrsw4wg1000026hv9u0z96j4"},{"post_id":"ckrsup4zp0003tjhv0elm9q94","category_id":"ckrswaiic000226hv9qm1cbmh","_id":"ckrswaiic000326hv9dztbdkf"},{"post_id":"ckrsup4zq0004tjhvf9rch1ju","category_id":"ckrswaiic000226hv9qm1cbmh","_id":"ckrswawch000426hv5xm60qxo"},{"post_id":"ckrswb3jx000526hvgdcmennv","category_id":"ckrswaiic000226hv9qm1cbmh","_id":"ckrswb3k0000626hv2r5107ie"},{"post_id":"ckrsup4zt0008tjhv72dd4oh9","category_id":"ckrswbmol000826hvgn4n6rnt","_id":"ckrswbmol000926hv06ro6akz"},{"post_id":"ckrsup4zs0007tjhv84dp8912","category_id":"ckrswbya6000a26hveb658hbx","_id":"ckrswbya6000b26hv7l7e95ke"},{"post_id":"ckrsup4zu0009tjhv8j08asxy","category_id":"ckrswbya6000a26hveb658hbx","_id":"ckrswc5ch000c26hv91o53f71"},{"post_id":"ckrsup5130021tjhv72ii7vne","category_id":"ckrswbya6000a26hveb658hbx","_id":"ckrswcg6g000d26hvczdjbc3m"},{"post_id":"ckrsup4zv000atjhv99hzf6km","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswe8up000f26hvba8chg55"},{"post_id":"ckrsup4zw000btjhv05uwayxc","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswelwo000g26hvaiw21rm4"},{"post_id":"ckrsup4zw000ctjhv8w020z6o","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrsweq7q000h26hvdbhwg5wf"},{"post_id":"ckrsup4zx000dtjhve6uk9pxy","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrsweu9f000i26hv7laeb90t"},{"post_id":"ckrsup4zy000etjhvb7s607r0","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswf18x000j26hvakp36ch4"},{"post_id":"ckrsup4zz000htjhvc3338ue3","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswf82t000k26hv8j3s867l"},{"post_id":"ckrsup4zy000ftjhv09ii5wdi","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswfi87000l26hvedws9bdl"},{"post_id":"ckrsup4zz000gtjhv67zb2wiv","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswfsim000m26hv7cid7imk"},{"post_id":"ckrsup500000itjhveblw28v5","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswg17x000n26hv0uzo7rxl"},{"post_id":"ckrsup501000jtjhvcxm45qzf","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswg805000o26hvg4kj6lwd"},{"post_id":"ckrsup501000ktjhvared5ynw","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswgfn4000p26hv7t2ugodi"},{"post_id":"ckrsup502000ltjhv761m87nf","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswgqtb000q26hv2vzaduat"},{"post_id":"ckrsup502000mtjhv62kp72qj","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswifnu000r26hvf19th4ve"},{"post_id":"ckrsup503000ntjhv6j7g0irn","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswiog9000s26hv65o43hdg"},{"post_id":"ckrsup503000otjhv8p735t39","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswivzw000t26hvc28l79w7"},{"post_id":"ckrsup504000ptjhv8078ctmv","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswj4ze000u26hvbq7z3ogj"},{"post_id":"ckrsup504000qtjhvcvvg5332","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswjcjg000v26hvgkuo78f4"},{"post_id":"ckrsup506000stjhvafsk67n8","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswjkcw000w26hve8vs92ea"},{"post_id":"ckrsup505000rtjhv5bnbax10","category_id":"ckrswe8up000e26hv4axdbya3","_id":"ckrswjvpz000x26hvdilzds9d"},{"post_id":"ckrsup507000utjhvhwab83cy","category_id":"ckrswk92a000y26hv0xc00wmw","_id":"ckrswk92b000z26hvewam0bhh"},{"post_id":"ckrsup506000ttjhv9tuvf9w2","category_id":"ckrswk92a000y26hv0xc00wmw","_id":"ckrswkffc001026hv1bp6gr97"},{"post_id":"ckrsup507000vtjhv6joicmti","category_id":"ckrswkts9001126hv79u47plu","_id":"ckrswkts9001226hv13nz15c5"},{"post_id":"ckrsup508000wtjhv6erf3zhi","category_id":"ckrswkts9001126hv79u47plu","_id":"ckrswkz2p001326hvfkwtglne"},{"post_id":"ckrsup509000xtjhv4z1a48a0","category_id":"ckrswkts9001126hv79u47plu","_id":"ckrswl853001426hvdnml78i1"},{"post_id":"ckrsup50a000ztjhv4r4ph1q7","category_id":"ckrswkts9001126hv79u47plu","_id":"ckrswlf9y001526hv1dwu745x"},{"post_id":"ckrsup5160022tjhvhv9n3y4i","category_id":"ckrswkts9001126hv79u47plu","_id":"ckrswoj67001626hv024l0s8k"},{"post_id":"ckrsup509000ytjhv8lzwhbj7","category_id":"ckrswkts9001126hv79u47plu","_id":"ckrsworbt001726hvfvczfcnk"},{"post_id":"ckrsup50a0010tjhvgj4lcf06","category_id":"ckrswp98d001826hv5xoe8bwv","_id":"ckrswp98d001926hv01vk47p9"},{"post_id":"ckrsup50e0014tjhvafcy9x2o","category_id":"ckrswp98d001826hv5xoe8bwv","_id":"ckrswqb0o0000b9hv1sha1r1g"},{"post_id":"ckrsup50k0019tjhvh3hr8qpm","category_id":"ckrswp98d001826hv5xoe8bwv","_id":"ckrswqjyq0001b9hv1gizebbw"},{"post_id":"ckrsup50c0012tjhv4dg7hnqm","category_id":"ckrswp98d001826hv5xoe8bwv","_id":"ckrswqrog0002b9hv9i1jfkgs"},{"post_id":"ckrsup50d0013tjhvg3694i6h","category_id":"ckrswp98d001826hv5xoe8bwv","_id":"ckrswrtmo0000kxhv20cma76q"},{"post_id":"ckrsup50g0015tjhv53dgfk57","category_id":"ckrswp98d001826hv5xoe8bwv","_id":"ckrsws8ml0001kxhv0r2v2gmo"},{"post_id":"ckrsup50k0018tjhv77b57v36","category_id":"ckrswp98d001826hv5xoe8bwv","_id":"ckrswsg1w0002kxhvg8ow3ly7"},{"post_id":"ckrsup50h0016tjhvg6z1bp5r","category_id":"ckrswp98d001826hv5xoe8bwv","_id":"ckrswsnkv0003kxhv8vxzcmi7"},{"post_id":"ckrsup50j0017tjhv5ef48n46","category_id":"ckrswp98d001826hv5xoe8bwv","_id":"ckrswsuju0004kxhv8jmucfes"},{"post_id":"ckrsup50l001atjhva2opg0oz","category_id":"ckrswp98d001826hv5xoe8bwv","_id":"ckrswt2fi0005kxhvhwnmdg4a"},{"post_id":"ckrsup5170023tjhv90moeysd","category_id":"ckrswte7s0006kxhv2qav3dqi","_id":"ckrswte7v0007kxhv1jd7giud"},{"post_id":"ckrswtnm00008kxhv5jbe3ex7","category_id":"ckrswte7s0006kxhv2qav3dqi","_id":"ckrswtnm10009kxhvcysngdzz"},{"post_id":"ckrsup51d0024tjhv0gfh3ani","category_id":"ckrswte7s0006kxhv2qav3dqi","_id":"ckrswtvm1000akxhv701i5s85"},{"post_id":"ckrsup50m001btjhvekvr9by9","category_id":"ckrswte7s0006kxhv2qav3dqi","_id":"ckrswu37f000bkxhv26wd8uva"},{"post_id":"ckrsup50n001ctjhvfiapao6w","category_id":"ckrswte7s0006kxhv2qav3dqi","_id":"ckrswucta000ckxhv80cwb803"},{"post_id":"ckrsup50n001dtjhv4ta97fnh","category_id":"ckrswte7s0006kxhv2qav3dqi","_id":"ckrswumln000dkxhv7zu6h43p"},{"post_id":"ckrsup50o001etjhvhrj6dd90","category_id":"ckrswte7s0006kxhv2qav3dqi","_id":"ckrswuu26000ekxhv7083em8x"},{"post_id":"ckrsup50p001ftjhvc5y9azw1","category_id":"ckrswte7s0006kxhv2qav3dqi","_id":"ckrswv1xm000fkxhv0hnbh54k"},{"post_id":"ckrsup50p001gtjhv4oi89ho4","category_id":"ckrswte7s0006kxhv2qav3dqi","_id":"ckrswv8ya000gkxhv7ncxfh0i"},{"post_id":"ckrsup50q001htjhvcwr6247y","category_id":"ckrsww5po000jkxhv2l4688kd","_id":"ckrsww5pp000kkxhv2dbhb8yv"},{"post_id":"ckrsup50q001itjhv8vrnd1o6","category_id":"ckrsww5po000jkxhv2l4688kd","_id":"ckrsww78w000lkxhvfjbk04wc"},{"post_id":"ckrsup51e0025tjhvc3mx2ivz","category_id":"ckrsww5po000jkxhv2l4688kd","_id":"ckrswwue4000mkxhve7mp1719"},{"post_id":"ckrsup50r001jtjhv16h0cy93","category_id":"ckrswx93k000nkxhv0rpoeojh","_id":"ckrswx93k000okxhv3cmo5we7"},{"post_id":"ckrsup50u001ptjhvgi7mecys","category_id":"ckrswx93k000nkxhv0rpoeojh","_id":"ckrswxjn3000pkxhv6dp19shv"},{"post_id":"ckrsup51e0026tjhv0kr0dfr4","category_id":"ckrswx93k000nkxhv0rpoeojh","_id":"ckrswxwtv000qkxhvbt7zh16t"},{"post_id":"ckrsup50t001otjhv18qv1tgm","category_id":"ckrswx93k000nkxhv0rpoeojh","_id":"ckrswy3lp000rkxhvchr0aw19"},{"post_id":"ckrsup50s001ltjhv8oasftqy","category_id":"ckrswx93k000nkxhv0rpoeojh","_id":"ckrswyc1t000skxhv4h10f9bz"},{"post_id":"ckrsup50r001ktjhvg8132iud","category_id":"ckrswx93k000nkxhv0rpoeojh","_id":"ckrswyhzw000tkxhv3m4mgmta"},{"post_id":"ckrsup50s001mtjhvelt5hw87","category_id":"ckrswx93k000nkxhv0rpoeojh","_id":"ckrswyr7d000ukxhvgvmg5r8f"},{"post_id":"ckrsup50t001ntjhvf82bdmpe","category_id":"ckrswx93k000nkxhv0rpoeojh","_id":"ckrswz3da000vkxhv40rb4wn5"},{"post_id":"ckrsup50v001qtjhv8jyw78uc","category_id":"ckrswzigd000wkxhvcmcz0gn8","_id":"ckrswzigd000xkxhv617xcakc"},{"post_id":"ckrsup50v001rtjhv8o3yhepq","category_id":"ckrswzu1j000ykxhv30njd8xe","_id":"ckrswzu1k000zkxhv391i8sfj"},{"post_id":"ckrsup50w001ttjhv92dl56cm","category_id":"ckrswzu1j000ykxhv30njd8xe","_id":"ckrsx01eu0010kxhva6fw7t7g"},{"post_id":"ckrsup50w001stjhvartzd3il","category_id":"ckrswzu1j000ykxhv30njd8xe","_id":"ckrsx08di0011kxhvcp3m9iqm"},{"post_id":"ckrsup50x001utjhv1rhjejh8","category_id":"ckrswzu1j000ykxhv30njd8xe","_id":"ckrsx0gmm0012kxhvax247wae"},{"post_id":"ckrsup50x001vtjhv08qz3cn4","category_id":"ckrswzu1j000ykxhv30njd8xe","_id":"ckrsx0oxd0013kxhvekfbbloq"},{"post_id":"ckrsup50y001wtjhv4yan8swi","category_id":"ckrswzu1j000ykxhv30njd8xe","_id":"ckrsx0y130014kxhv718z8j4f"},{"post_id":"ckrsup50y001xtjhvgz1m56mx","category_id":"ckrswzu1j000ykxhv30njd8xe","_id":"ckrsx1bmy0015kxhv0l85hhxe"},{"post_id":"ckrsup50z001ytjhvcfya62up","category_id":"ckrswzu1j000ykxhv30njd8xe","_id":"ckrsx1klk0016kxhv47cbcpv8"},{"post_id":"ckrsup50z001ztjhvblzy9v8n","category_id":"ckrswzu1j000ykxhv30njd8xe","_id":"ckrsx1src0017kxhv7ky2ffh6"},{"post_id":"ckrsup5100020tjhv2gqe0maf","category_id":"ckrswzu1j000ykxhv30njd8xe","_id":"ckrsx24430018kxhvddxp9d9p"},{"post_id":"ckrsup50b0011tjhv0ihhgezc","category_id":"ckrswp98d001826hv5xoe8bwv","_id":"ckrsx8hho00004khv8i6ycsi8"},{"post_id":"ckrulcwlu0000wxhvd4ed1bt6","category_id":"ckrswk92a000y26hv0xc00wmw","_id":"ckruld0op0002wxhv3v4vas2o"}],"PostTag":[],"Tag":[]}}