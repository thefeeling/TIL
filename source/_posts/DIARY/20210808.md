---
title: 20210808
date: 2021/8/8 00:00:00
categories:
- DIARY
---

## 데이터 중심 어플리케이션 설계 - 07장 트랜잭션 정리
- [갱신 손실 방지]. [원자적 쓰기 연산], [명시적인 잠금] 부분 다시 읽고 내용 정리 진행 중
- Isolation Level에 따라 발생할 수 있는 케이스에 대해 자료 조사하면서 Repeatable Read 단계에서 Phantom Read가 발생하는 케이스가 어떤건지 궁금해졌다. (자료마다 발생한다고 말하는 자료가 있고 아니다 라고 하는 자료가 있어서 혼란스러웠음) 결국 Real MySQL에 해당 부분을 읽게 되었다.

## Real MySQL 4장 트랜잭션과 잠금 읽기
- `데이터 중심 어플리케이션 설계 - 07장 트랜잭션`을 읽고 정리하면서 혼란스러움이 생겨서 결국 두꺼운(?) 책을 넘기게 되었다.
- Lock에 대한 종류 그리고 MySQL 엔진별로 Lock과 트랜잭션에 대한 차이를 간단하게 살펴볼 수 있었고 특히 5.X 전후 버젼에 따라 트랜잭션을 모니터링할 수 있는 수단과 방법에서 크게 차이가 나는 부분을 알게 되었다.
- InnoDB 기준으로 락은 Record Lock, Gap Lock, Next Key Lock, Auto-Increment Lock이 존재한다. 나머지 락은 다른 자료를 통해 접했었는데 AutoIncrement Lock에 대한 부분은 있다는 사실만 알고 있었지 내용에 대해 처음 접하는 부분이라 추후 정리하면서 다시 까먹지(?) 않도록 정리해야겠다.
- InnoDB 기준 Repeatable Read에서는 Phantom Read가 발생하지 않는다. 하지만 SELECT ~ FOR UPDATE와 같은 명시적인 락을 사용한 쿼리를 사용할 경우 Phantom Read가 발생한다는 내용을 읽고 이 경우에만 팬텀 리드가 발생하는구나를 알게 되었다.
- 다른 동시성이나 트랜잭션을 다루는 책에서도 동일한 이야기를 하고 있지만 4장 서두를 살펴보면 트랜잭션을 일단 피할 수 있다면 피하는 것이 최선이고 사용해야 한다면 커넥션의 점유 등과 같은 문제 때문에 빠르게 반환해야 대표적인 공유자원인 데이터베이스에 큰 영향(?)을 미치지 않고 안전하게 사용할 수 있다는 내용이 인상적.(뻔한 이야기지만 현실에서는 무분별하게 트랜잭션을 남용하는 경우등이 많으니...)

