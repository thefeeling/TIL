---
title: 데이터 중심 어플리케이션 설계 - 7장 트랜잭션
date: 2021/8/24 00:00:00
categories:
- ARCHITECTURE
toc: true
---

> 트랜잭션 없이 코딩하는 것보다 트랜잭션을 과용해서 병목지점이 생기는 성능 문제를 애플리케이션 프로그래머가 처리하게 하는 게 낫다고 생각한다.

## 트랜잭션과 현실 세계의 데이터 베이스
- 어플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법
- 프로그래밍 모델의 단순화 목적이며 잠재적 오류 / 동시성 문제를 무시할 수 있다.
- 트랜잭션이 매번 필요한 것은 아니며 보장을 완화하거나 아예 안쓰는게 이득일 수 있다.
- S/W, H/W는 언제라도 실패할 수 있다
- 어플리케이션은 언제라도 죽을 수 있다
- 네트워크 문제가 생기면 데이터베이스 노드 사이의 통신이 안될 수 있다
- 동시에 쓰기를 실행하면 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.
- 비정상적인 데이터를 읽을 수 있다.
- 예측하지 못한 버그를 유발할 수 있다.


## 모호한 트랜잭션 개념
- 새로운 세대의 데이터베이스 중 다수는 트랜잭션을 완전히 포기하거나 과거에 인식되던 것보다 훨씬 약한 보장을 의미하는 단어로 재정의
- 기존 DB 벤더들은 트랜잭션 보장을 "값진 데이터"가 있는 "중요 어플리케이션"에 필수적인 요구사항이라고 이야기하고 있음

### ACID
- 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)
- 데이터베이스마다 ACID에 대한 구현은 제각각
> 상위 수준의 아이디어는 비슷/견실하지만 악마는 세부사항에 있다.
- 기본적으로 가용성을 제공하고, 유연한 상태를 가지며 최종적 일관성을 지니는 뜻으로 사용

#### 원자성(Atomicity)
- 더 이상 쪼갤 수 없는 무엇인가를 가리킴
> Multi Thread Model에서 하나의 스레드가 원자적 연산을 실행하면 다른 스레드에서 중간 상태를 관찰할 수 없고 실행 전 혹은 실행 후만 관찰 가능
- 여러 쓰기 작업이 Atomic 하게 묶여 있을때 결함으로 커밋을 할수 없다면 어보트되고 데이터베이스는 지금까지 실행한 쓰기를 모두 무시/취소해야 함. ACID 원자성의 결정적인 특징이다.

#### 일관성(Consistency)
- 데이터 관한 어떤 선언(불변식)
  * FK, PK와 같은 제약 조건
- 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임
- ***원자성, 격리성, 지속성은 데이터베이스의 속성인 반면 일관성은 애플리케이션의 속성***

#### 격리성(Isolation)
- 동시에 실행되는 트랜잭션은 서로 격리되는 것을 의미. 다시 말해, 동시에 실행되는 트랜잭션들은 서로 방해하지 말아야 한다.
- 데이터베이스는 실제로는 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장
- 직렬성 격리는 성능 손해를 동반하므로 현실에서는 거의 사용을 안한다.

#### 지속성(Durability)
- 트랜잭션이 성공적으로 커밋됐다면 H/W 혹은 S/W 결함이 발생하더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장. 보통 비휘발성 저장소에 저장되는 데이터에 대해 데이터 구조가 오염됐을 때 복구해주는 쓰기 전 로그(write-ahead log)와 비슷한 수단을 동반함.
- 지속성을 보장하려면 성공적으로 커밋됐다고 보고하기 전에 쓰기나 복제가 완료될 때까지 기다려야 한다.
> 현실에서 절대적 보장을 제공하는 한 가지 기법은 없다. 
디스크에 쓰기, 원격 장비에 복제하기, 백업 등을 포함해 위험을 줄이려는 기법이 여러 가지 있을 뿐이다. 
이들은 함께 쓸 수 있으며 그래야만 한다. 이론적인 `보장`은 약간 에누리해서 듣는게 현명하다.

### 단일/다중 객체 연산
- 철수와 영식이가 이메일 서비스를 이용하고 있다고 가정해보자.
```puml
@startuml
actor 철수
database DB
actor 영식

철수 -> DB: insert into emails values(2, 'Hello' true)
DB -> 철수: ok
영식 -> DB: select body, unread_flag from emails \nwhere recipient_id = 2 limit 50
DB -> 영식: Hello, true
note left: **Dirty Read 발생**\n: 커밋되지 않은 데이터를 읽음
영식 -> DB: select unread from mailboxes \nwhere recipient_id = 2
DB -> 영식: 0
철수 -> DB: update mailboxes \nset unread = unread + 1 \nwhere recipient_id = 2
DB -> 철수: ok

@enduml
```
- 위와 같은 상황에서 영식이는 이상한 경험을 하게 된다. 메일 내용은 존재하지만 메일박스에서 읽지 않은 메일은 0으로 표시되기 때문이다.
> 물론 이메일과 같은 도메인의 특성상 심각한 문제가 되는 지점은 아니다.

- 다중 객체(Row, Document 등) 연산에서는 읽기 연산/쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 한다. 대표적으로 `BEGIN TRANSACTION ~ COMMIT`이 있다. 비관계형 데이터베이스에서도 다중 연산을 지원하긴 하지만 연산을 묶는 방법이 없는 경우가 많다. redis multi 오퍼레이션의 경우 부분 실패 부분 성공을 볼수도 있다. 
### 다중 객체 트랜잭션의 필요성
- 많은 분산 데이터스토어는 다중 객체 트랜잭션 지원을 포기했다. 다중 객체 트랜잭션은 여러 파티션에 걸쳐서 구현하기가 어렵고 매우 높은 가용성과 성능이 필요한 곳에서는 방해가 되는 시나리오도 있기 때문이다. 
- ***원자성이 없다면 오류 처리가 훨씬 더 복잡해지고 격리성이 없으면 동시성 문제가 생길 수 있다.***
### 오류와 어보트 처리
- TX의 핵심은 ***오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 것이다***
- 어보트된 트랜잭션을 재시도하는 것은 간단하지만 완벽하진 않다.
  * 실제로 성공한 트랜잭션이지만 커밋 중 네트워크 단절이 발생할 경우 재시도하면 별도의 중복 제거 메카니즘이 없다면 트랜잭션을 두 번 실행할수도 있다. 
  * 부하에 의한 재시도는 문제를 해결하기보다 악화시킬 수 있다. 이럴 경우 지수적 백오프 전략을 사용하여 별도로 처리하는 방법을 쓸 수 있다.
  * 위의 이메일 예제처럼 부수효과가 있는 경우 2단계 커밋이 도움이 될 수 있다.


## 완화된 격리 수준
- 동시성 문제는 TX가 다른 TX에서 동시에 변경한 데이터를 읽거나 두 TX가 동시에 같은 데이터를 변경하려고 할 떄만 나타난다.
- 문제 해결을 위해 직렬성 격리를 고려해볼 수 있지만 이는 동시성은 보장하겠지만 모든 이슈로부터 보호해주지 않는 완화된 격리 수준을 사용하는 시스템들이 흔하다.(인기있는 데이터베이스들 조차도 완화된 격리성을 사용하는 경우가 많다) 결국, 존재하는 동시성에 대한 종류를 잘 이해하고 방지하는 방법을 배우는 것이 필수다.

### 커밋 후 읽기(READ COMMITTED)
- 가장 기본적인 수준의 트랜잭션 격리
- 데이터베이스에서 읽을 때 커밋된 데이터만 보게된다.(Dirty Read가 없다)
- 데이터베이스에서 쓸 때 커밋된 데이터만 덮어쓰게 된다.(Dirty Write가 없다)

#### 더티 읽기 방지
```puml
@startuml
actor 사용자1
database DB
actor 사용자2


사용자2 -> DB: get x
activate 사용자2
DB -> 사용자2: 2


사용자1 -> DB: begin transaction
activate 사용자1
사용자1 -> DB: set x = 3
DB -> 사용자1: OK

사용자2 -> DB: get x
DB -> 사용자2: 2

사용자1 -> DB: set y = 3
DB -> 사용자1: OK
사용자1 -> DB: commit
deactivate 사용자1

사용자2 -> DB: get x
DB -> 사용자2: 3
note right: 사용자1이 커밋한 값인 `3`을 읽음

@enduml
```

- ***TX가 여러 객체를 갱신하는데 더티 읽기가 생기면 다른 TX에서 일부는 갱신된 값을, 일부는 갱신되지 않은 값을 볼 수 있다.***

#### 더티 쓰기 방지
- 먼저 쓴 내용이 아직 커밋되지 않은 트랜잭션에서 쓴 것이고, 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 겊어써버리는 걸 `더티 쓰기(Dirty Write)`라고 한다.
- 두 TX에서 데이터베이스의 동일 객체를 갱신하려고 할때 일반적으로 나중에 쓴 내용이 먼저 쓴 내용을 덮어쓴다고 가정한다. `READ_COMMITTED` 격리 수준에서는 이러한 더티 쓰기를 방지해야 하며, 먼저 쓴 TX가 커밋/어보트될 때까지 두 번째 쓰기를 지연시키는 방법을 쓴다.

```puml
@startuml
actor 철수
database 목록
database 송장
actor 영식이

철수 -> 목록: update listings set buyer = '철수' where id = 1234
목록 -> 철수: OK

영식이 -> 목록: update listings set buyer = '영식이' where id = 1234
목록 -> 영식이: OK

영식이 -> 송장: update invoices set recipient = '영식이' where listing_id = 1234
송장 -> 영식이: OK

철수 -> 목록: update invoices set recipient = '철수' where listing_id = 1234
목록 -> 철수: OK

@enduml
```
> 위 예제에서는 **더티 쓰기**가 발생하였고, 
***영식이와 철수 모두 같은 제품을 구매하는 상황에서 구매자는 영식이가 되고 송장은 철수로 찍혀 있는 상황이다.***

#### 커밋 후 읽기(READ_COMMITTED) 구현
- 커밋 후 읽기(READ_COMMITTED)는 Oracle, PostgreSQL, MS_SQL 등에서 기본 설정
- ***로우 수준의 잠금을 사용해 더티 쓰기를 방지하며 트랜잭션에서 특정 객체(로우/문서)를 변경하고 싶다면 먼저 해당 객체에 대한 잠금을 획득해야 한다. 그리고 트랜잭션이 커밋되거나 어보트될 때까지 잠금을 보유하고 있어야 한다. 오직 한 트랜잭션만 어떤 주어진 객체에 대한 잠금을 보유할 수 있고 다른 트랜잭션에서 동일한 객체에 쓰기를 원한다면 첫 번째 트랜잭션이 커밋/어보트된 후에야 잠금을 얻어 진행할 수 있다.***
- 더티 읽기를 막기 위해 동일한 잠금을 사용할 수 있다. 하지만, 현실적으로 잘사용하지 않고 응답 시간에 해를 끼치며 운영성이 나쁘다. 이러한 이유로 커밋 후 읽기(READ_COMMITTED)에서는 트랜잭션이 시작하면 과거에 커밋된 값과 새로운 값 모두 기억한다.
- 하지만, 커밋 후 읽기(READ_COMMITTED)에서도 동시성 버그가 생길 수 있는 경우가 많이 있다. 아래 계좌 잔고 예제를 살펴보자.

```puml
@startuml
@startuml
actor 철수
database 계좌1
database 계좌2
actor 영식이

철수 -> 계좌1: select balance from accounts from id = 1
계좌1 -> 철수: 500

영식이 -> 계좌1: update accounts set balance = balance + 100 where id = 1
계좌1 -> 영식이: 600

영식이 -> 계좌2: update accounts set balance = balance - 100 where id = 2
계좌2 -> 영식이: 400

철수 -> 계좌2: select balance from accounts from id = 2
계좌2 -> 철수: 400
@enduml
```
> 위 예제에서 일시적으로 철수는 계좌에서 100원이 갑자기 사라진처럼 보일 수 있다. 
영식이가 100원을 계좌1에서 꺼내 계좌2로 보내는 트랜잭션을 수행했고 
철수는 격리 수준에 따라 과거 커밋된 값인 계좌 1의 500원과 계좌2의 400원을 읽어 총액 1000원에서 900원으로 100원이 사라진처럼 보일 수 있다.

- 위와 같이 일시적으로 현상을 가리켜 비반복 읽기(Non-Repeatable-Read) 혹은 읽기 쓰큐(Read-Skew)라고 부른다. 커밋 후 읽기(READ_COMMITTED)에서 읽기 스큐는 받아들일 수 있는 것으로 여겨지지만 비즈니스마다 이런 일시적인 비일관성을 감내할 수 없는 경우도 존재한다.

### 스냅샷 격리와 반복 읽기
- 위 계좌 잔고 예제의 문제에서 일관된 읽기를 하지 못하는 것의 해결책으로 `스냅숏 격리`를 사용할 수 있다.
- 각 트랜잭션은 데이터베이스의 일관된 스냅샷으로부터 읽는다. 즉 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다. 데이터가 나중에 다른 트랜잭션에 의해 바뀌더라도 각 트랜잭션은 특정한 시점의 과거 데이터를 볼 뿐이다.
- 스냅샷 격리는 널리 쓰이는 기능으로 PostgreSQL, InnoDB 엔진을 사용하는 Oracle, MySQL, SQL_Server에서 지원된다.

#### 스냅샷 격리 구현
- 커밋 후 읽기(READ_COMMITTED)에서처럼 더티 쓰기를 방지하기 위해 쓰기 잠금을 사용한다.
- 같은 객체에 쓰기를 하는 경우 락을 획득한 트랜잭션에 먼저 진행하고 다른 트랜잭션은 앞의 트랜잭션이 락을 풀어줄때까지 기다려야 한다는 이야기다.
- 하지만, ***읽을 떄는 아무 잠금이 필요 없다. 읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다.***
- 스냅샷 격리를 지원하는 저장소 엔진은 보통 커밋 후 읽기 격리를 위해서 MVCC를 사용한다.
> **MVCC(Multi-Version-Concurrency-Control)**
> 데이터베이스마다 커밋된 여러 버젼을 유지하며 진행 중인 여러 트랜잭션에서 서로 다른 시점의 데이터베이스 상태를 봐야 할 수도 있기 때문. 데이터베이스가 객체의 여러 버전을 함께 유지하므로 이 기법은 다중 버젼 동시성 제어 라고 한다.


```puml
@startuml
actor "철수\n(trxId=12)" as 철수
database 계좌1
database 계좌2
actor "영식이\n(trxId=13)" as 영식이

note left of 계좌1: **계좌1 스냅샷**\n--\ncreated by = 3\ndeleted by = nil\nid = 1\nbalance=500 
/ note right of 계좌2: **계좌2 스냅샷**\n--\ncreated by = 5\ndeleted by = nil\nid = 2\nbalance=500


철수 -> 계좌1: select balance from accounts from id = 1
activate 철수
계좌1 -> 철수: 500


영식이 -> 계좌1: update accounts set balance = balance + 100 where id = 1
activate 영식이
계좌1 -> 영식이: OK
note left of 계좌1: **계좌1 스냅샷**\n--\ncreated by = 3\ndeleted by = 13\nid = 1\nbalance=500\n--\ncreated by = 13\ndeleted by = nil\nid = 1\nbalance=600

영식이 -> 계좌2: update accounts set balance = balance - 100 where id = 2
계좌2 -> 영식이: OK
deactivate 영식이

철수 -> 계좌2: select balance from accounts from id = 2
계좌2 -> 철수: 500
note right of 계좌2: **계좌2 스냅샷**\n--\ncreated by = 5\ndeleted by = 13\nid = 2\nbalance=500\n--\ncreated by = 13\ndeleted by = nil\nid=2\nbalance=400

deactivate 철수

@enduml
```

#### 일관된 스냅샷을 보는 가시성 규칙
- 트랜잭션은 데이터베이스에서 객체를 읽을 떄 트랜잭션 ID를 사용해 어떤 것을 볼 수 있고 어떤 것을 볼 수 없는지를 결정
- 면밀한 가시성 규칙을 정의함으로써 데이터베이스는 데이터베이스의 일관된 스냅샷을 애플리케이션에 제공할 수 있음
  * 각 트랜잭션을 시작할 때 그 시점에 진행 중인 트랜잭션 목록을 만들고 해당 트랜잭션들이 쓰는 데이터는 모두 무시
  * 트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터는 그 트랜잭션 커밋 여부와 무관하게 모두 무시
  * 위 조건 외 모든 데이터는 쿼리를 통하여 볼수 있음
- 데이터베이스는 갱신할 때 값을 교체하지 않고 값이 바뀔 때마다 새 버전을 생성함으로써 작은 오버헤드만 유발하면서 일관된 스냅샷을 제공

#### 색인과 스냅샷 격리
- 색인이 객체의 모든 버전을 가리키게 하고 색인 질의가 현재 트랜잭션에서 볼 수 없는 버전을 걸래내게 하는 것이 일반적인 구현. 하지만, 현실에서는 세부 사항에 따라 MVCC의 성능이 결정됨.
#### 반복 읽기와 혼란스러운 이름
- 스냅샷 격리는 읽기 전용 트랜잭션에 유용하며 오라클에서는 `직렬성`, PostgreSQL과 MySQL에서는 `반복읽기(Repreatable Read)`라고 부른다
- ***이름이 혼란스러운 이유는 SQL 표준에 스냅샷 격리가 존재하지 않기 때문이다.*** 대신 비슷한 반복 읽기는 SQL 표준에 정의되어 있다.

### 갱신 손실 방지
#### 원자적 쓰기 연산
#### 명시적인 잠금
#### 갱신 손실 자동 감지
#### Compare-And-Set
#### 출동 해소와 복제


### 쓰기 스큐와 팬텀
#### 쓰기 스큐를 특정짓기
#### 쓰기 스큐를 유발하는 패턴
#### 충돌 구체화
